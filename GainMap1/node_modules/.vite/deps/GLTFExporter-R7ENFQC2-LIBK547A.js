import {
  $s,
  Ce,
  Ft,
  In,
  Ke,
  Ks,
  Me,
  Oe,
  P,
  Rd,
  Ru,
  Se,
  Te,
  Va,
  Vi,
  Vt,
  Ye,
  Yn,
  Zr,
  _v,
  ao,
  bn,
  ed,
  ge,
  ka,
  nd,
  ne,
  sr,
  tn,
  uh,
  un,
  ur
} from "./chunk-763QVDXZ.js";
import {
  q,
  r
} from "./chunk-F6LUTOTK.js";

// node_modules/@mappedin/mappedin-js/lib/esm/GLTFExporter-R7ENFQC2.js
q();
q();
var B;
var J;
var U;
var K;
function j(c, e = 1 / 0, s = null) {
  J || (J = new ur(2, 2, 1, 1)), U || (U = new tn({ uniforms: { blitTexture: new Rd(c) }, vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`, fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}` })), U.uniforms.blitTexture.value = c, U.defines.IS_SRGB = c.colorSpace == Ke, U.needsUpdate = true, K || (K = new Me(J, U), K.frustrumCulled = false);
  let r2 = new Te(), t = new Ru();
  t.add(K), s === null && (s = B = new ao({ antialias: false }));
  let i = Math.min(c.image.width, e), n = Math.min(c.image.height, e);
  s.setSize(i, n), s.clear(), s.render(t, r2);
  let o = document.createElement("canvas"), a = o.getContext("2d");
  o.width = i, o.height = n, a.drawImage(s.domElement, 0, 0, i, n);
  let u = new nd(o);
  return u.minFilter = c.minFilter, u.magFilter = c.magFilter, u.wrapS = c.wrapS, u.wrapT = c.wrapT, u.name = c.name, B && (B.forceContextLoss(), B.dispose(), B = null), u;
}
r(j, "decompress");
var $e = { POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"], NORMAL: ["byte normalized", "short normalized"], TANGENT: ["byte normalized", "short normalized"], TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"] };
var pe = class pe2 {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new ee(e);
    }), this.register(function(e) {
      return new se(e);
    }), this.register(function(e) {
      return new re(e);
    }), this.register(function(e) {
      return new ie(e);
    }), this.register(function(e) {
      return new oe(e);
    }), this.register(function(e) {
      return new ae(e);
    }), this.register(function(e) {
      return new te(e);
    }), this.register(function(e) {
      return new ne2(e);
    }), this.register(function(e) {
      return new ce(e);
    }), this.register(function(e) {
      return new ue(e);
    }), this.register(function(e) {
      return new le(e);
    }), this.register(function(e) {
      return new fe(e);
    }), this.register(function(e) {
      return new he(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, s, r2, t) {
    let i = new $(), n = [];
    for (let o = 0, a = this.pluginCallbacks.length; o < a; o++) n.push(this.pluginCallbacks[o](i));
    i.setPlugins(n), i.write(e, s, t).catch(r2);
  }
  parseAsync(e, s) {
    let r2 = this;
    return new Promise(function(t, i) {
      r2.parse(e, t, i, s);
    });
  }
};
r(pe, "GLTFExporter");
var q2 = pe;
var x = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, INT: 5124, UNSIGNED_INT: 5125, FLOAT: 5126, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 };
var Q = "KHR_mesh_quantization";
var b = {};
b[ge] = x.NEAREST;
b[uh] = x.NEAREST_MIPMAP_NEAREST;
b[Vi] = x.NEAREST_MIPMAP_LINEAR;
b[Ce] = x.LINEAR;
b[Zr] = x.LINEAR_MIPMAP_NEAREST;
b[Yn] = x.LINEAR_MIPMAP_LINEAR;
b[Ye] = x.CLAMP_TO_EDGE;
b[ka] = x.REPEAT;
b[Va] = x.MIRRORED_REPEAT;
var es = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
var cs = new Vt();
var ss = 12;
var us = 1179937895;
var ls = 2;
var ts = 8;
var fs = 1313821514;
var hs = 5130562;
function F(c, e) {
  return c.length === e.length && c.every(function(s, r2) {
    return s === e[r2];
  });
}
r(F, "equalArray");
function ps(c) {
  return new TextEncoder().encode(c).buffer;
}
r(ps, "stringToArrayBuffer");
function ds(c) {
  return F(c.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
r(ds, "isIdentityMatrix");
function gs(c, e, s) {
  let r2 = { min: new Array(c.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(c.itemSize).fill(Number.NEGATIVE_INFINITY) };
  for (let t = e; t < e + s; t++) for (let i = 0; i < c.itemSize; i++) {
    let n;
    c.itemSize > 4 ? n = c.array[t * c.itemSize + i] : (i === 0 ? n = c.getX(t) : i === 1 ? n = c.getY(t) : i === 2 ? n = c.getZ(t) : i === 3 && (n = c.getW(t)), c.normalized === true && (n = _v.normalize(n, c.array))), r2.min[i] = Math.min(r2.min[i], n), r2.max[i] = Math.max(r2.max[i], n);
  }
  return r2;
}
r(gs, "getMinMax");
function is(c) {
  return Math.ceil(c / 4) * 4;
}
r(is, "getPaddedBufferSize");
function Z(c, e = 0) {
  let s = is(c.byteLength);
  if (s !== c.byteLength) {
    let r2 = new Uint8Array(s);
    if (r2.set(new Uint8Array(c)), e !== 0) for (let t = c.byteLength; t < s; t++) r2[t] = e;
    return r2.buffer;
  }
  return c;
}
r(Z, "getPaddedArrayBuffer");
function ns() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
r(ns, "getCanvas");
function rs(c, e) {
  if (c.toBlob !== void 0) return new Promise((r2) => c.toBlob(r2, e));
  let s;
  return e === "image/jpeg" ? s = 0.92 : e === "image/webp" && (s = 0.8), c.convertToBlob({ type: e, quality: s });
}
r(rs, "getToBlobPromise");
var de = class de2 {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  async write(e, s, r2 = {}) {
    this.options = Object.assign({ binary: false, trs: false, onlyVisible: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, r2), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(e), await Promise.all(this.pending);
    let t = this, i = t.buffers, n = t.json;
    r2 = t.options;
    let o = t.extensionsUsed, a = t.extensionsRequired, u = new Blob(i, { type: "application/octet-stream" }), p = Object.keys(o), f = Object.keys(a);
    if (p.length > 0 && (n.extensionsUsed = p), f.length > 0 && (n.extensionsRequired = f), n.buffers && n.buffers.length > 0 && (n.buffers[0].byteLength = u.size), r2.binary === true) {
      let m = new FileReader();
      m.readAsArrayBuffer(u), m.onloadend = function() {
        let l = Z(m.result), d = new DataView(new ArrayBuffer(ts));
        d.setUint32(0, l.byteLength, true), d.setUint32(4, hs, true);
        let h = Z(ps(JSON.stringify(n)), 32), w = new DataView(new ArrayBuffer(ts));
        w.setUint32(0, h.byteLength, true), w.setUint32(4, fs, true);
        let M = new ArrayBuffer(ss), N = new DataView(M);
        N.setUint32(0, us, true), N.setUint32(4, ls, true);
        let k = ss + w.byteLength + h.byteLength + d.byteLength + l.byteLength;
        N.setUint32(8, k, true);
        let g = new Blob([M, w, h, d, l], { type: "application/octet-stream" }), y = new FileReader();
        y.readAsArrayBuffer(g), y.onloadend = function() {
          s(y.result);
        };
      };
    } else if (n.buffers && n.buffers.length > 0) {
      let m = new FileReader();
      m.readAsDataURL(u), m.onloadend = function() {
        let l = m.result;
        n.buffers[0].uri = l, s(n);
      };
    } else s(n);
  }
  serializeUserData(e, s) {
    if (Object.keys(e.userData).length === 0) return;
    let r2 = this.options, t = this.extensionsUsed;
    try {
      let i = JSON.parse(JSON.stringify(e.userData));
      if (r2.includeCustomExtensions && i.gltfExtensions) {
        s.extensions === void 0 && (s.extensions = {});
        for (let n in i.gltfExtensions) s.extensions[n] = i.gltfExtensions[n], t[n] = true;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (s.extras = i);
    } catch (i) {
      console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message);
    }
  }
  getUID(e, s = false) {
    if (this.uids.has(e) === false) {
      let t = /* @__PURE__ */ new Map();
      t.set(true, this.uid++), t.set(false, this.uid++), this.uids.set(e, t);
    }
    return this.uids.get(e).get(s);
  }
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e)) return false;
    let r2 = new P();
    for (let t = 0, i = e.count; t < i; t++) if (Math.abs(r2.fromBufferAttribute(e, t).length() - 1) > 5e-4) return false;
    return true;
  }
  createNormalizedNormalAttribute(e) {
    let s = this.cache;
    if (s.attributesNormalized.has(e)) return s.attributesNormalized.get(e);
    let r2 = e.clone(), t = new P();
    for (let i = 0, n = r2.count; i < n; i++) t.fromBufferAttribute(r2, i), t.x === 0 && t.y === 0 && t.z === 0 ? t.setX(1) : t.normalize(), r2.setXYZ(i, t.x, t.y, t.z);
    return s.attributesNormalized.set(e, r2), r2;
  }
  applyTextureTransform(e, s) {
    let r2 = false, t = {};
    (s.offset.x !== 0 || s.offset.y !== 0) && (t.offset = s.offset.toArray(), r2 = true), s.rotation !== 0 && (t.rotation = s.rotation, r2 = true), (s.repeat.x !== 1 || s.repeat.y !== 1) && (t.scale = s.repeat.toArray(), r2 = true), r2 && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = t, this.extensionsUsed.KHR_texture_transform = true);
  }
  buildMetalRoughTexture(e, s) {
    if (e === s) return e;
    function r2(l) {
      return l.colorSpace === Ke ? r(function(h) {
        return h < 0.04045 ? h * 0.0773993808 : Math.pow(h * 0.9478672986 + 0.0521327014, 2.4);
      }, "SRGBToLinear") : r(function(h) {
        return h;
      }, "LinearToLinear");
    }
    r(r2, "getEncodingConversion"), console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof ed && (e = j(e)), s instanceof ed && (s = j(s));
    let t = e ? e.image : null, i = s ? s.image : null, n = Math.max(t ? t.width : 0, i ? i.width : 0), o = Math.max(t ? t.height : 0, i ? i.height : 0), a = ns();
    a.width = n, a.height = o;
    let u = a.getContext("2d");
    u.fillStyle = "#00ffff", u.fillRect(0, 0, n, o);
    let p = u.getImageData(0, 0, n, o);
    if (t) {
      u.drawImage(t, 0, 0, n, o);
      let l = r2(e), d = u.getImageData(0, 0, n, o).data;
      for (let h = 2; h < d.length; h += 4) p.data[h] = l(d[h] / 256) * 256;
    }
    if (i) {
      u.drawImage(i, 0, 0, n, o);
      let l = r2(s), d = u.getImageData(0, 0, n, o).data;
      for (let h = 1; h < d.length; h += 4) p.data[h] = l(d[h] / 256) * 256;
    }
    u.putImageData(p, 0, 0);
    let m = (e || s).clone();
    return m.source = new sr(a), m.colorSpace = bn, m.channel = (e || s).channel, e && s && e.channel !== s.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), m;
  }
  processBuffer(e) {
    let s = this.json, r2 = this.buffers;
    return s.buffers || (s.buffers = [{ byteLength: 0 }]), r2.push(e), 0;
  }
  processBufferView(e, s, r2, t, i) {
    let n = this.json;
    n.bufferViews || (n.bufferViews = []);
    let o;
    switch (s) {
      case x.BYTE:
      case x.UNSIGNED_BYTE:
        o = 1;
        break;
      case x.SHORT:
      case x.UNSIGNED_SHORT:
        o = 2;
        break;
      default:
        o = 4;
    }
    let a = is(t * e.itemSize * o), u = new DataView(new ArrayBuffer(a)), p = 0;
    for (let l = r2; l < r2 + t; l++) for (let d = 0; d < e.itemSize; d++) {
      let h;
      e.itemSize > 4 ? h = e.array[l * e.itemSize + d] : (d === 0 ? h = e.getX(l) : d === 1 ? h = e.getY(l) : d === 2 ? h = e.getZ(l) : d === 3 && (h = e.getW(l)), e.normalized === true && (h = _v.normalize(h, e.array))), s === x.FLOAT ? u.setFloat32(p, h, true) : s === x.INT ? u.setInt32(p, h, true) : s === x.UNSIGNED_INT ? u.setUint32(p, h, true) : s === x.SHORT ? u.setInt16(p, h, true) : s === x.UNSIGNED_SHORT ? u.setUint16(p, h, true) : s === x.BYTE ? u.setInt8(p, h) : s === x.UNSIGNED_BYTE && u.setUint8(p, h), p += o;
    }
    let f = { buffer: this.processBuffer(u.buffer), byteOffset: this.byteOffset, byteLength: a };
    return i !== void 0 && (f.target = i), i === x.ARRAY_BUFFER && (f.byteStride = e.itemSize * o), this.byteOffset += a, n.bufferViews.push(f), { id: n.bufferViews.length - 1, byteLength: 0 };
  }
  processBufferViewImage(e) {
    let s = this, r2 = s.json;
    return r2.bufferViews || (r2.bufferViews = []), new Promise(function(t) {
      let i = new FileReader();
      i.readAsArrayBuffer(e), i.onloadend = function() {
        let n = Z(i.result), o = { buffer: s.processBuffer(n), byteOffset: s.byteOffset, byteLength: n.byteLength };
        s.byteOffset += n.byteLength, t(r2.bufferViews.push(o) - 1);
      };
    });
  }
  processAccessor(e, s, r2, t) {
    let i = this.json, n = { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 9: "MAT3", 16: "MAT4" }, o;
    if (e.array.constructor === Float32Array) o = x.FLOAT;
    else if (e.array.constructor === Int32Array) o = x.INT;
    else if (e.array.constructor === Uint32Array) o = x.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array) o = x.SHORT;
    else if (e.array.constructor === Uint16Array) o = x.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array) o = x.BYTE;
    else if (e.array.constructor === Uint8Array) o = x.UNSIGNED_BYTE;
    else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
    if (r2 === void 0 && (r2 = 0), (t === void 0 || t === 1 / 0) && (t = e.count), t === 0) return null;
    let a = gs(e, r2, t), u;
    s !== void 0 && (u = e === s.index ? x.ELEMENT_ARRAY_BUFFER : x.ARRAY_BUFFER);
    let p = this.processBufferView(e, o, r2, t, u), f = { bufferView: p.id, byteOffset: p.byteOffset, componentType: o, count: t, max: a.max, min: a.min, type: n[e.itemSize] };
    return e.normalized === true && (f.normalized = true), i.accessors || (i.accessors = []), i.accessors.push(f) - 1;
  }
  processImage(e, s, r2, t = "image/png") {
    if (e !== null) {
      let i = this, n = i.cache, o = i.json, a = i.options, u = i.pending;
      n.images.has(e) || n.images.set(e, {});
      let p = n.images.get(e), f = t + ":flipY/" + r2.toString();
      if (p[f] !== void 0) return p[f];
      o.images || (o.images = []);
      let m = { mimeType: t }, l = ns();
      l.width = Math.min(e.width, a.maxTextureSize), l.height = Math.min(e.height, a.maxTextureSize);
      let d = l.getContext("2d");
      if (r2 === true && (d.translate(0, l.height), d.scale(1, -1)), e.data !== void 0) {
        s !== Oe && console.error("GLTFExporter: Only RGBAFormat is supported.", s), (e.width > a.maxTextureSize || e.height > a.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        let w = new Uint8ClampedArray(e.height * e.width * 4);
        for (let M = 0; M < w.length; M += 4) w[M + 0] = e.data[M + 0], w[M + 1] = e.data[M + 1], w[M + 2] = e.data[M + 2], w[M + 3] = e.data[M + 3];
        d.putImageData(new ImageData(w, e.width, e.height), 0, 0);
      } else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) d.drawImage(e, 0, 0, l.width, l.height);
      else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement or ImageBitmap.");
      a.binary === true ? u.push(rs(l, t).then((w) => i.processBufferViewImage(w)).then((w) => {
        m.bufferView = w;
      })) : l.toDataURL !== void 0 ? m.uri = l.toDataURL(t) : u.push(rs(l, t).then((w) => new FileReader().readAsDataURL(w)).then((w) => {
        m.uri = w;
      }));
      let h = o.images.push(m) - 1;
      return p[f] = h, h;
    } else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  processSampler(e) {
    let s = this.json;
    s.samplers || (s.samplers = []);
    let r2 = { magFilter: b[e.magFilter], minFilter: b[e.minFilter], wrapS: b[e.wrapS], wrapT: b[e.wrapT] };
    return s.samplers.push(r2) - 1;
  }
  processTexture(e) {
    let r2 = this.options, t = this.cache, i = this.json;
    if (t.textures.has(e)) return t.textures.get(e);
    i.textures || (i.textures = []), e instanceof ed && (e = j(e, r2.maxTextureSize));
    let n = e.userData.mimeType;
    n === "image/webp" && (n = "image/png");
    let o = { sampler: this.processSampler(e), source: this.processImage(e.image, e.format, e.flipY, n) };
    e.name && (o.name = e.name), this._invokeAll(function(u) {
      u.writeTexture && u.writeTexture(e, o);
    });
    let a = i.textures.push(o) - 1;
    return t.textures.set(e, a), a;
  }
  processMaterial(e) {
    let s = this.cache, r2 = this.json;
    if (s.materials.has(e)) return s.materials.get(e);
    if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    r2.materials || (r2.materials = []);
    let t = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== true && e.isMeshBasicMaterial !== true && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    let i = e.color.toArray().concat([e.opacity]);
    if (F(i, [1, 1, 1, 1]) || (t.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (t.pbrMetallicRoughness.metallicFactor = e.metalness, t.pbrMetallicRoughness.roughnessFactor = e.roughness) : (t.pbrMetallicRoughness.metallicFactor = 0.5, t.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
      let o = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), a = { index: this.processTexture(o), channel: o.channel };
      this.applyTextureTransform(a, o), t.pbrMetallicRoughness.metallicRoughnessTexture = a;
    }
    if (e.map) {
      let o = { index: this.processTexture(e.map), texCoord: e.map.channel };
      this.applyTextureTransform(o, e.map), t.pbrMetallicRoughness.baseColorTexture = o;
    }
    if (e.emissive) {
      let o = e.emissive;
      if (Math.max(o.r, o.g, o.b) > 0 && (t.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
        let u = { index: this.processTexture(e.emissiveMap), texCoord: e.emissiveMap.channel };
        this.applyTextureTransform(u, e.emissiveMap), t.emissiveTexture = u;
      }
    }
    if (e.normalMap) {
      let o = { index: this.processTexture(e.normalMap), texCoord: e.normalMap.channel };
      e.normalScale && e.normalScale.x !== 1 && (o.scale = e.normalScale.x), this.applyTextureTransform(o, e.normalMap), t.normalTexture = o;
    }
    if (e.aoMap) {
      let o = { index: this.processTexture(e.aoMap), texCoord: e.aoMap.channel };
      e.aoMapIntensity !== 1 && (o.strength = e.aoMapIntensity), this.applyTextureTransform(o, e.aoMap), t.occlusionTexture = o;
    }
    e.transparent ? t.alphaMode = "BLEND" : e.alphaTest > 0 && (t.alphaMode = "MASK", t.alphaCutoff = e.alphaTest), e.side === un && (t.doubleSided = true), e.name !== "" && (t.name = e.name), this.serializeUserData(e, t), this._invokeAll(function(o) {
      o.writeMaterial && o.writeMaterial(e, t);
    });
    let n = r2.materials.push(t) - 1;
    return s.materials.set(e, n), n;
  }
  processMesh(e) {
    let s = this.cache, r2 = this.json, t = [e.geometry.uuid];
    if (Array.isArray(e.material)) for (let g = 0, y = e.material.length; g < y; g++) t.push(e.material[g].uuid);
    else t.push(e.material.uuid);
    let i = t.join(":");
    if (s.meshes.has(i)) return s.meshes.get(i);
    let n = e.geometry, o;
    e.isLineSegments ? o = x.LINES : e.isLineLoop ? o = x.LINE_LOOP : e.isLine ? o = x.LINE_STRIP : e.isPoints ? o = x.POINTS : o = e.material.wireframe ? x.LINES : x.TRIANGLES;
    let a = {}, u = {}, p = [], f = [], m = { uv: "TEXCOORD_0", uv1: "TEXCOORD_1", uv2: "TEXCOORD_2", uv3: "TEXCOORD_3", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, l = n.getAttribute("normal");
    l !== void 0 && !this.isNormalizedNormalAttribute(l) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), n.setAttribute("normal", this.createNormalizedNormalAttribute(l)));
    let d = null;
    for (let g in n.attributes) {
      if (g.slice(0, 5) === "morph") continue;
      let y = n.attributes[g];
      if (g = m[g] || g.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g) || (g = "_" + g), s.attributes.has(this.getUID(y))) {
        u[g] = s.attributes.get(this.getUID(y));
        continue;
      }
      d = null;
      let A = y.array;
      g === "JOINTS_0" && !(A instanceof Uint16Array) && !(A instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), d = new Se(new Uint16Array(A), y.itemSize, y.normalized));
      let E = this.processAccessor(d || y, n);
      E !== null && (g.startsWith("_") || this.detectMeshQuantization(g, y), u[g] = E, s.attributes.set(this.getUID(y), E));
    }
    if (l !== void 0 && n.setAttribute("normal", l), Object.keys(u).length === 0) return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      let g = [], y = [], I = {};
      if (e.morphTargetDictionary !== void 0) for (let A in e.morphTargetDictionary) I[e.morphTargetDictionary[A]] = A;
      for (let A = 0; A < e.morphTargetInfluences.length; ++A) {
        let E = {}, Se2 = false;
        for (let v in n.morphAttributes) {
          if (v !== "position" && v !== "normal") {
            Se2 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), Se2 = true);
            continue;
          }
          let S = n.morphAttributes[v][A], X = v.toUpperCase(), L = n.attributes[v];
          if (s.attributes.has(this.getUID(S, true))) {
            E[X] = s.attributes.get(this.getUID(S, true));
            continue;
          }
          let O = S.clone();
          if (!n.morphTargetsRelative) for (let R = 0, os = S.count; R < os; R++) for (let C = 0; C < S.itemSize; C++) C === 0 && O.setX(R, S.getX(R) - L.getX(R)), C === 1 && O.setY(R, S.getY(R) - L.getY(R)), C === 2 && O.setZ(R, S.getZ(R) - L.getZ(R)), C === 3 && O.setW(R, S.getW(R) - L.getW(R));
          E[X] = this.processAccessor(O, n), s.attributes.set(this.getUID(L, true), E[X]);
        }
        f.push(E), g.push(e.morphTargetInfluences[A]), e.morphTargetDictionary !== void 0 && y.push(I[A]);
      }
      a.weights = g, y.length > 0 && (a.extras = {}, a.extras.targetNames = y);
    }
    let h = Array.isArray(e.material);
    if (h && n.groups.length === 0) return null;
    let w = false;
    if (h && n.index === null) {
      let g = [];
      for (let y = 0, I = n.attributes.position.count; y < I; y++) g[y] = y;
      n.setIndex(g), w = true;
    }
    let M = h ? e.material : [e.material], N = h ? n.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let g = 0, y = N.length; g < y; g++) {
      let I = { mode: o, attributes: u };
      if (this.serializeUserData(n, I), f.length > 0 && (I.targets = f), n.index !== null) {
        let E = this.getUID(n.index);
        (N[g].start !== void 0 || N[g].count !== void 0) && (E += ":" + N[g].start + ":" + N[g].count), s.attributes.has(E) ? I.indices = s.attributes.get(E) : (I.indices = this.processAccessor(n.index, n, N[g].start, N[g].count), s.attributes.set(E, I.indices)), I.indices === null && delete I.indices;
      }
      let A = this.processMaterial(M[N[g].materialIndex]);
      A !== null && (I.material = A), p.push(I);
    }
    w === true && n.setIndex(null), a.primitives = p, r2.meshes || (r2.meshes = []), this._invokeAll(function(g) {
      g.writeMesh && g.writeMesh(e, a);
    });
    let k = r2.meshes.push(a) - 1;
    return s.meshes.set(i, k), k;
  }
  detectMeshQuantization(e, s) {
    if (this.extensionsUsed[Q]) return;
    let r2;
    switch (s.array.constructor) {
      case Int8Array:
        r2 = "byte";
        break;
      case Uint8Array:
        r2 = "unsigned byte";
        break;
      case Int16Array:
        r2 = "short";
        break;
      case Uint16Array:
        r2 = "unsigned short";
        break;
      default:
        return;
    }
    s.normalized && (r2 += " normalized");
    let t = e.split("_", 1)[0];
    $e[t] && $e[t].includes(r2) && (this.extensionsUsed[Q] = true, this.extensionsRequired[Q] = true);
  }
  processCamera(e) {
    let s = this.json;
    s.cameras || (s.cameras = []);
    let r2 = e.isOrthographicCamera, t = { type: r2 ? "orthographic" : "perspective" };
    return r2 ? t.orthographic = { xmag: e.right * 2, ymag: e.top * 2, zfar: e.far <= 0 ? 1e-3 : e.far, znear: e.near < 0 ? 0 : e.near } : t.perspective = { aspectRatio: e.aspect, yfov: _v.degToRad(e.fov), zfar: e.far <= 0 ? 1e-3 : e.far, znear: e.near < 0 ? 0 : e.near }, e.name !== "" && (t.name = e.type), s.cameras.push(t) - 1;
  }
  processAnimation(e, s) {
    let r2 = this.json, t = this.nodeMap;
    r2.animations || (r2.animations = []), e = q2.Utils.mergeMorphTargetTracks(e.clone(), s);
    let i = e.tracks, n = [], o = [];
    for (let a = 0; a < i.length; ++a) {
      let u = i[a], p = ne.parseTrackName(u.name), f = ne.findNode(s, p.nodeName), m = es[p.propertyName];
      if (p.objectName === "bones" && (f.isSkinnedMesh === true ? f = f.skeleton.getBoneByName(p.objectIndex) : f = void 0), !f || !m) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', u.name), null;
      let l = 1, d = u.values.length / u.times.length;
      m === es.morphTargetInfluences && (d /= f.morphTargetInfluences.length);
      let h;
      u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ? (h = "CUBICSPLINE", d /= 3) : u.getInterpolation() === $s ? h = "STEP" : h = "LINEAR", o.push({ input: this.processAccessor(new Se(u.times, l)), output: this.processAccessor(new Se(u.values, d)), interpolation: h }), n.push({ sampler: o.length - 1, target: { node: t.get(f), path: m } });
    }
    return r2.animations.push({ name: e.name || "clip_" + r2.animations.length, samplers: o, channels: n }), r2.animations.length - 1;
  }
  processSkin(e) {
    let s = this.json, r2 = this.nodeMap, t = s.nodes[r2.get(e)], i = e.skeleton;
    if (i === void 0) return null;
    let n = e.skeleton.bones[0];
    if (n === void 0) return null;
    let o = [], a = new Float32Array(i.bones.length * 16), u = new Ft();
    for (let f = 0; f < i.bones.length; ++f) o.push(r2.get(i.bones[f])), u.copy(i.boneInverses[f]), u.multiply(e.bindMatrix).toArray(a, f * 16);
    return s.skins === void 0 && (s.skins = []), s.skins.push({ inverseBindMatrices: this.processAccessor(new Se(a, 16)), joints: o, skeleton: r2.get(n) }), t.skin = s.skins.length - 1;
  }
  processNode(e) {
    let s = this.json, r2 = this.options, t = this.nodeMap;
    s.nodes || (s.nodes = []);
    let i = {};
    if (r2.trs) {
      let o = e.quaternion.toArray(), a = e.position.toArray(), u = e.scale.toArray();
      F(o, [0, 0, 0, 1]) || (i.rotation = o), F(a, [0, 0, 0]) || (i.translation = a), F(u, [1, 1, 1]) || (i.scale = u);
    } else e.matrixAutoUpdate && e.updateMatrix(), ds(e.matrix) === false && (i.matrix = e.matrix.elements);
    if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
      let o = this.processMesh(e);
      o !== null && (i.mesh = o);
    } else e.isCamera && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      let o = [];
      for (let a = 0, u = e.children.length; a < u; a++) {
        let p = e.children[a];
        if (p.visible || r2.onlyVisible === false) {
          let f = this.processNode(p);
          f !== null && o.push(f);
        }
      }
      o.length > 0 && (i.children = o);
    }
    this._invokeAll(function(o) {
      o.writeNode && o.writeNode(e, i);
    });
    let n = s.nodes.push(i) - 1;
    return t.set(e, n), n;
  }
  processScene(e) {
    let s = this.json, r2 = this.options;
    s.scenes || (s.scenes = [], s.scene = 0);
    let t = {};
    e.name !== "" && (t.name = e.name), s.scenes.push(t);
    let i = [];
    for (let n = 0, o = e.children.length; n < o; n++) {
      let a = e.children[n];
      if (a.visible || r2.onlyVisible === false) {
        let u = this.processNode(a);
        u !== null && i.push(u);
      }
    }
    i.length > 0 && (t.nodes = i), this.serializeUserData(e, t);
  }
  processObjects(e) {
    let s = new Ru();
    s.name = "AuxScene";
    for (let r2 = 0; r2 < e.length; r2++) s.children.push(e[r2]);
    this.processScene(s);
  }
  processInput(e) {
    let s = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(t) {
      t.beforeParse && t.beforeParse(e);
    });
    let r2 = [];
    for (let t = 0; t < e.length; t++) e[t] instanceof Ru ? this.processScene(e[t]) : r2.push(e[t]);
    r2.length > 0 && this.processObjects(r2);
    for (let t = 0; t < this.skins.length; ++t) this.processSkin(this.skins[t]);
    for (let t = 0; t < s.animations.length; ++t) this.processAnimation(s.animations[t], e[0]);
    this._invokeAll(function(t) {
      t.afterParse && t.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let s = 0, r2 = this.plugins.length; s < r2; s++) e(this.plugins[s]);
  }
};
r(de, "GLTFWriter");
var $ = de;
var ge2 = class ge3 {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, s) {
    if (!e.isLight) return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    let r2 = this.writer, t = r2.json, i = r2.extensionsUsed, n = {};
    e.name && (n.name = e.name), n.color = e.color.toArray(), n.intensity = e.intensity, e.isDirectionalLight ? n.type = "directional" : e.isPointLight ? (n.type = "point", e.distance > 0 && (n.range = e.distance)) : e.isSpotLight && (n.type = "spot", e.distance > 0 && (n.range = e.distance), n.spot = {}, n.spot.innerConeAngle = (1 - e.penumbra) * e.angle, n.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (t.extensions = t.extensions || {}, t.extensions[this.name] = { lights: [] }, i[this.name] = true);
    let o = t.extensions[this.name].lights;
    o.push(n), s.extensions = s.extensions || {}, s.extensions[this.name] = { light: o.length - 1 };
  }
};
r(ge2, "GLTFLightExtension");
var ee = ge2;
var xe = class xe2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, s) {
    if (!e.isMeshBasicMaterial) return;
    let t = this.writer.extensionsUsed;
    s.extensions = s.extensions || {}, s.extensions[this.name] = {}, t[this.name] = true, s.pbrMetallicRoughness.metallicFactor = 0, s.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
r(xe, "GLTFMaterialsUnlitExtension");
var se = xe;
var me = class me2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      let n = { index: r2.processTexture(e.clearcoatMap), texCoord: e.clearcoatMap.channel };
      r2.applyTextureTransform(n, e.clearcoatMap), i.clearcoatTexture = n;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      let n = { index: r2.processTexture(e.clearcoatRoughnessMap), texCoord: e.clearcoatRoughnessMap.channel };
      r2.applyTextureTransform(n, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = n;
    }
    if (e.clearcoatNormalMap) {
      let n = { index: r2.processTexture(e.clearcoatNormalMap), texCoord: e.clearcoatNormalMap.channel };
      r2.applyTextureTransform(n, e.clearcoatNormalMap), i.clearcoatNormalTexture = n;
    }
    s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(me, "GLTFMaterialsClearcoatExtension");
var te = me;
var Te2 = class Te3 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      let n = { index: r2.processTexture(e.iridescenceMap), texCoord: e.iridescenceMap.channel };
      r2.applyTextureTransform(n, e.iridescenceMap), i.iridescenceTexture = n;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      let n = { index: r2.processTexture(e.iridescenceThicknessMap), texCoord: e.iridescenceThicknessMap.channel };
      r2.applyTextureTransform(n, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = n;
    }
    s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Te2, "GLTFMaterialsIridescenceExtension");
var ne2 = Te2;
var ye = class ye2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      let n = { index: r2.processTexture(e.transmissionMap), texCoord: e.transmissionMap.channel };
      r2.applyTextureTransform(n, e.transmissionMap), i.transmissionTexture = n;
    }
    s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(ye, "GLTFMaterialsTransmissionExtension");
var re = ye;
var we = class we2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      let n = { index: r2.processTexture(e.thicknessMap), texCoord: e.thicknessMap.channel };
      r2.applyTextureTransform(n, e.thicknessMap), i.thicknessTexture = n;
    }
    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(we, "GLTFMaterialsVolumeExtension");
var ie = we;
var Me2 = class Me3 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5) return;
    let t = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Me2, "GLTFMaterialsIorExtension");
var oe = Me2;
var Ie = class Ie2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(cs) && !e.specularIntensityMap && !e.specularColorMap) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      let n = { index: r2.processTexture(e.specularIntensityMap), texCoord: e.specularIntensityMap.channel };
      r2.applyTextureTransform(n, e.specularIntensityMap), i.specularTexture = n;
    }
    if (e.specularColorMap) {
      let n = { index: r2.processTexture(e.specularColorMap), texCoord: e.specularColorMap.channel };
      r2.applyTextureTransform(n, e.specularColorMap), i.specularColorTexture = n;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Ie, "GLTFMaterialsSpecularExtension");
var ae = Ie;
var Ae = class Ae2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      let n = { index: r2.processTexture(e.sheenRoughnessMap), texCoord: e.sheenRoughnessMap.channel };
      r2.applyTextureTransform(n, e.sheenRoughnessMap), i.sheenRoughnessTexture = n;
    }
    if (e.sheenColorMap) {
      let n = { index: r2.processTexture(e.sheenColorMap), texCoord: e.sheenColorMap.channel };
      r2.applyTextureTransform(n, e.sheenColorMap), i.sheenColorTexture = n;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Ae, "GLTFMaterialsSheenExtension");
var ce = Ae;
var Re = class Re2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, s) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      let n = { index: r2.processTexture(e.anisotropyMap) };
      r2.applyTextureTransform(n, e.anisotropyMap), i.anisotropyTexture = n;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Re, "GLTFMaterialsAnisotropyExtension");
var ue = Re;
var Ee = class Ee2 {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, s) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1) return;
    let t = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(Ee, "GLTFMaterialsEmissiveStrengthExtension");
var le = Ee;
var be = class be2 {
  constructor(e) {
    this.writer = e, this.name = "EXT_materials_bump";
  }
  writeMaterial(e, s) {
    if (!e.isMeshStandardMaterial || e.bumpScale === 1 && !e.bumpMap) return;
    let r2 = this.writer, t = r2.extensionsUsed, i = {};
    if (e.bumpMap) {
      let n = { index: r2.processTexture(e.bumpMap), texCoord: e.bumpMap.channel };
      r2.applyTextureTransform(n, e.bumpMap), i.bumpTexture = n;
    }
    i.bumpFactor = e.bumpScale, s.extensions = s.extensions || {}, s.extensions[this.name] = i, t[this.name] = true;
  }
};
r(be, "GLTFMaterialsBumpExtension");
var fe = be;
var Ne = class Ne2 {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, s) {
    if (!e.isInstancedMesh) return;
    let r2 = this.writer, t = e, i = new Float32Array(t.count * 3), n = new Float32Array(t.count * 4), o = new Float32Array(t.count * 3), a = new Ft(), u = new P(), p = new In(), f = new P();
    for (let l = 0; l < t.count; l++) t.getMatrixAt(l, a), a.decompose(u, p, f), u.toArray(i, l * 3), p.toArray(n, l * 4), f.toArray(o, l * 3);
    let m = { TRANSLATION: r2.processAccessor(new Se(i, 3)), ROTATION: r2.processAccessor(new Se(n, 4)), SCALE: r2.processAccessor(new Se(o, 3)) };
    t.instanceColor && (m._COLOR_0 = r2.processAccessor(t.instanceColor)), s.extensions = s.extensions || {}, s.extensions[this.name] = { attributes: m }, r2.extensionsUsed[this.name] = true, r2.extensionsRequired[this.name] = true;
  }
};
r(Ne, "GLTFMeshGpuInstancing");
var he = Ne;
q2.Utils = { insertKeyframe: function(c, e) {
  let r2 = c.getValueSize(), t = new c.TimeBufferType(c.times.length + 1), i = new c.ValueBufferType(c.values.length + r2), n = c.createInterpolant(new c.ValueBufferType(r2)), o;
  if (c.times.length === 0) {
    t[0] = e;
    for (let a = 0; a < r2; a++) i[a] = 0;
    o = 0;
  } else if (e < c.times[0]) {
    if (Math.abs(c.times[0] - e) < 1e-3) return 0;
    t[0] = e, t.set(c.times, 1), i.set(n.evaluate(e), 0), i.set(c.values, r2), o = 0;
  } else if (e > c.times[c.times.length - 1]) {
    if (Math.abs(c.times[c.times.length - 1] - e) < 1e-3) return c.times.length - 1;
    t[t.length - 1] = e, t.set(c.times, 0), i.set(c.values, 0), i.set(n.evaluate(e), c.values.length), o = t.length - 1;
  } else for (let a = 0; a < c.times.length; a++) {
    if (Math.abs(c.times[a] - e) < 1e-3) return a;
    if (c.times[a] < e && c.times[a + 1] > e) {
      t.set(c.times.slice(0, a + 1), 0), t[a + 1] = e, t.set(c.times.slice(a + 1), a + 2), i.set(c.values.slice(0, (a + 1) * r2), 0), i.set(n.evaluate(e), (a + 1) * r2), i.set(c.values.slice((a + 1) * r2), (a + 2) * r2), o = a + 1;
      break;
    }
  }
  return c.times = t, c.values = i, o;
}, mergeMorphTargetTracks: function(c, e) {
  let s = [], r2 = {}, t = c.tracks;
  for (let i = 0; i < t.length; ++i) {
    let n = t[i], o = ne.parseTrackName(n.name), a = ne.findNode(e, o.nodeName);
    if (o.propertyName !== "morphTargetInfluences" || o.propertyIndex === void 0) {
      s.push(n);
      continue;
    }
    if (n.createInterpolant !== n.InterpolantFactoryMethodDiscrete && n.createInterpolant !== n.InterpolantFactoryMethodLinear) {
      if (n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
      console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), n = n.clone(), n.setInterpolation(Ks);
    }
    let u = a.morphTargetInfluences.length, p = a.morphTargetDictionary[o.propertyIndex];
    if (p === void 0) throw new Error("THREE.GLTFExporter: Morph target name not found: " + o.propertyIndex);
    let f;
    if (r2[a.uuid] === void 0) {
      f = n.clone();
      let l = new f.ValueBufferType(u * f.times.length);
      for (let d = 0; d < f.times.length; d++) l[d * u + p] = f.values[d];
      f.name = (o.nodeName || "") + ".morphTargetInfluences", f.values = l, r2[a.uuid] = f, s.push(f);
      continue;
    }
    let m = n.createInterpolant(new n.ValueBufferType(1));
    f = r2[a.uuid];
    for (let l = 0; l < f.times.length; l++) f.values[l * u + p] = m.evaluate(f.times[l]);
    for (let l = 0; l < n.times.length; l++) {
      let d = this.insertKeyframe(f, n.times[l]);
      f.values[d * u + p] = n.values[l];
    }
  }
  return c.tracks = s, c;
} };
export {
  q2 as GLTFExporter
};
//# sourceMappingURL=GLTFExporter-R7ENFQC2-LIBK547A.js.map

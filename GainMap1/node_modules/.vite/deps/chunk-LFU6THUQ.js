import {
  q,
  r,
  s,
  t,
  u
} from "./chunk-F6LUTOTK.js";

// node_modules/@mappedin/mappedin-js/lib/esm/chunk-5QDDUDQO.js
var ge = s((SD, Vx) => {
  "use strict";
  q();
  Vx.exports = Ai;
  function Ai(r3, e) {
    this.x = r3, this.y = e;
  }
  r(Ai, "Point");
  Ai.prototype = { clone: function() {
    return new Ai(this.x, this.y);
  }, add: function(r3) {
    return this.clone()._add(r3);
  }, sub: function(r3) {
    return this.clone()._sub(r3);
  }, multByPoint: function(r3) {
    return this.clone()._multByPoint(r3);
  }, divByPoint: function(r3) {
    return this.clone()._divByPoint(r3);
  }, mult: function(r3) {
    return this.clone()._mult(r3);
  }, div: function(r3) {
    return this.clone()._div(r3);
  }, rotate: function(r3) {
    return this.clone()._rotate(r3);
  }, rotateAround: function(r3, e) {
    return this.clone()._rotateAround(r3, e);
  }, matMult: function(r3) {
    return this.clone()._matMult(r3);
  }, unit: function() {
    return this.clone()._unit();
  }, perp: function() {
    return this.clone()._perp();
  }, round: function() {
    return this.clone()._round();
  }, mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, equals: function(r3) {
    return this.x === r3.x && this.y === r3.y;
  }, dist: function(r3) {
    return Math.sqrt(this.distSqr(r3));
  }, distSqr: function(r3) {
    var e = r3.x - this.x, t3 = r3.y - this.y;
    return e * e + t3 * t3;
  }, angle: function() {
    return Math.atan2(this.y, this.x);
  }, angleTo: function(r3) {
    return Math.atan2(this.y - r3.y, this.x - r3.x);
  }, angleWith: function(r3) {
    return this.angleWithSep(r3.x, r3.y);
  }, angleWithSep: function(r3, e) {
    return Math.atan2(this.x * e - this.y * r3, this.x * r3 + this.y * e);
  }, _matMult: function(r3) {
    var e = r3[0] * this.x + r3[1] * this.y, t3 = r3[2] * this.x + r3[3] * this.y;
    return this.x = e, this.y = t3, this;
  }, _add: function(r3) {
    return this.x += r3.x, this.y += r3.y, this;
  }, _sub: function(r3) {
    return this.x -= r3.x, this.y -= r3.y, this;
  }, _mult: function(r3) {
    return this.x *= r3, this.y *= r3, this;
  }, _div: function(r3) {
    return this.x /= r3, this.y /= r3, this;
  }, _multByPoint: function(r3) {
    return this.x *= r3.x, this.y *= r3.y, this;
  }, _divByPoint: function(r3) {
    return this.x /= r3.x, this.y /= r3.y, this;
  }, _unit: function() {
    return this._div(this.mag()), this;
  }, _perp: function() {
    var r3 = this.y;
    return this.y = this.x, this.x = -r3, this;
  }, _rotate: function(r3) {
    var e = Math.cos(r3), t3 = Math.sin(r3), i = e * this.x - t3 * this.y, n = t3 * this.x + e * this.y;
    return this.x = i, this.y = n, this;
  }, _rotateAround: function(r3, e) {
    var t3 = Math.cos(r3), i = Math.sin(r3), n = e.x + t3 * (this.x - e.x) - i * (this.y - e.y), o = e.y + i * (this.x - e.x) + t3 * (this.y - e.y);
    return this.x = n, this.y = o, this;
  }, _round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  } };
  Ai.convert = function(r3) {
    return r3 instanceof Ai ? r3 : Array.isArray(r3) ? new Ai(r3[0], r3[1]) : r3;
  };
});
var Gx = s((MD, Nx) => {
  "use strict";
  q();
  Nx.exports = Ux;
  function Ux(r3, e, t3, i) {
    this.cx = 3 * r3, this.bx = 3 * (t3 - r3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r3, this.p1y = e, this.p2x = t3, this.p2y = i;
  }
  r(Ux, "UnitBezier");
  Ux.prototype = { sampleCurveX: function(r3) {
    return ((this.ax * r3 + this.bx) * r3 + this.cx) * r3;
  }, sampleCurveY: function(r3) {
    return ((this.ay * r3 + this.by) * r3 + this.cy) * r3;
  }, sampleCurveDerivativeX: function(r3) {
    return (3 * this.ax * r3 + 2 * this.bx) * r3 + this.cx;
  }, solveCurveX: function(r3, e) {
    if (e === void 0 && (e = 1e-6), r3 < 0) return 0;
    if (r3 > 1) return 1;
    for (var t3 = r3, i = 0; i < 8; i++) {
      var n = this.sampleCurveX(t3) - r3;
      if (Math.abs(n) < e) return t3;
      var o = this.sampleCurveDerivativeX(t3);
      if (Math.abs(o) < 1e-6) break;
      t3 = t3 - n / o;
    }
    var a = 0, s3 = 1;
    for (t3 = r3, i = 0; i < 20 && (n = this.sampleCurveX(t3), !(Math.abs(n - r3) < e)); i++) r3 > n ? a = t3 : s3 = t3, t3 = (s3 - a) * 0.5 + a;
    return t3;
  }, solve: function(r3, e) {
    return this.sampleCurveY(this.solveCurveX(r3, e));
  } };
});
var k_ = s((m3, Hf) => {
  q();
  function sM(r3, e) {
    var t3, i, n, o, a, s3, l, c, p, h;
    for (t3 = r3.length & 3, i = r3.length - t3, n = e, a = 3432918353, l = 461845907, h = 0; h < i; ) p = r3.charCodeAt(h) & 255 | (r3.charCodeAt(++h) & 255) << 8 | (r3.charCodeAt(++h) & 255) << 16 | (r3.charCodeAt(++h) & 255) << 24, ++h, p = (p & 65535) * a + (((p >>> 16) * a & 65535) << 16) & 4294967295, p = p << 15 | p >>> 17, p = (p & 65535) * l + (((p >>> 16) * l & 65535) << 16) & 4294967295, n ^= p, n = n << 13 | n >>> 19, o = (n & 65535) * 5 + (((n >>> 16) * 5 & 65535) << 16) & 4294967295, n = (o & 65535) + 27492 + (((o >>> 16) + 58964 & 65535) << 16);
    switch (p = 0, t3) {
      case 3:
        p ^= (r3.charCodeAt(h + 2) & 255) << 16;
      case 2:
        p ^= (r3.charCodeAt(h + 1) & 255) << 8;
      case 1:
        p ^= r3.charCodeAt(h) & 255, p = (p & 65535) * a + (((p >>> 16) * a & 65535) << 16) & 4294967295, p = p << 15 | p >>> 17, p = (p & 65535) * l + (((p >>> 16) * l & 65535) << 16) & 4294967295, n ^= p;
    }
    return n ^= r3.length, n ^= n >>> 16, n = (n & 65535) * 2246822507 + (((n >>> 16) * 2246822507 & 65535) << 16) & 4294967295, n ^= n >>> 13, n = (n & 65535) * 3266489909 + (((n >>> 16) * 3266489909 & 65535) << 16) & 4294967295, n ^= n >>> 16, n >>> 0;
  }
  r(sM, "murmurhash3_32_gc");
  typeof Hf < "u" && (Hf.exports = sM);
});
var L_ = s((g3, Wf) => {
  q();
  function lM(r3, e) {
    for (var t3 = r3.length, i = e ^ t3, n = 0, o; t3 >= 4; ) o = r3.charCodeAt(n) & 255 | (r3.charCodeAt(++n) & 255) << 8 | (r3.charCodeAt(++n) & 255) << 16 | (r3.charCodeAt(++n) & 255) << 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), o ^= o >>> 24, o = (o & 65535) * 1540483477 + (((o >>> 16) * 1540483477 & 65535) << 16), i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16) ^ o, t3 -= 4, ++n;
    switch (t3) {
      case 3:
        i ^= (r3.charCodeAt(n + 2) & 255) << 16;
      case 2:
        i ^= (r3.charCodeAt(n + 1) & 255) << 8;
      case 1:
        i ^= r3.charCodeAt(n) & 255, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16);
    }
    return i ^= i >>> 13, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16), i ^= i >>> 15, i >>> 0;
  }
  r(lM, "murmurhash2_32_gc");
  typeof Wf !== void 0 && (Wf.exports = lM);
});
var Xf = s((_3, Sl) => {
  q();
  var D_ = k_(), uM = L_();
  Sl.exports = D_;
  Sl.exports.murmur3 = D_;
  Sl.exports.murmur2 = uM;
});
var Am = s((lO, Mm) => {
  "use strict";
  q();
  Mm.exports = Vl;
  Mm.exports.default = Vl;
  function Vl(r3, e, t3) {
    t3 = t3 || 2;
    var i = e && e.length, n = i ? e[0] * t3 : r3.length, o = Ov(r3, 0, n, t3, true), a = [];
    if (!o || o.next === o.prev) return a;
    var s3, l, c, p, h, f, m;
    if (i && (o = bE(r3, e, o, t3)), r3.length > 80 * t3) {
      s3 = c = r3[0], l = p = r3[1];
      for (var y = t3; y < n; y += t3) h = r3[y], f = r3[y + 1], h < s3 && (s3 = h), f < l && (l = f), h > c && (c = h), f > p && (p = f);
      m = Math.max(c - s3, p - l), m = m !== 0 ? 32767 / m : 0;
    }
    return Uo(o, a, t3, s3, l, m, 0), a;
  }
  r(Vl, "earcut");
  function Ov(r3, e, t3, i, n) {
    var o, a;
    if (n === Tm(r3, e, t3, i) > 0) for (o = e; o < t3; o += i) a = Bv(o, r3[o], r3[o + 1], a);
    else for (o = t3 - i; o >= e; o -= i) a = Bv(o, r3[o], r3[o + 1], a);
    return a && Ul(a, a.next) && (Go(a), a = a.next), a;
  }
  r(Ov, "linkedList");
  function hi(r3, e) {
    if (!r3) return r3;
    e || (e = r3);
    var t3 = r3, i;
    do
      if (i = false, !t3.steiner && (Ul(t3, t3.next) || Oe(t3.prev, t3, t3.next) === 0)) {
        if (Go(t3), t3 = e = t3.prev, t3 === t3.next) break;
        i = true;
      } else t3 = t3.next;
    while (i || t3 !== e);
    return e;
  }
  r(hi, "filterPoints");
  function Uo(r3, e, t3, i, n, o, a) {
    if (r3) {
      !a && o && PE(r3, i, n, o);
      for (var s3 = r3, l, c; r3.prev !== r3.next; ) {
        if (l = r3.prev, c = r3.next, o ? yE(r3, i, n, o) : dE(r3)) {
          e.push(l.i / t3 | 0), e.push(r3.i / t3 | 0), e.push(c.i / t3 | 0), Go(r3), r3 = c.next, s3 = c.next;
          continue;
        }
        if (r3 = c, r3 === s3) {
          a ? a === 1 ? (r3 = gE(hi(r3), e, t3), Uo(r3, e, t3, i, n, o, 2)) : a === 2 && xE(r3, e, t3, i, n, o) : Uo(hi(r3), e, t3, i, n, o, 1);
          break;
        }
      }
    }
  }
  r(Uo, "earcutLinked");
  function dE(r3) {
    var e = r3.prev, t3 = r3, i = r3.next;
    if (Oe(e, t3, i) >= 0) return false;
    for (var n = e.x, o = t3.x, a = i.x, s3 = e.y, l = t3.y, c = i.y, p = n < o ? n < a ? n : a : o < a ? o : a, h = s3 < l ? s3 < c ? s3 : c : l < c ? l : c, f = n > o ? n > a ? n : a : o > a ? o : a, m = s3 > l ? s3 > c ? s3 : c : l > c ? l : c, y = i.next; y !== e; ) {
      if (y.x >= p && y.x <= f && y.y >= h && y.y <= m && on(n, s3, o, l, a, c, y.x, y.y) && Oe(y.prev, y, y.next) >= 0) return false;
      y = y.next;
    }
    return true;
  }
  r(dE, "isEar");
  function yE(r3, e, t3, i) {
    var n = r3.prev, o = r3, a = r3.next;
    if (Oe(n, o, a) >= 0) return false;
    for (var s3 = n.x, l = o.x, c = a.x, p = n.y, h = o.y, f = a.y, m = s3 < l ? s3 < c ? s3 : c : l < c ? l : c, y = p < h ? p < f ? p : f : h < f ? h : f, g = s3 > l ? s3 > c ? s3 : c : l > c ? l : c, x = p > h ? p > f ? p : f : h > f ? h : f, b = Sm(m, y, e, t3, i), w = Sm(g, x, e, t3, i), _ = r3.prevZ, S = r3.nextZ; _ && _.z >= b && S && S.z <= w; ) {
      if (_.x >= m && _.x <= g && _.y >= y && _.y <= x && _ !== n && _ !== a && on(s3, p, l, h, c, f, _.x, _.y) && Oe(_.prev, _, _.next) >= 0 || (_ = _.prevZ, S.x >= m && S.x <= g && S.y >= y && S.y <= x && S !== n && S !== a && on(s3, p, l, h, c, f, S.x, S.y) && Oe(S.prev, S, S.next) >= 0)) return false;
      S = S.nextZ;
    }
    for (; _ && _.z >= b; ) {
      if (_.x >= m && _.x <= g && _.y >= y && _.y <= x && _ !== n && _ !== a && on(s3, p, l, h, c, f, _.x, _.y) && Oe(_.prev, _, _.next) >= 0) return false;
      _ = _.prevZ;
    }
    for (; S && S.z <= w; ) {
      if (S.x >= m && S.x <= g && S.y >= y && S.y <= x && S !== n && S !== a && on(s3, p, l, h, c, f, S.x, S.y) && Oe(S.prev, S, S.next) >= 0) return false;
      S = S.nextZ;
    }
    return true;
  }
  r(yE, "isEarHashed");
  function gE(r3, e, t3) {
    var i = r3;
    do {
      var n = i.prev, o = i.next.next;
      !Ul(n, o) && Vv(n, i, i.next, o) && No(n, o) && No(o, n) && (e.push(n.i / t3 | 0), e.push(i.i / t3 | 0), e.push(o.i / t3 | 0), Go(i), Go(i.next), i = r3 = o), i = i.next;
    } while (i !== r3);
    return hi(i);
  }
  r(gE, "cureLocalIntersections");
  function xE(r3, e, t3, i, n, o) {
    var a = r3;
    do {
      for (var s3 = a.next.next; s3 !== a.prev; ) {
        if (a.i !== s3.i && AE(a, s3)) {
          var l = Uv(a, s3);
          a = hi(a, a.next), l = hi(l, l.next), Uo(a, e, t3, i, n, o, 0), Uo(l, e, t3, i, n, o, 0);
          return;
        }
        s3 = s3.next;
      }
      a = a.next;
    } while (a !== r3);
  }
  r(xE, "splitEarcut");
  function bE(r3, e, t3, i) {
    var n = [], o, a, s3, l, c;
    for (o = 0, a = e.length; o < a; o++) s3 = e[o] * i, l = o < a - 1 ? e[o + 1] * i : r3.length, c = Ov(r3, s3, l, i, false), c === c.next && (c.steiner = true), n.push(ME(c));
    for (n.sort(_E), o = 0; o < n.length; o++) t3 = vE(n[o], t3);
    return t3;
  }
  r(bE, "eliminateHoles");
  function _E(r3, e) {
    return r3.x - e.x;
  }
  r(_E, "compareX");
  function vE(r3, e) {
    var t3 = wE(r3, e);
    if (!t3) return e;
    var i = Uv(t3, r3);
    return hi(i, i.next), hi(t3, t3.next);
  }
  r(vE, "eliminateHole");
  function wE(r3, e) {
    var t3 = e, i = r3.x, n = r3.y, o = -1 / 0, a;
    do {
      if (n <= t3.y && n >= t3.next.y && t3.next.y !== t3.y) {
        var s3 = t3.x + (n - t3.y) * (t3.next.x - t3.x) / (t3.next.y - t3.y);
        if (s3 <= i && s3 > o && (o = s3, a = t3.x < t3.next.x ? t3 : t3.next, s3 === i)) return a;
      }
      t3 = t3.next;
    } while (t3 !== e);
    if (!a) return null;
    var l = a, c = a.x, p = a.y, h = 1 / 0, f;
    t3 = a;
    do
      i >= t3.x && t3.x >= c && i !== t3.x && on(n < p ? i : o, n, c, p, n < p ? o : i, n, t3.x, t3.y) && (f = Math.abs(n - t3.y) / (i - t3.x), No(t3, r3) && (f < h || f === h && (t3.x > a.x || t3.x === a.x && SE(a, t3))) && (a = t3, h = f)), t3 = t3.next;
    while (t3 !== l);
    return a;
  }
  r(wE, "findHoleBridge");
  function SE(r3, e) {
    return Oe(r3.prev, r3, e.prev) < 0 && Oe(e.next, r3, r3.next) < 0;
  }
  r(SE, "sectorContainsSector");
  function PE(r3, e, t3, i) {
    var n = r3;
    do
      n.z === 0 && (n.z = Sm(n.x, n.y, e, t3, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
    while (n !== r3);
    n.prevZ.nextZ = null, n.prevZ = null, TE(n);
  }
  r(PE, "indexCurve");
  function TE(r3) {
    var e, t3, i, n, o, a, s3, l, c = 1;
    do {
      for (t3 = r3, r3 = null, o = null, a = 0; t3; ) {
        for (a++, i = t3, s3 = 0, e = 0; e < c && (s3++, i = i.nextZ, !!i); e++) ;
        for (l = c; s3 > 0 || l > 0 && i; ) s3 !== 0 && (l === 0 || !i || t3.z <= i.z) ? (n = t3, t3 = t3.nextZ, s3--) : (n = i, i = i.nextZ, l--), o ? o.nextZ = n : r3 = n, n.prevZ = o, o = n;
        t3 = i;
      }
      o.nextZ = null, c *= 2;
    } while (a > 1);
    return r3;
  }
  r(TE, "sortLinked");
  function Sm(r3, e, t3, i, n) {
    return r3 = (r3 - t3) * n | 0, e = (e - i) * n | 0, r3 = (r3 | r3 << 8) & 16711935, r3 = (r3 | r3 << 4) & 252645135, r3 = (r3 | r3 << 2) & 858993459, r3 = (r3 | r3 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r3 | e << 1;
  }
  r(Sm, "zOrder");
  function ME(r3) {
    var e = r3, t3 = r3;
    do
      (e.x < t3.x || e.x === t3.x && e.y < t3.y) && (t3 = e), e = e.next;
    while (e !== r3);
    return t3;
  }
  r(ME, "getLeftmost");
  function on(r3, e, t3, i, n, o, a, s3) {
    return (n - a) * (e - s3) >= (r3 - a) * (o - s3) && (r3 - a) * (i - s3) >= (t3 - a) * (e - s3) && (t3 - a) * (o - s3) >= (n - a) * (i - s3);
  }
  r(on, "pointInTriangle");
  function AE(r3, e) {
    return r3.next.i !== e.i && r3.prev.i !== e.i && !IE(r3, e) && (No(r3, e) && No(e, r3) && CE(r3, e) && (Oe(r3.prev, r3, e.prev) || Oe(r3, e.prev, e)) || Ul(r3, e) && Oe(r3.prev, r3, r3.next) > 0 && Oe(e.prev, e, e.next) > 0);
  }
  r(AE, "isValidDiagonal");
  function Oe(r3, e, t3) {
    return (e.y - r3.y) * (t3.x - e.x) - (e.x - r3.x) * (t3.y - e.y);
  }
  r(Oe, "area");
  function Ul(r3, e) {
    return r3.x === e.x && r3.y === e.y;
  }
  r(Ul, "equals");
  function Vv(r3, e, t3, i) {
    var n = Ol(Oe(r3, e, t3)), o = Ol(Oe(r3, e, i)), a = Ol(Oe(t3, i, r3)), s3 = Ol(Oe(t3, i, e));
    return !!(n !== o && a !== s3 || n === 0 && Bl(r3, t3, e) || o === 0 && Bl(r3, i, e) || a === 0 && Bl(t3, r3, i) || s3 === 0 && Bl(t3, e, i));
  }
  r(Vv, "intersects");
  function Bl(r3, e, t3) {
    return e.x <= Math.max(r3.x, t3.x) && e.x >= Math.min(r3.x, t3.x) && e.y <= Math.max(r3.y, t3.y) && e.y >= Math.min(r3.y, t3.y);
  }
  r(Bl, "onSegment");
  function Ol(r3) {
    return r3 > 0 ? 1 : r3 < 0 ? -1 : 0;
  }
  r(Ol, "sign");
  function IE(r3, e) {
    var t3 = r3;
    do {
      if (t3.i !== r3.i && t3.next.i !== r3.i && t3.i !== e.i && t3.next.i !== e.i && Vv(t3, t3.next, r3, e)) return true;
      t3 = t3.next;
    } while (t3 !== r3);
    return false;
  }
  r(IE, "intersectsPolygon");
  function No(r3, e) {
    return Oe(r3.prev, r3, r3.next) < 0 ? Oe(r3, e, r3.next) >= 0 && Oe(r3, r3.prev, e) >= 0 : Oe(r3, e, r3.prev) < 0 || Oe(r3, r3.next, e) < 0;
  }
  r(No, "locallyInside");
  function CE(r3, e) {
    var t3 = r3, i = false, n = (r3.x + e.x) / 2, o = (r3.y + e.y) / 2;
    do
      t3.y > o != t3.next.y > o && t3.next.y !== t3.y && n < (t3.next.x - t3.x) * (o - t3.y) / (t3.next.y - t3.y) + t3.x && (i = !i), t3 = t3.next;
    while (t3 !== r3);
    return i;
  }
  r(CE, "middleInside");
  function Uv(r3, e) {
    var t3 = new Pm(r3.i, r3.x, r3.y), i = new Pm(e.i, e.x, e.y), n = r3.next, o = e.prev;
    return r3.next = e, e.prev = r3, t3.next = n, n.prev = t3, i.next = t3, t3.prev = i, o.next = i, i.prev = o, i;
  }
  r(Uv, "splitPolygon");
  function Bv(r3, e, t3, i) {
    var n = new Pm(r3, e, t3);
    return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
  }
  r(Bv, "insertNode");
  function Go(r3) {
    r3.next.prev = r3.prev, r3.prev.next = r3.next, r3.prevZ && (r3.prevZ.nextZ = r3.nextZ), r3.nextZ && (r3.nextZ.prevZ = r3.prevZ);
  }
  r(Go, "removeNode");
  function Pm(r3, e, t3) {
    this.i = r3, this.x = e, this.y = t3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  r(Pm, "Node");
  Vl.deviation = function(r3, e, t3, i) {
    var n = e && e.length, o = n ? e[0] * t3 : r3.length, a = Math.abs(Tm(r3, 0, o, t3));
    if (n) for (var s3 = 0, l = e.length; s3 < l; s3++) {
      var c = e[s3] * t3, p = s3 < l - 1 ? e[s3 + 1] * t3 : r3.length;
      a -= Math.abs(Tm(r3, c, p, t3));
    }
    var h = 0;
    for (s3 = 0; s3 < i.length; s3 += 3) {
      var f = i[s3] * t3, m = i[s3 + 1] * t3, y = i[s3 + 2] * t3;
      h += Math.abs((r3[f] - r3[y]) * (r3[m + 1] - r3[f + 1]) - (r3[f] - r3[m]) * (r3[y + 1] - r3[f + 1]));
    }
    return a === 0 && h === 0 ? 0 : Math.abs((h - a) / a);
  };
  function Tm(r3, e, t3, i) {
    for (var n = 0, o = e, a = t3 - i; o < t3; o += i) n += (r3[a] - r3[o]) * (r3[o + 1] + r3[a + 1]), a = o;
    return n;
  }
  r(Tm, "signedArea");
  Vl.flatten = function(r3) {
    for (var e = r3[0][0].length, t3 = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < r3.length; n++) {
      for (var o = 0; o < r3[n].length; o++) for (var a = 0; a < e; a++) t3.vertices.push(r3[n][o][a]);
      n > 0 && (i += r3[n - 1].length, t3.holes.push(i));
    }
    return t3;
  };
});
var km = s((a4, Wv) => {
  "use strict";
  q();
  var RE = ge();
  Wv.exports = ln;
  function ln(r3, e, t3, i, n) {
    this.properties = {}, this.extent = t3, this.type = 0, this._pbf = r3, this._geometry = -1, this._keys = i, this._values = n, r3.readFields(BE, this, e);
  }
  r(ln, "VectorTileFeature");
  function BE(r3, e, t3) {
    r3 == 1 ? e.id = t3.readVarint() : r3 == 2 ? OE(t3, e) : r3 == 3 ? e.type = t3.readVarint() : r3 == 4 && (e._geometry = t3.pos);
  }
  r(BE, "readFeature");
  function OE(r3, e) {
    for (var t3 = r3.readVarint() + r3.pos; r3.pos < t3; ) {
      var i = e._keys[r3.readVarint()], n = e._values[r3.readVarint()];
      e.properties[i] = n;
    }
  }
  r(OE, "readTag");
  ln.types = ["Unknown", "Point", "LineString", "Polygon"];
  ln.prototype.loadGeometry = function() {
    var r3 = this._pbf;
    r3.pos = this._geometry;
    for (var e = r3.readVarint() + r3.pos, t3 = 1, i = 0, n = 0, o = 0, a = [], s3; r3.pos < e; ) {
      if (i <= 0) {
        var l = r3.readVarint();
        t3 = l & 7, i = l >> 3;
      }
      if (i--, t3 === 1 || t3 === 2) n += r3.readSVarint(), o += r3.readSVarint(), t3 === 1 && (s3 && a.push(s3), s3 = []), s3.push(new RE(n, o));
      else if (t3 === 7) s3 && s3.push(s3[0].clone());
      else throw new Error("unknown command " + t3);
    }
    return s3 && a.push(s3), a;
  };
  ln.prototype.bbox = function() {
    var r3 = this._pbf;
    r3.pos = this._geometry;
    for (var e = r3.readVarint() + r3.pos, t3 = 1, i = 0, n = 0, o = 0, a = 1 / 0, s3 = -1 / 0, l = 1 / 0, c = -1 / 0; r3.pos < e; ) {
      if (i <= 0) {
        var p = r3.readVarint();
        t3 = p & 7, i = p >> 3;
      }
      if (i--, t3 === 1 || t3 === 2) n += r3.readSVarint(), o += r3.readSVarint(), n < a && (a = n), n > s3 && (s3 = n), o < l && (l = o), o > c && (c = o);
      else if (t3 !== 7) throw new Error("unknown command " + t3);
    }
    return [a, l, s3, c];
  };
  ln.prototype.toGeoJSON = function(r3, e, t3) {
    var i = this.extent * Math.pow(2, t3), n = this.extent * r3, o = this.extent * e, a = this.loadGeometry(), s3 = ln.types[this.type], l, c;
    function p(m) {
      for (var y = 0; y < m.length; y++) {
        var g = m[y], x = 180 - (g.y + o) * 360 / i;
        m[y] = [(g.x + n) * 360 / i - 180, 360 / Math.PI * Math.atan(Math.exp(x * Math.PI / 180)) - 90];
      }
    }
    switch (r(p, "project"), this.type) {
      case 1:
        var h = [];
        for (l = 0; l < a.length; l++) h[l] = a[l][0];
        a = h, p(a);
        break;
      case 2:
        for (l = 0; l < a.length; l++) p(a[l]);
        break;
      case 3:
        for (a = VE(a), l = 0; l < a.length; l++) for (c = 0; c < a[l].length; c++) p(a[l][c]);
        break;
    }
    a.length === 1 ? a = a[0] : s3 = "Multi" + s3;
    var f = { type: "Feature", geometry: { type: s3, coordinates: a }, properties: this.properties };
    return "id" in this && (f.id = this.id), f;
  };
  function VE(r3) {
    var e = r3.length;
    if (e <= 1) return [r3];
    for (var t3 = [], i, n, o = 0; o < e; o++) {
      var a = UE(r3[o]);
      a !== 0 && (n === void 0 && (n = a < 0), n === a < 0 ? (i && t3.push(i), i = [r3[o]]) : i.push(r3[o]));
    }
    return i && t3.push(i), t3;
  }
  r(VE, "classifyRings");
  function UE(r3) {
    for (var e = 0, t3 = 0, i = r3.length, n = i - 1, o, a; t3 < i; n = t3++) o = r3[t3], a = r3[n], e += (a.x - o.x) * (o.y + a.y);
    return e;
  }
  r(UE, "signedArea");
});
var Lm = s((u4, Kv) => {
  "use strict";
  q();
  var NE = km();
  Kv.exports = Xv;
  function Xv(r3, e) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r3, this._keys = [], this._values = [], this._features = [], r3.readFields(GE, this, e), this.length = this._features.length;
  }
  r(Xv, "VectorTileLayer");
  function GE(r3, e, t3) {
    r3 === 15 ? e.version = t3.readVarint() : r3 === 1 ? e.name = t3.readString() : r3 === 5 ? e.extent = t3.readVarint() : r3 === 2 ? e._features.push(t3.pos) : r3 === 3 ? e._keys.push(t3.readString()) : r3 === 4 && e._values.push($E(t3));
  }
  r(GE, "readLayer");
  function $E(r3) {
    for (var e = null, t3 = r3.readVarint() + r3.pos; r3.pos < t3; ) {
      var i = r3.readVarint() >> 3;
      e = i === 1 ? r3.readString() : i === 2 ? r3.readFloat() : i === 3 ? r3.readDouble() : i === 4 ? r3.readVarint64() : i === 5 ? r3.readVarint() : i === 6 ? r3.readSVarint() : i === 7 ? r3.readBoolean() : null;
    }
    return e;
  }
  r($E, "readValueMessage");
  Xv.prototype.feature = function(r3) {
    if (r3 < 0 || r3 >= this._features.length) throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[r3];
    var e = this._pbf.readVarint() + this._pbf.pos;
    return new NE(this._pbf, e, this.extent, this._keys, this._values);
  };
});
var Yv = s((h4, Jv) => {
  "use strict";
  q();
  var qE = Lm();
  Jv.exports = jE;
  function jE(r3, e) {
    this.layers = r3.readFields(ZE, {}, e);
  }
  r(jE, "VectorTile");
  function ZE(r3, e, t3) {
    if (r3 === 3) {
      var i = new qE(t3, t3.readVarint() + t3.pos);
      i.length && (e[i.name] = i);
    }
  }
  r(ZE, "readTile");
});
var Zo = s((d4, Gl) => {
  q();
  Gl.exports.VectorTile = Yv();
  Gl.exports.VectorTileFeature = km();
  Gl.exports.VectorTileLayer = Lm();
});
var _0 = s((Gm) => {
  q();
  Gm.read = function(r3, e, t3, i, n) {
    var o, a, s3 = n * 8 - i - 1, l = (1 << s3) - 1, c = l >> 1, p = -7, h = t3 ? n - 1 : 0, f = t3 ? -1 : 1, m = r3[e + h];
    for (h += f, o = m & (1 << -p) - 1, m >>= -p, p += s3; p > 0; o = o * 256 + r3[e + h], h += f, p -= 8) ;
    for (a = o & (1 << -p) - 1, o >>= -p, p += i; p > 0; a = a * 256 + r3[e + h], h += f, p -= 8) ;
    if (o === 0) o = 1 - c;
    else {
      if (o === l) return a ? NaN : (m ? -1 : 1) * (1 / 0);
      a = a + Math.pow(2, i), o = o - c;
    }
    return (m ? -1 : 1) * a * Math.pow(2, o - i);
  };
  Gm.write = function(r3, e, t3, i, n, o) {
    var a, s3, l, c = o * 8 - n - 1, p = (1 << c) - 1, h = p >> 1, f = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = i ? 0 : o - 1, y = i ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s3 = isNaN(e) ? 1 : 0, a = p) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + h >= 1 ? e += f / l : e += f * Math.pow(2, 1 - h), e * l >= 2 && (a++, l /= 2), a + h >= p ? (s3 = 0, a = p) : a + h >= 1 ? (s3 = (e * l - 1) * Math.pow(2, n), a = a + h) : (s3 = e * Math.pow(2, h - 1) * Math.pow(2, n), a = 0)); n >= 8; r3[t3 + m] = s3 & 255, m += y, s3 /= 256, n -= 8) ;
    for (a = a << n | s3, c += n; c > 0; r3[t3 + m] = a & 255, m += y, a /= 256, c -= 8) ;
    r3[t3 + m - y] |= g * 128;
  };
});
var qm = s((vV, T0) => {
  "use strict";
  q();
  T0.exports = Te;
  var Hl = _0();
  function Te(r3) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r3) ? r3 : new Uint8Array(r3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  r(Te, "Pbf");
  Te.Varint = 0;
  Te.Fixed64 = 1;
  Te.Bytes = 2;
  Te.Fixed32 = 5;
  var $m = 65536 * 65536, v0 = 1 / $m, pk = 12, P0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
  Te.prototype = { destroy: function() {
    this.buf = null;
  }, readFields: function(r3, e, t3) {
    for (t3 = t3 || this.length; this.pos < t3; ) {
      var i = this.readVarint(), n = i >> 3, o = this.pos;
      this.type = i & 7, r3(n, e, this), this.pos === o && this.skip(i);
    }
    return e;
  }, readMessage: function(r3, e) {
    return this.readFields(r3, e, this.readVarint() + this.pos);
  }, readFixed32: function() {
    var r3 = Wl(this.buf, this.pos);
    return this.pos += 4, r3;
  }, readSFixed32: function() {
    var r3 = S0(this.buf, this.pos);
    return this.pos += 4, r3;
  }, readFixed64: function() {
    var r3 = Wl(this.buf, this.pos) + Wl(this.buf, this.pos + 4) * $m;
    return this.pos += 8, r3;
  }, readSFixed64: function() {
    var r3 = Wl(this.buf, this.pos) + S0(this.buf, this.pos + 4) * $m;
    return this.pos += 8, r3;
  }, readFloat: function() {
    var r3 = Hl.read(this.buf, this.pos, true, 23, 4);
    return this.pos += 4, r3;
  }, readDouble: function() {
    var r3 = Hl.read(this.buf, this.pos, true, 52, 8);
    return this.pos += 8, r3;
  }, readVarint: function(r3) {
    var e = this.buf, t3, i;
    return i = e[this.pos++], t3 = i & 127, i < 128 || (i = e[this.pos++], t3 |= (i & 127) << 7, i < 128) || (i = e[this.pos++], t3 |= (i & 127) << 14, i < 128) || (i = e[this.pos++], t3 |= (i & 127) << 21, i < 128) ? t3 : (i = e[this.pos], t3 |= (i & 15) << 28, hk(t3, r3, this));
  }, readVarint64: function() {
    return this.readVarint(true);
  }, readSVarint: function() {
    var r3 = this.readVarint();
    return r3 % 2 === 1 ? (r3 + 1) / -2 : r3 / 2;
  }, readBoolean: function() {
    return !!this.readVarint();
  }, readString: function() {
    var r3 = this.readVarint() + this.pos, e = this.pos;
    return this.pos = r3, r3 - e >= pk && P0 ? Mk(this.buf, e, r3) : Tk(this.buf, e, r3);
  }, readBytes: function() {
    var r3 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, r3);
    return this.pos = r3, e;
  }, readPackedVarint: function(r3, e) {
    if (this.type !== Te.Bytes) return r3.push(this.readVarint(e));
    var t3 = lr(this);
    for (r3 = r3 || []; this.pos < t3; ) r3.push(this.readVarint(e));
    return r3;
  }, readPackedSVarint: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readSVarint());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readSVarint());
    return r3;
  }, readPackedBoolean: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readBoolean());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readBoolean());
    return r3;
  }, readPackedFloat: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readFloat());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readFloat());
    return r3;
  }, readPackedDouble: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readDouble());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readDouble());
    return r3;
  }, readPackedFixed32: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readFixed32());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readFixed32());
    return r3;
  }, readPackedSFixed32: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readSFixed32());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readSFixed32());
    return r3;
  }, readPackedFixed64: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readFixed64());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readFixed64());
    return r3;
  }, readPackedSFixed64: function(r3) {
    if (this.type !== Te.Bytes) return r3.push(this.readSFixed64());
    var e = lr(this);
    for (r3 = r3 || []; this.pos < e; ) r3.push(this.readSFixed64());
    return r3;
  }, skip: function(r3) {
    var e = r3 & 7;
    if (e === Te.Varint) for (; this.buf[this.pos++] > 127; ) ;
    else if (e === Te.Bytes) this.pos = this.readVarint() + this.pos;
    else if (e === Te.Fixed32) this.pos += 4;
    else if (e === Te.Fixed64) this.pos += 8;
    else throw new Error("Unimplemented type: " + e);
  }, writeTag: function(r3, e) {
    this.writeVarint(r3 << 3 | e);
  }, realloc: function(r3) {
    for (var e = this.length || 16; e < this.pos + r3; ) e *= 2;
    if (e !== this.length) {
      var t3 = new Uint8Array(e);
      t3.set(this.buf), this.buf = t3, this.length = e;
    }
  }, finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }, writeFixed32: function(r3) {
    this.realloc(4), cn(this.buf, r3, this.pos), this.pos += 4;
  }, writeSFixed32: function(r3) {
    this.realloc(4), cn(this.buf, r3, this.pos), this.pos += 4;
  }, writeFixed64: function(r3) {
    this.realloc(8), cn(this.buf, r3 & -1, this.pos), cn(this.buf, Math.floor(r3 * v0), this.pos + 4), this.pos += 8;
  }, writeSFixed64: function(r3) {
    this.realloc(8), cn(this.buf, r3 & -1, this.pos), cn(this.buf, Math.floor(r3 * v0), this.pos + 4), this.pos += 8;
  }, writeVarint: function(r3) {
    if (r3 = +r3 || 0, r3 > 268435455 || r3 < 0) {
      fk(r3, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = r3 & 127 | (r3 > 127 ? 128 : 0), !(r3 <= 127) && (this.buf[this.pos++] = (r3 >>>= 7) & 127 | (r3 > 127 ? 128 : 0), !(r3 <= 127) && (this.buf[this.pos++] = (r3 >>>= 7) & 127 | (r3 > 127 ? 128 : 0), !(r3 <= 127) && (this.buf[this.pos++] = r3 >>> 7 & 127)));
  }, writeSVarint: function(r3) {
    this.writeVarint(r3 < 0 ? -r3 * 2 - 1 : r3 * 2);
  }, writeBoolean: function(r3) {
    this.writeVarint(!!r3);
  }, writeString: function(r3) {
    r3 = String(r3), this.realloc(r3.length * 4), this.pos++;
    var e = this.pos;
    this.pos = Ak(this.buf, r3, this.pos);
    var t3 = this.pos - e;
    t3 >= 128 && w0(e, t3, this), this.pos = e - 1, this.writeVarint(t3), this.pos += t3;
  }, writeFloat: function(r3) {
    this.realloc(4), Hl.write(this.buf, r3, this.pos, true, 23, 4), this.pos += 4;
  }, writeDouble: function(r3) {
    this.realloc(8), Hl.write(this.buf, r3, this.pos, true, 52, 8), this.pos += 8;
  }, writeBytes: function(r3) {
    var e = r3.length;
    this.writeVarint(e), this.realloc(e);
    for (var t3 = 0; t3 < e; t3++) this.buf[this.pos++] = r3[t3];
  }, writeRawMessage: function(r3, e) {
    this.pos++;
    var t3 = this.pos;
    r3(e, this);
    var i = this.pos - t3;
    i >= 128 && w0(t3, i, this), this.pos = t3 - 1, this.writeVarint(i), this.pos += i;
  }, writeMessage: function(r3, e, t3) {
    this.writeTag(r3, Te.Bytes), this.writeRawMessage(e, t3);
  }, writePackedVarint: function(r3, e) {
    e.length && this.writeMessage(r3, yk, e);
  }, writePackedSVarint: function(r3, e) {
    e.length && this.writeMessage(r3, gk, e);
  }, writePackedBoolean: function(r3, e) {
    e.length && this.writeMessage(r3, _k, e);
  }, writePackedFloat: function(r3, e) {
    e.length && this.writeMessage(r3, xk, e);
  }, writePackedDouble: function(r3, e) {
    e.length && this.writeMessage(r3, bk, e);
  }, writePackedFixed32: function(r3, e) {
    e.length && this.writeMessage(r3, vk, e);
  }, writePackedSFixed32: function(r3, e) {
    e.length && this.writeMessage(r3, wk, e);
  }, writePackedFixed64: function(r3, e) {
    e.length && this.writeMessage(r3, Sk, e);
  }, writePackedSFixed64: function(r3, e) {
    e.length && this.writeMessage(r3, Pk, e);
  }, writeBytesField: function(r3, e) {
    this.writeTag(r3, Te.Bytes), this.writeBytes(e);
  }, writeFixed32Field: function(r3, e) {
    this.writeTag(r3, Te.Fixed32), this.writeFixed32(e);
  }, writeSFixed32Field: function(r3, e) {
    this.writeTag(r3, Te.Fixed32), this.writeSFixed32(e);
  }, writeFixed64Field: function(r3, e) {
    this.writeTag(r3, Te.Fixed64), this.writeFixed64(e);
  }, writeSFixed64Field: function(r3, e) {
    this.writeTag(r3, Te.Fixed64), this.writeSFixed64(e);
  }, writeVarintField: function(r3, e) {
    this.writeTag(r3, Te.Varint), this.writeVarint(e);
  }, writeSVarintField: function(r3, e) {
    this.writeTag(r3, Te.Varint), this.writeSVarint(e);
  }, writeStringField: function(r3, e) {
    this.writeTag(r3, Te.Bytes), this.writeString(e);
  }, writeFloatField: function(r3, e) {
    this.writeTag(r3, Te.Fixed32), this.writeFloat(e);
  }, writeDoubleField: function(r3, e) {
    this.writeTag(r3, Te.Fixed64), this.writeDouble(e);
  }, writeBooleanField: function(r3, e) {
    this.writeVarintField(r3, !!e);
  } };
  function hk(r3, e, t3) {
    var i = t3.buf, n, o;
    if (o = i[t3.pos++], n = (o & 112) >> 4, o < 128 || (o = i[t3.pos++], n |= (o & 127) << 3, o < 128) || (o = i[t3.pos++], n |= (o & 127) << 10, o < 128) || (o = i[t3.pos++], n |= (o & 127) << 17, o < 128) || (o = i[t3.pos++], n |= (o & 127) << 24, o < 128) || (o = i[t3.pos++], n |= (o & 1) << 31, o < 128)) return un(r3, n, e);
    throw new Error("Expected varint not more than 10 bytes");
  }
  r(hk, "readVarintRemainder");
  function lr(r3) {
    return r3.type === Te.Bytes ? r3.readVarint() + r3.pos : r3.pos + 1;
  }
  r(lr, "readPackedEnd");
  function un(r3, e, t3) {
    return t3 ? e * 4294967296 + (r3 >>> 0) : (e >>> 0) * 4294967296 + (r3 >>> 0);
  }
  r(un, "toNum");
  function fk(r3, e) {
    var t3, i;
    if (r3 >= 0 ? (t3 = r3 % 4294967296 | 0, i = r3 / 4294967296 | 0) : (t3 = ~(-r3 % 4294967296), i = ~(-r3 / 4294967296), t3 ^ 4294967295 ? t3 = t3 + 1 | 0 : (t3 = 0, i = i + 1 | 0)), r3 >= 18446744073709552e3 || r3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
    e.realloc(10), mk(t3, i, e), dk(i, e);
  }
  r(fk, "writeBigVarint");
  function mk(r3, e, t3) {
    t3.buf[t3.pos++] = r3 & 127 | 128, r3 >>>= 7, t3.buf[t3.pos++] = r3 & 127 | 128, r3 >>>= 7, t3.buf[t3.pos++] = r3 & 127 | 128, r3 >>>= 7, t3.buf[t3.pos++] = r3 & 127 | 128, r3 >>>= 7, t3.buf[t3.pos] = r3 & 127;
  }
  r(mk, "writeBigVarintLow");
  function dk(r3, e) {
    var t3 = (r3 & 7) << 4;
    e.buf[e.pos++] |= t3 | ((r3 >>>= 3) ? 128 : 0), r3 && (e.buf[e.pos++] = r3 & 127 | ((r3 >>>= 7) ? 128 : 0), r3 && (e.buf[e.pos++] = r3 & 127 | ((r3 >>>= 7) ? 128 : 0), r3 && (e.buf[e.pos++] = r3 & 127 | ((r3 >>>= 7) ? 128 : 0), r3 && (e.buf[e.pos++] = r3 & 127 | ((r3 >>>= 7) ? 128 : 0), r3 && (e.buf[e.pos++] = r3 & 127)))));
  }
  r(dk, "writeBigVarintHigh");
  function w0(r3, e, t3) {
    var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
    t3.realloc(i);
    for (var n = t3.pos - 1; n >= r3; n--) t3.buf[n + i] = t3.buf[n];
  }
  r(w0, "makeRoomForExtraLength");
  function yk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeVarint(r3[t3]);
  }
  r(yk, "writePackedVarint");
  function gk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeSVarint(r3[t3]);
  }
  r(gk, "writePackedSVarint");
  function xk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeFloat(r3[t3]);
  }
  r(xk, "writePackedFloat");
  function bk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeDouble(r3[t3]);
  }
  r(bk, "writePackedDouble");
  function _k(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeBoolean(r3[t3]);
  }
  r(_k, "writePackedBoolean");
  function vk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeFixed32(r3[t3]);
  }
  r(vk, "writePackedFixed32");
  function wk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeSFixed32(r3[t3]);
  }
  r(wk, "writePackedSFixed32");
  function Sk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeFixed64(r3[t3]);
  }
  r(Sk, "writePackedFixed64");
  function Pk(r3, e) {
    for (var t3 = 0; t3 < r3.length; t3++) e.writeSFixed64(r3[t3]);
  }
  r(Pk, "writePackedSFixed64");
  function Wl(r3, e) {
    return (r3[e] | r3[e + 1] << 8 | r3[e + 2] << 16) + r3[e + 3] * 16777216;
  }
  r(Wl, "readUInt32");
  function cn(r3, e, t3) {
    r3[t3] = e, r3[t3 + 1] = e >>> 8, r3[t3 + 2] = e >>> 16, r3[t3 + 3] = e >>> 24;
  }
  r(cn, "writeInt32");
  function S0(r3, e) {
    return (r3[e] | r3[e + 1] << 8 | r3[e + 2] << 16) + (r3[e + 3] << 24);
  }
  r(S0, "readInt32");
  function Tk(r3, e, t3) {
    for (var i = "", n = e; n < t3; ) {
      var o = r3[n], a = null, s3 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (n + s3 > t3) break;
      var l, c, p;
      s3 === 1 ? o < 128 && (a = o) : s3 === 2 ? (l = r3[n + 1], (l & 192) === 128 && (a = (o & 31) << 6 | l & 63, a <= 127 && (a = null))) : s3 === 3 ? (l = r3[n + 1], c = r3[n + 2], (l & 192) === 128 && (c & 192) === 128 && (a = (o & 15) << 12 | (l & 63) << 6 | c & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : s3 === 4 && (l = r3[n + 1], c = r3[n + 2], p = r3[n + 3], (l & 192) === 128 && (c & 192) === 128 && (p & 192) === 128 && (a = (o & 15) << 18 | (l & 63) << 12 | (c & 63) << 6 | p & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, s3 = 1) : a > 65535 && (a -= 65536, i += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), i += String.fromCharCode(a), n += s3;
    }
    return i;
  }
  r(Tk, "readUtf8");
  function Mk(r3, e, t3) {
    return P0.decode(r3.subarray(e, t3));
  }
  r(Mk, "readUtf8TextDecoder");
  function Ak(r3, e, t3) {
    for (var i = 0, n, o; i < e.length; i++) {
      if (n = e.charCodeAt(i), n > 55295 && n < 57344) if (o) if (n < 56320) {
        r3[t3++] = 239, r3[t3++] = 191, r3[t3++] = 189, o = n;
        continue;
      } else n = o - 55296 << 10 | n - 56320 | 65536, o = null;
      else {
        n > 56319 || i + 1 === e.length ? (r3[t3++] = 239, r3[t3++] = 191, r3[t3++] = 189) : o = n;
        continue;
      }
      else o && (r3[t3++] = 239, r3[t3++] = 191, r3[t3++] = 189, o = null);
      n < 128 ? r3[t3++] = n : (n < 2048 ? r3[t3++] = n >> 6 | 192 : (n < 65536 ? r3[t3++] = n >> 12 | 224 : (r3[t3++] = n >> 18 | 240, r3[t3++] = n >> 12 & 63 | 128), r3[t3++] = n >> 6 & 63 | 128), r3[t3++] = n & 63 | 128);
    }
    return t3;
  }
  r(Ak, "writeUtf8");
});
q();
var Qa = { name: "@packages/outdoor-context-v4", version: "4.1.3", private: true, main: "dist/maplibre-gl.js", style: "dist/maplibre-gl.css", license: "BSD-3-Clause", homepage: "https://maplibre.org/", funding: "https://github.com/maplibre/maplibre-gl-js?sponsor=1", bugs: { url: "https://github.com/maplibre/maplibre-gl-js/issues/" }, repository: { type: "git", url: "git://github.com/maplibre/maplibre-gl-js.git" }, types: "dist/maplibre-gl.d.ts", type: "module", dependencies: { "@mapbox/geojson-rewind": "^0.5.2", "@mapbox/jsonlint-lines-primitives": "^2.0.2", "@mapbox/point-geometry": "^0.1.0", "@mapbox/tiny-sdf": "^2.0.6", "@mapbox/unitbezier": "^0.0.1", "@mapbox/vector-tile": "^1.3.1", "@mapbox/whoots-js": "^3.1.0", "@maplibre/maplibre-gl-style-spec": "^20.1.1", "@types/geojson": "^7946.0.14", "@types/geojson-vt": "3.2.5", "@types/junit-report-builder": "^3.0.2", "@types/mapbox__point-geometry": "^0.1.4", "@types/mapbox__vector-tile": "^1.3.4", "@types/pbf": "^3.0.5", "@types/supercluster": "^7.1.3", earcut: "^2.2.4", "geojson-vt": "^3.2.1", "gl-matrix": "^3.4.3", "global-prefix": "^3.0.0", kdbush: "^4.0.2", "murmurhash-js": "^1.0.0", pbf: "^3.2.1", potpack: "^2.0.0", quickselect: "^2.0.0", supercluster: "^8.0.1", tinyqueue: "^2.0.3", "vt-pbf": "^3.1.3" }, devDependencies: { "@mapbox/mapbox-gl-rtl-text": "^0.2.3", "@mapbox/mvt-fixtures": "^3.10.0", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.1.0", "@rollup/plugin-node-resolve": "^15.2.3", "@rollup/plugin-replace": "^5.0.5", "@rollup/plugin-strip": "^3.0.4", "@rollup/plugin-terser": "^0.4.4", "@rollup/plugin-typescript": "^11.1.6", "@types/benchmark": "^2.1.5", "@types/cssnano": "^5.0.0", "@types/d3": "^7.4.3", "@types/diff": "^5.2.0", "@types/earcut": "^2.1.4", "@types/eslint": "^8.56.7", "@types/gl": "^6.0.5", "@types/glob": "^8.1.0", "@types/jest": "^29.5.12", "@types/jsdom": "^21.1.6", "@types/minimist": "^1.2.5", "@types/murmurhash-js": "^1.0.6", "@types/nise": "^1.4.4", "@types/node": "^20.12.7", "@types/offscreencanvas": "^2019.7.3", "@types/pixelmatch": "^5.2.6", "@types/pngjs": "^6.0.4", "@types/react": "^18.2.79", "@types/react-dom": "^18.2.25", "@types/request": "^2.48.12", "@types/shuffle-seed": "^1.1.3", "@types/window-or-global": "^1.0.6", "@typescript-eslint/eslint-plugin": "^7.7.1", "@typescript-eslint/parser": "^7.7.1", address: "^2.0.2", benchmark: "^2.1.4", canvas: "^2.11.2", cssnano: "^6.1.2", d3: "^7.9.0", "d3-queue": "^3.0.7", "devtools-protocol": "^0.0.1291694", diff: "^5.2.0", "dts-bundle-generator": "^9.5.1", eslint: "^8.57.0", "eslint-config-mourner": "^3.0.0", "eslint-plugin-html": "^8.1.1", "eslint-plugin-import": "^2.29.1", "eslint-plugin-jest": "^28.2.0", "eslint-plugin-react": "^7.34.1", "eslint-plugin-tsdoc": "0.2.17", expect: "^29.7.0", glob: "^10.3.12", "is-builtin-module": "^3.2.1", jest: "^29.7.0", "jest-environment-jsdom": "^29.7.0", "jest-junit": "^16.0.0", "jest-monocart-coverage": "^1.1.0", "jest-webgl-canvas-mock": "^2.5.3", jsdom: "^24.0.0", "json-stringify-pretty-compact": "^4.0.0", "junit-report-builder": "^3.2.1", minimist: "^1.2.8", "mock-geolocation": "^1.0.11", "monocart-coverage-reports": "^2.7.9", nise: "^5.1.9", "npm-font-open-sans": "^1.1.0", "npm-run-all": "^4.1.5", "pdf-merger-js": "^5.1.1", pixelmatch: "^5.3.0", pngjs: "^7.0.0", postcss: "^8.4.38", "postcss-cli": "^11.0.0", "postcss-inline-svg": "^6.0.0", "pretty-bytes": "^6.1.1", puppeteer: "^22.7.0", react: "^18.2.0", "react-dom": "^18.2.0", rollup: "^4.16.4", "rollup-plugin-sourcemaps": "^0.6.3", rw: "^1.3.3", semver: "^7.6.0", "shuffle-seed": "^1.1.6", "source-map-explorer": "^2.5.3", st: "^3.0.0", stylelint: "^16.4.0", "stylelint-config-standard": "^36.0.0", "ts-jest": "^29.1.2", "ts-node": "^10.9.2", tslib: "^2.6.2", typedoc: "^0.25.13", "typedoc-plugin-markdown": "^3.17.1", "typedoc-plugin-missing-exports": "^2.2.0", typescript: "^5.4.5" }, overrides: { "postcss-inline-svg": { "css-select": "^5.1.0", "dom-serializer": "^2.0.0", htmlparser2: "^8.0.1", "postcss-value-parser": "^4.2.0" } }, scripts: { "generate-dist-package": "node --no-warnings --loader ts-node/esm build/generate-dist-package.js", "generate-shaders": "node --no-warnings --loader ts-node/esm build/generate-shaders.ts", "generate-struct-arrays": "node --no-warnings --loader ts-node/esm build/generate-struct-arrays.ts", "generate-style-code": "node --no-warnings --loader ts-node/esm build/generate-style-code.ts", "generate-typings": "dts-bundle-generator --export-referenced-types --umd-module-name=maplibregl -o ./dist/maplibre-gl.d.ts ./src/index.ts", "generate-docs": "typedoc && node --no-warnings --loader ts-node/esm build/generate-docs.ts", "generate-images": "node --no-warnings --loader ts-node/esm build/generate-doc-images.ts", "build-dist": "npm run build-css && npm run generate-typings && npm run build-dev && npm run build-csp-dev && npm run build-prod && npm run build-csp", "build-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev", "watch-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev --watch", "build-prod": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:production", "build-csp": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts", "build-csp-dev": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts --environment BUILD:dev", "build-css": "postcss -o dist/maplibre-gl.css src/css/maplibre-gl.css", "watch-css": "postcss --watch -o dist/maplibre-gl.css src/css/maplibre-gl.css", "build-benchmarks": "npm run build-dev && rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts", "watch-benchmarks": "rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts --watch", "start-server": "st --no-cache -H 0.0.0.0 --port 9966 .", "start-docs": "docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material", start: "run-p watch-css watch-dev start-server", "start-bench": "run-p watch-css watch-benchmarks start-server", lint: "eslint --cache --ext .ts,.tsx,.js,.html --ignore-path .gitignore .", "lint-css": "stylelint src/css/maplibre-gl.css", test: "run-p lint lint-css test-render jest", jest: "jest", "test-build": "jest --selectProjects=build --reporters=default", "test-build-ci": "jest --selectProjects=build", "test-integration": "jest --selectProjects=integration --reporters=default", "test-integration-ci": "jest --selectProjects=integration", "test-render": "node --no-warnings --loader ts-node/esm test/integration/render/run_render_tests.ts", "test-unit": "jest --selectProjects=unit --reporters=default", "test-unit-ci": "jest --coverage --selectProjects unit", "test-watch-roots": "jest --watch", codegen: "run-p --print-label generate-dist-package generate-style-code generate-struct-arrays generate-shaders && npm run generate-typings", benchmark: "node --no-warnings --loader ts-node/esm test/bench/run-benchmarks.ts", "gl-stats": "node --no-warnings --loader ts-node/esm test/bench/gl-stats.ts", prepare: "npm run codegen", typecheck: "tsc --noEmit && tsc --project tsconfig.dist.json", tsnode: "node --experimental-loader=ts-node/esm --no-warnings" }, files: ["build/", "dist/*", "src/"], engines: { npm: ">=8.1.0", node: ">=16.14.0" } };
q();
q();
var jx = u(ge(), 1);
var Zx = u(Gx(), 1);
q();
q();
var gp;
function es() {
  return gp == null && (gp = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), gp;
}
r(es, "offscreenCanvasSupported");
var ts;
function xp() {
  if (ts == null && (ts = false, es())) {
    let t3 = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
    if (t3) {
      for (let n = 0; n < 5 * 5; n++) {
        let o = n * 4;
        t3.fillStyle = `rgb(${o},${o + 1},${o + 2})`, t3.fillRect(n % 5, Math.floor(n / 5), 1, 1);
      }
      let i = t3.getImageData(0, 0, 5, 5).data;
      for (let n = 0; n < 5 * 5 * 4; n++) if (n % 4 !== 3 && i[n] !== n) {
        ts = true;
        break;
      }
    }
  }
  return ts || false;
}
r(xp, "isOffscreenCanvasDistorted");
function Hx(r3) {
  if (r3 <= 0) return 0;
  if (r3 >= 1) return 1;
  let e = r3 * r3, t3 = e * r3;
  return 4 * (r3 < 0.5 ? t3 : 3 * (r3 - e) + t3 - 0.75);
}
r(Hx, "easeCubicInOut");
function In(r3, e, t3, i) {
  let n = new Zx.default(r3, e, t3, i);
  return function(o) {
    return n.solve(o);
  };
}
r(In, "bezier");
var Cn = In(0.25, 0.1, 0.25, 1);
function Ae(r3, e, t3) {
  return Math.min(t3, Math.max(e, r3));
}
r(Ae, "clamp");
function Qt(r3, e, t3) {
  let i = t3 - e, n = ((r3 - e) % i + i) % i + e;
  return n === e ? t3 : n;
}
r(Qt, "wrap");
function Wx(r3, e) {
  let t3 = [];
  for (let i in r3) i in e || t3.push(i);
  return t3;
}
r(Wx, "keysDifference");
function V(r3, ...e) {
  for (let t3 of e) for (let i in t3) r3[i] = t3[i];
  return r3;
}
r(V, "extend");
function dr(r3, e) {
  let t3 = {};
  for (let i = 0; i < e.length; i++) {
    let n = e[i];
    n in r3 && (t3[n] = r3[n]);
  }
  return t3;
}
r(dr, "pick");
var x2 = 1;
function rs() {
  return x2++;
}
r(rs, "uniqueId");
function Xx(r3) {
  return Math.log(r3) / Math.LN2 % 1 === 0;
}
r(Xx, "isPowerOfTwo");
function Kx(r3) {
  return r3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r3) / Math.LN2));
}
r(Kx, "nextPowerOfTwo");
function En(r3, e, t3) {
  let i = {};
  for (let n in r3) i[n] = e.call(t3 || this, r3[n], n, r3);
  return i;
}
r(En, "mapObject");
function is(r3, e, t3) {
  let i = {};
  for (let n in r3) e.call(t3 || this, r3[n], n, r3) && (i[n] = r3[n]);
  return i;
}
r(is, "filterObject");
function Yt(r3, e) {
  if (Array.isArray(r3)) {
    if (!Array.isArray(e) || r3.length !== e.length) return false;
    for (let t3 = 0; t3 < r3.length; t3++) if (!Yt(r3[t3], e[t3])) return false;
    return true;
  }
  if (typeof r3 == "object" && r3 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r3).length !== Object.keys(e).length) return false;
    for (let i in r3) if (!Yt(r3[i], e[i])) return false;
    return true;
  }
  return r3 === e;
}
r(Yt, "deepEqual");
function pt(r3) {
  return Array.isArray(r3) ? r3.map(pt) : typeof r3 == "object" && r3 ? En(r3, pt) : r3;
}
r(pt, "clone");
function Jx(r3, e) {
  for (let t3 = 0; t3 < r3.length; t3++) if (e.indexOf(r3[t3]) >= 0) return true;
  return false;
}
r(Jx, "arraysIntersect");
var $x = {};
function ke(r3) {
  $x[r3] || (typeof console < "u" && console.warn(r3), $x[r3] = true);
}
r(ke, "warnOnce");
function er(r3, e, t3) {
  return (t3.y - r3.y) * (e.x - r3.x) > (e.y - r3.y) * (t3.x - r3.x);
}
r(er, "isCounterClockwise");
function Yx(r3, e, t3, i) {
  let n = e.y - r3.y, o = e.x - r3.x, a = i.y - t3.y, s3 = i.x - t3.x, l = a * o - s3 * n;
  if (l === 0) return null;
  let c = r3.y - t3.y, p = r3.x - t3.x, h = (s3 * c - a * p) / l;
  return new jx.default(r3.x + h * o, r3.y + h * n);
}
r(Yx, "findLineIntersection");
function Qx(r3) {
  let e = 0;
  for (let t3 = 0, i = r3.length, n = i - 1, o, a; t3 < i; n = t3++) o = r3[t3], a = r3[n], e += (a.x - o.x) * (o.y + a.y);
  return e;
}
r(Qx, "calculateSignedArea");
function eb([r3, e, t3]) {
  return e += 90, e *= Math.PI / 180, t3 *= Math.PI / 180, { x: r3 * Math.cos(e) * Math.sin(t3), y: r3 * Math.sin(e) * Math.sin(t3), z: r3 * Math.cos(t3) };
}
r(eb, "sphericalToCartesian");
function tr(r3) {
  return typeof WorkerGlobalScope < "u" && typeof r3 < "u" && r3 instanceof WorkerGlobalScope;
}
r(tr, "isWorker");
function tb(r3) {
  let e = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, t3 = {};
  if (r3.replace(e, (i, n, o, a) => {
    let s3 = o || a;
    return t3[n] = s3 ? s3.toLowerCase() : true, "";
  }), t3["max-age"]) {
    let i = parseInt(t3["max-age"], 10);
    isNaN(i) ? delete t3["max-age"] : t3["max-age"] = i;
  }
  return t3;
}
r(tb, "parseCacheControl");
var bp = null;
function rb(r3) {
  if (bp == null) {
    let e = r3.navigator ? r3.navigator.userAgent : null;
    bp = !!r3.safari || !!(e && (/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
  }
  return bp;
}
r(rb, "isSafari");
function ht(r3) {
  return typeof ImageBitmap < "u" && r3 instanceof ImageBitmap;
}
r(ht, "isImageBitmap");
var ib = r(async (r3) => {
  if (r3.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
  let e = new Blob([new Uint8Array(r3)], { type: "image/png" });
  try {
    return createImageBitmap(e);
  } catch (t3) {
    throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
  }
}, "arrayBufferToImageBitmap");
var qx = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
var nb = r((r3) => new Promise((e, t3) => {
  let i = new Image();
  i.onload = () => {
    e(i), URL.revokeObjectURL(i.src), i.onload = null, window.requestAnimationFrame(() => {
      i.src = qx;
    });
  }, i.onerror = () => t3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  let n = new Blob([new Uint8Array(r3)], { type: "image/png" });
  i.src = r3.byteLength ? URL.createObjectURL(n) : qx;
}), "arrayBufferToImage");
function b2(r3, e, t3, i, n) {
  let o = Math.max(-e, 0) * 4, l = (Math.max(0, t3) - t3) * i * 4 + o, c = i * 4, p = Math.max(0, e), h = Math.max(0, t3), f = Math.min(r3.width, e + i), m = Math.min(r3.height, t3 + n);
  return { rect: { x: p, y: h, width: f - p, height: m - h }, layout: [{ offset: l, stride: c }] };
}
r(b2, "computeVideoFrameParameters");
async function ob(r3, e, t3, i, n) {
  if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
  let o = new VideoFrame(r3, { timestamp: 0 });
  try {
    let a = o == null ? void 0 : o.format;
    if (!a || !(a.startsWith("BGR") || a.startsWith("RGB"))) throw new Error(`Unrecognized format ${a}`);
    let s3 = a.startsWith("BGR"), l = new Uint8ClampedArray(i * n * 4);
    if (await o.copyTo(l, b2(r3, e, t3, i, n)), s3) for (let c = 0; c < l.length; c += 4) {
      let p = l[c];
      l[c] = l[c + 2], l[c + 2] = p;
    }
    return l;
  } finally {
    o.close();
  }
}
r(ob, "readImageUsingVideoFrame");
function ab(r3, e, t3, i) {
  return r3.addEventListener(e, t3, i), { unsubscribe: () => {
    r3.removeEventListener(e, t3, i);
  } };
}
r(ab, "subscribe");
function _p(r3) {
  return r3 * Math.PI / 180;
}
r(_p, "degreesToRadians");
q();
q();
var _2 = "AbortError";
function qr() {
  return new Error(_2);
}
r(qr, "createAbortError");
var v2 = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
var ns;
var vp;
var Y = { now: v2, frameAsync(r3) {
  return new Promise((e, t3) => {
    let i = requestAnimationFrame(e);
    r3.signal.addEventListener("abort", () => {
      cancelAnimationFrame(i), t3(qr());
    });
  });
}, getImageData(r3, e = 0) {
  return this.getImageCanvasContext(r3).getImageData(-e, -e, r3.width + 2 * e, r3.height + 2 * e);
}, getImageCanvasContext(r3) {
  let e = window.document.createElement("canvas"), t3 = e.getContext("2d", { willReadFrequently: true });
  if (!t3) throw new Error("failed to create canvas 2d context");
  return e.width = r3.width, e.height = r3.height, t3.drawImage(r3, 0, 0, r3.width, r3.height), t3;
}, resolveURL(r3) {
  return ns || (ns = document.createElement("a")), ns.href = r3, ns.href;
}, hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
  return matchMedia ? (vp == null && (vp = matchMedia("(prefers-reduced-motion: reduce)")), vp.matches) : false;
} };
q();
var sb = u(ge(), 1);
var Ie = class Ie2 {
  static testProp(e) {
    if (!Ie2.docStyle) return e[0];
    for (let t3 = 0; t3 < e.length; t3++) if (e[t3] in Ie2.docStyle) return e[t3];
    return e[0];
  }
  static create(e, t3, i) {
    let n = window.document.createElement(e);
    return t3 !== void 0 && (n.className = t3), i && i.appendChild(n), n;
  }
  static createNS(e, t3) {
    return window.document.createElementNS(e, t3);
  }
  static disableDrag() {
    Ie2.docStyle && Ie2.selectProp && (Ie2.userSelect = Ie2.docStyle[Ie2.selectProp], Ie2.docStyle[Ie2.selectProp] = "none");
  }
  static enableDrag() {
    Ie2.docStyle && Ie2.selectProp && (Ie2.docStyle[Ie2.selectProp] = Ie2.userSelect);
  }
  static setTransform(e, t3) {
    e.style[Ie2.transformProp] = t3;
  }
  static addEventListener(e, t3, i, n = {}) {
    "passive" in n ? e.addEventListener(t3, i, n) : e.addEventListener(t3, i, n.capture);
  }
  static removeEventListener(e, t3, i, n = {}) {
    "passive" in n ? e.removeEventListener(t3, i, n) : e.removeEventListener(t3, i, n.capture);
  }
  static suppressClickInternal(e) {
    e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Ie2.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", Ie2.suppressClickInternal, true), window.setTimeout(() => {
      window.removeEventListener("click", Ie2.suppressClickInternal, true);
    }, 0);
  }
  static getScale(e) {
    let t3 = e.getBoundingClientRect();
    return { x: t3.width / e.offsetWidth || 1, y: t3.height / e.offsetHeight || 1, boundingClientRect: t3 };
  }
  static getPoint(e, t3, i) {
    let n = t3.boundingClientRect;
    return new sb.default((i.clientX - n.left) / t3.x - e.clientLeft, (i.clientY - n.top) / t3.y - e.clientTop);
  }
  static mousePos(e, t3) {
    let i = Ie2.getScale(e);
    return Ie2.getPoint(e, i, t3);
  }
  static touchPos(e, t3) {
    let i = [], n = Ie2.getScale(e);
    for (let o = 0; o < t3.length; o++) i.push(Ie2.getPoint(e, n, t3[o]));
    return i;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
};
r(Ie, "DOM"), Ie.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Ie.selectProp = Ie.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Ie.transformProp = Ie.testProp(["transform", "WebkitTransform"]);
var D = Ie;
q();
q();
q();
var ot = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
function os(r3) {
  return ot.REGISTERED_PROTOCOLS[r3.substring(0, r3.indexOf("://"))];
}
r(os, "getProtocol");
function w2(r3, e) {
  ot.REGISTERED_PROTOCOLS[r3] = e;
}
r(w2, "addProtocol");
function S2(r3) {
  delete ot.REGISTERED_PROTOCOLS[r3];
}
r(S2, "removeProtocol");
q();
var as = "global-dispatcher";
var Sp = class Sp2 extends Error {
  constructor(e, t3, i, n) {
    super(`AJAXError: ${t3} (${e}): ${i}`), this.status = e, this.statusText = t3, this.url = i, this.body = n;
  }
};
r(Sp, "AJAXError");
var jr = Sp;
var ss = r(() => tr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, "getReferrer");
var P2 = r((r3) => /^file:/.test(r3) || /^file:/.test(ss()) && !/^\w+:/.test(r3), "isFileURL");
async function T2(r3, e) {
  let t3 = new Request(r3.url, { method: r3.method || "GET", body: r3.body, credentials: r3.credentials, headers: r3.headers, cache: r3.cache, referrer: ss(), signal: e.signal });
  r3.type === "json" && t3.headers.set("Accept", "application/json");
  let i = await fetch(t3);
  if (!i.ok) {
    let a = await i.blob();
    throw new jr(i.status, i.statusText, r3.url, a);
  }
  let n;
  r3.type === "arrayBuffer" || r3.type === "image" ? n = i.arrayBuffer() : r3.type === "json" ? n = i.json() : n = i.text();
  let o = await n;
  if (e.signal.aborted) throw qr();
  return { data: o, cacheControl: i.headers.get("Cache-Control"), expires: i.headers.get("Expires") };
}
r(T2, "makeFetchRequest");
function M2(r3, e) {
  return new Promise((t3, i) => {
    let n = new XMLHttpRequest();
    n.open(r3.method || "GET", r3.url, true), (r3.type === "arrayBuffer" || r3.type === "image") && (n.responseType = "arraybuffer");
    for (let o in r3.headers) n.setRequestHeader(o, r3.headers[o]);
    r3.type === "json" && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = r3.credentials === "include", n.onerror = () => {
      i(new Error(n.statusText));
    }, n.onload = () => {
      if (!e.signal.aborted) if ((n.status >= 200 && n.status < 300 || n.status === 0) && n.response !== null) {
        let o = n.response;
        if (r3.type === "json") try {
          o = JSON.parse(n.response);
        } catch (a) {
          i(a);
          return;
        }
        t3({ data: o, cacheControl: n.getResponseHeader("Cache-Control"), expires: n.getResponseHeader("Expires") });
      } else {
        let o = new Blob([n.response], { type: n.getResponseHeader("Content-Type") });
        i(new jr(n.status, n.statusText, r3.url, o));
      }
    }, e.signal.addEventListener("abort", () => {
      n.abort(), i(qr());
    }), n.send(r3.body);
  });
}
r(M2, "makeXMLHttpRequest");
var Ii = r(function(r3, e) {
  if (/:\/\//.test(r3.url) && !/^https?:|^file:/.test(r3.url)) {
    let t3 = os(r3.url);
    if (t3) return t3(r3, e);
    if (tr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r3, targetMapId: as }, e);
  }
  if (!P2(r3.url)) {
    if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return T2(r3, e);
    if (tr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r3, mustQueue: true, targetMapId: as }, e);
  }
  return M2(r3, e);
}, "makeRequest");
var yr = r((r3, e) => Ii(V(r3, { type: "json" }), e), "getJSON");
var lb = r((r3, e) => Ii(V(r3, { type: "arrayBuffer" }), e), "getArrayBuffer");
function wp(r3) {
  if (!r3 || r3.indexOf("://") <= 0 || r3.indexOf("data:image/") === 0 || r3.indexOf("blob:") === 0) return true;
  let e = new URL(r3), t3 = window.location;
  return e.protocol === t3.protocol && e.host === t3.host;
}
r(wp, "sameOrigin");
var ub = r((r3) => {
  let e = window.document.createElement("video");
  return e.muted = true, new Promise((t3) => {
    e.onloadstart = () => {
      t3(e);
    };
    for (let i of r3) {
      let n = window.document.createElement("source");
      wp(i) || (e.crossOrigin = "Anonymous"), n.src = i, e.appendChild(n);
    }
  });
}, "getVideo");
q();
q();
var Ln = { supported: false, testSupport: A2 };
var kn;
var Pp = false;
var Ci;
var cb = false;
typeof document < "u" && (Ci = document.createElement("img"), Ci.onload = function() {
  kn && pb(kn), kn = null, cb = true;
}, Ci.onerror = function() {
  Pp = true, kn = null;
}, Ci.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
function A2(r3) {
  Pp || !Ci || (cb ? pb(r3) : kn = r3);
}
r(A2, "testSupport");
function pb(r3) {
  let e = r3.createTexture();
  r3.bindTexture(r3.TEXTURE_2D, e);
  try {
    if (r3.texImage2D(r3.TEXTURE_2D, 0, r3.RGBA, r3.RGBA, r3.UNSIGNED_BYTE, Ci), r3.isContextLost()) return;
    Ln.supported = true;
  } catch {
  }
  r3.deleteTexture(e), Pp = true;
}
r(pb, "testWebpTextureUpload");
var st;
((m) => {
  let r3, e, t3, i;
  m.resetRequestQueue = r(() => {
    r3 = [], e = 0, t3 = 0, i = {};
  }, "resetRequestQueue"), m.addThrottleControl = r((y) => {
    let g = t3++;
    return i[g] = y, g;
  }, "addThrottleControl"), m.removeThrottleControl = r((y) => {
    delete i[y], h();
  }, "removeThrottleControl");
  let s3 = r(() => {
    for (let y of Object.keys(i)) if (i[y]()) return true;
    return false;
  }, "isThrottled");
  m.getImage = r((y, g, x = true) => new Promise((b, w) => {
    Ln.supported && (y.headers || (y.headers = {}), y.headers.accept = "image/webp,*/*"), V(y, { type: "image" });
    let _ = { abortController: g, requestParameters: y, supportImageRefresh: x, state: "queued", onError: (S) => {
      w(S);
    }, onSuccess: (S) => {
      b(S);
    } };
    r3.push(_), h();
  }), "getImage");
  let c = r((y) => typeof createImageBitmap == "function" ? ib(y) : nb(y), "arrayBufferToCanvasImageSource"), p = r(async (y) => {
    y.state = "running";
    let { requestParameters: g, supportImageRefresh: x, onError: b, onSuccess: w, abortController: _ } = y, S = x === false && !tr(self) && !os(g.url) && (!g.headers || Object.keys(g.headers).reduce((T, L) => T && L === "accept", true));
    e++;
    let P = S ? f(g, _) : Ii(g, _);
    try {
      let T = await P;
      if (delete y.abortController, y.state = "completed", T.data instanceof HTMLImageElement || ht(T.data)) w(T);
      else if (T.data) {
        let L = await c(T.data);
        w({ data: L, cacheControl: T.cacheControl, expires: T.expires });
      }
    } catch (T) {
      delete y.abortController, b(T);
    } finally {
      e--, h();
    }
  }, "doImageRequest"), h = r(() => {
    let y = s3() ? ot.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : ot.MAX_PARALLEL_IMAGE_REQUESTS;
    for (let g = e; g < y && r3.length > 0; g++) {
      let x = r3.shift();
      if (x.abortController.signal.aborted) {
        g--;
        continue;
      }
      p(x);
    }
  }, "processQueue"), f = r((y, g) => new Promise((x, b) => {
    let w = new Image(), _ = y.url, S = y.credentials;
    S && S === "include" ? w.crossOrigin = "use-credentials" : (S && S === "same-origin" || !wp(_)) && (w.crossOrigin = "anonymous"), g.signal.addEventListener("abort", () => {
      w.src = "", b(qr());
    }), w.fetchPriority = "high", w.onload = () => {
      w.onerror = w.onload = null, x({ data: w });
    }, w.onerror = () => {
      w.onerror = w.onload = null, !g.signal.aborted && b(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
    }, w.src = _;
  }), "getImageUsingHtmlImage");
})(st || (st = {}));
st.resetRequestQueue();
q();
var Tp = class Tp2 {
  constructor(e) {
    this._transformRequestFn = e;
  }
  transformRequest(e, t3) {
    return this._transformRequestFn ? this._transformRequestFn(e, t3) || { url: e } : { url: e };
  }
  normalizeSpriteURL(e, t3, i) {
    let n = C2(e);
    return n.path += `${t3}${i}`, E2(n);
  }
  setTransformRequest(e) {
    this._transformRequestFn = e;
  }
};
r(Tp, "RequestManager");
var ls = Tp;
var I2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
function C2(r3) {
  let e = r3.match(I2);
  if (!e) throw new Error(`Unable to parse URL "${r3}"`);
  return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] };
}
r(C2, "parseUrl");
function E2(r3) {
  let e = r3.params.length ? `?${r3.params.join("&")}` : "";
  return `${r3.protocol}://${r3.authority}${r3.path}${e}`;
}
r(E2, "formatUrl");
q();
q();
function hb(r3, e, t3) {
  t3[r3] && t3[r3].indexOf(e) !== -1 || (t3[r3] = t3[r3] || [], t3[r3].push(e));
}
r(hb, "_addEventListener");
function Mp(r3, e, t3) {
  if (t3 && t3[r3]) {
    let i = t3[r3].indexOf(e);
    i !== -1 && t3[r3].splice(i, 1);
  }
}
r(Mp, "_removeEventListener");
var Ap = class Ap2 {
  constructor(e, t3 = {}) {
    V(this, t3), this.type = e;
  }
};
r(Ap, "Event");
var F = Ap;
var Ip = class Ip2 extends F {
  constructor(e, t3 = {}) {
    super("error", V({ error: e }, t3));
  }
};
r(Ip, "ErrorEvent");
var Z = Ip;
var Cp = class Cp2 {
  on(e, t3) {
    return this._listeners = this._listeners || {}, hb(e, t3, this._listeners), this;
  }
  off(e, t3) {
    return Mp(e, t3, this._listeners), Mp(e, t3, this._oneTimeListeners), this;
  }
  once(e, t3) {
    return t3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, hb(e, t3, this._oneTimeListeners), this) : new Promise((i) => this.once(e, i));
  }
  fire(e, t3) {
    typeof e == "string" && (e = new F(e, t3 || {}));
    let i = e.type;
    if (this.listens(i)) {
      e.target = this;
      let n = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
      for (let s3 of n) s3.call(this, e);
      let o = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : [];
      for (let s3 of o) Mp(i, s3, this._oneTimeListeners), s3.call(this, e);
      let a = this._eventedParent;
      a && (V(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), a.fire(e));
    } else e instanceof Z && console.error(e.error);
    return this;
  }
  listens(e) {
    return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
  }
  setEventedParent(e, t3) {
    return this._eventedParent = e, this._eventedParentData = t3, this;
  }
};
r(Cp, "Evented");
var de = Cp;
q();
q();
q();
q();
var k2 = 8;
var L2 = { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } };
var D2 = { "*": { type: "source" } };
var z2 = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var F2 = { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var R2 = { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var B2 = { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var O2 = { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } };
var V2 = { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var U2 = { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var N2 = { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } };
var G2 = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var $2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var q2 = { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var j2 = { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Z2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var H2 = { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var W2 = { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var X2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var K2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var J2 = { type: "array", value: "*" };
var Y2 = { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } };
var Q2 = { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } };
var eP = { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 };
var tP = { type: "array", value: "*", minimum: 1 };
var rP = { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var iP = { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var nP = { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } };
var oP = { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } };
var aP = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var sP = { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } };
var lP = { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } };
var uP = { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } };
var cP = { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var pP = { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } };
var hP = { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var fP = { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var mP = { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var dP = { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } };
var yP = { "*": { type: "string" } };
var A = { $version: k2, $root: L2, sources: D2, source: z2, source_vector: F2, source_raster: R2, source_raster_dem: B2, source_geojson: O2, source_video: V2, source_image: U2, layer: N2, layout: G2, layout_background: $2, layout_fill: q2, layout_circle: j2, layout_heatmap: Z2, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: H2, layout_symbol: W2, layout_raster: X2, layout_hillshade: K2, filter: J2, filter_operator: Y2, geometry_type: Q2, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: eP, expression: tP, light: rP, sky: iP, terrain: nP, projection: oP, paint: aP, paint_fill: sP, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: lP, paint_circle: uP, paint_heatmap: cP, paint_symbol: pP, paint_raster: hP, paint_hillshade: fP, paint_background: mP, transition: dP, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: yP };
var gP = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function xP(r3, e) {
  let t3 = {};
  for (let i in r3) i !== "ref" && (t3[i] = r3[i]);
  return gP.forEach((i) => {
    i in e && (t3[i] = e[i]);
  }), t3;
}
r(xP, "deref");
function eh(r3) {
  r3 = r3.slice();
  let e = /* @__PURE__ */ Object.create(null);
  for (let t3 = 0; t3 < r3.length; t3++) e[r3[t3].id] = r3[t3];
  for (let t3 = 0; t3 < r3.length; t3++) "ref" in r3[t3] && (r3[t3] = xP(r3[t3], e[r3[t3].ref]));
  return r3;
}
r(eh, "derefLayers");
function Le(r3, e) {
  if (Array.isArray(r3)) {
    if (!Array.isArray(e) || r3.length !== e.length) return false;
    for (let t3 = 0; t3 < r3.length; t3++) if (!Le(r3[t3], e[t3])) return false;
    return true;
  }
  if (typeof r3 == "object" && r3 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r3).length !== Object.keys(e).length) return false;
    for (let i in r3) if (!Le(r3[i], e[i])) return false;
    return true;
  }
  return r3 === e;
}
r(Le, "deepEqual");
function Mt(r3, e) {
  r3.push(e);
}
r(Mt, "addCommand");
function Fb(r3, e, t3) {
  Mt(t3, { command: "addSource", args: [r3, e[r3]] });
}
r(Fb, "addSource");
function Rb(r3, e, t3) {
  Mt(e, { command: "removeSource", args: [r3] }), t3[r3] = true;
}
r(Rb, "removeSource");
function bP(r3, e, t3, i) {
  Rb(r3, t3, i), Fb(r3, e, t3);
}
r(bP, "updateSource");
function _P(r3, e, t3) {
  let i;
  for (i in r3[t3]) if (Object.prototype.hasOwnProperty.call(r3[t3], i) && i !== "data" && !Le(r3[t3][i], e[t3][i])) return false;
  for (i in e[t3]) if (Object.prototype.hasOwnProperty.call(e[t3], i) && i !== "data" && !Le(r3[t3][i], e[t3][i])) return false;
  return true;
}
r(_P, "canUpdateGeoJSON");
function vP(r3, e, t3, i) {
  r3 = r3 || {}, e = e || {};
  let n;
  for (n in r3) Object.prototype.hasOwnProperty.call(r3, n) && (Object.prototype.hasOwnProperty.call(e, n) || Rb(n, t3, i));
  for (n in e) Object.prototype.hasOwnProperty.call(e, n) && (Object.prototype.hasOwnProperty.call(r3, n) ? Le(r3[n], e[n]) || (r3[n].type === "geojson" && e[n].type === "geojson" && _P(r3, e, n) ? Mt(t3, { command: "setGeoJSONSourceData", args: [n, e[n].data] }) : bP(n, e, t3, i)) : Fb(n, e, t3));
}
r(vP, "diffSources");
function us(r3, e, t3, i, n, o) {
  r3 = r3 || {}, e = e || {};
  for (let a in r3) Object.prototype.hasOwnProperty.call(r3, a) && (Le(r3[a], e[a]) || t3.push({ command: o, args: [i, a, e[a], n] }));
  for (let a in e) !Object.prototype.hasOwnProperty.call(e, a) || Object.prototype.hasOwnProperty.call(r3, a) || Le(r3[a], e[a]) || t3.push({ command: o, args: [i, a, e[a], n] });
}
r(us, "diffLayerPropertyChanges");
function fb(r3) {
  return r3.id;
}
r(fb, "pluckId");
function mb(r3, e) {
  return r3[e.id] = e, r3;
}
r(mb, "indexById");
function wP(r3, e, t3) {
  r3 = r3 || [], e = e || [];
  let i = r3.map(fb), n = e.map(fb), o = r3.reduce(mb, {}), a = e.reduce(mb, {}), s3 = i.slice(), l = /* @__PURE__ */ Object.create(null), c, p, h, f, m;
  for (let y = 0, g = 0; y < i.length; y++) c = i[y], Object.prototype.hasOwnProperty.call(a, c) ? g++ : (Mt(t3, { command: "removeLayer", args: [c] }), s3.splice(s3.indexOf(c, g), 1));
  for (let y = 0, g = 0; y < n.length; y++) c = n[n.length - 1 - y], s3[s3.length - 1 - y] !== c && (Object.prototype.hasOwnProperty.call(o, c) ? (Mt(t3, { command: "removeLayer", args: [c] }), s3.splice(s3.lastIndexOf(c, s3.length - g), 1)) : g++, f = s3[s3.length - y], Mt(t3, { command: "addLayer", args: [a[c], f] }), s3.splice(s3.length - y, 0, c), l[c] = true);
  for (let y = 0; y < n.length; y++) if (c = n[y], p = o[c], h = a[c], !(l[c] || Le(p, h))) {
    if (!Le(p.source, h.source) || !Le(p["source-layer"], h["source-layer"]) || !Le(p.type, h.type)) {
      Mt(t3, { command: "removeLayer", args: [c] }), f = s3[s3.lastIndexOf(c) + 1], Mt(t3, { command: "addLayer", args: [h, f] });
      continue;
    }
    us(p.layout, h.layout, t3, c, null, "setLayoutProperty"), us(p.paint, h.paint, t3, c, null, "setPaintProperty"), Le(p.filter, h.filter) || Mt(t3, { command: "setFilter", args: [c, h.filter] }), (!Le(p.minzoom, h.minzoom) || !Le(p.maxzoom, h.maxzoom)) && Mt(t3, { command: "setLayerZoomRange", args: [c, h.minzoom, h.maxzoom] });
    for (m in p) Object.prototype.hasOwnProperty.call(p, m) && (m === "layout" || m === "paint" || m === "filter" || m === "metadata" || m === "minzoom" || m === "maxzoom" || (m.indexOf("paint.") === 0 ? us(p[m], h[m], t3, c, m.slice(6), "setPaintProperty") : Le(p[m], h[m]) || Mt(t3, { command: "setLayerProperty", args: [c, m, h[m]] })));
    for (m in h) !Object.prototype.hasOwnProperty.call(h, m) || Object.prototype.hasOwnProperty.call(p, m) || m === "layout" || m === "paint" || m === "filter" || m === "metadata" || m === "minzoom" || m === "maxzoom" || (m.indexOf("paint.") === 0 ? us(p[m], h[m], t3, c, m.slice(6), "setPaintProperty") : Le(p[m], h[m]) || Mt(t3, { command: "setLayerProperty", args: [c, m, h[m]] }));
  }
}
r(wP, "diffLayers");
function Bb(r3, e) {
  if (!r3) return [{ command: "setStyle", args: [e] }];
  let t3 = [];
  try {
    if (!Le(r3.version, e.version)) return [{ command: "setStyle", args: [e] }];
    Le(r3.center, e.center) || t3.push({ command: "setCenter", args: [e.center] }), Le(r3.zoom, e.zoom) || t3.push({ command: "setZoom", args: [e.zoom] }), Le(r3.bearing, e.bearing) || t3.push({ command: "setBearing", args: [e.bearing] }), Le(r3.pitch, e.pitch) || t3.push({ command: "setPitch", args: [e.pitch] }), Le(r3.sprite, e.sprite) || t3.push({ command: "setSprite", args: [e.sprite] }), Le(r3.glyphs, e.glyphs) || t3.push({ command: "setGlyphs", args: [e.glyphs] }), Le(r3.transition, e.transition) || t3.push({ command: "setTransition", args: [e.transition] }), Le(r3.light, e.light) || t3.push({ command: "setLight", args: [e.light] }), Le(r3.terrain, e.terrain) || t3.push({ command: "setTerrain", args: [e.terrain] }), Le(r3.sky, e.sky) || t3.push({ command: "setSky", args: [e.sky] }), Le(r3.projection, e.projection) || t3.push({ command: "setProjection", args: [e.projection] });
    let i = {}, n = [];
    vP(r3.sources, e.sources, n, i);
    let o = [];
    r3.layers && r3.layers.forEach((a) => {
      "source" in a && i[a.source] ? t3.push({ command: "removeLayer", args: [a.id] }) : o.push(a);
    }), t3 = t3.concat(n), wP(o, e.layers, t3);
  } catch (i) {
    console.warn("Unable to compute style diff:", i), t3 = [{ command: "setStyle", args: [e] }];
  }
  return t3;
}
r(Bb, "diffStyles");
var hh = class hh2 {
  constructor(e, t3, i, n) {
    this.message = (e ? `${e}: ` : "") + i, n && (this.identifier = n), t3 != null && t3.__line__ && (this.line = t3.__line__);
  }
};
r(hh, "ValidationError");
var B = hh;
function Oi(r3, ...e) {
  for (let t3 of e) for (let i in t3) r3[i] = t3[i];
  return r3;
}
r(Oi, "extendBy");
var fh = class fh2 extends Error {
  constructor(e, t3) {
    super(t3), this.message = t3, this.key = e;
  }
};
r(fh, "ExpressionParsingError");
var At = fh;
var Is = class Is2 {
  constructor(e, t3 = []) {
    this.parent = e, this.bindings = {};
    for (let [i, n] of t3) this.bindings[i] = n;
  }
  concat(e) {
    return new Is2(this, e);
  }
  get(e) {
    if (this.bindings[e]) return this.bindings[e];
    if (this.parent) return this.parent.get(e);
    throw new Error(`${e} not found in scope.`);
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
r(Is, "Scope");
var Op = Is;
var Ni = { kind: "null" };
var q3 = { kind: "number" };
var pe = { kind: "string" };
var se = { kind: "boolean" };
var Ct = { kind: "color" };
var Ri = { kind: "object" };
var le = { kind: "value" };
var SP = { kind: "error" };
var Hs = { kind: "collator" };
var Gi = { kind: "formatted" };
var Ws = { kind: "padding" };
var ro = { kind: "resolvedImage" };
var Xs = { kind: "variableAnchorOffsetCollection" };
function _t(r3, e) {
  return { kind: "array", itemType: r3, N: e };
}
r(_t, "array$1");
function Re(r3) {
  if (r3.kind === "array") {
    let e = Re(r3.itemType);
    return typeof r3.N == "number" ? `array<${e}, ${r3.N}>` : r3.itemType.kind === "value" ? "array" : `array<${e}>`;
  } else return r3.kind;
}
r(Re, "toString$1");
var PP = [Ni, q3, pe, se, Ct, Gi, Ri, _t(le), Ws, ro, Xs];
function $n(r3, e) {
  if (e.kind === "error") return null;
  if (r3.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !$n(r3.itemType, e.itemType)) && (typeof r3.N != "number" || r3.N === e.N)) return null;
  } else {
    if (r3.kind === e.kind) return null;
    if (r3.kind === "value") {
      for (let t3 of PP) if (!$n(t3, e)) return null;
    }
  }
  return `Expected ${Re(r3)} but found ${Re(e)} instead.`;
}
r($n, "checkSubtype");
function th(r3, e) {
  return e.some((t3) => t3.kind === r3.kind);
}
r(th, "isValidType");
function qn(r3, e) {
  return e.some((t3) => t3 === "null" ? r3 === null : t3 === "array" ? Array.isArray(r3) : t3 === "object" ? r3 && !Array.isArray(r3) && typeof r3 == "object" : t3 === typeof r3);
}
r(qn, "isValidNativeType");
function Dn(r3, e) {
  return r3.kind === "array" && e.kind === "array" ? r3.itemType.kind === e.itemType.kind && typeof r3.N == "number" : r3.kind === e.kind;
}
r(Dn, "verifyType");
var Ob = 0.96422;
var Vb = 1;
var Ub = 0.82521;
var Nb = 4 / 29;
var Bi = 6 / 29;
var Gb = 3 * Bi * Bi;
var TP = Bi * Bi * Bi;
var MP = Math.PI / 180;
var AP = 180 / Math.PI;
function $b(r3) {
  return r3 = r3 % 360, r3 < 0 && (r3 += 360), r3;
}
r($b, "constrainAngle");
function qb([r3, e, t3, i]) {
  r3 = Ep(r3), e = Ep(e), t3 = Ep(t3);
  let n, o, a = kp((0.2225045 * r3 + 0.7168786 * e + 0.0606169 * t3) / Vb);
  r3 === e && e === t3 ? n = o = a : (n = kp((0.4360747 * r3 + 0.3850649 * e + 0.1430804 * t3) / Ob), o = kp((0.0139322 * r3 + 0.0971045 * e + 0.7141733 * t3) / Ub));
  let s3 = 116 * a - 16;
  return [s3 < 0 ? 0 : s3, 500 * (n - a), 200 * (a - o), i];
}
r(qb, "rgbToLab");
function Ep(r3) {
  return r3 <= 0.04045 ? r3 / 12.92 : Math.pow((r3 + 0.055) / 1.055, 2.4);
}
r(Ep, "rgb2xyz");
function kp(r3) {
  return r3 > TP ? Math.pow(r3, 1 / 3) : r3 / Gb + Nb;
}
r(kp, "xyz2lab");
function jb([r3, e, t3, i]) {
  let n = (r3 + 16) / 116, o = isNaN(e) ? n : n + e / 500, a = isNaN(t3) ? n : n - t3 / 200;
  return n = Vb * Dp(n), o = Ob * Dp(o), a = Ub * Dp(a), [Lp(3.1338561 * o - 1.6168667 * n - 0.4906146 * a), Lp(-0.9787684 * o + 1.9161415 * n + 0.033454 * a), Lp(0.0719453 * o - 0.2289914 * n + 1.4052427 * a), i];
}
r(jb, "labToRgb");
function Lp(r3) {
  return r3 = r3 <= 304e-5 ? 12.92 * r3 : 1.055 * Math.pow(r3, 1 / 2.4) - 0.055, r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
}
r(Lp, "xyz2rgb");
function Dp(r3) {
  return r3 > Bi ? r3 * r3 * r3 : Gb * (r3 - Nb);
}
r(Dp, "lab2xyz");
function IP(r3) {
  let [e, t3, i, n] = qb(r3), o = Math.sqrt(t3 * t3 + i * i);
  return [Math.round(o * 1e4) ? $b(Math.atan2(i, t3) * AP) : NaN, o, e, n];
}
r(IP, "rgbToHcl");
function CP([r3, e, t3, i]) {
  return r3 = isNaN(r3) ? 0 : r3 * MP, jb([t3, Math.cos(r3) * e, Math.sin(r3) * e, i]);
}
r(CP, "hclToRgb");
function EP([r3, e, t3, i]) {
  r3 = $b(r3), e /= 100, t3 /= 100;
  function n(o) {
    let a = (o + r3 / 30) % 12, s3 = e * Math.min(t3, 1 - t3);
    return t3 - s3 * Math.max(-1, Math.min(a - 3, 9 - a, 1));
  }
  return r(n, "f"), [n(0), n(8), n(4), i];
}
r(EP, "hslToRgb");
function kP(r3) {
  if (r3 = r3.toLowerCase().trim(), r3 === "transparent") return [0, 0, 0, 0];
  let e = LP[r3];
  if (e) {
    let [n, o, a] = e;
    return [n / 255, o / 255, a / 255, 1];
  }
  if (r3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r3)) {
    let o = r3.length < 6 ? 1 : 2, a = 1;
    return [cs(r3.slice(a, a += o)), cs(r3.slice(a, a += o)), cs(r3.slice(a, a += o)), cs(r3.slice(a, a + o) || "ff")];
  }
  if (r3.startsWith("rgb")) {
    let n = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = r3.match(n);
    if (o) {
      let [a, s3, l, c, p, h, f, m, y, g, x, b] = o, w = [c || " ", f || " ", g].join("");
      if (w === "  " || w === "  /" || w === ",," || w === ",,,") {
        let _ = [l, h, y].join(""), S = _ === "%%%" ? 100 : _ === "" ? 255 : 0;
        if (S) {
          let P = [Ei(+s3 / S, 0, 1), Ei(+p / S, 0, 1), Ei(+m / S, 0, 1), x ? db(+x, b) : 1];
          if (yb(P)) return P;
        }
      }
      return;
    }
  }
  let t3 = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, i = r3.match(t3);
  if (i) {
    let [n, o, a, s3, l, c, p, h, f] = i, m = [a || " ", l || " ", p].join("");
    if (m === "  " || m === "  /" || m === ",," || m === ",,,") {
      let y = [+o, Ei(+s3, 0, 100), Ei(+c, 0, 100), h ? db(+h, f) : 1];
      if (yb(y)) return EP(y);
    }
  }
}
r(kP, "parseCssColor");
function cs(r3) {
  return parseInt(r3.padEnd(2, r3), 16) / 255;
}
r(cs, "parseHex");
function db(r3, e) {
  return Ei(e ? r3 / 100 : r3, 0, 1);
}
r(db, "parseAlpha");
function Ei(r3, e, t3) {
  return Math.min(Math.max(e, r3), t3);
}
r(Ei, "clamp");
function yb(r3) {
  return !r3.some(Number.isNaN);
}
r(yb, "validateNumbers");
var LP = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var Bn = class Bn2 {
  constructor(e, t3, i, n = 1, o = true) {
    this.r = e, this.g = t3, this.b = i, this.a = n, o || (this.r *= n, this.g *= n, this.b *= n, n || this.overwriteGetter("rgb", [e, t3, i, n]));
  }
  static parse(e) {
    if (e instanceof Bn2) return e;
    if (typeof e != "string") return;
    let t3 = kP(e);
    if (t3) return new Bn2(...t3, false);
  }
  get rgb() {
    let { r: e, g: t3, b: i, a: n } = this, o = n || 1 / 0;
    return this.overwriteGetter("rgb", [e / o, t3 / o, i / o, n]);
  }
  get hcl() {
    return this.overwriteGetter("hcl", IP(this.rgb));
  }
  get lab() {
    return this.overwriteGetter("lab", qb(this.rgb));
  }
  overwriteGetter(e, t3) {
    return Object.defineProperty(this, e, { value: t3 }), t3;
  }
  toString() {
    let [e, t3, i, n] = this.rgb;
    return `rgba(${[e, t3, i].map((o) => Math.round(o * 255)).join(",")},${n})`;
  }
};
r(Bn, "Color");
var X = Bn;
X.black = new X(0, 0, 0, 1);
X.white = new X(1, 1, 1, 1);
X.transparent = new X(0, 0, 0, 0);
X.red = new X(1, 0, 0, 1);
var mh = class mh2 {
  constructor(e, t3, i) {
    e ? this.sensitivity = t3 ? "variant" : "case" : this.sensitivity = t3 ? "accent" : "base", this.locale = i, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, t3) {
    return this.collator.compare(e, t3);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
r(mh, "Collator");
var jn = mh;
var dh = class dh2 {
  constructor(e, t3, i, n, o) {
    this.text = e, this.image = t3, this.scale = i, this.fontStack = n, this.textColor = o;
  }
};
r(dh, "FormattedSection");
var Zn = dh;
var Li = class Li2 {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new Li2([new Zn(e, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof Li2 ? e : Li2.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
};
r(Li, "Formatted");
var wt = Li;
var Di = class Di2 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof Di2) return e;
    if (typeof e == "number") return new Di2([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (let t3 of e) if (typeof t3 != "number") return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new Di2(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
r(Di, "Padding");
var Rt = Di;
var DP = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
var On = class On2 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof On2) return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t3 = 0; t3 < e.length; t3 += 2) {
        let i = e[t3], n = e[t3 + 1];
        if (typeof i != "string" || !DP.has(i) || !Array.isArray(n) || n.length !== 2 || typeof n[0] != "number" || typeof n[1] != "number") return;
      }
      return new On2(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
r(On, "VariableAnchorOffsetCollection");
var rr = On;
var Cs = class Cs2 {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new Cs2({ name: e, available: false }) : null;
  }
};
r(Cs, "ResolvedImage");
var ft = Cs;
function Zb(r3, e, t3, i) {
  return typeof r3 == "number" && r3 >= 0 && r3 <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t3 == "number" && t3 >= 0 && t3 <= 255 ? typeof i > "u" || typeof i == "number" && i >= 0 && i <= 1 ? null : `Invalid rgba value [${[r3, e, t3, i].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof i == "number" ? [r3, e, t3, i] : [r3, e, t3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
r(Zb, "validateRGBA");
function Hn(r3) {
  if (r3 === null || typeof r3 == "string" || typeof r3 == "boolean" || typeof r3 == "number" || r3 instanceof X || r3 instanceof jn || r3 instanceof wt || r3 instanceof Rt || r3 instanceof rr || r3 instanceof ft) return true;
  if (Array.isArray(r3)) {
    for (let e of r3) if (!Hn(e)) return false;
    return true;
  } else if (typeof r3 == "object") {
    for (let e in r3) if (!Hn(r3[e])) return false;
    return true;
  } else return false;
}
r(Hn, "isValue");
function Ze(r3) {
  if (r3 === null) return Ni;
  if (typeof r3 == "string") return pe;
  if (typeof r3 == "boolean") return se;
  if (typeof r3 == "number") return q3;
  if (r3 instanceof X) return Ct;
  if (r3 instanceof jn) return Hs;
  if (r3 instanceof wt) return Gi;
  if (r3 instanceof Rt) return Ws;
  if (r3 instanceof rr) return Xs;
  if (r3 instanceof ft) return ro;
  if (Array.isArray(r3)) {
    let e = r3.length, t3;
    for (let i of r3) {
      let n = Ze(i);
      if (!t3) t3 = n;
      else {
        if (t3 === n) continue;
        t3 = le;
        break;
      }
    }
    return _t(t3 || le, e);
  } else return Ri;
}
r(Ze, "typeOf");
function Fn(r3) {
  let e = typeof r3;
  return r3 === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r3) : r3 instanceof X || r3 instanceof wt || r3 instanceof Rt || r3 instanceof rr || r3 instanceof ft ? r3.toString() : JSON.stringify(r3);
}
r(Fn, "toString");
var Es = class Es2 {
  constructor(e, t3) {
    this.type = e, this.value = t3;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (!Hn(e[1])) return t3.error("invalid value");
    let i = e[1], n = Ze(i), o = t3.expectedType;
    return n.kind === "array" && n.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (n = o), new Es2(n, i);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
r(Es, "Literal");
var xr = Es;
var yh = class yh2 {
  constructor(e) {
    this.name = "ExpressionEvaluationError", this.message = e;
  }
  toJSON() {
    return this.message;
  }
};
r(yh, "RuntimeError");
var Be = yh;
var ps = { string: pe, number: q3, boolean: se, object: Ri };
var ks = class ks2 {
  constructor(e, t3) {
    this.type = e, this.args = t3;
  }
  static parse(e, t3) {
    if (e.length < 2) return t3.error("Expected at least one argument.");
    let i = 1, n, o = e[0];
    if (o === "array") {
      let s3;
      if (e.length > 2) {
        let c = e[1];
        if (typeof c != "string" || !(c in ps) || c === "object") return t3.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s3 = ps[c], i++;
      } else s3 = le;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t3.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], i++;
      }
      n = _t(s3, l);
    } else {
      if (!ps[o]) throw new Error(`Types doesn't contain name = ${o}`);
      n = ps[o];
    }
    let a = [];
    for (; i < e.length; i++) {
      let s3 = t3.parse(e[i], i, le);
      if (!s3) return null;
      a.push(s3);
    }
    return new ks2(n, a);
  }
  evaluate(e) {
    for (let t3 = 0; t3 < this.args.length; t3++) {
      let i = this.args[t3].evaluate(e);
      if ($n(this.type, Ze(i))) {
        if (t3 === this.args.length - 1) throw new Be(`Expected value to be of type ${Re(this.type)}, but found ${Re(Ze(i))} instead.`);
      } else return i;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
r(ks, "Assertion");
var Ft = ks;
var gb = { "to-boolean": se, "to-color": Ct, "to-number": q3, "to-string": pe };
var Ls = class Ls2 {
  constructor(e, t3) {
    this.type = e, this.args = t3;
  }
  static parse(e, t3) {
    if (e.length < 2) return t3.error("Expected at least one argument.");
    let i = e[0];
    if (!gb[i]) throw new Error(`Can't parse ${i} as it is not part of the known types`);
    if ((i === "to-boolean" || i === "to-string") && e.length !== 2) return t3.error("Expected one argument.");
    let n = gb[i], o = [];
    for (let a = 1; a < e.length; a++) {
      let s3 = t3.parse(e[a], a, le);
      if (!s3) return null;
      o.push(s3);
    }
    return new Ls2(n, o);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t3, i;
        for (let n of this.args) {
          if (t3 = n.evaluate(e), i = null, t3 instanceof X) return t3;
          if (typeof t3 == "string") {
            let o = e.parseColor(t3);
            if (o) return o;
          } else if (Array.isArray(t3) && (t3.length < 3 || t3.length > 4 ? i = `Invalid rbga value ${JSON.stringify(t3)}: expected an array containing either three or four numeric values.` : i = Zb(t3[0], t3[1], t3[2], t3[3]), !i)) return new X(t3[0] / 255, t3[1] / 255, t3[2] / 255, t3[3]);
        }
        throw new Be(i || `Could not parse color from value '${typeof t3 == "string" ? t3 : JSON.stringify(t3)}'`);
      }
      case "padding": {
        let t3;
        for (let i of this.args) {
          t3 = i.evaluate(e);
          let n = Rt.parse(t3);
          if (n) return n;
        }
        throw new Be(`Could not parse padding from value '${typeof t3 == "string" ? t3 : JSON.stringify(t3)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let t3;
        for (let i of this.args) {
          t3 = i.evaluate(e);
          let n = rr.parse(t3);
          if (n) return n;
        }
        throw new Be(`Could not parse variableAnchorOffsetCollection from value '${typeof t3 == "string" ? t3 : JSON.stringify(t3)}'`);
      }
      case "number": {
        let t3 = null;
        for (let i of this.args) {
          if (t3 = i.evaluate(e), t3 === null) return 0;
          let n = Number(t3);
          if (!isNaN(n)) return n;
        }
        throw new Be(`Could not convert ${JSON.stringify(t3)} to number.`);
      }
      case "formatted":
        return wt.fromString(Fn(this.args[0].evaluate(e)));
      case "resolvedImage":
        return ft.fromString(Fn(this.args[0].evaluate(e)));
      default:
        return Fn(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
r(Ls, "Coercion");
var gr = Ls;
var zP = ["Unknown", "Point", "LineString", "Polygon"];
var gh = class gh2 {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? zP[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t3 = this._parseColorCache[e];
    return t3 || (t3 = this._parseColorCache[e] = X.parse(e)), t3;
  }
};
r(gh, "EvaluationContext");
var ds = gh;
var Ds = class Ds2 {
  constructor(e, t3, i = [], n, o = new Op(), a = []) {
    this.registry = e, this.path = i, this.key = i.map((s3) => `[${s3}]`).join(""), this.scope = o, this.errors = a, this.expectedType = n, this._isConstant = t3;
  }
  parse(e, t3, i, n, o = {}) {
    return t3 ? this.concat(t3, i, n)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, t3) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function i(n, o, a) {
      return a === "assert" ? new Ft(o, [n]) : a === "coerce" ? new gr(o, [n]) : n;
    }
    if (r(i, "annotate"), Array.isArray(e)) {
      if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      let n = e[0];
      if (typeof n != "string") return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      let o = this.registry[n];
      if (o) {
        let a = o.parse(e, this);
        if (!a) return null;
        if (this.expectedType) {
          let s3 = this.expectedType, l = a.type;
          if ((s3.kind === "string" || s3.kind === "number" || s3.kind === "boolean" || s3.kind === "object" || s3.kind === "array") && l.kind === "value") a = i(a, s3, t3.typeAnnotation || "assert");
          else if ((s3.kind === "color" || s3.kind === "formatted" || s3.kind === "resolvedImage") && (l.kind === "value" || l.kind === "string")) a = i(a, s3, t3.typeAnnotation || "coerce");
          else if (s3.kind === "padding" && (l.kind === "value" || l.kind === "number" || l.kind === "array")) a = i(a, s3, t3.typeAnnotation || "coerce");
          else if (s3.kind === "variableAnchorOffsetCollection" && (l.kind === "value" || l.kind === "array")) a = i(a, s3, t3.typeAnnotation || "coerce");
          else if (this.checkSubtype(s3, l)) return null;
        }
        if (!(a instanceof xr) && a.type.kind !== "resolvedImage" && this._isConstant(a)) {
          let s3 = new ds();
          try {
            a = new xr(a.type, a.evaluate(s3));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return a;
      }
      return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
  }
  concat(e, t3, i) {
    let n = typeof e == "number" ? this.path.concat(e) : this.path, o = i ? this.scope.concat(i) : this.scope;
    return new Ds2(this.registry, this._isConstant, n, t3 || null, o, this.errors);
  }
  error(e, ...t3) {
    let i = `${this.key}${t3.map((n) => `[${n}]`).join("")}`;
    this.errors.push(new At(i, e));
  }
  checkSubtype(e, t3) {
    let i = $n(e, t3);
    return i && this.error(i), i;
  }
};
r(Ds, "ParsingContext");
var ys = Ds;
var zs = class zs2 {
  constructor(e, t3) {
    this.type = t3.type, this.bindings = [].concat(e), this.result = t3;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (let t3 of this.bindings) e(t3[1]);
    e(this.result);
  }
  static parse(e, t3) {
    if (e.length < 4) return t3.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
    let i = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      let a = e[o];
      if (typeof a != "string") return t3.error(`Expected string, but found ${typeof a} instead.`, o);
      if (/[^a-zA-Z0-9_]/.test(a)) return t3.error("Variable names must contain only alphanumeric characters or '_'.", o);
      let s3 = t3.parse(e[o + 1], o + 1);
      if (!s3) return null;
      i.push([a, s3]);
    }
    let n = t3.parse(e[e.length - 1], e.length - 1, t3.expectedType, i);
    return n ? new zs2(i, n) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
r(zs, "Let");
var gs = zs;
var Fs = class Fs2 {
  constructor(e, t3) {
    this.type = t3.type, this.name = e, this.boundExpression = t3;
  }
  static parse(e, t3) {
    if (e.length !== 2 || typeof e[1] != "string") return t3.error("'var' expression requires exactly one string literal argument.");
    let i = e[1];
    return t3.scope.has(i) ? new Fs2(i, t3.scope.get(i)) : t3.error(`Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
r(Fs, "Var");
var xs = Fs;
var Rs = class Rs2 {
  constructor(e, t3, i) {
    this.type = e, this.index = t3, this.input = i;
  }
  static parse(e, t3) {
    if (e.length !== 3) return t3.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    let i = t3.parse(e[1], 1, q3), n = t3.parse(e[2], 2, _t(t3.expectedType || le));
    if (!i || !n) return null;
    let o = n.type;
    return new Rs2(o.itemType, i, n);
  }
  evaluate(e) {
    let t3 = this.index.evaluate(e), i = this.input.evaluate(e);
    if (t3 < 0) throw new Be(`Array index out of bounds: ${t3} < 0.`);
    if (t3 >= i.length) throw new Be(`Array index out of bounds: ${t3} > ${i.length - 1}.`);
    if (t3 !== Math.floor(t3)) throw new Be(`Array index must be an integer, but found ${t3} instead.`);
    return i[t3];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
};
r(Rs, "At");
var Vp = Rs;
var Bs = class Bs2 {
  constructor(e, t3) {
    this.type = se, this.needle = e, this.haystack = t3;
  }
  static parse(e, t3) {
    if (e.length !== 3) return t3.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    let i = t3.parse(e[1], 1, le), n = t3.parse(e[2], 2, le);
    return !i || !n ? null : th(i.type, [se, pe, q3, Ni, le]) ? new Bs2(i, n) : t3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Re(i.type)} instead`);
  }
  evaluate(e) {
    let t3 = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!i) return false;
    if (!qn(t3, ["boolean", "string", "number", "null"])) throw new Be(`Expected first argument to be of type boolean, string, number or null, but found ${Re(Ze(t3))} instead.`);
    if (!qn(i, ["string", "array"])) throw new Be(`Expected second argument to be of type array or string, but found ${Re(Ze(i))} instead.`);
    return i.indexOf(t3) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
r(Bs, "In");
var Up = Bs;
var Vn = class Vn2 {
  constructor(e, t3, i) {
    this.type = q3, this.needle = e, this.haystack = t3, this.fromIndex = i;
  }
  static parse(e, t3) {
    if (e.length <= 2 || e.length >= 5) return t3.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    let i = t3.parse(e[1], 1, le), n = t3.parse(e[2], 2, le);
    if (!i || !n) return null;
    if (!th(i.type, [se, pe, q3, Ni, le])) return t3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Re(i.type)} instead`);
    if (e.length === 4) {
      let o = t3.parse(e[3], 3, q3);
      return o ? new Vn2(i, n, o) : null;
    } else return new Vn2(i, n);
  }
  evaluate(e) {
    let t3 = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!qn(t3, ["boolean", "string", "number", "null"])) throw new Be(`Expected first argument to be of type boolean, string, number or null, but found ${Re(Ze(t3))} instead.`);
    if (!qn(i, ["string", "array"])) throw new Be(`Expected second argument to be of type array or string, but found ${Re(Ze(i))} instead.`);
    if (this.fromIndex) {
      let n = this.fromIndex.evaluate(e);
      return i.indexOf(t3, n);
    }
    return i.indexOf(t3);
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
r(Vn, "IndexOf");
var Np = Vn;
var Os = class Os2 {
  constructor(e, t3, i, n, o, a) {
    this.inputType = e, this.type = t3, this.input = i, this.cases = n, this.outputs = o, this.otherwise = a;
  }
  static parse(e, t3) {
    if (e.length < 5) return t3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 1) return t3.error("Expected an even number of arguments.");
    let i, n;
    t3.expectedType && t3.expectedType.kind !== "value" && (n = t3.expectedType);
    let o = {}, a = [];
    for (let c = 2; c < e.length - 1; c += 2) {
      let p = e[c], h = e[c + 1];
      Array.isArray(p) || (p = [p]);
      let f = t3.concat(c);
      if (p.length === 0) return f.error("Expected at least one branch label.");
      for (let y of p) {
        if (typeof y != "number" && typeof y != "string") return f.error("Branch labels must be numbers or strings.");
        if (typeof y == "number" && Math.abs(y) > Number.MAX_SAFE_INTEGER) return f.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof y == "number" && Math.floor(y) !== y) return f.error("Numeric branch labels must be integer values.");
        if (!i) i = Ze(y);
        else if (f.checkSubtype(i, Ze(y))) return null;
        if (typeof o[String(y)] < "u") return f.error("Branch labels must be unique.");
        o[String(y)] = a.length;
      }
      let m = t3.parse(h, c, n);
      if (!m) return null;
      n = n || m.type, a.push(m);
    }
    let s3 = t3.parse(e[1], 1, le);
    if (!s3) return null;
    let l = t3.parse(e[e.length - 1], e.length - 1, n);
    return !l || s3.type.kind !== "value" && t3.concat(1).checkSubtype(i, s3.type) ? null : new Os2(i, n, s3, o, a, l);
  }
  evaluate(e) {
    let t3 = this.input.evaluate(e);
    return (Ze(t3) === this.inputType && this.outputs[this.cases[t3]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
};
r(Os, "Match");
var Gp = Os;
var Vs = class Vs2 {
  constructor(e, t3, i) {
    this.type = e, this.branches = t3, this.otherwise = i;
  }
  static parse(e, t3) {
    if (e.length < 4) return t3.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 0) return t3.error("Expected an odd number of arguments.");
    let i;
    t3.expectedType && t3.expectedType.kind !== "value" && (i = t3.expectedType);
    let n = [];
    for (let a = 1; a < e.length - 1; a += 2) {
      let s3 = t3.parse(e[a], a, se);
      if (!s3) return null;
      let l = t3.parse(e[a + 1], a + 1, i);
      if (!l) return null;
      n.push([s3, l]), i = i || l.type;
    }
    let o = t3.parse(e[e.length - 1], e.length - 1, i);
    if (!o) return null;
    if (!i) throw new Error("Can't infer output type");
    return new Vs2(i, n, o);
  }
  evaluate(e) {
    for (let [t3, i] of this.branches) if (t3.evaluate(e)) return i.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (let [t3, i] of this.branches) e(t3), e(i);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t3]) => t3.outputDefined()) && this.otherwise.outputDefined();
  }
};
r(Vs, "Case");
var $p = Vs;
var Un = class Un2 {
  constructor(e, t3, i, n) {
    this.type = e, this.input = t3, this.beginIndex = i, this.endIndex = n;
  }
  static parse(e, t3) {
    if (e.length <= 2 || e.length >= 5) return t3.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    let i = t3.parse(e[1], 1, le), n = t3.parse(e[2], 2, q3);
    if (!i || !n) return null;
    if (!th(i.type, [_t(le), pe, le])) return t3.error(`Expected first argument to be of type array or string, but found ${Re(i.type)} instead`);
    if (e.length === 4) {
      let o = t3.parse(e[3], 3, q3);
      return o ? new Un2(i.type, i, n, o) : null;
    } else return new Un2(i.type, i, n);
  }
  evaluate(e) {
    let t3 = this.input.evaluate(e), i = this.beginIndex.evaluate(e);
    if (!qn(t3, ["string", "array"])) throw new Be(`Expected first argument to be of type array or string, but found ${Re(Ze(t3))} instead.`);
    if (this.endIndex) {
      let n = this.endIndex.evaluate(e);
      return t3.slice(i, n);
    }
    return t3.slice(i);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
r(Un, "Slice");
var qp = Un;
function Ks(r3, e) {
  let t3 = r3.length - 1, i = 0, n = t3, o = 0, a, s3;
  for (; i <= n; ) if (o = Math.floor((i + n) / 2), a = r3[o], s3 = r3[o + 1], a <= e) {
    if (o === t3 || e < s3) return o;
    i = o + 1;
  } else if (a > e) n = o - 1;
  else throw new Be("Input is not a number.");
  return 0;
}
r(Ks, "findStopLessThanOrEqualTo");
var Us = class Us2 {
  constructor(e, t3, i) {
    this.type = e, this.input = t3, this.labels = [], this.outputs = [];
    for (let [n, o] of i) this.labels.push(n), this.outputs.push(o);
  }
  static parse(e, t3) {
    if (e.length - 1 < 4) return t3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0) return t3.error("Expected an even number of arguments.");
    let i = t3.parse(e[1], 1, q3);
    if (!i) return null;
    let n = [], o = null;
    t3.expectedType && t3.expectedType.kind !== "value" && (o = t3.expectedType);
    for (let a = 1; a < e.length; a += 2) {
      let s3 = a === 1 ? -1 / 0 : e[a], l = e[a + 1], c = a, p = a + 1;
      if (typeof s3 != "number") return t3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', c);
      if (n.length && n[n.length - 1][0] >= s3) return t3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', c);
      let h = t3.parse(l, p, o);
      if (!h) return null;
      o = o || h.type, n.push([s3, h]);
    }
    return new Us2(o, i, n);
  }
  evaluate(e) {
    let t3 = this.labels, i = this.outputs;
    if (t3.length === 1) return i[0].evaluate(e);
    let n = this.input.evaluate(e);
    if (n <= t3[0]) return i[0].evaluate(e);
    let o = t3.length;
    if (n >= t3[o - 1]) return i[o - 1].evaluate(e);
    let a = Ks(t3, n);
    return i[a].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (let t3 of this.outputs) e(t3);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
r(Us, "Step");
var Vi = Us;
function FP(r3) {
  return r3 && r3.__esModule && Object.prototype.hasOwnProperty.call(r3, "default") ? r3.default : r3;
}
r(FP, "getDefaultExportFromCjs");
var RP = Hb;
function Hb(r3, e, t3, i) {
  this.cx = 3 * r3, this.bx = 3 * (t3 - r3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r3, this.p1y = e, this.p2x = t3, this.p2y = i;
}
r(Hb, "UnitBezier");
Hb.prototype = { sampleCurveX: function(r3) {
  return ((this.ax * r3 + this.bx) * r3 + this.cx) * r3;
}, sampleCurveY: function(r3) {
  return ((this.ay * r3 + this.by) * r3 + this.cy) * r3;
}, sampleCurveDerivativeX: function(r3) {
  return (3 * this.ax * r3 + 2 * this.bx) * r3 + this.cx;
}, solveCurveX: function(r3, e) {
  if (e === void 0 && (e = 1e-6), r3 < 0) return 0;
  if (r3 > 1) return 1;
  for (var t3 = r3, i = 0; i < 8; i++) {
    var n = this.sampleCurveX(t3) - r3;
    if (Math.abs(n) < e) return t3;
    var o = this.sampleCurveDerivativeX(t3);
    if (Math.abs(o) < 1e-6) break;
    t3 = t3 - n / o;
  }
  var a = 0, s3 = 1;
  for (t3 = r3, i = 0; i < 20 && (n = this.sampleCurveX(t3), !(Math.abs(n - r3) < e)); i++) r3 > n ? a = t3 : s3 = t3, t3 = (s3 - a) * 0.5 + a;
  return t3;
}, solve: function(r3, e) {
  return this.sampleCurveY(this.solveCurveX(r3, e));
} };
var BP = FP(RP);
function OP(r3) {
  return r3 === "rgb" || r3 === "hcl" || r3 === "lab";
}
r(OP, "isSupportedInterpolationColorSpace");
function Kr(r3, e, t3) {
  return r3 + t3 * (e - r3);
}
r(Kr, "number");
function VP(r3, e, t3, i = "rgb") {
  switch (i) {
    case "rgb": {
      let [n, o, a, s3] = bs(r3.rgb, e.rgb, t3);
      return new X(n, o, a, s3, false);
    }
    case "hcl": {
      let [n, o, a, s3] = r3.hcl, [l, c, p, h] = e.hcl, f, m;
      if (!isNaN(n) && !isNaN(l)) {
        let w = l - n;
        l > n && w > 180 ? w -= 360 : l < n && n - l > 180 && (w += 360), f = n + t3 * w;
      } else isNaN(n) ? isNaN(l) ? f = NaN : (f = l, (a === 1 || a === 0) && (m = c)) : (f = n, (p === 1 || p === 0) && (m = o));
      let [y, g, x, b] = CP([f, m != null ? m : Kr(o, c, t3), Kr(a, p, t3), Kr(s3, h, t3)]);
      return new X(y, g, x, b, false);
    }
    case "lab": {
      let [n, o, a, s3] = jb(bs(r3.lab, e.lab, t3));
      return new X(n, o, a, s3, false);
    }
  }
}
r(VP, "color");
function bs(r3, e, t3) {
  return r3.map((i, n) => Kr(i, e[n], t3));
}
r(bs, "array");
function UP(r3, e, t3) {
  return new Rt(bs(r3.values, e.values, t3));
}
r(UP, "padding");
function NP(r3, e, t3) {
  let i = r3.values, n = e.values;
  if (i.length !== n.length) throw new Be(`Cannot interpolate values of different length. from: ${r3.toString()}, to: ${e.toString()}`);
  let o = [];
  for (let a = 0; a < i.length; a += 2) {
    if (i[a] !== n[a]) throw new Be(`Cannot interpolate values containing mismatched anchors. from[${a}]: ${i[a]}, to[${a}]: ${n[a]}`);
    o.push(i[a]);
    let [s3, l] = i[a + 1], [c, p] = n[a + 1];
    o.push([Kr(s3, c, t3), Kr(l, p, t3)]);
  }
  return new rr(o);
}
r(NP, "variableAnchorOffsetCollection");
var Pe = { number: Kr, color: VP, array: bs, padding: UP, variableAnchorOffsetCollection: NP };
var Nn = class Nn2 {
  constructor(e, t3, i, n, o) {
    this.type = e, this.operator = t3, this.interpolation = i, this.input = n, this.labels = [], this.outputs = [];
    for (let [a, s3] of o) this.labels.push(a), this.outputs.push(s3);
  }
  static interpolationFactor(e, t3, i, n) {
    let o = 0;
    if (e.name === "exponential") o = zp(t3, e.base, i, n);
    else if (e.name === "linear") o = zp(t3, 1, i, n);
    else if (e.name === "cubic-bezier") {
      let a = e.controlPoints;
      o = new BP(a[0], a[1], a[2], a[3]).solve(zp(t3, 1, i, n));
    }
    return o;
  }
  static parse(e, t3) {
    let [i, n, o, ...a] = e;
    if (!Array.isArray(n) || n.length === 0) return t3.error("Expected an interpolation type expression.", 1);
    if (n[0] === "linear") n = { name: "linear" };
    else if (n[0] === "exponential") {
      let c = n[1];
      if (typeof c != "number") return t3.error("Exponential interpolation requires a numeric base.", 1, 1);
      n = { name: "exponential", base: c };
    } else if (n[0] === "cubic-bezier") {
      let c = n.slice(1);
      if (c.length !== 4 || c.some((p) => typeof p != "number" || p < 0 || p > 1)) return t3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      n = { name: "cubic-bezier", controlPoints: c };
    } else return t3.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
    if (e.length - 1 < 4) return t3.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0) return t3.error("Expected an even number of arguments.");
    if (o = t3.parse(o, 2, q3), !o) return null;
    let s3 = [], l = null;
    i === "interpolate-hcl" || i === "interpolate-lab" ? l = Ct : t3.expectedType && t3.expectedType.kind !== "value" && (l = t3.expectedType);
    for (let c = 0; c < a.length; c += 2) {
      let p = a[c], h = a[c + 1], f = c + 3, m = c + 4;
      if (typeof p != "number") return t3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
      if (s3.length && s3[s3.length - 1][0] >= p) return t3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f);
      let y = t3.parse(h, m, l);
      if (!y) return null;
      l = l || y.type, s3.push([p, y]);
    }
    return !Dn(l, q3) && !Dn(l, Ct) && !Dn(l, Ws) && !Dn(l, Xs) && !Dn(l, _t(q3)) ? t3.error(`Type ${Re(l)} is not interpolatable.`) : new Nn2(l, i, n, o, s3);
  }
  evaluate(e) {
    let t3 = this.labels, i = this.outputs;
    if (t3.length === 1) return i[0].evaluate(e);
    let n = this.input.evaluate(e);
    if (n <= t3[0]) return i[0].evaluate(e);
    let o = t3.length;
    if (n >= t3[o - 1]) return i[o - 1].evaluate(e);
    let a = Ks(t3, n), s3 = t3[a], l = t3[a + 1], c = Nn2.interpolationFactor(this.interpolation, n, s3, l), p = i[a].evaluate(e), h = i[a + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        return Pe[this.type.kind](p, h, c);
      case "interpolate-hcl":
        return Pe.color(p, h, c, "hcl");
      case "interpolate-lab":
        return Pe.color(p, h, c, "lab");
    }
  }
  eachChild(e) {
    e(this.input);
    for (let t3 of this.outputs) e(t3);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
r(Nn, "Interpolate");
var vt = Nn;
function zp(r3, e, t3, i) {
  let n = i - t3, o = r3 - t3;
  return n === 0 ? 0 : e === 1 ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
}
r(zp, "exponentialInterpolation");
var Gn = class Gn2 {
  constructor(e, t3) {
    this.type = e, this.args = t3;
  }
  static parse(e, t3) {
    if (e.length < 2) return t3.error("Expectected at least one argument.");
    let i = null, n = t3.expectedType;
    n && n.kind !== "value" && (i = n);
    let o = [];
    for (let s3 of e.slice(1)) {
      let l = t3.parse(s3, 1 + o.length, i, void 0, { typeAnnotation: "omit" });
      if (!l) return null;
      i = i || l.type, o.push(l);
    }
    if (!i) throw new Error("No output type");
    return n && o.some((s3) => $n(n, s3.type)) ? new Gn2(le, o) : new Gn2(i, o);
  }
  evaluate(e) {
    let t3 = null, i = 0, n;
    for (let o of this.args) if (i++, t3 = o.evaluate(e), t3 && t3 instanceof ft && !t3.available && (n || (n = t3.name), t3 = null, i === this.args.length && (t3 = n)), t3 !== null) break;
    return t3;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
r(Gn, "Coalesce");
var _s = Gn;
function xb(r3, e) {
  return r3 === "==" || r3 === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
r(xb, "isComparableType");
function GP(r3, e, t3) {
  return e === t3;
}
r(GP, "eq");
function $P(r3, e, t3) {
  return e !== t3;
}
r($P, "neq");
function qP(r3, e, t3) {
  return e < t3;
}
r(qP, "lt");
function jP(r3, e, t3) {
  return e > t3;
}
r(jP, "gt");
function ZP(r3, e, t3) {
  return e <= t3;
}
r(ZP, "lteq");
function HP(r3, e, t3) {
  return e >= t3;
}
r(HP, "gteq");
function Wb(r3, e, t3, i) {
  return i.compare(e, t3) === 0;
}
r(Wb, "eqCollate");
function WP(r3, e, t3, i) {
  return !Wb(r3, e, t3, i);
}
r(WP, "neqCollate");
function XP(r3, e, t3, i) {
  return i.compare(e, t3) < 0;
}
r(XP, "ltCollate");
function KP(r3, e, t3, i) {
  return i.compare(e, t3) > 0;
}
r(KP, "gtCollate");
function JP(r3, e, t3, i) {
  return i.compare(e, t3) <= 0;
}
r(JP, "lteqCollate");
function YP(r3, e, t3, i) {
  return i.compare(e, t3) >= 0;
}
r(YP, "gteqCollate");
function $i(r3, e, t3) {
  var n;
  let i = r3 !== "==" && r3 !== "!=";
  return n = class {
    constructor(a, s3, l) {
      this.type = se, this.lhs = a, this.rhs = s3, this.collator = l, this.hasUntypedArgument = a.type.kind === "value" || s3.type.kind === "value";
    }
    static parse(a, s3) {
      if (a.length !== 3 && a.length !== 4) return s3.error("Expected two or three arguments.");
      let l = a[0], c = s3.parse(a[1], 1, le);
      if (!c) return null;
      if (!xb(l, c.type)) return s3.concat(1).error(`"${l}" comparisons are not supported for type '${Re(c.type)}'.`);
      let p = s3.parse(a[2], 2, le);
      if (!p) return null;
      if (!xb(l, p.type)) return s3.concat(2).error(`"${l}" comparisons are not supported for type '${Re(p.type)}'.`);
      if (c.type.kind !== p.type.kind && c.type.kind !== "value" && p.type.kind !== "value") return s3.error(`Cannot compare types '${Re(c.type)}' and '${Re(p.type)}'.`);
      i && (c.type.kind === "value" && p.type.kind !== "value" ? c = new Ft(p.type, [c]) : c.type.kind !== "value" && p.type.kind === "value" && (p = new Ft(c.type, [p])));
      let h = null;
      if (a.length === 4) {
        if (c.type.kind !== "string" && p.type.kind !== "string" && c.type.kind !== "value" && p.type.kind !== "value") return s3.error("Cannot use collator to compare non-string types.");
        if (h = s3.parse(a[3], 3, Hs), !h) return null;
      }
      return new n(c, p, h);
    }
    evaluate(a) {
      let s3 = this.lhs.evaluate(a), l = this.rhs.evaluate(a);
      if (i && this.hasUntypedArgument) {
        let c = Ze(s3), p = Ze(l);
        if (c.kind !== p.kind || !(c.kind === "string" || c.kind === "number")) throw new Be(`Expected arguments for "${r3}" to be (string, string) or (number, number), but found (${c.kind}, ${p.kind}) instead.`);
      }
      if (this.collator && !i && this.hasUntypedArgument) {
        let c = Ze(s3), p = Ze(l);
        if (c.kind !== "string" || p.kind !== "string") return e(a, s3, l);
      }
      return this.collator ? t3(a, s3, l, this.collator.evaluate(a)) : e(a, s3, l);
    }
    eachChild(a) {
      a(this.lhs), a(this.rhs), this.collator && a(this.collator);
    }
    outputDefined() {
      return true;
    }
  }, r(n, "Comparison"), n;
}
r($i, "makeComparison");
var QP = $i("==", GP, Wb);
var eT = $i("!=", $P, WP);
var tT = $i("<", qP, XP);
var rT = $i(">", jP, KP);
var iT = $i("<=", ZP, JP);
var nT = $i(">=", HP, YP);
var Ns = class Ns2 {
  constructor(e, t3, i) {
    this.type = Hs, this.locale = i, this.caseSensitive = e, this.diacriticSensitive = t3;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error("Expected one argument.");
    let i = e[1];
    if (typeof i != "object" || Array.isArray(i)) return t3.error("Collator options argument must be an object.");
    let n = t3.parse(i["case-sensitive"] === void 0 ? false : i["case-sensitive"], 1, se);
    if (!n) return null;
    let o = t3.parse(i["diacritic-sensitive"] === void 0 ? false : i["diacritic-sensitive"], 1, se);
    if (!o) return null;
    let a = null;
    return i.locale && (a = t3.parse(i.locale, 1, pe), !a) ? null : new Ns2(n, o, a);
  }
  evaluate(e) {
    return new jn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
};
r(Ns, "CollatorExpression");
var vs = Ns;
var Gs = class Gs2 {
  constructor(e, t3, i, n, o) {
    this.type = pe, this.number = e, this.locale = t3, this.currency = i, this.minFractionDigits = n, this.maxFractionDigits = o;
  }
  static parse(e, t3) {
    if (e.length !== 3) return t3.error("Expected two arguments.");
    let i = t3.parse(e[1], 1, q3);
    if (!i) return null;
    let n = e[2];
    if (typeof n != "object" || Array.isArray(n)) return t3.error("NumberFormat options argument must be an object.");
    let o = null;
    if (n.locale && (o = t3.parse(n.locale, 1, pe), !o)) return null;
    let a = null;
    if (n.currency && (a = t3.parse(n.currency, 1, pe), !a)) return null;
    let s3 = null;
    if (n["min-fraction-digits"] && (s3 = t3.parse(n["min-fraction-digits"], 1, q3), !s3)) return null;
    let l = null;
    return n["max-fraction-digits"] && (l = t3.parse(n["max-fraction-digits"], 1, q3), !l) ? null : new Gs2(i, o, a, s3, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
r(Gs, "NumberFormat");
var jp = Gs;
var $s = class $s2 {
  constructor(e) {
    this.type = Gi, this.sections = e;
  }
  static parse(e, t3) {
    if (e.length < 2) return t3.error("Expected at least one argument.");
    let i = e[1];
    if (!Array.isArray(i) && typeof i == "object") return t3.error("First argument must be an image or text section.");
    let n = [], o = false;
    for (let a = 1; a <= e.length - 1; ++a) {
      let s3 = e[a];
      if (o && typeof s3 == "object" && !Array.isArray(s3)) {
        o = false;
        let l = null;
        if (s3["font-scale"] && (l = t3.parse(s3["font-scale"], 1, q3), !l)) return null;
        let c = null;
        if (s3["text-font"] && (c = t3.parse(s3["text-font"], 1, _t(pe)), !c)) return null;
        let p = null;
        if (s3["text-color"] && (p = t3.parse(s3["text-color"], 1, Ct), !p)) return null;
        let h = n[n.length - 1];
        h.scale = l, h.font = c, h.textColor = p;
      } else {
        let l = t3.parse(e[a], 1, le);
        if (!l) return null;
        let c = l.type.kind;
        if (c !== "string" && c !== "value" && c !== "null" && c !== "resolvedImage") return t3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = true, n.push({ content: l, scale: null, font: null, textColor: null });
      }
    }
    return new $s2(n);
  }
  evaluate(e) {
    let t3 = r((i) => {
      let n = i.content.evaluate(e);
      return Ze(n) === ro ? new Zn("", n, null, null, null) : new Zn(Fn(n), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null);
    }, "evaluateSection");
    return new wt(this.sections.map(t3));
  }
  eachChild(e) {
    for (let t3 of this.sections) e(t3.content), t3.scale && e(t3.scale), t3.font && e(t3.font), t3.textColor && e(t3.textColor);
  }
  outputDefined() {
    return false;
  }
};
r($s, "FormatExpression");
var Wn = $s;
var qs = class qs2 {
  constructor(e) {
    this.type = ro, this.input = e;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error("Expected two arguments.");
    let i = t3.parse(e[1], 1, pe);
    return i ? new qs2(i) : t3.error("No image name provided.");
  }
  evaluate(e) {
    let t3 = this.input.evaluate(e), i = ft.fromString(t3);
    return i && e.availableImages && (i.available = e.availableImages.indexOf(t3) > -1), i;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
r(qs, "ImageExpression");
var Zp = qs;
var js = class js2 {
  constructor(e) {
    this.type = q3, this.input = e;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    let i = t3.parse(e[1], 1);
    return i ? i.type.kind !== "array" && i.type.kind !== "string" && i.type.kind !== "value" ? t3.error(`Expected argument of type string or array, but found ${Re(i.type)} instead.`) : new js2(i) : null;
  }
  evaluate(e) {
    let t3 = this.input.evaluate(e);
    if (typeof t3 == "string") return t3.length;
    if (Array.isArray(t3)) return t3.length;
    throw new Be(`Expected value to be of type string or array, but found ${Re(Ze(t3))} instead.`);
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
r(js, "Length");
var Hp = js;
var Vt = 8192;
function oT(r3, e) {
  let t3 = aT(r3[0]), i = lT(r3[1]), n = Math.pow(2, e.z);
  return [Math.round(t3 * n * Vt), Math.round(i * n * Vt)];
}
r(oT, "getTileCoordinates");
function rh(r3, e) {
  let t3 = Math.pow(2, e.z), i = (r3[0] / Vt + e.x) / t3, n = (r3[1] / Vt + e.y) / t3;
  return [sT(i), uT(n)];
}
r(rh, "getLngLatFromTileCoord");
function aT(r3) {
  return (180 + r3) / 360;
}
r(aT, "mercatorXfromLng");
function sT(r3) {
  return r3 * 360 - 180;
}
r(sT, "lngFromMercatorXfromLng");
function lT(r3) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r3 * Math.PI / 360))) / 360;
}
r(lT, "mercatorYfromLat");
function uT(r3) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - r3 * 360) * Math.PI / 180)) - 90;
}
r(uT, "latFromMercatorY");
function io(r3, e) {
  r3[0] = Math.min(r3[0], e[0]), r3[1] = Math.min(r3[1], e[1]), r3[2] = Math.max(r3[2], e[0]), r3[3] = Math.max(r3[3], e[1]);
}
r(io, "updateBBox");
function Xn(r3, e) {
  return !(r3[0] <= e[0] || r3[2] >= e[2] || r3[1] <= e[1] || r3[3] >= e[3]);
}
r(Xn, "boxWithinBox");
function cT(r3, e, t3) {
  return e[1] > r3[1] != t3[1] > r3[1] && r3[0] < (t3[0] - e[0]) * (r3[1] - e[1]) / (t3[1] - e[1]) + e[0];
}
r(cT, "rayIntersect");
function pT(r3, e, t3) {
  let i = r3[0] - e[0], n = r3[1] - e[1], o = r3[0] - t3[0], a = r3[1] - t3[1];
  return i * a - o * n === 0 && i * o <= 0 && n * a <= 0;
}
r(pT, "pointOnBoundary");
function Js(r3, e, t3, i) {
  let n = [e[0] - r3[0], e[1] - r3[1]], o = [i[0] - t3[0], i[1] - t3[1]];
  return dT(o, n) === 0 ? false : !!(bb(r3, e, t3, i) && bb(t3, i, r3, e));
}
r(Js, "segmentIntersectSegment");
function hT(r3, e, t3) {
  for (let i of t3) for (let n = 0; n < i.length - 1; ++n) if (Js(r3, e, i[n], i[n + 1])) return true;
  return false;
}
r(hT, "lineIntersectPolygon");
function qi(r3, e, t3 = false) {
  let i = false;
  for (let n of e) for (let o = 0; o < n.length - 1; o++) {
    if (pT(r3, n[o], n[o + 1])) return t3;
    cT(r3, n[o], n[o + 1]) && (i = !i);
  }
  return i;
}
r(qi, "pointWithinPolygon");
function fT(r3, e) {
  for (let t3 of e) if (qi(r3, t3)) return true;
  return false;
}
r(fT, "pointWithinPolygons");
function Xb(r3, e) {
  for (let t3 of r3) if (!qi(t3, e)) return false;
  for (let t3 = 0; t3 < r3.length - 1; ++t3) if (hT(r3[t3], r3[t3 + 1], e)) return false;
  return true;
}
r(Xb, "lineStringWithinPolygon");
function mT(r3, e) {
  for (let t3 of e) if (Xb(r3, t3)) return true;
  return false;
}
r(mT, "lineStringWithinPolygons");
function dT(r3, e) {
  return r3[0] * e[1] - r3[1] * e[0];
}
r(dT, "perp");
function bb(r3, e, t3, i) {
  let n = r3[0] - t3[0], o = r3[1] - t3[1], a = e[0] - t3[0], s3 = e[1] - t3[1], l = i[0] - t3[0], c = i[1] - t3[1], p = n * c - l * o, h = a * c - l * s3;
  return p > 0 && h < 0 || p < 0 && h > 0;
}
r(bb, "twoSided");
function ih(r3, e, t3) {
  let i = [];
  for (let n = 0; n < r3.length; n++) {
    let o = [];
    for (let a = 0; a < r3[n].length; a++) {
      let s3 = oT(r3[n][a], t3);
      io(e, s3), o.push(s3);
    }
    i.push(o);
  }
  return i;
}
r(ih, "getTilePolygon");
function Kb(r3, e, t3) {
  let i = [];
  for (let n = 0; n < r3.length; n++) {
    let o = ih(r3[n], e, t3);
    i.push(o);
  }
  return i;
}
r(Kb, "getTilePolygons");
function Jb(r3, e, t3, i) {
  if (r3[0] < t3[0] || r3[0] > t3[2]) {
    let n = i * 0.5, o = r3[0] - t3[0] > n ? -i : t3[0] - r3[0] > n ? i : 0;
    o === 0 && (o = r3[0] - t3[2] > n ? -i : t3[2] - r3[0] > n ? i : 0), r3[0] += o;
  }
  io(e, r3);
}
r(Jb, "updatePoint");
function yT(r3) {
  r3[0] = r3[1] = 1 / 0, r3[2] = r3[3] = -1 / 0;
}
r(yT, "resetBBox");
function _b(r3, e, t3, i) {
  let n = Math.pow(2, i.z) * Vt, o = [i.x * Vt, i.y * Vt], a = [];
  for (let s3 of r3) for (let l of s3) {
    let c = [l.x + o[0], l.y + o[1]];
    Jb(c, e, t3, n), a.push(c);
  }
  return a;
}
r(_b, "getTilePoints");
function vb(r3, e, t3, i) {
  let n = Math.pow(2, i.z) * Vt, o = [i.x * Vt, i.y * Vt], a = [];
  for (let s3 of r3) {
    let l = [];
    for (let c of s3) {
      let p = [c.x + o[0], c.y + o[1]];
      io(e, p), l.push(p);
    }
    a.push(l);
  }
  if (e[2] - e[0] <= n / 2) {
    yT(e);
    for (let s3 of a) for (let l of s3) Jb(l, e, t3, n);
  }
  return a;
}
r(vb, "getTileLines");
function gT(r3, e) {
  let t3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = r3.canonicalID();
  if (e.type === "Polygon") {
    let o = ih(e.coordinates, i, n), a = _b(r3.geometry(), t3, i, n);
    if (!Xn(t3, i)) return false;
    for (let s3 of a) if (!qi(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = Kb(e.coordinates, i, n), a = _b(r3.geometry(), t3, i, n);
    if (!Xn(t3, i)) return false;
    for (let s3 of a) if (!fT(s3, o)) return false;
  }
  return true;
}
r(gT, "pointsWithinPolygons");
function xT(r3, e) {
  let t3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = r3.canonicalID();
  if (e.type === "Polygon") {
    let o = ih(e.coordinates, i, n), a = vb(r3.geometry(), t3, i, n);
    if (!Xn(t3, i)) return false;
    for (let s3 of a) if (!Xb(s3, o)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o = Kb(e.coordinates, i, n), a = vb(r3.geometry(), t3, i, n);
    if (!Xn(t3, i)) return false;
    for (let s3 of a) if (!mT(s3, o)) return false;
  }
  return true;
}
r(xT, "linesWithinPolygons");
var zi = class zi2 {
  constructor(e, t3) {
    this.type = se, this.geojson = e, this.geometries = t3;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (Hn(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") {
        let n = [];
        for (let o of i.features) {
          let { type: a, coordinates: s3 } = o.geometry;
          a === "Polygon" && n.push(s3), a === "MultiPolygon" && n.push(...s3);
        }
        if (n.length) {
          let o = { type: "MultiPolygon", coordinates: n };
          return new zi2(i, o);
        }
      } else if (i.type === "Feature") {
        let n = i.geometry.type;
        if (n === "Polygon" || n === "MultiPolygon") return new zi2(i, i.geometry);
      } else if (i.type === "Polygon" || i.type === "MultiPolygon") return new zi2(i, i);
    }
    return t3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return gT(e, this.geometries);
      if (e.geometryType() === "LineString") return xT(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
r(zi, "Within");
var Kn = zi;
var xh = class xh2 {
  constructor(e = [], t3 = bT) {
    if (this.data = e, this.length = this.data.length, this.compare = t3, this.length > 0) for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
  }
  push(e) {
    this.data.push(e), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    let e = this.data[0], t3 = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = t3, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    let { data: t3, compare: i } = this, n = t3[e];
    for (; e > 0; ) {
      let o = e - 1 >> 1, a = t3[o];
      if (i(n, a) >= 0) break;
      t3[e] = a, e = o;
    }
    t3[e] = n;
  }
  _down(e) {
    let { data: t3, compare: i } = this, n = this.length >> 1, o = t3[e];
    for (; e < n; ) {
      let a = (e << 1) + 1, s3 = t3[a], l = a + 1;
      if (l < this.length && i(t3[l], s3) < 0 && (a = l, s3 = t3[l]), i(s3, o) >= 0) break;
      t3[e] = s3, e = a;
    }
    t3[e] = o;
  }
};
r(xh, "TinyQueue");
var ws = xh;
function bT(r3, e) {
  return r3 < e ? -1 : r3 > e ? 1 : 0;
}
r(bT, "defaultCompare$1");
function _T(r3, e, t3, i, n) {
  Yb(r3, e, t3, i || r3.length - 1, n || vT);
}
r(_T, "quickselect");
function Yb(r3, e, t3, i, n) {
  for (; i > t3; ) {
    if (i - t3 > 600) {
      var o = i - t3 + 1, a = e - t3 + 1, s3 = Math.log(o), l = 0.5 * Math.exp(2 * s3 / 3), c = 0.5 * Math.sqrt(s3 * l * (o - l) / o) * (a - o / 2 < 0 ? -1 : 1), p = Math.max(t3, Math.floor(e - a * l / o + c)), h = Math.min(i, Math.floor(e + (o - a) * l / o + c));
      Yb(r3, e, p, h, n);
    }
    var f = r3[e], m = t3, y = i;
    for (zn(r3, t3, e), n(r3[i], f) > 0 && zn(r3, t3, i); m < y; ) {
      for (zn(r3, m, y), m++, y--; n(r3[m], f) < 0; ) m++;
      for (; n(r3[y], f) > 0; ) y--;
    }
    n(r3[t3], f) === 0 ? zn(r3, t3, y) : (y++, zn(r3, y, i)), y <= e && (t3 = y + 1), e <= y && (i = y - 1);
  }
}
r(Yb, "quickselectStep");
function zn(r3, e, t3) {
  var i = r3[e];
  r3[e] = r3[t3], r3[t3] = i;
}
r(zn, "swap");
function vT(r3, e) {
  return r3 < e ? -1 : r3 > e ? 1 : 0;
}
r(vT, "defaultCompare");
function wT(r3, e) {
  if (r3.length <= 1) return [r3];
  let i = [], n, o;
  for (let a of r3) {
    let s3 = PT(a);
    s3 !== 0 && (a.area = Math.abs(s3), o === void 0 && (o = s3 < 0), o === s3 < 0 ? (n && i.push(n), n = [a]) : n.push(a));
  }
  if (n && i.push(n), e > 1) for (let a = 0; a < i.length; a++) i[a].length <= e || (_T(i[a], e, 1, i[a].length - 1, ST), i[a] = i[a].slice(0, e));
  return i;
}
r(wT, "classifyRings");
function ST(r3, e) {
  return e.area - r3.area;
}
r(ST, "compareAreas");
function PT(r3) {
  let e = 0;
  for (let t3 = 0, i = r3.length, n = i - 1, o, a; t3 < i; n = t3++) o = r3[t3], a = r3[n], e += (a.x - o.x) * (o.y + a.y);
  return e;
}
r(PT, "calculateSignedArea");
var TT = 6378.137;
var wb = 1 / 298.257223563;
var Sb = wb * (2 - wb);
var Pb = Math.PI / 180;
var bh = class bh2 {
  constructor(e) {
    let t3 = Pb * TT * 1e3, i = Math.cos(e * Pb), n = 1 / (1 - Sb * (1 - i * i)), o = Math.sqrt(n);
    this.kx = t3 * o * i, this.ky = t3 * o * n * (1 - Sb);
  }
  distance(e, t3) {
    let i = this.wrap(e[0] - t3[0]) * this.kx, n = (e[1] - t3[1]) * this.ky;
    return Math.sqrt(i * i + n * n);
  }
  pointOnLine(e, t3) {
    let i = 1 / 0, n, o, a, s3;
    for (let l = 0; l < e.length - 1; l++) {
      let c = e[l][0], p = e[l][1], h = this.wrap(e[l + 1][0] - c) * this.kx, f = (e[l + 1][1] - p) * this.ky, m = 0;
      (h !== 0 || f !== 0) && (m = (this.wrap(t3[0] - c) * this.kx * h + (t3[1] - p) * this.ky * f) / (h * h + f * f), m > 1 ? (c = e[l + 1][0], p = e[l + 1][1]) : m > 0 && (c += h / this.kx * m, p += f / this.ky * m)), h = this.wrap(t3[0] - c) * this.kx, f = (t3[1] - p) * this.ky;
      let y = h * h + f * f;
      y < i && (i = y, n = c, o = p, a = l, s3 = m);
    }
    return { point: [n, o], index: a, t: Math.max(0, Math.min(1, s3)) };
  }
  wrap(e) {
    for (; e < -180; ) e += 360;
    for (; e > 180; ) e -= 360;
    return e;
  }
};
r(bh, "CheapRuler");
var Jn = bh;
var Wp = 100;
var Xp = 50;
function Qb(r3, e) {
  return e[0] - r3[0];
}
r(Qb, "compareDistPair");
function Ss(r3) {
  return r3[1] - r3[0] + 1;
}
r(Ss, "getRangeSize");
function ir(r3, e) {
  return r3[1] >= r3[0] && r3[1] < e;
}
r(ir, "isRangeSafe");
function Kp(r3, e) {
  if (r3[0] > r3[1]) return [null, null];
  let t3 = Ss(r3);
  if (e) {
    if (t3 === 2) return [r3, null];
    let n = Math.floor(t3 / 2);
    return [[r3[0], r3[0] + n], [r3[0] + n, r3[1]]];
  }
  if (t3 === 1) return [r3, null];
  let i = Math.floor(t3 / 2) - 1;
  return [[r3[0], r3[0] + i], [r3[0] + i + 1, r3[1]]];
}
r(Kp, "splitRange");
function Jp(r3, e) {
  if (!ir(e, r3.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  let t3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let i = e[0]; i <= e[1]; ++i) io(t3, r3[i]);
  return t3;
}
r(Jp, "getBBox");
function Yp(r3) {
  let e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let t3 of r3) for (let i of t3) io(e, i);
  return e;
}
r(Yp, "getPolygonBBox");
function Tb(r3) {
  return r3[0] !== -1 / 0 && r3[1] !== -1 / 0 && r3[2] !== 1 / 0 && r3[3] !== 1 / 0;
}
r(Tb, "isValidBBox");
function nh(r3, e, t3) {
  if (!Tb(r3) || !Tb(e)) return NaN;
  let i = 0, n = 0;
  return r3[2] < e[0] && (i = e[0] - r3[2]), r3[0] > e[2] && (i = r3[0] - e[2]), r3[1] > e[3] && (n = r3[1] - e[3]), r3[3] < e[1] && (n = e[1] - r3[3]), t3.distance([0, 0], [i, n]);
}
r(nh, "bboxToBBoxDistance");
function Xr(r3, e, t3) {
  let i = t3.pointOnLine(e, r3);
  return t3.distance(r3, i.point);
}
r(Xr, "pointToLineDistance");
function oh(r3, e, t3, i, n) {
  let o = Math.min(Xr(r3, [t3, i], n), Xr(e, [t3, i], n)), a = Math.min(Xr(t3, [r3, e], n), Xr(i, [r3, e], n));
  return Math.min(o, a);
}
r(oh, "segmentToSegmentDistance");
function MT(r3, e, t3, i, n) {
  if (!(ir(e, r3.length) && ir(i, t3.length))) return 1 / 0;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 < e[1]; ++s3) {
    let l = r3[s3], c = r3[s3 + 1];
    for (let p = i[0]; p < i[1]; ++p) {
      let h = t3[p], f = t3[p + 1];
      if (Js(l, c, h, f)) return 0;
      a = Math.min(a, oh(l, c, h, f, n));
    }
  }
  return a;
}
r(MT, "lineToLineDistance");
function AT(r3, e, t3, i, n) {
  if (!(ir(e, r3.length) && ir(i, t3.length))) return NaN;
  let a = 1 / 0;
  for (let s3 = e[0]; s3 <= e[1]; ++s3) for (let l = i[0]; l <= i[1]; ++l) if (a = Math.min(a, n.distance(r3[s3], t3[l])), a === 0) return a;
  return a;
}
r(AT, "pointsToPointsDistance");
function IT(r3, e, t3) {
  if (qi(r3, e, true)) return 0;
  let i = 1 / 0;
  for (let n of e) {
    let o = n[0], a = n[n.length - 1];
    if (o !== a && (i = Math.min(i, Xr(r3, [a, o], t3)), i === 0)) return i;
    let s3 = t3.pointOnLine(n, r3);
    if (i = Math.min(i, t3.distance(r3, s3.point)), i === 0) return i;
  }
  return i;
}
r(IT, "pointToPolygonDistance");
function CT(r3, e, t3, i) {
  if (!ir(e, r3.length)) return NaN;
  for (let o = e[0]; o <= e[1]; ++o) if (qi(r3[o], t3, true)) return 0;
  let n = 1 / 0;
  for (let o = e[0]; o < e[1]; ++o) {
    let a = r3[o], s3 = r3[o + 1];
    for (let l of t3) for (let c = 0, p = l.length, h = p - 1; c < p; h = c++) {
      let f = l[h], m = l[c];
      if (Js(a, s3, f, m)) return 0;
      n = Math.min(n, oh(a, s3, f, m, i));
    }
  }
  return n;
}
r(CT, "lineToPolygonDistance");
function Mb(r3, e) {
  for (let t3 of r3) for (let i of t3) if (qi(i, e, true)) return true;
  return false;
}
r(Mb, "polygonIntersect");
function ET(r3, e, t3, i = 1 / 0) {
  let n = Yp(r3), o = Yp(e);
  if (i !== 1 / 0 && nh(n, o, t3) >= i) return i;
  if (Xn(n, o)) {
    if (Mb(r3, e)) return 0;
  } else if (Mb(e, r3)) return 0;
  let a = 1 / 0;
  for (let s3 of r3) for (let l = 0, c = s3.length, p = c - 1; l < c; p = l++) {
    let h = s3[p], f = s3[l];
    for (let m of e) for (let y = 0, g = m.length, x = g - 1; y < g; x = y++) {
      let b = m[x], w = m[y];
      if (Js(h, f, b, w)) return 0;
      a = Math.min(a, oh(h, f, b, w, t3));
    }
  }
  return a;
}
r(ET, "polygonToPolygonDistance");
function Ab(r3, e, t3, i, n, o) {
  if (!o) return;
  let a = nh(Jp(i, o), n, t3);
  a < e && r3.push([a, o, [0, 0]]);
}
r(Ab, "updateQueue");
function hs(r3, e, t3, i, n, o, a) {
  if (!o || !a) return;
  let s3 = nh(Jp(i, o), Jp(n, a), t3);
  s3 < e && r3.push([s3, o, a]);
}
r(hs, "updateQueueTwoSets");
function Ps(r3, e, t3, i, n = 1 / 0) {
  let o = Math.min(i.distance(r3[0], t3[0][0]), n);
  if (o === 0) return o;
  let a = new ws([[0, [0, r3.length - 1], [0, 0]]], Qb), s3 = Yp(t3);
  for (; a.length > 0; ) {
    let l = a.pop();
    if (l[0] >= o) continue;
    let c = l[1], p = e ? Xp : Wp;
    if (Ss(c) <= p) {
      if (!ir(c, r3.length)) return NaN;
      if (e) {
        let h = CT(r3, c, t3, i);
        if (isNaN(h) || h === 0) return h;
        o = Math.min(o, h);
      } else for (let h = c[0]; h <= c[1]; ++h) {
        let f = IT(r3[h], t3, i);
        if (o = Math.min(o, f), o === 0) return 0;
      }
    } else {
      let h = Kp(c, e);
      Ab(a, o, i, r3, s3, h[0]), Ab(a, o, i, r3, s3, h[1]);
    }
  }
  return o;
}
r(Ps, "pointsToPolygonDistance");
function Ts(r3, e, t3, i, n, o = 1 / 0) {
  let a = Math.min(o, n.distance(r3[0], t3[0]));
  if (a === 0) return a;
  let s3 = new ws([[0, [0, r3.length - 1], [0, t3.length - 1]]], Qb);
  for (; s3.length > 0; ) {
    let l = s3.pop();
    if (l[0] >= a) continue;
    let c = l[1], p = l[2], h = e ? Xp : Wp, f = i ? Xp : Wp;
    if (Ss(c) <= h && Ss(p) <= f) {
      if (!ir(c, r3.length) && ir(p, t3.length)) return NaN;
      let m;
      if (e && i) m = MT(r3, c, t3, p, n), a = Math.min(a, m);
      else if (e && !i) {
        let y = r3.slice(c[0], c[1] + 1);
        for (let g = p[0]; g <= p[1]; ++g) if (m = Xr(t3[g], y, n), a = Math.min(a, m), a === 0) return a;
      } else if (!e && i) {
        let y = t3.slice(p[0], p[1] + 1);
        for (let g = c[0]; g <= c[1]; ++g) if (m = Xr(r3[g], y, n), a = Math.min(a, m), a === 0) return a;
      } else m = AT(r3, c, t3, p, n), a = Math.min(a, m);
    } else {
      let m = Kp(c, e), y = Kp(p, i);
      hs(s3, a, n, r3, t3, m[0], y[0]), hs(s3, a, n, r3, t3, m[0], y[1]), hs(s3, a, n, r3, t3, m[1], y[0]), hs(s3, a, n, r3, t3, m[1], y[1]);
    }
  }
  return a;
}
r(Ts, "pointSetToPointSetDistance");
function kT(r3, e) {
  let t3 = r3.geometry(), i = t3.flat().map((a) => rh([a.x, a.y], r3.canonical));
  if (t3.length === 0) return NaN;
  let n = new Jn(i[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Ts(i, false, [a.coordinates], false, n, o));
        break;
      case "LineString":
        o = Math.min(o, Ts(i, false, a.coordinates, true, n, o));
        break;
      case "Polygon":
        o = Math.min(o, Ps(i, false, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
r(kT, "pointToGeometryDistance");
function LT(r3, e) {
  let t3 = r3.geometry(), i = t3.flat().map((a) => rh([a.x, a.y], r3.canonical));
  if (t3.length === 0) return NaN;
  let n = new Jn(i[0][1]), o = 1 / 0;
  for (let a of e) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Ts(i, true, [a.coordinates], false, n, o));
        break;
      case "LineString":
        o = Math.min(o, Ts(i, true, a.coordinates, true, n, o));
        break;
      case "Polygon":
        o = Math.min(o, Ps(i, true, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
r(LT, "lineStringToGeometryDistance");
function DT(r3, e) {
  let t3 = r3.geometry();
  if (t3.length === 0 || t3[0].length === 0) return NaN;
  let i = wT(t3, 0).map((a) => a.map((s3) => s3.map((l) => rh([l.x, l.y], r3.canonical)))), n = new Jn(i[0][0][0][1]), o = 1 / 0;
  for (let a of e) for (let s3 of i) {
    switch (a.type) {
      case "Point":
        o = Math.min(o, Ps([a.coordinates], false, s3, n, o));
        break;
      case "LineString":
        o = Math.min(o, Ps(a.coordinates, true, s3, n, o));
        break;
      case "Polygon":
        o = Math.min(o, ET(s3, a.coordinates, n, o));
        break;
    }
    if (o === 0) return o;
  }
  return o;
}
r(DT, "polygonToGeometryDistance");
function Fp(r3) {
  return r3.type === "MultiPolygon" ? r3.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : r3.type === "MultiLineString" ? r3.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : r3.type === "MultiPoint" ? r3.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [r3];
}
r(Fp, "toSimpleGeometry");
var Fi = class Fi2 {
  constructor(e, t3) {
    this.type = q3, this.geojson = e, this.geometries = t3;
  }
  static parse(e, t3) {
    if (e.length !== 2) return t3.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (Hn(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") return new Fi2(i, i.features.map((n) => Fp(n.geometry)).flat());
      if (i.type === "Feature") return new Fi2(i, Fp(i.geometry));
      if ("type" in i && "coordinates" in i) return new Fi2(i, Fp(i));
    }
    return t3.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return kT(e, this.geometries);
      if (e.geometryType() === "LineString") return LT(e, this.geometries);
      if (e.geometryType() === "Polygon") return DT(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
r(Fi, "Distance");
var Yn = Fi;
var ei = { "==": QP, "!=": eT, ">": rT, "<": tT, ">=": nT, "<=": iT, array: Ft, at: Vp, boolean: Ft, case: $p, coalesce: _s, collator: vs, format: Wn, image: Zp, in: Up, "index-of": Np, interpolate: vt, "interpolate-hcl": vt, "interpolate-lab": vt, length: Hp, let: gs, literal: xr, match: Gp, number: Ft, "number-format": jp, object: Ft, slice: qp, step: Vi, string: Ft, "to-boolean": gr, "to-color": gr, "to-number": gr, "to-string": gr, var: xs, within: Kn, distance: Yn };
var Wr = class Wr2 {
  constructor(e, t3, i, n) {
    this.name = e, this.type = t3, this._evaluate = i, this.args = n;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  static parse(e, t3) {
    let i = e[0], n = Wr2.definitions[i];
    if (!n) return t3.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0);
    let o = Array.isArray(n) ? n[0] : n.type, a = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, s3 = a.filter(([c]) => !Array.isArray(c) || c.length === e.length - 1), l = null;
    for (let [c, p] of s3) {
      l = new ys(t3.registry, Ms, t3.path, null, t3.scope);
      let h = [], f = false;
      for (let m = 1; m < e.length; m++) {
        let y = e[m], g = Array.isArray(c) ? c[m - 1] : c.type, x = l.parse(y, 1 + h.length, g);
        if (!x) {
          f = true;
          break;
        }
        h.push(x);
      }
      if (!f) {
        if (Array.isArray(c) && c.length !== h.length) {
          l.error(`Expected ${c.length} arguments, but found ${h.length} instead.`);
          continue;
        }
        for (let m = 0; m < h.length; m++) {
          let y = Array.isArray(c) ? c[m] : c.type, g = h[m];
          l.concat(m + 1).checkSubtype(y, g.type);
        }
        if (l.errors.length === 0) return new Wr2(i, o, p, h);
      }
    }
    if (s3.length === 1) t3.errors.push(...l.errors);
    else {
      let p = (s3.length ? s3 : a).map(([f]) => FT(f)).join(" | "), h = [];
      for (let f = 1; f < e.length; f++) {
        let m = t3.parse(e[f], 1 + h.length);
        if (!m) return null;
        h.push(Re(m.type));
      }
      t3.error(`Expected arguments of type ${p}, but found (${h.join(", ")}) instead.`);
    }
    return null;
  }
  static register(e, t3) {
    Wr2.definitions = t3;
    for (let i in t3) e[i] = Wr2;
  }
};
r(Wr, "CompoundExpression");
var Ut = Wr;
function Ib(r3, [e, t3, i, n]) {
  e = e.evaluate(r3), t3 = t3.evaluate(r3), i = i.evaluate(r3);
  let o = n ? n.evaluate(r3) : 1, a = Zb(e, t3, i, o);
  if (a) throw new Be(a);
  return new X(e / 255, t3 / 255, i / 255, o, false);
}
r(Ib, "rgba");
function Cb(r3, e) {
  return r3 in e;
}
r(Cb, "has");
function Rp(r3, e) {
  let t3 = e[r3];
  return typeof t3 > "u" ? null : t3;
}
r(Rp, "get");
function zT(r3, e, t3, i) {
  for (; t3 <= i; ) {
    let n = t3 + i >> 1;
    if (e[n] === r3) return true;
    e[n] > r3 ? i = n - 1 : t3 = n + 1;
  }
  return false;
}
r(zT, "binarySearch");
function Hr(r3) {
  return { type: r3 };
}
r(Hr, "varargs");
Ut.register(ei, { error: [SP, [pe], (r3, [e]) => {
  throw new Be(e.evaluate(r3));
}], typeof: [pe, [le], (r3, [e]) => Re(Ze(e.evaluate(r3)))], "to-rgba": [_t(q3, 4), [Ct], (r3, [e]) => {
  let [t3, i, n, o] = e.evaluate(r3).rgb;
  return [t3 * 255, i * 255, n * 255, o];
}], rgb: [Ct, [q3, q3, q3], Ib], rgba: [Ct, [q3, q3, q3, q3], Ib], has: { type: se, overloads: [[[pe], (r3, [e]) => Cb(e.evaluate(r3), r3.properties())], [[pe, Ri], (r3, [e, t3]) => Cb(e.evaluate(r3), t3.evaluate(r3))]] }, get: { type: le, overloads: [[[pe], (r3, [e]) => Rp(e.evaluate(r3), r3.properties())], [[pe, Ri], (r3, [e, t3]) => Rp(e.evaluate(r3), t3.evaluate(r3))]] }, "feature-state": [le, [pe], (r3, [e]) => Rp(e.evaluate(r3), r3.featureState || {})], properties: [Ri, [], (r3) => r3.properties()], "geometry-type": [pe, [], (r3) => r3.geometryType()], id: [le, [], (r3) => r3.id()], zoom: [q3, [], (r3) => r3.globals.zoom], "heatmap-density": [q3, [], (r3) => r3.globals.heatmapDensity || 0], "line-progress": [q3, [], (r3) => r3.globals.lineProgress || 0], accumulated: [le, [], (r3) => r3.globals.accumulated === void 0 ? null : r3.globals.accumulated], "+": [q3, Hr(q3), (r3, e) => {
  let t3 = 0;
  for (let i of e) t3 += i.evaluate(r3);
  return t3;
}], "*": [q3, Hr(q3), (r3, e) => {
  let t3 = 1;
  for (let i of e) t3 *= i.evaluate(r3);
  return t3;
}], "-": { type: q3, overloads: [[[q3, q3], (r3, [e, t3]) => e.evaluate(r3) - t3.evaluate(r3)], [[q3], (r3, [e]) => -e.evaluate(r3)]] }, "/": [q3, [q3, q3], (r3, [e, t3]) => e.evaluate(r3) / t3.evaluate(r3)], "%": [q3, [q3, q3], (r3, [e, t3]) => e.evaluate(r3) % t3.evaluate(r3)], ln2: [q3, [], () => Math.LN2], pi: [q3, [], () => Math.PI], e: [q3, [], () => Math.E], "^": [q3, [q3, q3], (r3, [e, t3]) => Math.pow(e.evaluate(r3), t3.evaluate(r3))], sqrt: [q3, [q3], (r3, [e]) => Math.sqrt(e.evaluate(r3))], log10: [q3, [q3], (r3, [e]) => Math.log(e.evaluate(r3)) / Math.LN10], ln: [q3, [q3], (r3, [e]) => Math.log(e.evaluate(r3))], log2: [q3, [q3], (r3, [e]) => Math.log(e.evaluate(r3)) / Math.LN2], sin: [q3, [q3], (r3, [e]) => Math.sin(e.evaluate(r3))], cos: [q3, [q3], (r3, [e]) => Math.cos(e.evaluate(r3))], tan: [q3, [q3], (r3, [e]) => Math.tan(e.evaluate(r3))], asin: [q3, [q3], (r3, [e]) => Math.asin(e.evaluate(r3))], acos: [q3, [q3], (r3, [e]) => Math.acos(e.evaluate(r3))], atan: [q3, [q3], (r3, [e]) => Math.atan(e.evaluate(r3))], min: [q3, Hr(q3), (r3, e) => Math.min(...e.map((t3) => t3.evaluate(r3)))], max: [q3, Hr(q3), (r3, e) => Math.max(...e.map((t3) => t3.evaluate(r3)))], abs: [q3, [q3], (r3, [e]) => Math.abs(e.evaluate(r3))], round: [q3, [q3], (r3, [e]) => {
  let t3 = e.evaluate(r3);
  return t3 < 0 ? -Math.round(-t3) : Math.round(t3);
}], floor: [q3, [q3], (r3, [e]) => Math.floor(e.evaluate(r3))], ceil: [q3, [q3], (r3, [e]) => Math.ceil(e.evaluate(r3))], "filter-==": [se, [pe, le], (r3, [e, t3]) => r3.properties()[e.value] === t3.value], "filter-id-==": [se, [le], (r3, [e]) => r3.id() === e.value], "filter-type-==": [se, [pe], (r3, [e]) => r3.geometryType() === e.value], "filter-<": [se, [pe, le], (r3, [e, t3]) => {
  let i = r3.properties()[e.value], n = t3.value;
  return typeof i == typeof n && i < n;
}], "filter-id-<": [se, [le], (r3, [e]) => {
  let t3 = r3.id(), i = e.value;
  return typeof t3 == typeof i && t3 < i;
}], "filter->": [se, [pe, le], (r3, [e, t3]) => {
  let i = r3.properties()[e.value], n = t3.value;
  return typeof i == typeof n && i > n;
}], "filter-id->": [se, [le], (r3, [e]) => {
  let t3 = r3.id(), i = e.value;
  return typeof t3 == typeof i && t3 > i;
}], "filter-<=": [se, [pe, le], (r3, [e, t3]) => {
  let i = r3.properties()[e.value], n = t3.value;
  return typeof i == typeof n && i <= n;
}], "filter-id-<=": [se, [le], (r3, [e]) => {
  let t3 = r3.id(), i = e.value;
  return typeof t3 == typeof i && t3 <= i;
}], "filter->=": [se, [pe, le], (r3, [e, t3]) => {
  let i = r3.properties()[e.value], n = t3.value;
  return typeof i == typeof n && i >= n;
}], "filter-id->=": [se, [le], (r3, [e]) => {
  let t3 = r3.id(), i = e.value;
  return typeof t3 == typeof i && t3 >= i;
}], "filter-has": [se, [le], (r3, [e]) => e.value in r3.properties()], "filter-has-id": [se, [], (r3) => r3.id() !== null && r3.id() !== void 0], "filter-type-in": [se, [_t(pe)], (r3, [e]) => e.value.indexOf(r3.geometryType()) >= 0], "filter-id-in": [se, [_t(le)], (r3, [e]) => e.value.indexOf(r3.id()) >= 0], "filter-in-small": [se, [pe, _t(le)], (r3, [e, t3]) => t3.value.indexOf(r3.properties()[e.value]) >= 0], "filter-in-large": [se, [pe, _t(le)], (r3, [e, t3]) => zT(r3.properties()[e.value], t3.value, 0, t3.value.length - 1)], all: { type: se, overloads: [[[se, se], (r3, [e, t3]) => e.evaluate(r3) && t3.evaluate(r3)], [Hr(se), (r3, e) => {
  for (let t3 of e) if (!t3.evaluate(r3)) return false;
  return true;
}]] }, any: { type: se, overloads: [[[se, se], (r3, [e, t3]) => e.evaluate(r3) || t3.evaluate(r3)], [Hr(se), (r3, e) => {
  for (let t3 of e) if (t3.evaluate(r3)) return true;
  return false;
}]] }, "!": [se, [se], (r3, [e]) => !e.evaluate(r3)], "is-supported-script": [se, [pe], (r3, [e]) => {
  let t3 = r3.globals && r3.globals.isSupportedScript;
  return t3 ? t3(e.evaluate(r3)) : true;
}], upcase: [pe, [pe], (r3, [e]) => e.evaluate(r3).toUpperCase()], downcase: [pe, [pe], (r3, [e]) => e.evaluate(r3).toLowerCase()], concat: [pe, Hr(le), (r3, e) => e.map((t3) => Fn(t3.evaluate(r3))).join("")], "resolved-locale": [pe, [Hs], (r3, [e]) => e.evaluate(r3).resolvedLocale()] });
function FT(r3) {
  return Array.isArray(r3) ? `(${r3.map(Re).join(", ")})` : `(${Re(r3.type)}...)`;
}
r(FT, "stringifySignature");
function Ms(r3) {
  if (r3 instanceof xs) return Ms(r3.boundExpression);
  if (r3 instanceof Ut && r3.name === "error") return false;
  if (r3 instanceof vs) return false;
  if (r3 instanceof Kn) return false;
  if (r3 instanceof Yn) return false;
  let e = r3 instanceof gr || r3 instanceof Ft, t3 = true;
  return r3.eachChild((i) => {
    e ? t3 = t3 && Ms(i) : t3 = t3 && i instanceof xr;
  }), t3 ? Ys(r3) && Qs(r3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) : false;
}
r(Ms, "isExpressionConstant");
function Ys(r3) {
  if (r3 instanceof Ut) {
    if (r3.name === "get" && r3.args.length === 1) return false;
    if (r3.name === "feature-state") return false;
    if (r3.name === "has" && r3.args.length === 1) return false;
    if (r3.name === "properties" || r3.name === "geometry-type" || r3.name === "id") return false;
    if (/^filter-/.test(r3.name)) return false;
  }
  if (r3 instanceof Kn || r3 instanceof Yn) return false;
  let e = true;
  return r3.eachChild((t3) => {
    e && !Ys(t3) && (e = false);
  }), e;
}
r(Ys, "isFeatureConstant");
function Qn(r3) {
  if (r3 instanceof Ut && r3.name === "feature-state") return false;
  let e = true;
  return r3.eachChild((t3) => {
    e && !Qn(t3) && (e = false);
  }), e;
}
r(Qn, "isStateConstant");
function Qs(r3, e) {
  if (r3 instanceof Ut && e.indexOf(r3.name) >= 0) return false;
  let t3 = true;
  return r3.eachChild((i) => {
    t3 && !Qs(i, e) && (t3 = false);
  }), t3;
}
r(Qs, "isGlobalPropertyConstant");
function Qp(r3) {
  return { result: "success", value: r3 };
}
r(Qp, "success");
function ki(r3) {
  return { result: "error", value: r3 };
}
r(ki, "error");
function br(r3) {
  return r3["property-type"] === "data-driven" || r3["property-type"] === "cross-faded-data-driven";
}
r(br, "supportsPropertyExpression");
function e_(r3) {
  return !!r3.expression && r3.expression.parameters.indexOf("zoom") > -1;
}
r(e_, "supportsZoomExpression");
function ah(r3) {
  return !!r3.expression && r3.expression.interpolated;
}
r(ah, "supportsInterpolation");
function xe(r3) {
  return r3 instanceof Number ? "number" : r3 instanceof String ? "string" : r3 instanceof Boolean ? "boolean" : Array.isArray(r3) ? "array" : r3 === null ? "null" : typeof r3;
}
r(xe, "getType");
function el(r3) {
  return typeof r3 == "object" && r3 !== null && !Array.isArray(r3);
}
r(el, "isFunction$1");
function RT(r3) {
  return r3;
}
r(RT, "identityFunction");
function t_(r3, e) {
  let t3 = e.type === "color", i = r3.stops && typeof r3.stops[0][0] == "object", n = i || r3.property !== void 0, o = i || !n, a = r3.type || (ah(e) ? "exponential" : "interval");
  if (t3 || e.type === "padding") {
    let p = t3 ? X.parse : Rt.parse;
    r3 = Oi({}, r3), r3.stops && (r3.stops = r3.stops.map((h) => [h[0], p(h[1])])), r3.default ? r3.default = p(r3.default) : r3.default = p(e.default);
  }
  if (r3.colorSpace && !OP(r3.colorSpace)) throw new Error(`Unknown color space: "${r3.colorSpace}"`);
  let s3, l, c;
  if (a === "exponential") s3 = Eb;
  else if (a === "interval") s3 = OT;
  else if (a === "categorical") {
    s3 = BT, l = /* @__PURE__ */ Object.create(null);
    for (let p of r3.stops) l[p[0]] = p[1];
    c = typeof r3.stops[0][0];
  } else if (a === "identity") s3 = VT;
  else throw new Error(`Unknown function type "${a}"`);
  if (i) {
    let p = {}, h = [];
    for (let y = 0; y < r3.stops.length; y++) {
      let g = r3.stops[y], x = g[0].zoom;
      p[x] === void 0 && (p[x] = { zoom: x, type: r3.type, property: r3.property, default: r3.default, stops: [] }, h.push(x)), p[x].stops.push([g[0].value, g[1]]);
    }
    let f = [];
    for (let y of h) f.push([p[y].zoom, t_(p[y], e)]);
    let m = { name: "linear" };
    return { kind: "composite", interpolationType: m, interpolationFactor: vt.interpolationFactor.bind(void 0, m), zoomStops: f.map((y) => y[0]), evaluate({ zoom: y }, g) {
      return Eb({ stops: f, base: r3.base }, e, y).evaluate(y, g);
    } };
  } else if (o) {
    let p = a === "exponential" ? { name: "exponential", base: r3.base !== void 0 ? r3.base : 1 } : null;
    return { kind: "camera", interpolationType: p, interpolationFactor: vt.interpolationFactor.bind(void 0, p), zoomStops: r3.stops.map((h) => h[0]), evaluate: ({ zoom: h }) => s3(r3, e, h, l, c) };
  } else return { kind: "source", evaluate(p, h) {
    let f = h && h.properties ? h.properties[r3.property] : void 0;
    return f === void 0 ? no(r3.default, e.default) : s3(r3, e, f, l, c);
  } };
}
r(t_, "createFunction");
function no(r3, e, t3) {
  if (r3 !== void 0) return r3;
  if (e !== void 0) return e;
  if (t3 !== void 0) return t3;
}
r(no, "coalesce$1");
function BT(r3, e, t3, i, n) {
  let o = typeof t3 === n ? i[t3] : void 0;
  return no(o, r3.default, e.default);
}
r(BT, "evaluateCategoricalFunction");
function OT(r3, e, t3) {
  if (xe(t3) !== "number") return no(r3.default, e.default);
  let i = r3.stops.length;
  if (i === 1 || t3 <= r3.stops[0][0]) return r3.stops[0][1];
  if (t3 >= r3.stops[i - 1][0]) return r3.stops[i - 1][1];
  let n = Ks(r3.stops.map((o) => o[0]), t3);
  return r3.stops[n][1];
}
r(OT, "evaluateIntervalFunction");
function Eb(r3, e, t3) {
  let i = r3.base !== void 0 ? r3.base : 1;
  if (xe(t3) !== "number") return no(r3.default, e.default);
  let n = r3.stops.length;
  if (n === 1 || t3 <= r3.stops[0][0]) return r3.stops[0][1];
  if (t3 >= r3.stops[n - 1][0]) return r3.stops[n - 1][1];
  let o = Ks(r3.stops.map((p) => p[0]), t3), a = UT(t3, i, r3.stops[o][0], r3.stops[o + 1][0]), s3 = r3.stops[o][1], l = r3.stops[o + 1][1], c = Pe[e.type] || RT;
  return typeof s3.evaluate == "function" ? { evaluate(...p) {
    let h = s3.evaluate.apply(void 0, p), f = l.evaluate.apply(void 0, p);
    if (!(h === void 0 || f === void 0)) return c(h, f, a, r3.colorSpace);
  } } : c(s3, l, a, r3.colorSpace);
}
r(Eb, "evaluateExponentialFunction");
function VT(r3, e, t3) {
  switch (e.type) {
    case "color":
      t3 = X.parse(t3);
      break;
    case "formatted":
      t3 = wt.fromString(t3.toString());
      break;
    case "resolvedImage":
      t3 = ft.fromString(t3.toString());
      break;
    case "padding":
      t3 = Rt.parse(t3);
      break;
    default:
      xe(t3) !== e.type && (e.type !== "enum" || !e.values[t3]) && (t3 = void 0);
  }
  return no(t3, r3.default, e.default);
}
r(VT, "evaluateIdentityFunction");
function UT(r3, e, t3, i) {
  let n = i - t3, o = r3 - t3;
  return n === 0 ? 0 : e === 1 ? o / n : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
}
r(UT, "interpolationFactor");
var _h = class _h2 {
  constructor(e, t3) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new ds(), this._defaultValue = t3 ? GT(t3) : null, this._enumValues = t3 && t3.type === "enum" ? t3.values : null;
  }
  evaluateWithoutErrorHandling(e, t3, i, n, o, a) {
    return this._evaluator.globals = e, this._evaluator.feature = t3, this._evaluator.featureState = i, this._evaluator.canonical = n, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t3, i, n, o, a) {
    this._evaluator.globals = e, this._evaluator.feature = t3 || null, this._evaluator.featureState = i || null, this._evaluator.canonical = n, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a || null;
    try {
      let s3 = this.expression.evaluate(this._evaluator);
      if (s3 == null || typeof s3 == "number" && s3 !== s3) return this._defaultValue;
      if (this._enumValues && !(s3 in this._enumValues)) throw new Be(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s3)} instead.`);
      return s3;
    } catch (s3) {
      return this._warningHistory[s3.message] || (this._warningHistory[s3.message] = true, typeof console < "u" && console.warn(s3.message)), this._defaultValue;
    }
  }
};
r(_h, "StyleExpression");
var Jr = _h;
function ti(r3) {
  return Array.isArray(r3) && r3.length > 0 && typeof r3[0] == "string" && r3[0] in ei;
}
r(ti, "isExpression");
function sh(r3, e) {
  let t3 = new ys(ei, Ms, [], e ? NT(e) : void 0), i = t3.parse(r3, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return i ? Qp(new Jr(i, e)) : ki(t3.errors);
}
r(sh, "createExpression");
var vh = class vh2 {
  constructor(e, t3) {
    this.kind = e, this._styleExpression = t3, this.isStateDependent = e !== "constant" && !Qn(t3.expression);
  }
  evaluateWithoutErrorHandling(e, t3, i, n, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t3, i, n, o, a);
  }
  evaluate(e, t3, i, n, o, a) {
    return this._styleExpression.evaluate(e, t3, i, n, o, a);
  }
};
r(vh, "ZoomConstantExpression");
var _r = vh;
var wh = class wh2 {
  constructor(e, t3, i, n) {
    this.kind = e, this.zoomStops = i, this._styleExpression = t3, this.isStateDependent = e !== "camera" && !Qn(t3.expression), this.interpolationType = n;
  }
  evaluateWithoutErrorHandling(e, t3, i, n, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t3, i, n, o, a);
  }
  evaluate(e, t3, i, n, o, a) {
    return this._styleExpression.evaluate(e, t3, i, n, o, a);
  }
  interpolationFactor(e, t3, i) {
    return this.interpolationType ? vt.interpolationFactor(this.interpolationType, e, t3, i) : 0;
  }
};
r(wh, "ZoomDependentExpression");
var vr = wh;
function r_(r3, e) {
  let t3 = sh(r3, e);
  if (t3.result === "error") return t3;
  let i = t3.value.expression, n = Ys(i);
  if (!n && !br(e)) return ki([new At("", "data expressions not supported")]);
  let o = Qs(i, ["zoom"]);
  if (!o && !e_(e)) return ki([new At("", "zoom expressions not supported")]);
  let a = ms(i);
  if (!a && !o) return ki([new At("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (a instanceof At) return ki([a]);
  if (a instanceof vt && !ah(e)) return ki([new At("", '"interpolate" expressions cannot be used with this property')]);
  if (!a) return Qp(n ? new _r("constant", t3.value) : new _r("source", t3.value));
  let s3 = a instanceof vt ? a.interpolation : void 0;
  return Qp(n ? new vr("camera", t3.value, a.labels, s3) : new vr("composite", t3.value, a.labels, s3));
}
r(r_, "createPropertyExpression");
var Zs = class Zs2 {
  constructor(e, t3) {
    this._parameters = e, this._specification = t3, Oi(this, t_(this._parameters, this._specification));
  }
  static deserialize(e) {
    return new Zs2(e._parameters, e._specification);
  }
  static serialize(e) {
    return { _parameters: e._parameters, _specification: e._specification };
  }
};
r(Zs, "StylePropertyFunction");
var eo = Zs;
function i_(r3, e) {
  if (el(r3)) return new eo(r3, e);
  if (ti(r3)) {
    let t3 = r_(r3, e);
    if (t3.result === "error") throw new Error(t3.value.map((i) => `${i.key}: ${i.message}`).join(", "));
    return t3.value;
  } else {
    let t3 = r3;
    return e.type === "color" && typeof r3 == "string" ? t3 = X.parse(r3) : e.type === "padding" && (typeof r3 == "number" || Array.isArray(r3)) ? t3 = Rt.parse(r3) : e.type === "variableAnchorOffsetCollection" && Array.isArray(r3) && (t3 = rr.parse(r3)), { kind: "constant", evaluate: () => t3 };
  }
}
r(i_, "normalizePropertyExpression");
function ms(r3) {
  let e = null;
  if (r3 instanceof gs) e = ms(r3.result);
  else if (r3 instanceof _s) {
    for (let t3 of r3.args) if (e = ms(t3), e) break;
  } else (r3 instanceof Vi || r3 instanceof vt) && r3.input instanceof Ut && r3.input.name === "zoom" && (e = r3);
  return e instanceof At || r3.eachChild((t3) => {
    let i = ms(t3);
    i instanceof At ? e = i : !e && i ? e = new At("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && i && e !== i && (e = new At("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
r(ms, "findZoomCurve");
function NT(r3) {
  let e = { color: Ct, string: pe, number: q3, enum: pe, boolean: se, formatted: Gi, padding: Ws, resolvedImage: ro, variableAnchorOffsetCollection: Xs };
  return r3.type === "array" ? _t(e[r3.value] || le, r3.length) : e[r3.type];
}
r(NT, "getExpectedType");
function GT(r3) {
  return r3.type === "color" && el(r3.default) ? new X(0, 0, 0, 0) : r3.type === "color" ? X.parse(r3.default) || null : r3.type === "padding" ? Rt.parse(r3.default) || null : r3.type === "variableAnchorOffsetCollection" ? rr.parse(r3.default) || null : r3.default === void 0 ? null : r3.default;
}
r(GT, "getDefaultValue");
function lh(r3) {
  if (r3 === true || r3 === false) return true;
  if (!Array.isArray(r3) || r3.length === 0) return false;
  switch (r3[0]) {
    case "has":
      return r3.length >= 2 && r3[1] !== "$id" && r3[1] !== "$type";
    case "in":
      return r3.length >= 3 && (typeof r3[1] != "string" || Array.isArray(r3[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r3.length !== 3 || Array.isArray(r3[1]) || Array.isArray(r3[2]);
    case "any":
    case "all":
      for (let e of r3.slice(1)) if (!lh(e) && typeof e != "boolean") return false;
      return true;
    default:
      return true;
  }
}
r(lh, "isExpressionFilter");
var $T = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
function oo(r3) {
  if (r3 == null) return { filter: () => true, needGeometry: false };
  lh(r3) || (r3 = As(r3));
  let e = sh(r3, $T);
  if (e.result === "error") throw new Error(e.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
  {
    let t3 = n_(r3);
    return { filter: (i, n, o) => e.value.evaluate(i, n, {}, o), needGeometry: t3 };
  }
}
r(oo, "createFilter");
function qT(r3, e) {
  return r3 < e ? -1 : r3 > e ? 1 : 0;
}
r(qT, "compare");
function n_(r3) {
  if (!Array.isArray(r3)) return false;
  if (r3[0] === "within" || r3[0] === "distance") return true;
  for (let e = 1; e < r3.length; e++) if (n_(r3[e])) return true;
  return false;
}
r(n_, "geometryNeeded");
function As(r3) {
  if (!r3) return true;
  let e = r3[0];
  return r3.length <= 1 ? e !== "any" : e === "==" ? Bp(r3[1], r3[2], "==") : e === "!=" ? fs(Bp(r3[1], r3[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Bp(r3[1], r3[2], e) : e === "any" ? jT(r3.slice(1)) : e === "all" ? ["all"].concat(r3.slice(1).map(As)) : e === "none" ? ["all"].concat(r3.slice(1).map(As).map(fs)) : e === "in" ? kb(r3[1], r3.slice(2)) : e === "!in" ? fs(kb(r3[1], r3.slice(2))) : e === "has" ? Lb(r3[1]) : e === "!has" ? fs(Lb(r3[1])) : true;
}
r(As, "convertFilter$1");
function Bp(r3, e, t3) {
  switch (r3) {
    case "$type":
      return [`filter-type-${t3}`, e];
    case "$id":
      return [`filter-id-${t3}`, e];
    default:
      return [`filter-${t3}`, r3, e];
  }
}
r(Bp, "convertComparisonOp$1");
function jT(r3) {
  return ["any"].concat(r3.map(As));
}
r(jT, "convertDisjunctionOp");
function kb(r3, e) {
  if (e.length === 0) return false;
  switch (r3) {
    case "$type":
      return ["filter-type-in", ["literal", e]];
    case "$id":
      return ["filter-id-in", ["literal", e]];
    default:
      return e.length > 200 && !e.some((t3) => typeof t3 != typeof e[0]) ? ["filter-in-large", r3, ["literal", e.sort(qT)]] : ["filter-in-small", r3, ["literal", e]];
  }
}
r(kb, "convertInOp$1");
function Lb(r3) {
  switch (r3) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", r3];
  }
}
r(Lb, "convertHasOp$1");
function fs(r3) {
  return ["!", r3];
}
r(fs, "convertNegation");
function o_() {
  let r3 = {}, e = A.$version;
  for (let t3 in A.$root) {
    let i = A.$root[t3];
    if (i.required) {
      let n = null;
      t3 === "version" ? n = e : i.type === "array" ? n = [] : n = {}, n != null && (r3[t3] = n);
    }
  }
  return r3;
}
r(o_, "emptyStyle");
function a_(r3) {
  let e = r3.key, t3 = r3.value;
  return t3 ? [new B(e, t3, "constants have been deprecated as of v8")] : [];
}
r(a_, "validateConstants");
function Ue(r3) {
  return r3 instanceof Number || r3 instanceof String || r3 instanceof Boolean ? r3.valueOf() : r3;
}
r(Ue, "unbundle");
function Yr(r3) {
  if (Array.isArray(r3)) return r3.map(Yr);
  if (r3 instanceof Object && !(r3 instanceof Number || r3 instanceof String || r3 instanceof Boolean)) {
    let e = {};
    for (let t3 in r3) e[t3] = Yr(r3[t3]);
    return e;
  }
  return Ue(r3);
}
r(Yr, "deepUnbundle");
function It(r3) {
  let e = r3.key, t3 = r3.value, i = r3.valueSpec || {}, n = r3.objectElementValidators || {}, o = r3.style, a = r3.styleSpec, s3 = r3.validateSpec, l = [], c = xe(t3);
  if (c !== "object") return [new B(e, t3, `object expected, ${c} found`)];
  for (let p in t3) {
    let h = p.split(".")[0], f = i[h] || i["*"], m;
    if (n[h]) m = n[h];
    else if (i[h]) m = s3;
    else if (n["*"]) m = n["*"];
    else if (i["*"]) m = s3;
    else {
      l.push(new B(e, t3[p], `unknown property "${p}"`));
      continue;
    }
    l = l.concat(m({ key: (e && `${e}.`) + p, value: t3[p], valueSpec: f, style: o, styleSpec: a, object: t3, objectKey: p, validateSpec: s3 }, t3));
  }
  for (let p in i) n[p] || i[p].required && i[p].default === void 0 && t3[p] === void 0 && l.push(new B(e, t3, `missing required property "${p}"`));
  return l;
}
r(It, "validateObject");
function uh(r3) {
  let e = r3.value, t3 = r3.valueSpec, i = r3.validateSpec, n = r3.style, o = r3.styleSpec, a = r3.key, s3 = r3.arrayElementValidator || i;
  if (xe(e) !== "array") return [new B(a, e, `array expected, ${xe(e)} found`)];
  if (t3.length && e.length !== t3.length) return [new B(a, e, `array length ${t3.length} expected, length ${e.length} found`)];
  if (t3["min-length"] && e.length < t3["min-length"]) return [new B(a, e, `array length at least ${t3["min-length"]} expected, length ${e.length} found`)];
  let l = { type: t3.value, values: t3.values };
  o.$version < 7 && (l.function = t3.function), xe(t3.value) === "object" && (l = t3.value);
  let c = [];
  for (let p = 0; p < e.length; p++) c = c.concat(s3({ array: e, arrayIndex: p, value: e[p], valueSpec: l, validateSpec: r3.validateSpec, style: n, styleSpec: o, key: `${a}[${p}]` }));
  return c;
}
r(uh, "validateArray");
function ch(r3) {
  let e = r3.key, t3 = r3.value, i = r3.valueSpec, n = xe(t3);
  return n === "number" && t3 !== t3 && (n = "NaN"), n !== "number" ? [new B(e, t3, `number expected, ${n} found`)] : "minimum" in i && t3 < i.minimum ? [new B(e, t3, `${t3} is less than the minimum value ${i.minimum}`)] : "maximum" in i && t3 > i.maximum ? [new B(e, t3, `${t3} is greater than the maximum value ${i.maximum}`)] : [];
}
r(ch, "validateNumber");
function s_(r3) {
  let e = r3.valueSpec, t3 = Ue(r3.value.type), i, n = {}, o, a, s3 = t3 !== "categorical" && r3.value.property === void 0, l = !s3, c = xe(r3.value.stops) === "array" && xe(r3.value.stops[0]) === "array" && xe(r3.value.stops[0][0]) === "object", p = It({ key: r3.key, value: r3.value, valueSpec: r3.styleSpec.function, validateSpec: r3.validateSpec, style: r3.style, styleSpec: r3.styleSpec, objectElementValidators: { stops: h, default: y } });
  return t3 === "identity" && s3 && p.push(new B(r3.key, r3.value, 'missing required property "property"')), t3 !== "identity" && !r3.value.stops && p.push(new B(r3.key, r3.value, 'missing required property "stops"')), t3 === "exponential" && r3.valueSpec.expression && !ah(r3.valueSpec) && p.push(new B(r3.key, r3.value, "exponential functions not supported")), r3.styleSpec.$version >= 8 && (l && !br(r3.valueSpec) ? p.push(new B(r3.key, r3.value, "property functions not supported")) : s3 && !e_(r3.valueSpec) && p.push(new B(r3.key, r3.value, "zoom functions not supported"))), (t3 === "categorical" || c) && r3.value.property === void 0 && p.push(new B(r3.key, r3.value, '"property" property is required')), p;
  function h(g) {
    if (t3 === "identity") return [new B(g.key, g.value, 'identity function may not have a "stops" property')];
    let x = [], b = g.value;
    return x = x.concat(uh({ key: g.key, value: b, valueSpec: g.valueSpec, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, arrayElementValidator: f })), xe(b) === "array" && b.length === 0 && x.push(new B(g.key, b, "array must have at least one stop")), x;
  }
  r(h, "validateFunctionStops");
  function f(g) {
    let x = [], b = g.value, w = g.key;
    if (xe(b) !== "array") return [new B(w, b, `array expected, ${xe(b)} found`)];
    if (b.length !== 2) return [new B(w, b, `array length 2 expected, length ${b.length} found`)];
    if (c) {
      if (xe(b[0]) !== "object") return [new B(w, b, `object expected, ${xe(b[0])} found`)];
      if (b[0].zoom === void 0) return [new B(w, b, "object stop key must have zoom")];
      if (b[0].value === void 0) return [new B(w, b, "object stop key must have value")];
      if (a && a > Ue(b[0].zoom)) return [new B(w, b[0].zoom, "stop zoom values must appear in ascending order")];
      Ue(b[0].zoom) !== a && (a = Ue(b[0].zoom), o = void 0, n = {}), x = x.concat(It({ key: `${w}[0]`, value: b[0], valueSpec: { zoom: {} }, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, objectElementValidators: { zoom: ch, value: m } }));
    } else x = x.concat(m({ key: `${w}[0]`, value: b[0], valueSpec: {}, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }, b));
    return ti(Yr(b[1])) ? x.concat([new B(`${w}[1]`, b[1], "expressions are not allowed in function stops.")]) : x.concat(g.validateSpec({ key: `${w}[1]`, value: b[1], valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }));
  }
  r(f, "validateFunctionStop");
  function m(g, x) {
    let b = xe(g.value), w = Ue(g.value), _ = g.value !== null ? g.value : x;
    if (!i) i = b;
    else if (b !== i) return [new B(g.key, _, `${b} stop domain type must match previous stop domain type ${i}`)];
    if (b !== "number" && b !== "string" && b !== "boolean") return [new B(g.key, _, "stop domain value must be a number, string, or boolean")];
    if (b !== "number" && t3 !== "categorical") {
      let S = `number expected, ${b} found`;
      return br(e) && t3 === void 0 && (S += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new B(g.key, _, S)];
    }
    return t3 === "categorical" && b === "number" && (!isFinite(w) || Math.floor(w) !== w) ? [new B(g.key, _, `integer expected, found ${w}`)] : t3 !== "categorical" && b === "number" && o !== void 0 && w < o ? [new B(g.key, _, "stop domain values must appear in ascending order")] : (o = w, t3 === "categorical" && w in n ? [new B(g.key, _, "stop domain values must be unique")] : (n[w] = true, []));
  }
  r(m, "validateStopDomainValue");
  function y(g) {
    return g.validateSpec({ key: g.key, value: g.value, valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec });
  }
  r(y, "validateFunctionDefault");
}
r(s_, "validateFunction");
function Ui(r3) {
  let e = (r3.expressionContext === "property" ? r_ : sh)(Yr(r3.value), r3.valueSpec);
  if (e.result === "error") return e.value.map((i) => new B(`${r3.key}${i.key}`, r3.value, i.message));
  let t3 = e.value.expression || e.value._styleExpression.expression;
  if (r3.expressionContext === "property" && r3.propertyKey === "text-font" && !t3.outputDefined()) return [new B(r3.key, r3.value, `Invalid data expression for "${r3.propertyKey}". Output values must be contained as literals within the expression.`)];
  if (r3.expressionContext === "property" && r3.propertyType === "layout" && !Qn(t3)) return [new B(r3.key, r3.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (r3.expressionContext === "filter" && !Qn(t3)) return [new B(r3.key, r3.value, '"feature-state" data expressions are not supported with filters.')];
  if (r3.expressionContext && r3.expressionContext.indexOf("cluster") === 0) {
    if (!Qs(t3, ["zoom", "feature-state"])) return [new B(r3.key, r3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (r3.expressionContext === "cluster-initial" && !Ys(t3)) return [new B(r3.key, r3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
r(Ui, "validateExpression");
function ZT(r3) {
  let e = r3.value, t3 = r3.key, i = xe(e);
  return i !== "boolean" ? [new B(t3, e, `boolean expected, ${i} found`)] : [];
}
r(ZT, "validateBoolean");
function HT(r3) {
  let e = r3.key, t3 = r3.value, i = xe(t3);
  return i !== "string" ? [new B(e, t3, `color expected, ${i} found`)] : X.parse(String(t3)) ? [] : [new B(e, t3, `color expected, "${t3}" found`)];
}
r(HT, "validateColor");
function to(r3) {
  let e = r3.key, t3 = r3.value, i = r3.valueSpec, n = [];
  return Array.isArray(i.values) ? i.values.indexOf(Ue(t3)) === -1 && n.push(new B(e, t3, `expected one of [${i.values.join(", ")}], ${JSON.stringify(t3)} found`)) : Object.keys(i.values).indexOf(Ue(t3)) === -1 && n.push(new B(e, t3, `expected one of [${Object.keys(i.values).join(", ")}], ${JSON.stringify(t3)} found`)), n;
}
r(to, "validateEnum");
function ph(r3) {
  return lh(Yr(r3.value)) ? Ui(Oi({}, r3, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : l_(r3);
}
r(ph, "validateFilter");
function l_(r3) {
  let e = r3.value, t3 = r3.key;
  if (xe(e) !== "array") return [new B(t3, e, `array expected, ${xe(e)} found`)];
  let i = r3.styleSpec, n, o = [];
  if (e.length < 1) return [new B(t3, e, "filter array must have at least 1 element")];
  switch (o = o.concat(to({ key: `${t3}[0]`, value: e[0], valueSpec: i.filter_operator, style: r3.style, styleSpec: r3.styleSpec })), Ue(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && Ue(e[1]) === "$type" && o.push(new B(t3, e, `"$type" cannot be use with operator "${e[0]}"`));
    case "==":
    case "!=":
      e.length !== 3 && o.push(new B(t3, e, `filter array for operator "${e[0]}" must have 3 elements`));
    case "in":
    case "!in":
      e.length >= 2 && (n = xe(e[1]), n !== "string" && o.push(new B(`${t3}[1]`, e[1], `string expected, ${n} found`)));
      for (let a = 2; a < e.length; a++) n = xe(e[a]), Ue(e[1]) === "$type" ? o = o.concat(to({ key: `${t3}[${a}]`, value: e[a], valueSpec: i.geometry_type, style: r3.style, styleSpec: r3.styleSpec })) : n !== "string" && n !== "number" && n !== "boolean" && o.push(new B(`${t3}[${a}]`, e[a], `string, number, or boolean expected, ${n} found`));
      break;
    case "any":
    case "all":
    case "none":
      for (let a = 1; a < e.length; a++) o = o.concat(l_({ key: `${t3}[${a}]`, value: e[a], style: r3.style, styleSpec: r3.styleSpec }));
      break;
    case "has":
    case "!has":
      n = xe(e[1]), e.length !== 2 ? o.push(new B(t3, e, `filter array for "${e[0]}" operator must have 2 elements`)) : n !== "string" && o.push(new B(`${t3}[1]`, e[1], `string expected, ${n} found`));
      break;
  }
  return o;
}
r(l_, "validateNonExpressionFilter");
function u_(r3, e) {
  let t3 = r3.key, i = r3.validateSpec, n = r3.style, o = r3.styleSpec, a = r3.value, s3 = r3.objectKey, l = o[`${e}_${r3.layerType}`];
  if (!l) return [];
  let c = s3.match(/^(.*)-transition$/);
  if (e === "paint" && c && l[c[1]] && l[c[1]].transition) return i({ key: t3, value: a, valueSpec: o.transition, style: n, styleSpec: o });
  let p = r3.valueSpec || l[s3];
  if (!p) return [new B(t3, a, `unknown property "${s3}"`)];
  let h;
  if (xe(a) === "string" && br(p) && !p.tokens && (h = /^{([^}]+)}$/.exec(a))) return [new B(t3, a, `"${s3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h[1])} }\`.`)];
  let f = [];
  return r3.layerType === "symbol" && (s3 === "text-field" && n && !n.glyphs && f.push(new B(t3, a, 'use of "text-field" requires a style "glyphs" property')), s3 === "text-font" && el(Yr(a)) && Ue(a.type) === "identity" && f.push(new B(t3, a, '"text-font" does not support identity functions'))), f.concat(i({ key: r3.key, value: a, valueSpec: p, style: n, styleSpec: o, expressionContext: "property", propertyType: e, propertyKey: s3 }));
}
r(u_, "validateProperty");
function c_(r3) {
  return u_(r3, "paint");
}
r(c_, "validatePaintProperty");
function p_(r3) {
  return u_(r3, "layout");
}
r(p_, "validateLayoutProperty");
function h_(r3) {
  let e = [], t3 = r3.value, i = r3.key, n = r3.style, o = r3.styleSpec;
  !t3.type && !t3.ref && e.push(new B(i, t3, 'either "type" or "ref" is required'));
  let a = Ue(t3.type), s3 = Ue(t3.ref);
  if (t3.id) {
    let l = Ue(t3.id);
    for (let c = 0; c < r3.arrayIndex; c++) {
      let p = n.layers[c];
      Ue(p.id) === l && e.push(new B(i, t3.id, `duplicate layer id "${t3.id}", previously used at line ${p.id.__line__}`));
    }
  }
  if ("ref" in t3) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((c) => {
      c in t3 && e.push(new B(i, t3[c], `"${c}" is prohibited for ref layers`));
    });
    let l;
    n.layers.forEach((c) => {
      Ue(c.id) === s3 && (l = c);
    }), l ? l.ref ? e.push(new B(i, t3.ref, "ref cannot reference another ref layer")) : a = Ue(l.type) : e.push(new B(i, t3.ref, `ref layer "${s3}" not found`));
  } else if (a !== "background") if (!t3.source) e.push(new B(i, t3, 'missing required property "source"'));
  else {
    let l = n.sources && n.sources[t3.source], c = l && Ue(l.type);
    l ? c === "vector" && a === "raster" ? e.push(new B(i, t3.source, `layer "${t3.id}" requires a raster source`)) : c !== "raster-dem" && a === "hillshade" ? e.push(new B(i, t3.source, `layer "${t3.id}" requires a raster-dem source`)) : c === "raster" && a !== "raster" ? e.push(new B(i, t3.source, `layer "${t3.id}" requires a vector source`)) : c === "vector" && !t3["source-layer"] ? e.push(new B(i, t3, `layer "${t3.id}" must specify a "source-layer"`)) : c === "raster-dem" && a !== "hillshade" ? e.push(new B(i, t3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a === "line" && t3.paint && t3.paint["line-gradient"] && (c !== "geojson" || !l.lineMetrics) && e.push(new B(i, t3, `layer "${t3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new B(i, t3.source, `source "${t3.source}" not found`));
  }
  return e = e.concat(It({ key: i, value: t3, valueSpec: o.layer, style: r3.style, styleSpec: r3.styleSpec, validateSpec: r3.validateSpec, objectElementValidators: { "*"() {
    return [];
  }, type() {
    return r3.validateSpec({ key: `${i}.type`, value: t3.type, valueSpec: o.layer.type, style: r3.style, styleSpec: r3.styleSpec, validateSpec: r3.validateSpec, object: t3, objectKey: "type" });
  }, filter: ph, layout(l) {
    return It({ layer: t3, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(c) {
      return p_(Oi({ layerType: a }, c));
    } } });
  }, paint(l) {
    return It({ layer: t3, key: l.key, value: l.value, style: l.style, styleSpec: l.styleSpec, validateSpec: l.validateSpec, objectElementValidators: { "*"(c) {
      return c_(Oi({ layerType: a }, c));
    } } });
  } } })), e;
}
r(h_, "validateLayer");
function Qr(r3) {
  let e = r3.value, t3 = r3.key, i = xe(e);
  return i !== "string" ? [new B(t3, e, `string expected, ${i} found`)] : [];
}
r(Qr, "validateString");
function WT(r3) {
  var e;
  let t3 = (e = r3.sourceName) !== null && e !== void 0 ? e : "", i = r3.value, n = r3.styleSpec, o = n.source_raster_dem, a = r3.style, s3 = [], l = xe(i);
  if (i === void 0) return s3;
  if (l !== "object") return s3.push(new B("source_raster_dem", i, `object expected, ${l} found`)), s3;
  let p = Ue(i.encoding) === "custom", h = ["redFactor", "greenFactor", "blueFactor", "baseShift"], f = r3.value.encoding ? `"${r3.value.encoding}"` : "Default";
  for (let m in i) !p && h.includes(m) ? s3.push(new B(m, i[m], `In "${t3}": "${m}" is only valid when "encoding" is set to "custom". ${f} encoding found`)) : o[m] ? s3 = s3.concat(r3.validateSpec({ key: m, value: i[m], valueSpec: o[m], validateSpec: r3.validateSpec, style: a, styleSpec: n })) : s3.push(new B(m, i[m], `unknown property "${m}"`));
  return s3;
}
r(WT, "validateRasterDEMSource");
var Db = { promoteId: XT };
function f_(r3) {
  let e = r3.value, t3 = r3.key, i = r3.styleSpec, n = r3.style, o = r3.validateSpec;
  if (!e.type) return [new B(t3, e, '"type" is required')];
  let a = Ue(e.type), s3;
  switch (a) {
    case "vector":
    case "raster":
      return s3 = It({ key: t3, value: e, valueSpec: i[`source_${a.replace("-", "_")}`], style: r3.style, styleSpec: i, objectElementValidators: Db, validateSpec: o }), s3;
    case "raster-dem":
      return s3 = WT({ sourceName: t3, value: e, style: r3.style, styleSpec: i, validateSpec: o }), s3;
    case "geojson":
      if (s3 = It({ key: t3, value: e, valueSpec: i.source_geojson, style: n, styleSpec: i, validateSpec: o, objectElementValidators: Db }), e.cluster) for (let l in e.clusterProperties) {
        let [c, p] = e.clusterProperties[l], h = typeof c == "string" ? [c, ["accumulated"], ["get", l]] : c;
        s3.push(...Ui({ key: `${t3}.${l}.map`, value: p, validateSpec: o, expressionContext: "cluster-map" })), s3.push(...Ui({ key: `${t3}.${l}.reduce`, value: h, validateSpec: o, expressionContext: "cluster-reduce" }));
      }
      return s3;
    case "video":
      return It({ key: t3, value: e, valueSpec: i.source_video, style: n, validateSpec: o, styleSpec: i });
    case "image":
      return It({ key: t3, value: e, valueSpec: i.source_image, style: n, validateSpec: o, styleSpec: i });
    case "canvas":
      return [new B(t3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return to({ key: `${t3}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: n, validateSpec: o, styleSpec: i });
  }
}
r(f_, "validateSource");
function XT({ key: r3, value: e }) {
  if (xe(e) === "string") return Qr({ key: r3, value: e });
  {
    let t3 = [];
    for (let i in e) t3.push(...Qr({ key: `${r3}.${i}`, value: e[i] }));
    return t3;
  }
}
r(XT, "validatePromoteId");
function m_(r3) {
  let e = r3.value, t3 = r3.styleSpec, i = t3.light, n = r3.style, o = [], a = xe(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new B("light", e, `object expected, ${a} found`)]), o;
  for (let s3 in e) {
    let l = s3.match(/^(.*)-transition$/);
    l && i[l[1]] && i[l[1]].transition ? o = o.concat(r3.validateSpec({ key: s3, value: e[s3], valueSpec: t3.transition, validateSpec: r3.validateSpec, style: n, styleSpec: t3 })) : i[s3] ? o = o.concat(r3.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], validateSpec: r3.validateSpec, style: n, styleSpec: t3 })) : o = o.concat([new B(s3, e[s3], `unknown property "${s3}"`)]);
  }
  return o;
}
r(m_, "validateLight");
function d_(r3) {
  let e = r3.value, t3 = r3.styleSpec, i = t3.sky, n = r3.style, o = xe(e);
  if (e === void 0) return [];
  if (o !== "object") return [new B("sky", e, `object expected, ${o} found`)];
  let a = [];
  for (let s3 in e) i[s3] ? a = a.concat(r3.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], style: n, styleSpec: t3 })) : a = a.concat([new B(s3, e[s3], `unknown property "${s3}"`)]);
  return a;
}
r(d_, "validateSky");
function y_(r3) {
  let e = r3.value, t3 = r3.styleSpec, i = t3.terrain, n = r3.style, o = [], a = xe(e);
  if (e === void 0) return o;
  if (a !== "object") return o = o.concat([new B("terrain", e, `object expected, ${a} found`)]), o;
  for (let s3 in e) i[s3] ? o = o.concat(r3.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], validateSpec: r3.validateSpec, style: n, styleSpec: t3 })) : o = o.concat([new B(s3, e[s3], `unknown property "${s3}"`)]);
  return o;
}
r(y_, "validateTerrain");
function KT(r3) {
  return Qr(r3).length === 0 ? [] : Ui(r3);
}
r(KT, "validateFormatted");
function JT(r3) {
  return Qr(r3).length === 0 ? [] : Ui(r3);
}
r(JT, "validateImage");
function YT(r3) {
  let e = r3.key, t3 = r3.value;
  if (xe(t3) === "array") {
    if (t3.length < 1 || t3.length > 4) return [new B(e, t3, `padding requires 1 to 4 values; ${t3.length} values found`)];
    let n = { type: "number" }, o = [];
    for (let a = 0; a < t3.length; a++) o = o.concat(r3.validateSpec({ key: `${e}[${a}]`, value: t3[a], validateSpec: r3.validateSpec, valueSpec: n }));
    return o;
  } else return ch({ key: e, value: t3, valueSpec: {} });
}
r(YT, "validatePadding");
function QT(r3) {
  let e = r3.key, t3 = r3.value, i = xe(t3), n = r3.styleSpec;
  if (i !== "array" || t3.length < 1 || t3.length % 2 !== 0) return [new B(e, t3, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let o = [];
  for (let a = 0; a < t3.length; a += 2) o = o.concat(to({ key: `${e}[${a}]`, value: t3[a], valueSpec: n.layout_symbol["text-anchor"] })), o = o.concat(uh({ key: `${e}[${a + 1}]`, value: t3[a + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r3.validateSpec, style: r3.style, styleSpec: n }));
  return o;
}
r(QT, "validateVariableAnchorOffsetCollection");
function g_(r3) {
  let e = [], t3 = r3.value, i = r3.key;
  if (Array.isArray(t3)) {
    let n = [], o = [];
    for (let a in t3) {
      t3[a].id && n.includes(t3[a].id) && e.push(new B(i, t3, `all the sprites' ids must be unique, but ${t3[a].id} is duplicated`)), n.push(t3[a].id), t3[a].url && o.includes(t3[a].url) && e.push(new B(i, t3, `all the sprites' URLs must be unique, but ${t3[a].url} is duplicated`)), o.push(t3[a].url);
      let s3 = { id: { type: "string", required: true }, url: { type: "string", required: true } };
      e = e.concat(It({ key: `${i}[${a}]`, value: t3[a], valueSpec: s3, validateSpec: r3.validateSpec }));
    }
    return e;
  } else return Qr({ key: i, value: t3 });
}
r(g_, "validateSprite");
function eM(r3) {
  let e = r3.value, t3 = r3.styleSpec, i = t3.projection, n = r3.style, o = xe(e);
  if (e === void 0) return [];
  if (o !== "object") return [new B("projection", e, `object expected, ${o} found`)];
  let a = [];
  for (let s3 in e) i[s3] ? a = a.concat(r3.validateSpec({ key: s3, value: e[s3], valueSpec: i[s3], style: n, styleSpec: t3 })) : a = a.concat([new B(s3, e[s3], `unknown property "${s3}"`)]);
  return a;
}
r(eM, "validateProjection");
var zb = { "*"() {
  return [];
}, array: uh, boolean: ZT, number: ch, color: HT, constants: a_, enum: to, filter: ph, function: s_, layer: h_, object: It, source: f_, light: m_, sky: d_, terrain: y_, projection: eM, string: Qr, formatted: KT, resolvedImage: JT, padding: YT, variableAnchorOffsetCollection: QT, sprite: g_ };
function Rn(r3) {
  let e = r3.value, t3 = r3.valueSpec, i = r3.styleSpec;
  return r3.validateSpec = Rn, t3.expression && el(Ue(e)) ? s_(r3) : t3.expression && ti(Yr(e)) ? Ui(r3) : t3.type && zb[t3.type] ? zb[t3.type](r3) : It(Oi({}, r3, { valueSpec: t3.type ? i[t3.type] : t3 }));
}
r(Rn, "validate");
function x_(r3) {
  let e = r3.value, t3 = r3.key, i = Qr(r3);
  return i.length || (e.indexOf("{fontstack}") === -1 && i.push(new B(t3, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && i.push(new B(t3, e, '"glyphs" url must include a "{range}" token'))), i;
}
r(x_, "validateGlyphsUrl");
function Et(r3, e = A) {
  let t3 = [];
  return t3 = t3.concat(Rn({ key: "", value: r3, valueSpec: e.$root, styleSpec: e, style: r3, validateSpec: Rn, objectElementValidators: { glyphs: x_, "*"() {
    return [];
  } } })), r3.constants && (t3 = t3.concat(a_({ key: "constants", value: r3.constants, style: r3, styleSpec: e, validateSpec: Rn }))), b_(t3);
}
r(Et, "validateStyleMin");
Et.source = Gt(Nt(f_));
Et.sprite = Gt(Nt(g_));
Et.glyphs = Gt(Nt(x_));
Et.light = Gt(Nt(m_));
Et.sky = Gt(Nt(d_));
Et.terrain = Gt(Nt(y_));
Et.layer = Gt(Nt(h_));
Et.filter = Gt(Nt(ph));
Et.paintProperty = Gt(Nt(c_));
Et.layoutProperty = Gt(Nt(p_));
function Nt(r3) {
  return function(e) {
    return r3({ ...e, validateSpec: Rn });
  };
}
r(Nt, "injectValidateSpec");
function b_(r3) {
  return [].concat(r3).sort((e, t3) => e.line - t3.line);
}
r(b_, "sortErrors");
function Gt(r3) {
  return function(...e) {
    return b_(r3.apply(this, e));
  };
}
r(Gt, "wrapCleanErrors");
q();
var Ne = Et;
var Bz = Ne.source;
var __ = Ne.light;
var Oz = Ne.terrain;
var Vz = Ne.filter;
var v_ = Ne.paintProperty;
var w_ = Ne.layoutProperty;
function ji(r3, e) {
  let t3 = false;
  if (e && e.length) for (let i of e) r3.fire(new Z(new Error(i.message))), t3 = true;
  return t3;
}
r(ji, "emitValidationErrors");
q();
q();
q();
var tl = class tl2 {
  constructor(e, t3, i) {
    let n = this.cells = [];
    if (e instanceof ArrayBuffer) {
      this.arrayBuffer = e;
      let a = new Int32Array(this.arrayBuffer);
      e = a[0], t3 = a[1], i = a[2], this.d = t3 + 2 * i;
      for (let c = 0; c < this.d * this.d; c++) {
        let p = a[3 + c], h = a[3 + c + 1];
        n.push(p === h ? null : a.subarray(p, h));
      }
      let s3 = a[3 + n.length], l = a[3 + n.length + 1];
      this.keys = a.subarray(s3, l), this.bboxes = a.subarray(l), this.insert = this._insertReadonly;
    } else {
      this.d = t3 + 2 * i;
      for (let a = 0; a < this.d * this.d; a++) n.push([]);
      this.keys = [], this.bboxes = [];
    }
    this.n = t3, this.extent = e, this.padding = i, this.scale = t3 / e, this.uid = 0;
    let o = i / t3 * e;
    this.min = -o, this.max = e + o;
  }
  insert(e, t3, i, n, o) {
    this._forEachCell(t3, i, n, o, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(t3), this.bboxes.push(i), this.bboxes.push(n), this.bboxes.push(o);
  }
  _insertReadonly() {
    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
  }
  _insertCell(e, t3, i, n, o, a) {
    this.cells[o].push(a);
  }
  query(e, t3, i, n, o) {
    let a = this.min, s3 = this.max;
    if (e <= a && t3 <= a && s3 <= i && s3 <= n && !o) return Array.prototype.slice.call(this.keys);
    {
      let l = [], c = {};
      return this._forEachCell(e, t3, i, n, this._queryCell, l, c, o), l;
    }
  }
  _queryCell(e, t3, i, n, o, a, s3, l) {
    let c = this.cells[o];
    if (c !== null) {
      let p = this.keys, h = this.bboxes;
      for (let f = 0; f < c.length; f++) {
        let m = c[f];
        if (s3[m] === void 0) {
          let y = m * 4;
          (l ? l(h[y + 0], h[y + 1], h[y + 2], h[y + 3]) : e <= h[y + 2] && t3 <= h[y + 3] && i >= h[y + 0] && n >= h[y + 1]) ? (s3[m] = true, a.push(p[m])) : s3[m] = false;
        }
      }
    }
  }
  _forEachCell(e, t3, i, n, o, a, s3, l) {
    let c = this._convertToCellCoord(e), p = this._convertToCellCoord(t3), h = this._convertToCellCoord(i), f = this._convertToCellCoord(n);
    for (let m = c; m <= h; m++) for (let y = p; y <= f; y++) {
      let g = this.d * y + m;
      if (!(l && !l(this._convertFromCellCoord(m), this._convertFromCellCoord(y), this._convertFromCellCoord(m + 1), this._convertFromCellCoord(y + 1))) && o.call(this, e, t3, i, n, g, a, s3, l)) return;
    }
  }
  _convertFromCellCoord(e) {
    return (e - this.padding) / this.scale;
  }
  _convertToCellCoord(e) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
  }
  toArrayBuffer() {
    if (this.arrayBuffer) return this.arrayBuffer;
    let e = this.cells, t3 = 3 + this.cells.length + 1 + 1, i = 0;
    for (let a = 0; a < this.cells.length; a++) i += this.cells[a].length;
    let n = new Int32Array(t3 + i + this.keys.length + this.bboxes.length);
    n[0] = this.extent, n[1] = this.n, n[2] = this.padding;
    let o = t3;
    for (let a = 0; a < e.length; a++) {
      let s3 = e[a];
      n[3 + a] = o, n.set(s3, o), o += s3.length;
    }
    return n[3 + e.length] = o, n.set(this.keys, o), o += this.keys.length, n[3 + e.length + 1] = o, n.set(this.bboxes, o), o += this.bboxes.length, n.buffer;
  }
  static serialize(e, t3) {
    let i = e.toArrayBuffer();
    return t3 && t3.push(i), { buffer: i };
  }
  static deserialize(e) {
    return new tl2(e.buffer);
  }
};
r(tl, "TransferableGridIndex");
var ri = tl;
var wr = {};
function N(r3, e, t3 = {}) {
  if (wr[r3]) throw new Error(`${r3} is already registered.`);
  Object.defineProperty(e, "_classRegistryKey", { value: r3, writeable: false }), wr[r3] = { klass: e, omit: t3.omit || [], shallow: t3.shallow || [] };
}
r(N, "register");
N("Object", Object);
N("TransferableGridIndex", ri);
N("Color", X);
N("Error", Error);
N("AJAXError", jr);
N("ResolvedImage", ft);
N("StylePropertyFunction", eo);
N("StyleExpression", Jr, { omit: ["_evaluator"] });
N("ZoomDependentExpression", vr);
N("ZoomConstantExpression", _r);
N("CompoundExpression", Ut, { omit: ["_evaluate"] });
for (let r3 in ei) ei[r3]._classRegistryKey || N(`Expression_${r3}`, ei[r3]);
function S_(r3) {
  return r3 && typeof ArrayBuffer < "u" && (r3 instanceof ArrayBuffer || r3.constructor && r3.constructor.name === "ArrayBuffer");
}
r(S_, "isArrayBuffer");
function Zi(r3, e) {
  if (r3 == null || typeof r3 == "boolean" || typeof r3 == "number" || typeof r3 == "string" || r3 instanceof Boolean || r3 instanceof Number || r3 instanceof String || r3 instanceof Date || r3 instanceof RegExp || r3 instanceof Blob || r3 instanceof Error) return r3;
  if (S_(r3) || ht(r3)) return e && e.push(r3), r3;
  if (ArrayBuffer.isView(r3)) {
    let t3 = r3;
    return e && e.push(t3.buffer), t3;
  }
  if (r3 instanceof ImageData) return e && e.push(r3.data.buffer), r3;
  if (Array.isArray(r3)) {
    let t3 = [];
    for (let i of r3) t3.push(Zi(i, e));
    return t3;
  }
  if (typeof r3 == "object") {
    let t3 = r3.constructor, i = t3._classRegistryKey;
    if (!i) throw new Error(`can't serialize object of unregistered class ${t3.name}`);
    if (!wr[i]) throw new Error(`${i} is not registered.`);
    let n = t3.serialize ? t3.serialize(r3, e) : {};
    if (t3.serialize) {
      if (e && n === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
    } else {
      for (let o in r3) {
        if (!r3.hasOwnProperty(o) || wr[i].omit.indexOf(o) >= 0) continue;
        let a = r3[o];
        n[o] = wr[i].shallow.indexOf(o) >= 0 ? a : Zi(a, e);
      }
      r3 instanceof Error && (n.message = r3.message);
    }
    if (n.$name) throw new Error("$name property is reserved for worker serialization logic.");
    return i !== "Object" && (n.$name = i), n;
  }
  throw new Error(`can't serialize object of type ${typeof r3}`);
}
r(Zi, "serialize");
function Hi(r3) {
  if (r3 == null || typeof r3 == "boolean" || typeof r3 == "number" || typeof r3 == "string" || r3 instanceof Boolean || r3 instanceof Number || r3 instanceof String || r3 instanceof Date || r3 instanceof RegExp || r3 instanceof Blob || r3 instanceof Error || S_(r3) || ht(r3) || ArrayBuffer.isView(r3) || r3 instanceof ImageData) return r3;
  if (Array.isArray(r3)) return r3.map(Hi);
  if (typeof r3 == "object") {
    let e = r3.$name || "Object";
    if (!wr[e]) throw new Error(`can't deserialize unregistered class ${e}`);
    let { klass: t3 } = wr[e];
    if (!t3) throw new Error(`can't deserialize unregistered class ${e}`);
    if (t3.deserialize) return t3.deserialize(r3);
    let i = Object.create(t3.prototype);
    for (let n of Object.keys(r3)) {
      if (n === "$name") continue;
      let o = r3[n];
      i[n] = wr[e].shallow.indexOf(n) >= 0 ? o : Hi(o);
    }
    return i;
  }
  throw new Error(`can't deserialize object of type ${typeof r3}`);
}
r(Hi, "deserialize");
q();
q();
var Sh = class Sh2 {
  constructor() {
    this.first = true;
  }
  update(e, t3) {
    let i = Math.floor(e);
    return this.first ? (this.first = false, this.lastIntegerZoom = i, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = i, true) : (this.lastFloorZoom > i ? (this.lastIntegerZoom = i + 1, this.lastIntegerZoomTime = t3) : this.lastFloorZoom < i && (this.lastIntegerZoom = i, this.lastIntegerZoomTime = t3), e !== this.lastZoom ? (this.lastZoom = e, this.lastFloorZoom = i, true) : false);
  }
};
r(Sh, "ZoomHistory");
var Wi = Sh;
q();
q();
var he = { "Latin-1 Supplement": (r3) => r3 >= 128 && r3 <= 255, Arabic: (r3) => r3 >= 1536 && r3 <= 1791, "Arabic Supplement": (r3) => r3 >= 1872 && r3 <= 1919, "Arabic Extended-A": (r3) => r3 >= 2208 && r3 <= 2303, "Hangul Jamo": (r3) => r3 >= 4352 && r3 <= 4607, "Unified Canadian Aboriginal Syllabics": (r3) => r3 >= 5120 && r3 <= 5759, Khmer: (r3) => r3 >= 6016 && r3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (r3) => r3 >= 6320 && r3 <= 6399, "General Punctuation": (r3) => r3 >= 8192 && r3 <= 8303, "Letterlike Symbols": (r3) => r3 >= 8448 && r3 <= 8527, "Number Forms": (r3) => r3 >= 8528 && r3 <= 8591, "Miscellaneous Technical": (r3) => r3 >= 8960 && r3 <= 9215, "Control Pictures": (r3) => r3 >= 9216 && r3 <= 9279, "Optical Character Recognition": (r3) => r3 >= 9280 && r3 <= 9311, "Enclosed Alphanumerics": (r3) => r3 >= 9312 && r3 <= 9471, "Geometric Shapes": (r3) => r3 >= 9632 && r3 <= 9727, "Miscellaneous Symbols": (r3) => r3 >= 9728 && r3 <= 9983, "Miscellaneous Symbols and Arrows": (r3) => r3 >= 11008 && r3 <= 11263, "CJK Radicals Supplement": (r3) => r3 >= 11904 && r3 <= 12031, "Kangxi Radicals": (r3) => r3 >= 12032 && r3 <= 12255, "Ideographic Description Characters": (r3) => r3 >= 12272 && r3 <= 12287, "CJK Symbols and Punctuation": (r3) => r3 >= 12288 && r3 <= 12351, Hiragana: (r3) => r3 >= 12352 && r3 <= 12447, Katakana: (r3) => r3 >= 12448 && r3 <= 12543, Bopomofo: (r3) => r3 >= 12544 && r3 <= 12591, "Hangul Compatibility Jamo": (r3) => r3 >= 12592 && r3 <= 12687, Kanbun: (r3) => r3 >= 12688 && r3 <= 12703, "Bopomofo Extended": (r3) => r3 >= 12704 && r3 <= 12735, "CJK Strokes": (r3) => r3 >= 12736 && r3 <= 12783, "Katakana Phonetic Extensions": (r3) => r3 >= 12784 && r3 <= 12799, "Enclosed CJK Letters and Months": (r3) => r3 >= 12800 && r3 <= 13055, "CJK Compatibility": (r3) => r3 >= 13056 && r3 <= 13311, "CJK Unified Ideographs Extension A": (r3) => r3 >= 13312 && r3 <= 19903, "Yijing Hexagram Symbols": (r3) => r3 >= 19904 && r3 <= 19967, "CJK Unified Ideographs": (r3) => r3 >= 19968 && r3 <= 40959, "Yi Syllables": (r3) => r3 >= 40960 && r3 <= 42127, "Yi Radicals": (r3) => r3 >= 42128 && r3 <= 42191, "Hangul Jamo Extended-A": (r3) => r3 >= 43360 && r3 <= 43391, "Hangul Syllables": (r3) => r3 >= 44032 && r3 <= 55215, "Hangul Jamo Extended-B": (r3) => r3 >= 55216 && r3 <= 55295, "Private Use Area": (r3) => r3 >= 57344 && r3 <= 63743, "CJK Compatibility Ideographs": (r3) => r3 >= 63744 && r3 <= 64255, "Arabic Presentation Forms-A": (r3) => r3 >= 64336 && r3 <= 65023, "Vertical Forms": (r3) => r3 >= 65040 && r3 <= 65055, "CJK Compatibility Forms": (r3) => r3 >= 65072 && r3 <= 65103, "Small Form Variants": (r3) => r3 >= 65104 && r3 <= 65135, "Arabic Presentation Forms-B": (r3) => r3 >= 65136 && r3 <= 65279, "Halfwidth and Fullwidth Forms": (r3) => r3 >= 65280 && r3 <= 65519 };
function Ph(r3) {
  for (let e of r3) if (P_(e.charCodeAt(0))) return true;
  return false;
}
r(Ph, "allowsVerticalWritingMode");
function P_(r3) {
  return r3 === 746 || r3 === 747 ? true : r3 < 4352 ? false : !!(he["Bopomofo Extended"](r3) || he.Bopomofo(r3) || he["CJK Compatibility Forms"](r3) && !(r3 >= 65097 && r3 <= 65103) || he["CJK Compatibility Ideographs"](r3) || he["CJK Compatibility"](r3) || he["CJK Radicals Supplement"](r3) || he["CJK Strokes"](r3) || he["CJK Symbols and Punctuation"](r3) && !(r3 >= 12296 && r3 <= 12305) && !(r3 >= 12308 && r3 <= 12319) && r3 !== 12336 || he["CJK Unified Ideographs Extension A"](r3) || he["CJK Unified Ideographs"](r3) || he["Enclosed CJK Letters and Months"](r3) || he["Hangul Compatibility Jamo"](r3) || he["Hangul Jamo Extended-A"](r3) || he["Hangul Jamo Extended-B"](r3) || he["Hangul Jamo"](r3) || he["Hangul Syllables"](r3) || he.Hiragana(r3) || he["Ideographic Description Characters"](r3) || he.Kanbun(r3) || he["Kangxi Radicals"](r3) || he["Katakana Phonetic Extensions"](r3) || he.Katakana(r3) && r3 !== 12540 || he["Halfwidth and Fullwidth Forms"](r3) && r3 !== 65288 && r3 !== 65289 && r3 !== 65293 && !(r3 >= 65306 && r3 <= 65310) && r3 !== 65339 && r3 !== 65341 && r3 !== 65343 && !(r3 >= 65371 && r3 <= 65503) && r3 !== 65507 && !(r3 >= 65512 && r3 <= 65519) || he["Small Form Variants"](r3) && !(r3 >= 65112 && r3 <= 65118) && !(r3 >= 65123 && r3 <= 65126) || he["Unified Canadian Aboriginal Syllabics"](r3) || he["Unified Canadian Aboriginal Syllabics Extended"](r3) || he["Vertical Forms"](r3) || he["Yijing Hexagram Symbols"](r3) || he["Yi Syllables"](r3) || he["Yi Radicals"](r3));
}
r(P_, "charHasUprightVerticalOrientation");
function T_(r3) {
  return r3 >= 1424 && r3 <= 2303 || he["Arabic Presentation Forms-A"](r3) || he["Arabic Presentation Forms-B"](r3);
}
r(T_, "charInRTLScript");
function tM(r3, e) {
  return !(!e && T_(r3) || r3 >= 2304 && r3 <= 3583 || r3 >= 3840 && r3 <= 4255 || he.Khmer(r3));
}
r(tM, "charInSupportedScript");
function M_(r3) {
  for (let e of r3) if (T_(e.charCodeAt(0))) return true;
  return false;
}
r(M_, "stringContainsRTLText");
function A_(r3, e) {
  for (let t3 of r3) if (!tM(t3.charCodeAt(0), e)) return false;
  return true;
}
r(A_, "isStringInSupportedScript");
q();
var Mh = class Mh2 {
  constructor() {
    this.applyArabicShaping = null;
    this.processBidirectionalText = null;
    this.processStyledBidirectionalText = null;
    this.pluginStatus = "unavailable";
    this.pluginURL = null;
  }
  setState(e) {
    this.pluginStatus = e.pluginStatus, this.pluginURL = e.pluginURL;
  }
  getState() {
    return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
  }
  setMethods(e) {
    this.applyArabicShaping = e.applyArabicShaping, this.processBidirectionalText = e.processBidirectionalText, this.processStyledBidirectionalText = e.processStyledBidirectionalText;
  }
  isParsed() {
    return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
  }
  getPluginURL() {
    return this.pluginURL;
  }
  getRTLTextPluginStatus() {
    return this.pluginStatus;
  }
};
r(Mh, "RTLWorkerPlugin");
var Th = Mh;
var nr = new Th();
var Ah = class Ah2 {
  constructor(e, t3) {
    this.zoom = e, t3 ? (this.now = t3.now, this.fadeDuration = t3.fadeDuration, this.zoomHistory = t3.zoomHistory, this.transition = t3.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wi(), this.transition = {});
  }
  isSupportedScript(e) {
    return A_(e, nr.getRTLTextPluginStatus() === "loaded");
  }
  crossFadingFactor() {
    return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
  }
  getCrossfadeParameters() {
    let e = this.zoom, t3 = e - Math.floor(e), i = this.crossFadingFactor();
    return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t3 + (1 - t3) * i } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * t3 };
  }
};
r(Ah, "EvaluationParameters");
var ye = Ah;
var Ih = class Ih2 {
  constructor(e, t3) {
    this.property = e, this.value = t3, this.expression = i_(t3 === void 0 ? e.specification.default : t3, e.specification);
  }
  isDataDriven() {
    return this.expression.kind === "source" || this.expression.kind === "composite";
  }
  possiblyEvaluate(e, t3, i) {
    return this.property.possiblyEvaluate(this, e, t3, i);
  }
};
r(Ih, "PropertyValue");
var Xi = Ih;
var Ch = class Ch2 {
  constructor(e) {
    this.property = e, this.value = new Xi(e, void 0);
  }
  transitioned(e, t3) {
    return new rl(this.property, this.value, t3, V({}, e.transition, this.transition), e.now);
  }
  untransitioned() {
    return new rl(this.property, this.value, null, {}, 0);
  }
};
r(Ch, "TransitionablePropertyValue");
var ao = Ch;
var Eh = class Eh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
  }
  getValue(e) {
    return pt(this._values[e].value.value);
  }
  setValue(e, t3) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ao(this._values[e].property)), this._values[e].value = new Xi(this._values[e].property, t3 === null ? void 0 : pt(t3));
  }
  getTransition(e) {
    return pt(this._values[e].transition);
  }
  setTransition(e, t3) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ao(this._values[e].property)), this._values[e].transition = pt(t3) || void 0;
  }
  serialize() {
    let e = {};
    for (let t3 of Object.keys(this._values)) {
      let i = this.getValue(t3);
      i !== void 0 && (e[t3] = i);
      let n = this.getTransition(t3);
      n !== void 0 && (e[`${t3}-transition`] = n);
    }
    return e;
  }
  transitioned(e, t3) {
    let i = new il(this._properties);
    for (let n of Object.keys(this._values)) i._values[n] = this._values[n].transitioned(e, t3._values[n]);
    return i;
  }
  untransitioned() {
    let e = new il(this._properties);
    for (let t3 of Object.keys(this._values)) e._values[t3] = this._values[t3].untransitioned();
    return e;
  }
};
r(Eh, "Transitionable");
var Ki = Eh;
var kh = class kh2 {
  constructor(e, t3, i, n, o) {
    this.property = e, this.value = t3, this.begin = o + n.delay || 0, this.end = this.begin + n.duration || 0, e.specification.transition && (n.delay || n.duration) && (this.prior = i);
  }
  possiblyEvaluate(e, t3, i) {
    let n = e.now || 0, o = this.value.possiblyEvaluate(e, t3, i), a = this.prior;
    if (a) {
      if (n > this.end) return this.prior = null, o;
      if (this.value.isDataDriven()) return this.prior = null, o;
      if (n < this.begin) return a.possiblyEvaluate(e, t3, i);
      {
        let s3 = (n - this.begin) / (this.end - this.begin);
        return this.property.interpolate(a.possiblyEvaluate(e, t3, i), o, Hx(s3));
      }
    } else return o;
  }
};
r(kh, "TransitioningPropertyValue");
var rl = kh;
var Lh = class Lh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
  }
  possiblyEvaluate(e, t3, i) {
    let n = new Sr(this._properties);
    for (let o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(e, t3, i);
    return n;
  }
  hasTransition() {
    for (let e of Object.keys(this._values)) if (this._values[e].prior) return true;
    return false;
  }
};
r(Lh, "Transitioning");
var il = Lh;
var Dh = class Dh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPropertyValues);
  }
  hasValue(e) {
    return this._values[e].value !== void 0;
  }
  getValue(e) {
    return pt(this._values[e].value);
  }
  setValue(e, t3) {
    this._values[e] = new Xi(this._values[e].property, t3 === null ? void 0 : pt(t3));
  }
  serialize() {
    let e = {};
    for (let t3 of Object.keys(this._values)) {
      let i = this.getValue(t3);
      i !== void 0 && (e[t3] = i);
    }
    return e;
  }
  possiblyEvaluate(e, t3, i) {
    let n = new Sr(this._properties);
    for (let o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(e, t3, i);
    return n;
  }
};
r(Dh, "Layout");
var nl = Dh;
var zh = class zh2 {
  constructor(e, t3, i) {
    this.property = e, this.value = t3, this.parameters = i;
  }
  isConstant() {
    return this.value.kind === "constant";
  }
  constantOr(e) {
    return this.value.kind === "constant" ? this.value.value : e;
  }
  evaluate(e, t3, i, n) {
    return this.property.evaluate(this.value, this.parameters, e, t3, i, n);
  }
};
r(zh, "PossiblyEvaluatedPropertyValue");
var at = zh;
var Fh = class Fh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
  }
  get(e) {
    return this._values[e];
  }
};
r(Fh, "PossiblyEvaluated");
var Sr = Fh;
var Rh = class Rh2 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t3) {
    if (e.isDataDriven()) throw new Error("Value should not be data driven");
    return e.expression.evaluate(t3);
  }
  interpolate(e, t3, i) {
    let n = this.specification.type, o = Pe[n];
    return o ? o(e, t3, i) : e;
  }
};
r(Rh, "DataConstantProperty");
var j = Rh;
var Bh = class Bh2 {
  constructor(e, t3) {
    this.specification = e, this.overrides = t3;
  }
  possiblyEvaluate(e, t3, i, n) {
    return e.expression.kind === "constant" || e.expression.kind === "camera" ? new at(this, { kind: "constant", value: e.expression.evaluate(t3, null, {}, i, n) }, t3) : new at(this, e.expression, t3);
  }
  interpolate(e, t3, i) {
    if (e.value.kind !== "constant" || t3.value.kind !== "constant") return e;
    if (e.value.value === void 0 || t3.value.value === void 0) return new at(this, { kind: "constant", value: void 0 }, e.parameters);
    let n = this.specification.type, o = Pe[n];
    if (o) {
      let a = o(e.value.value, t3.value.value, i);
      return new at(this, { kind: "constant", value: a }, e.parameters);
    } else return e;
  }
  evaluate(e, t3, i, n, o, a) {
    return e.kind === "constant" ? e.value : e.evaluate(t3, i, n, o, a);
  }
};
r(Bh, "DataDrivenProperty");
var H = Bh;
var Oh = class Oh2 extends H {
  possiblyEvaluate(e, t3, i, n) {
    if (e.value === void 0) return new at(this, { kind: "constant", value: void 0 }, t3);
    if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(t3, null, {}, i, n), s3 = e.property.specification.type === "resolvedImage" && typeof o != "string" ? o.name : o, l = this._calculate(s3, s3, s3, t3);
      return new at(this, { kind: "constant", value: l }, t3);
    } else if (e.expression.kind === "camera") {
      let o = this._calculate(e.expression.evaluate({ zoom: t3.zoom - 1 }), e.expression.evaluate({ zoom: t3.zoom }), e.expression.evaluate({ zoom: t3.zoom + 1 }), t3);
      return new at(this, { kind: "constant", value: o }, t3);
    } else return new at(this, e.expression, t3);
  }
  evaluate(e, t3, i, n, o, a) {
    if (e.kind === "source") {
      let s3 = e.evaluate(t3, i, n, o, a);
      return this._calculate(s3, s3, s3, t3);
    } else return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(t3.zoom) - 1 }, i, n), e.evaluate({ zoom: Math.floor(t3.zoom) }, i, n), e.evaluate({ zoom: Math.floor(t3.zoom) + 1 }, i, n), t3) : e.value;
  }
  _calculate(e, t3, i, n) {
    return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t3 } : { from: i, to: t3 };
  }
  interpolate(e) {
    return e;
  }
};
r(Oh, "CrossFadedDataDrivenProperty");
var or = Oh;
var Vh = class Vh2 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t3, i, n) {
    if (e.value !== void 0) if (e.expression.kind === "constant") {
      let o = e.expression.evaluate(t3, null, {}, i, n);
      return this._calculate(o, o, o, t3);
    } else return this._calculate(e.expression.evaluate(new ye(Math.floor(t3.zoom - 1), t3)), e.expression.evaluate(new ye(Math.floor(t3.zoom), t3)), e.expression.evaluate(new ye(Math.floor(t3.zoom + 1), t3)), t3);
  }
  _calculate(e, t3, i, n) {
    return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: e, to: t3 } : { from: i, to: t3 };
  }
  interpolate(e) {
    return e;
  }
};
r(Vh, "CrossFadedProperty");
var ii = Vh;
var Uh = class Uh2 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t3, i, n) {
    return !!e.expression.evaluate(t3, null, {}, i, n);
  }
  interpolate() {
    return false;
  }
};
r(Uh, "ColorRampProperty");
var ni = Uh;
var Nh = class Nh2 {
  constructor(e) {
    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
    for (let t3 in e) {
      let i = e[t3];
      i.specification.overridable && this.overridableProperties.push(t3);
      let n = this.defaultPropertyValues[t3] = new Xi(i, void 0), o = this.defaultTransitionablePropertyValues[t3] = new ao(i);
      this.defaultTransitioningPropertyValues[t3] = o.untransitioned(), this.defaultPossiblyEvaluatedValues[t3] = n.possiblyEvaluate({});
    }
  }
};
r(Nh, "Properties");
var De = Nh;
N("DataDrivenProperty", H);
N("DataConstantProperty", j);
N("CrossFadedDataDrivenProperty", or);
N("CrossFadedProperty", ii);
N("ColorRampProperty", ni);
var ol = "-transition";
var Gh = class Gh2 extends de {
  constructor(e, t3) {
    if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => true, needGeometry: false }, e.type !== "custom" && (e = e, this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t3.layout && (this._unevaluatedLayout = new nl(t3.layout)), t3.paint)) {
      this._transitionablePaint = new Ki(t3.paint);
      for (let i in e.paint) this.setPaintProperty(i, e.paint[i], { validate: false });
      for (let i in e.layout) this.setLayoutProperty(i, e.layout[i], { validate: false });
      this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Sr(t3.paint);
    }
  }
  getCrossfadeParameters() {
    return this._crossfadeParameters;
  }
  getLayoutProperty(e) {
    return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
  }
  setLayoutProperty(e, t3, i = {}) {
    if (t3 != null) {
      let n = `layers.${this.id}.layout.${e}`;
      if (this._validate(w_, n, e, t3, i)) return;
    }
    if (e === "visibility") {
      this.visibility = t3;
      return;
    }
    this._unevaluatedLayout.setValue(e, t3);
  }
  getPaintProperty(e) {
    return e.endsWith(ol) ? this._transitionablePaint.getTransition(e.slice(0, -ol.length)) : this._transitionablePaint.getValue(e);
  }
  setPaintProperty(e, t3, i = {}) {
    if (t3 != null) {
      let n = `layers.${this.id}.paint.${e}`;
      if (this._validate(v_, n, e, t3, i)) return false;
    }
    if (e.endsWith(ol)) return this._transitionablePaint.setTransition(e.slice(0, -ol.length), t3 || void 0), false;
    {
      let n = this._transitionablePaint._values[e], o = n.property.specification["property-type"] === "cross-faded-data-driven", a = n.value.isDataDriven(), s3 = n.value;
      this._transitionablePaint.setValue(e, t3), this._handleSpecialPaintPropertyUpdate(e);
      let l = this._transitionablePaint._values[e].value;
      return l.isDataDriven() || a || o || this._handleOverridablePaintPropertyUpdate(e, s3, l);
    }
  }
  _handleSpecialPaintPropertyUpdate(e) {
  }
  _handleOverridablePaintPropertyUpdate(e, t3, i) {
    return false;
  }
  isHidden(e) {
    return this.minzoom && e < this.minzoom || this.maxzoom && e >= this.maxzoom ? true : this.visibility === "none";
  }
  updateTransitions(e) {
    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
  }
  hasTransition() {
    return this._transitioningPaint.hasTransition();
  }
  recalculate(e, t3) {
    e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t3)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t3);
  }
  serialize() {
    let e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
    return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), is(e, (t3, i) => t3 !== void 0 && !(i === "layout" && !Object.keys(t3).length) && !(i === "paint" && !Object.keys(t3).length));
  }
  _validate(e, t3, i, n, o = {}) {
    return o && o.validate === false ? false : ji(this, e.call(Ne, { key: t3, layerType: this.type, objectKey: i, value: n, styleSpec: A, style: { glyphs: true, sprite: true } }));
  }
  is3D() {
    return false;
  }
  isTileClipped() {
    return false;
  }
  hasOffscreenPass() {
    return false;
  }
  resize() {
  }
  isStateDependent() {
    for (let e in this.paint._values) {
      let t3 = this.paint.get(e);
      if (!(!(t3 instanceof at) || !br(t3.property.specification)) && (t3.value.kind === "source" || t3.value.kind === "composite") && t3.value.isStateDependent) return true;
    }
    return false;
  }
};
r(Gh, "StyleLayer");
var Ge = Gh;
q();
q();
q();
var rM = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
var $h = class $h2 {
  constructor(e, t3) {
    this._structArray = e, this._pos1 = t3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
  }
};
r($h, "Struct");
var Pr = $h;
var iM = 128;
var nM = 5;
var qh = class qh2 {
  constructor() {
    this.isTransferred = false, this.capacity = -1, this.resize(0);
  }
  static serialize(e, t3) {
    return e._trim(), t3 && (e.isTransferred = true, t3.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
  }
  static deserialize(e) {
    let t3 = Object.create(this.prototype);
    return t3.arrayBuffer = e.arrayBuffer, t3.length = e.length, t3.capacity = e.arrayBuffer.byteLength / t3.bytesPerElement, t3._refreshViews(), t3;
  }
  _trim() {
    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  resize(e) {
    this.reserve(e), this.length = e;
  }
  reserve(e) {
    if (e > this.capacity) {
      this.capacity = Math.max(e, Math.floor(this.capacity * nM), iM), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
      let t3 = this.uint8;
      this._refreshViews(), t3 && this.uint8.set(t3);
    }
  }
  _refreshViews() {
    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
  }
};
r(qh, "StructArray");
var ze = qh;
function _e(r3, e = 1) {
  let t3 = 0, i = 0, n = r3.map((a) => {
    let s3 = oM(a.type), l = t3 = I_(t3, Math.max(e, s3)), c = a.components || 1;
    return i = Math.max(i, s3), t3 += s3 * c, { name: a.name, type: a.type, components: c, offset: l };
  }), o = I_(t3, Math.max(i, e));
  return { members: n, size: o, alignment: e };
}
r(_e, "createLayout");
function oM(r3) {
  return rM[r3].BYTES_PER_ELEMENT;
}
r(oM, "sizeOf");
function I_(r3, e) {
  return Math.ceil(r3 / e) * e;
}
r(I_, "align");
var C_ = u(ge(), 1);
var jh = class jh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t3);
  }
  emplace(e, t3, i) {
    let n = e * 2;
    return this.int16[n + 0] = t3, this.int16[n + 1] = i, e;
  }
};
r(jh, "StructArrayLayout2i4");
var oi = jh;
oi.prototype.bytesPerElement = 4;
N("StructArrayLayout2i4", oi);
var Zh = class Zh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t3, i);
  }
  emplace(e, t3, i, n) {
    let o = e * 3;
    return this.int16[o + 0] = t3, this.int16[o + 1] = i, this.int16[o + 2] = n, e;
  }
};
r(Zh, "StructArrayLayout3i6");
var Ji = Zh;
Ji.prototype.bytesPerElement = 6;
N("StructArrayLayout3i6", Ji);
var Hh = class Hh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t3, i, n);
  }
  emplace(e, t3, i, n, o) {
    let a = e * 4;
    return this.int16[a + 0] = t3, this.int16[a + 1] = i, this.int16[a + 2] = n, this.int16[a + 3] = o, e;
  }
};
r(Hh, "StructArrayLayout4i8");
var so = Hh;
so.prototype.bytesPerElement = 8;
N("StructArrayLayout4i8", so);
var Wh = class Wh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t3, i, n, o, a);
  }
  emplace(e, t3, i, n, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = t3, this.int16[l + 1] = i, this.int16[l + 2] = n, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
r(Wh, "StructArrayLayout2i4i12");
var lo = Wh;
lo.prototype.bytesPerElement = 12;
N("StructArrayLayout2i4i12", lo);
var Xh = class Xh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t3, i, n, o, a);
  }
  emplace(e, t3, i, n, o, a, s3) {
    let l = e * 4, c = e * 8;
    return this.int16[l + 0] = t3, this.int16[l + 1] = i, this.uint8[c + 4] = n, this.uint8[c + 5] = o, this.uint8[c + 6] = a, this.uint8[c + 7] = s3, e;
  }
};
r(Xh, "StructArrayLayout2i4ub8");
var uo = Xh;
uo.prototype.bytesPerElement = 8;
N("StructArrayLayout2i4ub8", uo);
var Kh = class Kh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t3);
  }
  emplace(e, t3, i) {
    let n = e * 2;
    return this.float32[n + 0] = t3, this.float32[n + 1] = i, e;
  }
};
r(Kh, "StructArrayLayout2f8");
var Tr = Kh;
Tr.prototype.bytesPerElement = 8;
N("StructArrayLayout2f8", Tr);
var Jh = class Jh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a, s3, l, c, p) {
    let h = this.length;
    return this.resize(h + 1), this.emplace(h, e, t3, i, n, o, a, s3, l, c, p);
  }
  emplace(e, t3, i, n, o, a, s3, l, c, p, h) {
    let f = e * 10;
    return this.uint16[f + 0] = t3, this.uint16[f + 1] = i, this.uint16[f + 2] = n, this.uint16[f + 3] = o, this.uint16[f + 4] = a, this.uint16[f + 5] = s3, this.uint16[f + 6] = l, this.uint16[f + 7] = c, this.uint16[f + 8] = p, this.uint16[f + 9] = h, e;
  }
};
r(Jh, "StructArrayLayout10ui20");
var co = Jh;
co.prototype.bytesPerElement = 20;
N("StructArrayLayout10ui20", co);
var Yh = class Yh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a, s3, l, c, p, h, f) {
    let m = this.length;
    return this.resize(m + 1), this.emplace(m, e, t3, i, n, o, a, s3, l, c, p, h, f);
  }
  emplace(e, t3, i, n, o, a, s3, l, c, p, h, f, m) {
    let y = e * 12;
    return this.int16[y + 0] = t3, this.int16[y + 1] = i, this.int16[y + 2] = n, this.int16[y + 3] = o, this.uint16[y + 4] = a, this.uint16[y + 5] = s3, this.uint16[y + 6] = l, this.uint16[y + 7] = c, this.int16[y + 8] = p, this.int16[y + 9] = h, this.int16[y + 10] = f, this.int16[y + 11] = m, e;
  }
};
r(Yh, "StructArrayLayout4i4ui4i24");
var po = Yh;
po.prototype.bytesPerElement = 24;
N("StructArrayLayout4i4ui4i24", po);
var Qh = class Qh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t3, i);
  }
  emplace(e, t3, i, n) {
    let o = e * 3;
    return this.float32[o + 0] = t3, this.float32[o + 1] = i, this.float32[o + 2] = n, e;
  }
};
r(Qh, "StructArrayLayout3f12");
var ho = Qh;
ho.prototype.bytesPerElement = 12;
N("StructArrayLayout3f12", ho);
var ef = class ef2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e);
  }
  emplace(e, t3) {
    let i = e * 1;
    return this.uint32[i + 0] = t3, e;
  }
};
r(ef, "StructArrayLayout1ul4");
var fo = ef;
fo.prototype.bytesPerElement = 4;
N("StructArrayLayout1ul4", fo);
var tf = class tf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a, s3, l, c) {
    let p = this.length;
    return this.resize(p + 1), this.emplace(p, e, t3, i, n, o, a, s3, l, c);
  }
  emplace(e, t3, i, n, o, a, s3, l, c, p) {
    let h = e * 10, f = e * 5;
    return this.int16[h + 0] = t3, this.int16[h + 1] = i, this.int16[h + 2] = n, this.int16[h + 3] = o, this.int16[h + 4] = a, this.int16[h + 5] = s3, this.uint32[f + 3] = l, this.uint16[h + 8] = c, this.uint16[h + 9] = p, e;
  }
};
r(tf, "StructArrayLayout6i1ul2ui20");
var mo = tf;
mo.prototype.bytesPerElement = 20;
N("StructArrayLayout6i1ul2ui20", mo);
var rf = class rf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e, t3, i, n, o, a);
  }
  emplace(e, t3, i, n, o, a, s3) {
    let l = e * 6;
    return this.int16[l + 0] = t3, this.int16[l + 1] = i, this.int16[l + 2] = n, this.int16[l + 3] = o, this.int16[l + 4] = a, this.int16[l + 5] = s3, e;
  }
};
r(rf, "StructArrayLayout2i2i2i12");
var yo = rf;
yo.prototype.bytesPerElement = 12;
N("StructArrayLayout2i2i2i12", yo);
var nf = class nf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e, t3, i, n, o);
  }
  emplace(e, t3, i, n, o, a) {
    let s3 = e * 4, l = e * 8;
    return this.float32[s3 + 0] = t3, this.float32[s3 + 1] = i, this.float32[s3 + 2] = n, this.int16[l + 6] = o, this.int16[l + 7] = a, e;
  }
};
r(nf, "StructArrayLayout2f1f2i16");
var go = nf;
go.prototype.bytesPerElement = 16;
N("StructArrayLayout2f1f2i16", go);
var of = class of2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t3, i, n);
  }
  emplace(e, t3, i, n, o) {
    let a = e * 12, s3 = e * 3;
    return this.uint8[a + 0] = t3, this.uint8[a + 1] = i, this.float32[s3 + 1] = n, this.float32[s3 + 2] = o, e;
  }
};
r(of, "StructArrayLayout2ub2f12");
var xo = of;
xo.prototype.bytesPerElement = 12;
N("StructArrayLayout2ub2f12", xo);
var af = class af2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t3, i);
  }
  emplace(e, t3, i, n) {
    let o = e * 3;
    return this.uint16[o + 0] = t3, this.uint16[o + 1] = i, this.uint16[o + 2] = n, e;
  }
};
r(af, "StructArrayLayout3ui6");
var Yi = af;
Yi.prototype.bytesPerElement = 6;
N("StructArrayLayout3ui6", Yi);
var sf = class sf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b) {
    let w = this.length;
    return this.resize(w + 1), this.emplace(w, e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b);
  }
  emplace(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b, w) {
    let _ = e * 24, S = e * 12, P = e * 48;
    return this.int16[_ + 0] = t3, this.int16[_ + 1] = i, this.uint16[_ + 2] = n, this.uint16[_ + 3] = o, this.uint32[S + 2] = a, this.uint32[S + 3] = s3, this.uint32[S + 4] = l, this.uint16[_ + 10] = c, this.uint16[_ + 11] = p, this.uint16[_ + 12] = h, this.float32[S + 7] = f, this.float32[S + 8] = m, this.uint8[P + 36] = y, this.uint8[P + 37] = g, this.uint8[P + 38] = x, this.uint32[S + 10] = b, this.int16[_ + 22] = w, e;
  }
};
r(sf, "StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48");
var bo = sf;
bo.prototype.bytesPerElement = 48;
N("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", bo);
var lf = class lf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b, w, _, S, P, T, L, C, E, I, R, z) {
    let k = this.length;
    return this.resize(k + 1), this.emplace(k, e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b, w, _, S, P, T, L, C, E, I, R, z);
  }
  emplace(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b, w, _, S, P, T, L, C, E, I, R, z, k) {
    let M = e * 32, G = e * 16;
    return this.int16[M + 0] = t3, this.int16[M + 1] = i, this.int16[M + 2] = n, this.int16[M + 3] = o, this.int16[M + 4] = a, this.int16[M + 5] = s3, this.int16[M + 6] = l, this.int16[M + 7] = c, this.uint16[M + 8] = p, this.uint16[M + 9] = h, this.uint16[M + 10] = f, this.uint16[M + 11] = m, this.uint16[M + 12] = y, this.uint16[M + 13] = g, this.uint16[M + 14] = x, this.uint16[M + 15] = b, this.uint16[M + 16] = w, this.uint16[M + 17] = _, this.uint16[M + 18] = S, this.uint16[M + 19] = P, this.uint16[M + 20] = T, this.uint16[M + 21] = L, this.uint16[M + 22] = C, this.uint32[G + 12] = E, this.float32[G + 13] = I, this.float32[G + 14] = R, this.uint16[M + 30] = z, this.uint16[M + 31] = k, e;
  }
};
r(lf, "StructArrayLayout8i15ui1ul2f2ui64");
var _o = lf;
_o.prototype.bytesPerElement = 64;
N("StructArrayLayout8i15ui1ul2f2ui64", _o);
var uf = class uf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e);
  }
  emplace(e, t3) {
    let i = e * 1;
    return this.float32[i + 0] = t3, e;
  }
};
r(uf, "StructArrayLayout1f4");
var ai = uf;
ai.prototype.bytesPerElement = 4;
N("StructArrayLayout1f4", ai);
var cf = class cf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t3, i);
  }
  emplace(e, t3, i, n) {
    let o = e * 6, a = e * 3;
    return this.uint16[o + 0] = t3, this.float32[a + 1] = i, this.float32[a + 2] = n, e;
  }
};
r(cf, "StructArrayLayout1ui2f12");
var vo = cf;
vo.prototype.bytesPerElement = 12;
N("StructArrayLayout1ui2f12", vo);
var pf = class pf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e, t3, i);
  }
  emplace(e, t3, i, n) {
    let o = e * 2, a = e * 4;
    return this.uint32[o + 0] = t3, this.uint16[a + 2] = i, this.uint16[a + 3] = n, e;
  }
};
r(pf, "StructArrayLayout1ul2ui8");
var wo = pf;
wo.prototype.bytesPerElement = 8;
N("StructArrayLayout1ul2ui8", wo);
var hf = class hf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t3) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t3);
  }
  emplace(e, t3, i) {
    let n = e * 2;
    return this.uint16[n + 0] = t3, this.uint16[n + 1] = i, e;
  }
};
r(hf, "StructArrayLayout2ui4");
var So = hf;
So.prototype.bytesPerElement = 4;
N("StructArrayLayout2ui4", So);
var ff = class ff2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e);
  }
  emplace(e, t3) {
    let i = e * 1;
    return this.uint16[i + 0] = t3, e;
  }
};
r(ff, "StructArrayLayout1ui2");
var Po = ff;
Po.prototype.bytesPerElement = 2;
N("StructArrayLayout1ui2", Po);
var mf = class mf2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t3, i, n) {
    let o = this.length;
    return this.resize(o + 1), this.emplace(o, e, t3, i, n);
  }
  emplace(e, t3, i, n, o) {
    let a = e * 4;
    return this.float32[a + 0] = t3, this.float32[a + 1] = i, this.float32[a + 2] = n, this.float32[a + 3] = o, e;
  }
};
r(mf, "StructArrayLayout4f16");
var Qi = mf;
Qi.prototype.bytesPerElement = 16;
N("StructArrayLayout4f16", Qi);
var df = class df2 extends Pr {
  get anchorPointX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorPointY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get x1() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get y1() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get x2() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get y2() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get anchorPoint() {
    return new C_.default(this.anchorPointX, this.anchorPointY);
  }
};
r(df, "CollisionBoxStruct");
var al = df;
al.prototype.size = 20;
var yf = class yf2 extends mo {
  get(e) {
    return new al(this, e);
  }
};
r(yf, "CollisionBoxArray");
var To = yf;
N("CollisionBoxArray", To);
var gf = class gf2 extends Pr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get glyphStartIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get numGlyphs() {
    return this._structArray.uint16[this._pos2 + 3];
  }
  get vertexStartIndex() {
    return this._structArray.uint32[this._pos4 + 2];
  }
  get lineStartIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get lineLength() {
    return this._structArray.uint32[this._pos4 + 4];
  }
  get segment() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get lowerSize() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get upperSize() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get lineOffsetX() {
    return this._structArray.float32[this._pos4 + 7];
  }
  get lineOffsetY() {
    return this._structArray.float32[this._pos4 + 8];
  }
  get writingMode() {
    return this._structArray.uint8[this._pos1 + 36];
  }
  get placedOrientation() {
    return this._structArray.uint8[this._pos1 + 37];
  }
  set placedOrientation(e) {
    this._structArray.uint8[this._pos1 + 37] = e;
  }
  get hidden() {
    return this._structArray.uint8[this._pos1 + 38];
  }
  set hidden(e) {
    this._structArray.uint8[this._pos1 + 38] = e;
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 10];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 10] = e;
  }
  get associatedIconIndex() {
    return this._structArray.int16[this._pos2 + 22];
  }
};
r(gf, "PlacedSymbolStruct");
var sl = gf;
sl.prototype.size = 48;
var xf = class xf2 extends bo {
  get(e) {
    return new sl(this, e);
  }
};
r(xf, "PlacedSymbolArray");
var Mo = xf;
N("PlacedSymbolArray", Mo);
var bf = class bf2 extends Pr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get rightJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get centerJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get leftJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get verticalPlacedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get placedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 6];
  }
  get verticalPlacedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 7];
  }
  get key() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get textBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get textBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get verticalTextBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get verticalTextBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get iconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 13];
  }
  get iconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 14];
  }
  get verticalIconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 15];
  }
  get verticalIconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 16];
  }
  get featureIndex() {
    return this._structArray.uint16[this._pos2 + 17];
  }
  get numHorizontalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 18];
  }
  get numVerticalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 19];
  }
  get numIconVertices() {
    return this._structArray.uint16[this._pos2 + 20];
  }
  get numVerticalIconVertices() {
    return this._structArray.uint16[this._pos2 + 21];
  }
  get useRuntimeCollisionCircles() {
    return this._structArray.uint16[this._pos2 + 22];
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 12];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 12] = e;
  }
  get textBoxScale() {
    return this._structArray.float32[this._pos4 + 13];
  }
  get collisionCircleDiameter() {
    return this._structArray.float32[this._pos4 + 14];
  }
  get textAnchorOffsetStartIndex() {
    return this._structArray.uint16[this._pos2 + 30];
  }
  get textAnchorOffsetEndIndex() {
    return this._structArray.uint16[this._pos2 + 31];
  }
};
r(bf, "SymbolInstanceStruct");
var ll = bf;
ll.prototype.size = 64;
var _f = class _f2 extends _o {
  get(e) {
    return new ll(this, e);
  }
};
r(_f, "SymbolInstanceArray");
var Ao = _f;
N("SymbolInstanceArray", Ao);
var vf = class vf2 extends ai {
  getoffsetX(e) {
    return this.float32[e * 1 + 0];
  }
};
r(vf, "GlyphOffsetArray");
var Io = vf;
N("GlyphOffsetArray", Io);
var wf = class wf2 extends Ji {
  getx(e) {
    return this.int16[e * 3 + 0];
  }
  gety(e) {
    return this.int16[e * 3 + 1];
  }
  gettileUnitDistanceFromAnchor(e) {
    return this.int16[e * 3 + 2];
  }
};
r(wf, "SymbolLineVertexArray");
var Co = wf;
N("SymbolLineVertexArray", Co);
var Sf = class Sf2 extends Pr {
  get textAnchor() {
    return this._structArray.uint16[this._pos2 + 0];
  }
  get textOffset0() {
    return this._structArray.float32[this._pos4 + 1];
  }
  get textOffset1() {
    return this._structArray.float32[this._pos4 + 2];
  }
};
r(Sf, "TextAnchorOffsetStruct");
var ul = Sf;
ul.prototype.size = 12;
var Pf = class Pf2 extends vo {
  get(e) {
    return new ul(this, e);
  }
};
r(Pf, "TextAnchorOffsetArray");
var Eo = Pf;
N("TextAnchorOffsetArray", Eo);
var Tf = class Tf2 extends Pr {
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 0];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 3];
  }
};
r(Tf, "FeatureIndexStruct");
var cl = Tf;
cl.prototype.size = 8;
var Mf = class Mf2 extends wo {
  get(e) {
    return new cl(this, e);
  }
};
r(Mf, "FeatureIndexArray");
var ko = Mf;
N("FeatureIndexArray", ko);
var Af = class Af2 extends oi {
};
r(Af, "PosArray");
var Mr = Af;
var If = class If2 extends Ji {
};
r(If, "Pos3dArray");
var pl = If;
var Cf = class Cf2 extends so {
};
r(Cf, "RasterBoundsArray");
var en = Cf;
var Ef = class Ef2 extends oi {
};
r(Ef, "CircleLayoutArray");
var hl = Ef;
var kf = class kf2 extends oi {
};
r(kf, "FillLayoutArray");
var fl = kf;
var Lf = class Lf2 extends lo {
};
r(Lf, "FillExtrusionLayoutArray");
var ml = Lf;
var Df = class Df2 extends uo {
};
r(Df, "LineLayoutArray");
var dl = Df;
var zf = class zf2 extends Tr {
};
r(zf, "LineExtLayoutArray");
var yl = zf;
var Ff = class Ff2 extends co {
};
r(Ff, "PatternLayoutArray");
var ar = Ff;
var Rf = class Rf2 extends po {
};
r(Rf, "SymbolLayoutArray");
var gl = Rf;
var Bf = class Bf2 extends ho {
};
r(Bf, "SymbolDynamicLayoutArray");
var xl = Bf;
var Of = class Of2 extends fo {
};
r(Of, "SymbolOpacityArray");
var bl = Of;
var Vf = class Vf2 extends yo {
};
r(Vf, "CollisionBoxLayoutArray");
var Lo = Vf;
var Uf = class Uf2 extends go {
};
r(Uf, "CollisionCircleLayoutArray");
var _l = Uf;
var Nf = class Nf2 extends xo {
};
r(Nf, "CollisionVertexArray");
var vl = Nf;
var Gf = class Gf2 extends Yi {
};
r(Gf, "QuadTriangleArray");
var wl = Gf;
var $f = class $f2 extends Yi {
};
r($f, "TriangleIndexArray");
var rt = $f;
var qf = class qf2 extends So {
};
r(qf, "LineIndexArray");
var Ar = qf;
var jf = class jf2 extends Po {
};
r(jf, "LineStripIndexArray");
var Do = jf;
q();
var aM = _e([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: E_, size: YF, alignment: QF } = aM;
q();
var si = class si2 {
  constructor(e = []) {
    this.segments = e;
  }
  prepareSegment(e, t3, i, n) {
    let o = this.segments[this.segments.length - 1];
    return e > si2.MAX_VERTEX_ARRAY_LENGTH && ke(`Max vertices per segment is ${si2.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!o || o.vertexLength + e > si2.MAX_VERTEX_ARRAY_LENGTH || o.sortKey !== n) && (o = { vertexOffset: t3.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0 }, n !== void 0 && (o.sortKey = n), this.segments.push(o)), o;
  }
  get() {
    return this.segments;
  }
  destroy() {
    for (let e of this.segments) for (let t3 in e.vaos) e.vaos[t3].destroy();
  }
  static simpleSegment(e, t3, i, n) {
    return new si2([{ vertexOffset: e, primitiveOffset: t3, vertexLength: i, primitiveLength: n, vaos: {}, sortKey: 0 }]);
  }
};
r(si, "SegmentVector");
var me = si;
me.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
N("SegmentVector", me);
q();
q();
function Zf(r3, e) {
  return r3 = Ae(Math.floor(r3), 0, 255), e = Ae(Math.floor(e), 0, 255), 256 * r3 + e;
}
r(Zf, "packUint8ToFloat");
q();
var zo = _e([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
q();
var F_ = u(Xf(), 1);
var Tl = class Tl2 {
  constructor() {
    this.ids = [], this.positions = [], this.indexed = false;
  }
  add(e, t3, i, n) {
    this.ids.push(z_(e)), this.positions.push(t3, i, n);
  }
  getPositions(e) {
    if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
    let t3 = z_(e), i = 0, n = this.ids.length - 1;
    for (; i < n; ) {
      let a = i + n >> 1;
      this.ids[a] >= t3 ? n = a : i = a + 1;
    }
    let o = [];
    for (; this.ids[i] === t3; ) {
      let a = this.positions[3 * i], s3 = this.positions[3 * i + 1], l = this.positions[3 * i + 2];
      o.push({ index: a, start: s3, end: l }), i++;
    }
    return o;
  }
  static serialize(e, t3) {
    let i = new Float64Array(e.ids), n = new Uint32Array(e.positions);
    return Kf(i, n, 0, i.length - 1), t3 && t3.push(i.buffer, n.buffer), { ids: i, positions: n };
  }
  static deserialize(e) {
    let t3 = new Tl2();
    return t3.ids = e.ids, t3.positions = e.positions, t3.indexed = true, t3;
  }
};
r(Tl, "FeaturePositionMap");
var Fo = Tl;
function z_(r3) {
  let e = +r3;
  return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : (0, F_.default)(String(r3));
}
r(z_, "getNumericId");
function Kf(r3, e, t3, i) {
  for (; t3 < i; ) {
    let n = r3[t3 + i >> 1], o = t3 - 1, a = i + 1;
    for (; ; ) {
      do
        o++;
      while (r3[o] < n);
      do
        a--;
      while (r3[a] > n);
      if (o >= a) break;
      Pl(r3, o, a), Pl(e, 3 * o, 3 * a), Pl(e, 3 * o + 1, 3 * a + 1), Pl(e, 3 * o + 2, 3 * a + 2);
    }
    a - t3 < i - a ? (Kf(r3, e, t3, a), t3 = a + 1) : (Kf(r3, e, a + 1, i), i = a);
  }
}
r(Kf, "sort");
function Pl(r3, e, t3) {
  let i = r3[e];
  r3[e] = r3[t3], r3[t3] = i;
}
r(Pl, "swap");
N("FeaturePositionMap", Fo);
q();
var Jf = class Jf2 {
  constructor(e, t3) {
    this.gl = e.gl, this.location = t3;
  }
};
r(Jf, "Uniform");
var sr = Jf;
var Yf = class Yf2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
  }
};
r(Yf, "Uniform1i");
var Q = Yf;
var Qf = class Qf2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
  }
};
r(Qf, "Uniform1f");
var U = Qf;
var em = class em2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = [0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1]) && (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
  }
};
r(em, "Uniform2f");
var te = em;
var tm = class tm2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = [0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2]) && (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
  }
};
r(tm, "Uniform3f");
var lt = tm;
var rm = class rm2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = [0, 0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2] || e[3] !== this.current[3]) && (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
  }
};
r(rm, "Uniform4f");
var Ir = rm;
var im = class im2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = X.transparent;
  }
  set(e) {
    (e.r !== this.current.r || e.g !== this.current.g || e.b !== this.current.b || e.a !== this.current.a) && (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
  }
};
r(im, "UniformColor");
var kt = im;
var cM = new Float32Array(16);
var nm = class nm2 extends sr {
  constructor(e, t3) {
    super(e, t3), this.current = cM;
  }
  set(e) {
    if (e[12] !== this.current[12] || e[0] !== this.current[0]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      return;
    }
    for (let t3 = 1; t3 < 16; t3++) if (e[t3] !== this.current[t3]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      break;
    }
  }
};
r(nm, "UniformMatrix4f");
var re = nm;
function om(r3) {
  return [Zf(255 * r3.r, 255 * r3.g), Zf(255 * r3.b, 255 * r3.a)];
}
r(om, "packColor");
var am = class am2 {
  constructor(e, t3, i) {
    this.value = e, this.uniformNames = t3.map((n) => `u_${n}`), this.type = i;
  }
  setUniform(e, t3, i) {
    e.set(i.constantOr(this.value));
  }
  getBinding(e, t3, i) {
    return this.type === "color" ? new kt(e, t3) : new U(e, t3);
  }
};
r(am, "ConstantBinder");
var li = am;
var sm = class sm2 {
  constructor(e, t3) {
    this.uniformNames = t3.map((i) => `u_${i}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
  }
  setConstantPatternPositions(e, t3) {
    this.pixelRatioFrom = t3.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t3.tlbr, this.patternTo = e.tlbr;
  }
  setUniform(e, t3, i, n) {
    let o = n === "u_pattern_to" ? this.patternTo : n === "u_pattern_from" ? this.patternFrom : n === "u_pixel_ratio_to" ? this.pixelRatioTo : n === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
    o && e.set(o);
  }
  getBinding(e, t3, i) {
    return i.substr(0, 9) === "u_pattern" ? new Ir(e, t3) : new U(e, t3);
  }
};
r(sm, "CrossFadedConstantBinder");
var Cr = sm;
var lm = class lm2 {
  constructor(e, t3, i, n) {
    this.expression = e, this.type = i, this.maxValue = 0, this.paintVertexAttributes = t3.map((o) => ({ name: `a_${o}`, type: "Float32", components: i === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n();
  }
  populatePaintArray(e, t3, i, n, o) {
    let a = this.paintVertexArray.length, s3 = this.expression.evaluate(new ye(0), t3, {}, n, [], o);
    this.paintVertexArray.resize(e), this._setPaintValue(a, e, s3);
  }
  updatePaintArray(e, t3, i, n) {
    let o = this.expression.evaluate({ zoom: 0 }, i, n);
    this._setPaintValue(e, t3, o);
  }
  _setPaintValue(e, t3, i) {
    if (this.type === "color") {
      let n = om(i);
      for (let o = e; o < t3; o++) this.paintVertexArray.emplace(o, n[0], n[1]);
    } else {
      for (let n = e; n < t3; n++) this.paintVertexArray.emplace(n, i);
      this.maxValue = Math.max(this.maxValue, Math.abs(i));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
};
r(lm, "SourceExpressionBinder");
var Bt = lm;
var um = class um2 {
  constructor(e, t3, i, n, o, a) {
    this.expression = e, this.uniformNames = t3.map((s3) => `u_${s3}_t`), this.type = i, this.useIntegerZoom = n, this.zoom = o, this.maxValue = 0, this.paintVertexAttributes = t3.map((s3) => ({ name: `a_${s3}`, type: "Float32", components: i === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new a();
  }
  populatePaintArray(e, t3, i, n, o) {
    let a = this.expression.evaluate(new ye(this.zoom), t3, {}, n, [], o), s3 = this.expression.evaluate(new ye(this.zoom + 1), t3, {}, n, [], o), l = this.paintVertexArray.length;
    this.paintVertexArray.resize(e), this._setPaintValue(l, e, a, s3);
  }
  updatePaintArray(e, t3, i, n) {
    let o = this.expression.evaluate({ zoom: this.zoom }, i, n), a = this.expression.evaluate({ zoom: this.zoom + 1 }, i, n);
    this._setPaintValue(e, t3, o, a);
  }
  _setPaintValue(e, t3, i, n) {
    if (this.type === "color") {
      let o = om(i), a = om(n);
      for (let s3 = e; s3 < t3; s3++) this.paintVertexArray.emplace(s3, o[0], o[1], a[0], a[1]);
    } else {
      for (let o = e; o < t3; o++) this.paintVertexArray.emplace(o, i, n);
      this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(n));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
  setUniform(e, t3) {
    let i = this.useIntegerZoom ? Math.floor(t3.zoom) : t3.zoom, n = Ae(this.expression.interpolationFactor(i, this.zoom, this.zoom + 1), 0, 1);
    e.set(n);
  }
  getBinding(e, t3, i) {
    return new U(e, t3);
  }
};
r(um, "CompositeExpressionBinder");
var St = um;
var cm = class cm2 {
  constructor(e, t3, i, n, o, a) {
    this.expression = e, this.type = t3, this.useIntegerZoom = i, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new o(), this.zoomOutPaintVertexArray = new o();
  }
  populatePaintArray(e, t3, i) {
    let n = this.zoomInPaintVertexArray.length;
    this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(n, e, t3.patterns && t3.patterns[this.layerId], i);
  }
  updatePaintArray(e, t3, i, n, o) {
    this._setPaintValues(e, t3, i.patterns && i.patterns[this.layerId], o);
  }
  _setPaintValues(e, t3, i, n) {
    if (!n || !i) return;
    let { min: o, mid: a, max: s3 } = i, l = n[o], c = n[a], p = n[s3];
    if (!(!l || !c || !p)) for (let h = e; h < t3; h++) this.zoomInPaintVertexArray.emplace(h, c.tl[0], c.tl[1], c.br[0], c.br[1], l.tl[0], l.tl[1], l.br[0], l.br[1], c.pixelRatio, l.pixelRatio), this.zoomOutPaintVertexArray.emplace(h, c.tl[0], c.tl[1], c.br[0], c.br[1], p.tl[0], p.tl[1], p.br[0], p.br[1], c.pixelRatio, p.pixelRatio);
  }
  upload(e) {
    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, zo.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, zo.members, this.expression.isStateDependent));
  }
  destroy() {
    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
  }
};
r(cm, "CrossFadedCompositeBinder");
var $t = cm;
var pm = class pm2 {
  constructor(e, t3, i) {
    this.binders = {}, this._buffers = [];
    let n = [];
    for (let o in e.paint._values) {
      if (!i(o)) continue;
      let a = e.paint.get(o);
      if (!(a instanceof at) || !br(a.property.specification)) continue;
      let s3 = pM(o, e.type), l = a.value, c = a.property.specification.type, p = a.property.useIntegerZoom, h = a.property.specification["property-type"], f = h === "cross-faded" || h === "cross-faded-data-driven";
      if (l.kind === "constant") this.binders[o] = f ? new Cr(l.value, s3) : new li(l.value, s3, c), n.push(`/u_${o}`);
      else if (l.kind === "source" || f) {
        let m = R_(o, c, "source");
        this.binders[o] = f ? new $t(l, c, p, t3, m, e.id) : new Bt(l, s3, c, m), n.push(`/a_${o}`);
      } else {
        let m = R_(o, c, "composite");
        this.binders[o] = new St(l, s3, c, p, t3, m), n.push(`/z_${o}`);
      }
    }
    this.cacheKey = n.sort().join("");
  }
  getMaxValue(e) {
    let t3 = this.binders[e];
    return t3 instanceof Bt || t3 instanceof St ? t3.maxValue : 0;
  }
  populatePaintArrays(e, t3, i, n, o) {
    for (let a in this.binders) {
      let s3 = this.binders[a];
      (s3 instanceof Bt || s3 instanceof St || s3 instanceof $t) && s3.populatePaintArray(e, t3, i, n, o);
    }
  }
  setConstantPatternPositions(e, t3) {
    for (let i in this.binders) {
      let n = this.binders[i];
      n instanceof Cr && n.setConstantPatternPositions(e, t3);
    }
  }
  updatePaintArrays(e, t3, i, n, o) {
    let a = false;
    for (let s3 in e) {
      let l = t3.getPositions(s3);
      for (let c of l) {
        let p = i.feature(c.index);
        for (let h in this.binders) {
          let f = this.binders[h];
          if ((f instanceof Bt || f instanceof St || f instanceof $t) && f.expression.isStateDependent === true) {
            let m = n.paint.get(h);
            f.expression = m.value, f.updatePaintArray(c.start, c.end, p, e[s3], o), a = true;
          }
        }
      }
    }
    return a;
  }
  defines() {
    let e = [];
    for (let t3 in this.binders) {
      let i = this.binders[t3];
      (i instanceof li || i instanceof Cr) && e.push(...i.uniformNames.map((n) => `#define HAS_UNIFORM_${n}`));
    }
    return e;
  }
  getBinderAttributes() {
    let e = [];
    for (let t3 in this.binders) {
      let i = this.binders[t3];
      if (i instanceof Bt || i instanceof St) for (let n = 0; n < i.paintVertexAttributes.length; n++) e.push(i.paintVertexAttributes[n].name);
      else if (i instanceof $t) for (let n = 0; n < zo.members.length; n++) e.push(zo.members[n].name);
    }
    return e;
  }
  getBinderUniforms() {
    let e = [];
    for (let t3 in this.binders) {
      let i = this.binders[t3];
      if (i instanceof li || i instanceof Cr || i instanceof St) for (let n of i.uniformNames) e.push(n);
    }
    return e;
  }
  getPaintVertexBuffers() {
    return this._buffers;
  }
  getUniforms(e, t3) {
    let i = [];
    for (let n in this.binders) {
      let o = this.binders[n];
      if (o instanceof li || o instanceof Cr || o instanceof St) {
        for (let a of o.uniformNames) if (t3[a]) {
          let s3 = o.getBinding(e, t3[a], a);
          i.push({ name: a, property: n, binding: s3 });
        }
      }
    }
    return i;
  }
  setUniforms(e, t3, i, n) {
    for (let { name: o, property: a, binding: s3 } of t3) this.binders[a].setUniform(s3, n, i.get(a), o);
  }
  updatePaintBuffers(e) {
    this._buffers = [];
    for (let t3 in this.binders) {
      let i = this.binders[t3];
      if (e && i instanceof $t) {
        let n = e.fromScale === 2 ? i.zoomInPaintVertexBuffer : i.zoomOutPaintVertexBuffer;
        n && this._buffers.push(n);
      } else (i instanceof Bt || i instanceof St) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
    }
  }
  upload(e) {
    for (let t3 in this.binders) {
      let i = this.binders[t3];
      (i instanceof Bt || i instanceof St || i instanceof $t) && i.upload(e);
    }
    this.updatePaintBuffers();
  }
  destroy() {
    for (let e in this.binders) {
      let t3 = this.binders[e];
      (t3 instanceof Bt || t3 instanceof St || t3 instanceof $t) && t3.destroy();
    }
  }
};
r(pm, "ProgramConfiguration");
var Ml = pm;
var hm = class hm2 {
  constructor(e, t3, i = () => true) {
    this.programConfigurations = {};
    for (let n of e) this.programConfigurations[n.id] = new Ml(n, t3, i);
    this.needsUpload = false, this._featureMap = new Fo(), this._bufferOffset = 0;
  }
  populatePaintArrays(e, t3, i, n, o, a) {
    for (let s3 in this.programConfigurations) this.programConfigurations[s3].populatePaintArrays(e, t3, n, o, a);
    t3.id !== void 0 && this._featureMap.add(t3.id, i, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = true;
  }
  updatePaintArrays(e, t3, i, n) {
    for (let o of i) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(e, this._featureMap, t3, o, n) || this.needsUpload;
  }
  get(e) {
    return this.programConfigurations[e];
  }
  upload(e) {
    if (this.needsUpload) {
      for (let t3 in this.programConfigurations) this.programConfigurations[t3].upload(e);
      this.needsUpload = false;
    }
  }
  destroy() {
    for (let e in this.programConfigurations) this.programConfigurations[e].destroy();
  }
};
r(hm, "ProgramConfigurationSet");
var mt = hm;
function pM(r3, e) {
  return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r3] || [r3.replace(`${e}-`, "").replace(/-/g, "_")];
}
r(pM, "paintAttributeNames");
function hM(r3) {
  return { "line-pattern": { source: ar, composite: ar }, "fill-pattern": { source: ar, composite: ar }, "fill-extrusion-pattern": { source: ar, composite: ar } }[r3];
}
r(hM, "getLayoutException");
function R_(r3, e, t3) {
  let i = { color: { source: Tr, composite: Qi }, number: { source: ai, composite: Tr } }, n = hM(r3);
  return n && n[t3] || i[e][t3];
}
r(R_, "layoutType");
N("ConstantBinder", li);
N("CrossFadedConstantBinder", Cr);
N("SourceExpressionBinder", Bt);
N("CrossFadedCompositeBinder", $t);
N("CompositeExpressionBinder", St);
N("ProgramConfiguration", Ml, { omit: ["_buffers"] });
N("ProgramConfigurationSet", mt);
q();
q();
q();
var fM = 15;
var fm = Math.pow(2, fM - 1) - 1;
var B_ = -fm - 1;
function dt(r3) {
  let e = 8192 / r3.extent, t3 = r3.loadGeometry();
  for (let i = 0; i < t3.length; i++) {
    let n = t3[i];
    for (let o = 0; o < n.length; o++) {
      let a = n[o], s3 = Math.round(a.x * e), l = Math.round(a.y * e);
      a.x = Ae(s3, B_, fm), a.y = Ae(l, B_, fm), (s3 < a.x || s3 > a.x + 1 || l < a.y || l > a.y + 1) && ke("Geometry exceeds allowed extent, reduce your vector tile buffer size");
    }
  }
  return t3;
}
r(dt, "loadGeometry");
q();
function yt(r3, e) {
  return { type: r3.type, id: r3.id, properties: r3.properties, geometry: e ? dt(r3) : [] };
}
r(yt, "toEvaluationFeature");
function Al(r3, e, t3, i, n) {
  r3.emplaceBack(e * 2 + (i + 1) / 2, t3 * 2 + (n + 1) / 2);
}
r(Al, "addCircleVertex");
var mm = class mm2 {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new hl(), this.indexArray = new rt(), this.segments = new me(), this.programConfigurations = new mt(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
  }
  populate(e, t3, i) {
    let n = this.layers[0], o = [], a = null, s3 = false;
    n.type === "circle" && (a = n.layout.get("circle-sort-key"), s3 = !a.isConstant());
    for (let { feature: l, id: c, index: p, sourceLayerIndex: h } of e) {
      let f = this.layers[0]._featureFilter.needGeometry, m = yt(l, f);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), m, i)) continue;
      let y = s3 ? a.evaluate(m, {}, i) : void 0, g = { id: c, properties: l.properties, type: l.type, sourceLayerIndex: h, index: p, geometry: f ? m.geometry : dt(l), patterns: {}, sortKey: y };
      o.push(g);
    }
    s3 && o.sort((l, c) => l.sortKey - c.sortKey);
    for (let l of o) {
      let { geometry: c, index: p, sourceLayerIndex: h } = l, f = e[p].feature;
      this.addFeature(l, c, p, i), t3.featureIndex.insert(f, c, p, h, this.index);
    }
  }
  update(e, t3, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t3, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, E_), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  addFeature(e, t3, i, n) {
    for (let o of t3) for (let a of o) {
      let s3 = a.x, l = a.y;
      if (s3 < 0 || s3 >= 8192 || l < 0 || l >= 8192) continue;
      let c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), p = c.vertexLength;
      Al(this.layoutVertexArray, s3, l, -1, -1), Al(this.layoutVertexArray, s3, l, 1, -1), Al(this.layoutVertexArray, s3, l, 1, 1), Al(this.layoutVertexArray, s3, l, -1, 1), this.indexArray.emplaceBack(p, p + 1, p + 2), this.indexArray.emplaceBack(p, p + 3, p + 2), c.vertexLength += 4, c.primitiveLength += 2;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n);
  }
};
r(mm, "CircleBucket");
var ui = mm;
N("CircleBucket", ui, { omit: ["layers"] });
q();
var Ro = u(ge(), 1);
function Il(r3, e) {
  for (let t3 = 0; t3 < r3.length; t3++) if (tn(e, r3[t3])) return true;
  for (let t3 = 0; t3 < e.length; t3++) if (tn(r3, e[t3])) return true;
  return !!ym(r3, e);
}
r(Il, "polygonIntersectsPolygon");
function V_(r3, e, t3) {
  return !!(tn(r3, e) || dm(e, r3, t3));
}
r(V_, "polygonIntersectsBufferedPoint");
function Cl(r3, e) {
  if (r3.length === 1) return O_(e, r3[0]);
  for (let t3 = 0; t3 < e.length; t3++) {
    let i = e[t3];
    for (let n = 0; n < i.length; n++) if (tn(r3, i[n])) return true;
  }
  for (let t3 = 0; t3 < r3.length; t3++) if (O_(e, r3[t3])) return true;
  for (let t3 = 0; t3 < e.length; t3++) if (ym(r3, e[t3])) return true;
  return false;
}
r(Cl, "polygonIntersectsMultiPolygon");
function U_(r3, e, t3) {
  for (let i = 0; i < e.length; i++) {
    let n = e[i];
    if (r3.length >= 3) {
      for (let o = 0; o < n.length; o++) if (tn(r3, n[o])) return true;
    }
    if (mM(r3, n, t3)) return true;
  }
  return false;
}
r(U_, "polygonIntersectsBufferedMultiLine");
function mM(r3, e, t3) {
  if (r3.length > 1) {
    if (ym(r3, e)) return true;
    for (let i = 0; i < e.length; i++) if (dm(e[i], r3, t3)) return true;
  }
  for (let i = 0; i < r3.length; i++) if (dm(r3[i], e, t3)) return true;
  return false;
}
r(mM, "lineIntersectsBufferedLine");
function ym(r3, e) {
  if (r3.length === 0 || e.length === 0) return false;
  for (let t3 = 0; t3 < r3.length - 1; t3++) {
    let i = r3[t3], n = r3[t3 + 1];
    for (let o = 0; o < e.length - 1; o++) {
      let a = e[o], s3 = e[o + 1];
      if (dM(i, n, a, s3)) return true;
    }
  }
  return false;
}
r(ym, "lineIntersectsLine");
function dM(r3, e, t3, i) {
  return er(r3, t3, i) !== er(e, t3, i) && er(r3, e, t3) !== er(r3, e, i);
}
r(dM, "lineSegmentIntersectsLineSegment");
function dm(r3, e, t3) {
  let i = t3 * t3;
  if (e.length === 1) return r3.distSqr(e[0]) < i;
  for (let n = 1; n < e.length; n++) {
    let o = e[n - 1], a = e[n];
    if (N_(r3, o, a) < i) return true;
  }
  return false;
}
r(dm, "pointIntersectsBufferedLine");
function N_(r3, e, t3) {
  let i = e.distSqr(t3);
  if (i === 0) return r3.distSqr(e);
  let n = ((r3.x - e.x) * (t3.x - e.x) + (r3.y - e.y) * (t3.y - e.y)) / i;
  return n < 0 ? r3.distSqr(e) : n > 1 ? r3.distSqr(t3) : r3.distSqr(t3.sub(e)._mult(n)._add(e));
}
r(N_, "distToSegmentSquared");
function O_(r3, e) {
  let t3 = false, i, n, o;
  for (let a = 0; a < r3.length; a++) {
    i = r3[a];
    for (let s3 = 0, l = i.length - 1; s3 < i.length; l = s3++) n = i[s3], o = i[l], n.y > e.y != o.y > e.y && e.x < (o.x - n.x) * (e.y - n.y) / (o.y - n.y) + n.x && (t3 = !t3);
  }
  return t3;
}
r(O_, "multiPolygonContainsPoint");
function tn(r3, e) {
  let t3 = false;
  for (let i = 0, n = r3.length - 1; i < r3.length; n = i++) {
    let o = r3[i], a = r3[n];
    o.y > e.y != a.y > e.y && e.x < (a.x - o.x) * (e.y - o.y) / (a.y - o.y) + o.x && (t3 = !t3);
  }
  return t3;
}
r(tn, "polygonContainsPoint");
function G_(r3, e, t3, i, n) {
  for (let a of r3) if (e <= a.x && t3 <= a.y && i >= a.x && n >= a.y) return true;
  let o = [new Ro.default(e, t3), new Ro.default(e, n), new Ro.default(i, n), new Ro.default(i, t3)];
  if (r3.length > 2) {
    for (let a of o) if (tn(r3, a)) return true;
  }
  for (let a = 0; a < r3.length - 1; a++) {
    let s3 = r3[a], l = r3[a + 1];
    if (yM(s3, l, o)) return true;
  }
  return false;
}
r(G_, "polygonIntersectsBox");
function yM(r3, e, t3) {
  let i = t3[0], n = t3[2];
  if (r3.x < i.x && e.x < i.x || r3.x > n.x && e.x > n.x || r3.y < i.y && e.y < i.y || r3.y > n.y && e.y > n.y) return false;
  let o = er(r3, e, t3[0]);
  return o !== er(r3, e, t3[1]) || o !== er(r3, e, t3[2]) || o !== er(r3, e, t3[3]);
}
r(yM, "edgeIntersectsBox");
q();
var El = u(ge(), 1);
function ci(r3, e, t3) {
  let i = e.paint.get(r3).value;
  return i.kind === "constant" ? i.value : t3.programConfigurations.get(e.id).getMaxValue(r3);
}
r(ci, "getMaximumPaintValue");
function Er(r3) {
  return Math.sqrt(r3[0] * r3[0] + r3[1] * r3[1]);
}
r(Er, "translateDistance");
function kr(r3, e, t3, i, n) {
  if (!e[0] && !e[1]) return r3;
  let o = El.default.convert(e)._mult(n);
  t3 === "viewport" && o._rotate(-i);
  let a = [];
  for (let s3 = 0; s3 < r3.length; s3++) {
    let l = r3[s3];
    a.push(l.sub(o));
  }
  return a;
}
r(kr, "translate");
function $_(r3, e) {
  let t3 = [];
  for (let i = 0; i < r3.length; i++) {
    let n = r3[i], o = [];
    for (let a = 0; a < n.length; a++) {
      let s3 = n[a - 1], l = n[a], c = n[a + 1], p = a === 0 ? new El.default(0, 0) : l.sub(s3)._unit()._perp(), h = a === n.length - 1 ? new El.default(0, 0) : c.sub(l)._unit()._perp(), f = p._add(h)._unit(), m = f.x * h.x + f.y * h.y;
      m !== 0 && f._mult(1 / m), o.push(f._mult(e)._add(l));
    }
    t3.push(o);
  }
  return t3;
}
r($_, "offsetLine");
q();
var q_;
var xM = r(() => q_ = q_ || new De({ "circle-sort-key": new H(A.layout_circle["circle-sort-key"]) }), "getLayout");
var j_;
var bM = r(() => j_ = j_ || new De({ "circle-radius": new H(A.paint_circle["circle-radius"]), "circle-color": new H(A.paint_circle["circle-color"]), "circle-blur": new H(A.paint_circle["circle-blur"]), "circle-opacity": new H(A.paint_circle["circle-opacity"]), "circle-translate": new j(A.paint_circle["circle-translate"]), "circle-translate-anchor": new j(A.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new j(A.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new j(A.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new H(A.paint_circle["circle-stroke-width"]), "circle-stroke-color": new H(A.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new H(A.paint_circle["circle-stroke-opacity"]) }), "getPaint");
var Z_ = { get paint() {
  return bM();
}, get layout() {
  return xM();
} };
q();
q();
var oe = 1e-6;
var we = typeof Float32Array < "u" ? Float32Array : Array;
var qt = Math.random;
var zR = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
  for (var r3 = 0, e = arguments.length; e--; ) r3 += arguments[e] * arguments[e];
  return Math.sqrt(r3);
});
var Bo = {};
t(Bo, { LDU: () => RM, add: () => BM, adjoint: () => IM, clone: () => vM, copy: () => wM, create: () => _M, determinant: () => CM, equals: () => VM, exactEquals: () => OM, frob: () => FM, fromRotation: () => LM, fromScaling: () => DM, fromValues: () => PM, identity: () => SM, invert: () => AM, mul: () => GM, multiply: () => H_, multiplyScalar: () => UM, multiplyScalarAndAdd: () => NM, rotate: () => EM, scale: () => kM, set: () => TM, str: () => zM, sub: () => $M, subtract: () => W_, transpose: () => MM });
q();
function _M() {
  var r3 = new we(4);
  return we != Float32Array && (r3[1] = 0, r3[2] = 0), r3[0] = 1, r3[3] = 1, r3;
}
r(_M, "create");
function vM(r3) {
  var e = new we(4);
  return e[0] = r3[0], e[1] = r3[1], e[2] = r3[2], e[3] = r3[3], e;
}
r(vM, "clone");
function wM(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[3], r3;
}
r(wM, "copy");
function SM(r3) {
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 1, r3;
}
r(SM, "identity");
function PM(r3, e, t3, i) {
  var n = new we(4);
  return n[0] = r3, n[1] = e, n[2] = t3, n[3] = i, n;
}
r(PM, "fromValues");
function TM(r3, e, t3, i, n) {
  return r3[0] = e, r3[1] = t3, r3[2] = i, r3[3] = n, r3;
}
r(TM, "set");
function MM(r3, e) {
  if (r3 === e) {
    var t3 = e[1];
    r3[1] = e[2], r3[2] = t3;
  } else r3[0] = e[0], r3[1] = e[2], r3[2] = e[1], r3[3] = e[3];
  return r3;
}
r(MM, "transpose");
function AM(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = t3 * o - n * i;
  return a ? (a = 1 / a, r3[0] = o * a, r3[1] = -i * a, r3[2] = -n * a, r3[3] = t3 * a, r3) : null;
}
r(AM, "invert");
function IM(r3, e) {
  var t3 = e[0];
  return r3[0] = e[3], r3[1] = -e[1], r3[2] = -e[2], r3[3] = t3, r3;
}
r(IM, "adjoint");
function CM(r3) {
  return r3[0] * r3[3] - r3[2] * r3[1];
}
r(CM, "determinant");
function H_(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = t3[0], l = t3[1], c = t3[2], p = t3[3];
  return r3[0] = i * s3 + o * l, r3[1] = n * s3 + a * l, r3[2] = i * c + o * p, r3[3] = n * c + a * p, r3;
}
r(H_, "multiply");
function EM(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = Math.sin(t3), l = Math.cos(t3);
  return r3[0] = i * l + o * s3, r3[1] = n * l + a * s3, r3[2] = i * -s3 + o * l, r3[3] = n * -s3 + a * l, r3;
}
r(EM, "rotate");
function kM(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = t3[0], l = t3[1];
  return r3[0] = i * s3, r3[1] = n * s3, r3[2] = o * l, r3[3] = a * l, r3;
}
r(kM, "scale");
function LM(r3, e) {
  var t3 = Math.sin(e), i = Math.cos(e);
  return r3[0] = i, r3[1] = t3, r3[2] = -t3, r3[3] = i, r3;
}
r(LM, "fromRotation");
function DM(r3, e) {
  return r3[0] = e[0], r3[1] = 0, r3[2] = 0, r3[3] = e[1], r3;
}
r(DM, "fromScaling");
function zM(r3) {
  return "mat2(" + r3[0] + ", " + r3[1] + ", " + r3[2] + ", " + r3[3] + ")";
}
r(zM, "str");
function FM(r3) {
  return Math.hypot(r3[0], r3[1], r3[2], r3[3]);
}
r(FM, "frob");
function RM(r3, e, t3, i) {
  return r3[2] = i[2] / i[0], t3[0] = i[0], t3[1] = i[1], t3[3] = i[3] - r3[2] * t3[1], [r3, e, t3];
}
r(RM, "LDU");
function BM(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3[2] = e[2] + t3[2], r3[3] = e[3] + t3[3], r3;
}
r(BM, "add");
function W_(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3[2] = e[2] - t3[2], r3[3] = e[3] - t3[3], r3;
}
r(W_, "subtract");
function OM(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1] && r3[2] === e[2] && r3[3] === e[3];
}
r(OM, "exactEquals");
function VM(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = r3[3], a = e[0], s3 = e[1], l = e[2], c = e[3];
  return Math.abs(t3 - a) <= oe * Math.max(1, Math.abs(t3), Math.abs(a)) && Math.abs(i - s3) <= oe * Math.max(1, Math.abs(i), Math.abs(s3)) && Math.abs(n - l) <= oe * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - c) <= oe * Math.max(1, Math.abs(o), Math.abs(c));
}
r(VM, "equals");
function UM(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3[2] = e[2] * t3, r3[3] = e[3] * t3, r3;
}
r(UM, "multiplyScalar");
function NM(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3[2] = e[2] + t3[2] * i, r3[3] = e[3] + t3[3] * i, r3;
}
r(NM, "multiplyScalarAndAdd");
var GM = H_;
var $M = W_;
var Oo = {};
t(Oo, { add: () => fA, adjoint: () => QM, clone: () => ZM, copy: () => HM, create: () => qM, determinant: () => eA, equals: () => gA, exactEquals: () => yA, frob: () => hA, fromMat2d: () => sA, fromMat4: () => jM, fromQuat: () => lA, fromRotation: () => oA, fromScaling: () => aA, fromTranslation: () => nA, fromValues: () => WM, identity: () => KM, invert: () => YM, mul: () => xA, multiply: () => X_, multiplyScalar: () => mA, multiplyScalarAndAdd: () => dA, normalFromMat4: () => uA, projection: () => cA, rotate: () => rA, scale: () => iA, set: () => XM, str: () => pA, sub: () => bA, subtract: () => K_, translate: () => tA, transpose: () => JM });
q();
function qM() {
  var r3 = new we(9);
  return we != Float32Array && (r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[5] = 0, r3[6] = 0, r3[7] = 0), r3[0] = 1, r3[4] = 1, r3[8] = 1, r3;
}
r(qM, "create");
function jM(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[4], r3[4] = e[5], r3[5] = e[6], r3[6] = e[8], r3[7] = e[9], r3[8] = e[10], r3;
}
r(jM, "fromMat4");
function ZM(r3) {
  var e = new we(9);
  return e[0] = r3[0], e[1] = r3[1], e[2] = r3[2], e[3] = r3[3], e[4] = r3[4], e[5] = r3[5], e[6] = r3[6], e[7] = r3[7], e[8] = r3[8], e;
}
r(ZM, "clone");
function HM(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[3], r3[4] = e[4], r3[5] = e[5], r3[6] = e[6], r3[7] = e[7], r3[8] = e[8], r3;
}
r(HM, "copy");
function WM(r3, e, t3, i, n, o, a, s3, l) {
  var c = new we(9);
  return c[0] = r3, c[1] = e, c[2] = t3, c[3] = i, c[4] = n, c[5] = o, c[6] = a, c[7] = s3, c[8] = l, c;
}
r(WM, "fromValues");
function XM(r3, e, t3, i, n, o, a, s3, l, c) {
  return r3[0] = e, r3[1] = t3, r3[2] = i, r3[3] = n, r3[4] = o, r3[5] = a, r3[6] = s3, r3[7] = l, r3[8] = c, r3;
}
r(XM, "set");
function KM(r3) {
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 1, r3[5] = 0, r3[6] = 0, r3[7] = 0, r3[8] = 1, r3;
}
r(KM, "identity");
function JM(r3, e) {
  if (r3 === e) {
    var t3 = e[1], i = e[2], n = e[5];
    r3[1] = e[3], r3[2] = e[6], r3[3] = t3, r3[5] = e[7], r3[6] = i, r3[7] = n;
  } else r3[0] = e[0], r3[1] = e[3], r3[2] = e[6], r3[3] = e[1], r3[4] = e[4], r3[5] = e[7], r3[6] = e[2], r3[7] = e[5], r3[8] = e[8];
  return r3;
}
r(JM, "transpose");
function YM(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], c = e[7], p = e[8], h = p * a - s3 * c, f = -p * o + s3 * l, m = c * o - a * l, y = t3 * h + i * f + n * m;
  return y ? (y = 1 / y, r3[0] = h * y, r3[1] = (-p * i + n * c) * y, r3[2] = (s3 * i - n * a) * y, r3[3] = f * y, r3[4] = (p * t3 - n * l) * y, r3[5] = (-s3 * t3 + n * o) * y, r3[6] = m * y, r3[7] = (-c * t3 + i * l) * y, r3[8] = (a * t3 - i * o) * y, r3) : null;
}
r(YM, "invert");
function QM(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], c = e[7], p = e[8];
  return r3[0] = a * p - s3 * c, r3[1] = n * c - i * p, r3[2] = i * s3 - n * a, r3[3] = s3 * l - o * p, r3[4] = t3 * p - n * l, r3[5] = n * o - t3 * s3, r3[6] = o * c - a * l, r3[7] = i * l - t3 * c, r3[8] = t3 * a - i * o, r3;
}
r(QM, "adjoint");
function eA(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2], n = r3[3], o = r3[4], a = r3[5], s3 = r3[6], l = r3[7], c = r3[8];
  return e * (c * o - a * l) + t3 * (-c * n + a * s3) + i * (l * n - o * s3);
}
r(eA, "determinant");
function X_(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], c = e[6], p = e[7], h = e[8], f = t3[0], m = t3[1], y = t3[2], g = t3[3], x = t3[4], b = t3[5], w = t3[6], _ = t3[7], S = t3[8];
  return r3[0] = f * i + m * a + y * c, r3[1] = f * n + m * s3 + y * p, r3[2] = f * o + m * l + y * h, r3[3] = g * i + x * a + b * c, r3[4] = g * n + x * s3 + b * p, r3[5] = g * o + x * l + b * h, r3[6] = w * i + _ * a + S * c, r3[7] = w * n + _ * s3 + S * p, r3[8] = w * o + _ * l + S * h, r3;
}
r(X_, "multiply");
function tA(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], c = e[6], p = e[7], h = e[8], f = t3[0], m = t3[1];
  return r3[0] = i, r3[1] = n, r3[2] = o, r3[3] = a, r3[4] = s3, r3[5] = l, r3[6] = f * i + m * a + c, r3[7] = f * n + m * s3 + p, r3[8] = f * o + m * l + h, r3;
}
r(tA, "translate");
function rA(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], c = e[6], p = e[7], h = e[8], f = Math.sin(t3), m = Math.cos(t3);
  return r3[0] = m * i + f * a, r3[1] = m * n + f * s3, r3[2] = m * o + f * l, r3[3] = m * a - f * i, r3[4] = m * s3 - f * n, r3[5] = m * l - f * o, r3[6] = c, r3[7] = p, r3[8] = h, r3;
}
r(rA, "rotate");
function iA(r3, e, t3) {
  var i = t3[0], n = t3[1];
  return r3[0] = i * e[0], r3[1] = i * e[1], r3[2] = i * e[2], r3[3] = n * e[3], r3[4] = n * e[4], r3[5] = n * e[5], r3[6] = e[6], r3[7] = e[7], r3[8] = e[8], r3;
}
r(iA, "scale");
function nA(r3, e) {
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 1, r3[5] = 0, r3[6] = e[0], r3[7] = e[1], r3[8] = 1, r3;
}
r(nA, "fromTranslation");
function oA(r3, e) {
  var t3 = Math.sin(e), i = Math.cos(e);
  return r3[0] = i, r3[1] = t3, r3[2] = 0, r3[3] = -t3, r3[4] = i, r3[5] = 0, r3[6] = 0, r3[7] = 0, r3[8] = 1, r3;
}
r(oA, "fromRotation");
function aA(r3, e) {
  return r3[0] = e[0], r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = e[1], r3[5] = 0, r3[6] = 0, r3[7] = 0, r3[8] = 1, r3;
}
r(aA, "fromScaling");
function sA(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = 0, r3[3] = e[2], r3[4] = e[3], r3[5] = 0, r3[6] = e[4], r3[7] = e[5], r3[8] = 1, r3;
}
r(sA, "fromMat2d");
function lA(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = t3 + t3, s3 = i + i, l = n + n, c = t3 * a, p = i * a, h = i * s3, f = n * a, m = n * s3, y = n * l, g = o * a, x = o * s3, b = o * l;
  return r3[0] = 1 - h - y, r3[3] = p - b, r3[6] = f + x, r3[1] = p + b, r3[4] = 1 - c - y, r3[7] = m - g, r3[2] = f - x, r3[5] = m + g, r3[8] = 1 - c - h, r3;
}
r(lA, "fromQuat");
function uA(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], c = e[7], p = e[8], h = e[9], f = e[10], m = e[11], y = e[12], g = e[13], x = e[14], b = e[15], w = t3 * s3 - i * a, _ = t3 * l - n * a, S = t3 * c - o * a, P = i * l - n * s3, T = i * c - o * s3, L = n * c - o * l, C = p * g - h * y, E = p * x - f * y, I = p * b - m * y, R = h * x - f * g, z = h * b - m * g, k = f * b - m * x, M = w * k - _ * z + S * R + P * I - T * E + L * C;
  return M ? (M = 1 / M, r3[0] = (s3 * k - l * z + c * R) * M, r3[1] = (l * I - a * k - c * E) * M, r3[2] = (a * z - s3 * I + c * C) * M, r3[3] = (n * z - i * k - o * R) * M, r3[4] = (t3 * k - n * I + o * E) * M, r3[5] = (i * I - t3 * z - o * C) * M, r3[6] = (g * L - x * T + b * P) * M, r3[7] = (x * S - y * L - b * _) * M, r3[8] = (y * T - g * S + b * w) * M, r3) : null;
}
r(uA, "normalFromMat4");
function cA(r3, e, t3) {
  return r3[0] = 2 / e, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = -2 / t3, r3[5] = 0, r3[6] = -1, r3[7] = 1, r3[8] = 1, r3;
}
r(cA, "projection");
function pA(r3) {
  return "mat3(" + r3[0] + ", " + r3[1] + ", " + r3[2] + ", " + r3[3] + ", " + r3[4] + ", " + r3[5] + ", " + r3[6] + ", " + r3[7] + ", " + r3[8] + ")";
}
r(pA, "str");
function hA(r3) {
  return Math.hypot(r3[0], r3[1], r3[2], r3[3], r3[4], r3[5], r3[6], r3[7], r3[8]);
}
r(hA, "frob");
function fA(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3[2] = e[2] + t3[2], r3[3] = e[3] + t3[3], r3[4] = e[4] + t3[4], r3[5] = e[5] + t3[5], r3[6] = e[6] + t3[6], r3[7] = e[7] + t3[7], r3[8] = e[8] + t3[8], r3;
}
r(fA, "add");
function K_(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3[2] = e[2] - t3[2], r3[3] = e[3] - t3[3], r3[4] = e[4] - t3[4], r3[5] = e[5] - t3[5], r3[6] = e[6] - t3[6], r3[7] = e[7] - t3[7], r3[8] = e[8] - t3[8], r3;
}
r(K_, "subtract");
function mA(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3[2] = e[2] * t3, r3[3] = e[3] * t3, r3[4] = e[4] * t3, r3[5] = e[5] * t3, r3[6] = e[6] * t3, r3[7] = e[7] * t3, r3[8] = e[8] * t3, r3;
}
r(mA, "multiplyScalar");
function dA(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3[2] = e[2] + t3[2] * i, r3[3] = e[3] + t3[3] * i, r3[4] = e[4] + t3[4] * i, r3[5] = e[5] + t3[5] * i, r3[6] = e[6] + t3[6] * i, r3[7] = e[7] + t3[7] * i, r3[8] = e[8] + t3[8] * i, r3;
}
r(dA, "multiplyScalarAndAdd");
function yA(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1] && r3[2] === e[2] && r3[3] === e[3] && r3[4] === e[4] && r3[5] === e[5] && r3[6] === e[6] && r3[7] === e[7] && r3[8] === e[8];
}
r(yA, "exactEquals");
function gA(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = r3[3], a = r3[4], s3 = r3[5], l = r3[6], c = r3[7], p = r3[8], h = e[0], f = e[1], m = e[2], y = e[3], g = e[4], x = e[5], b = e[6], w = e[7], _ = e[8];
  return Math.abs(t3 - h) <= oe * Math.max(1, Math.abs(t3), Math.abs(h)) && Math.abs(i - f) <= oe * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(n - m) <= oe * Math.max(1, Math.abs(n), Math.abs(m)) && Math.abs(o - y) <= oe * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(a - g) <= oe * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(s3 - x) <= oe * Math.max(1, Math.abs(s3), Math.abs(x)) && Math.abs(l - b) <= oe * Math.max(1, Math.abs(l), Math.abs(b)) && Math.abs(c - w) <= oe * Math.max(1, Math.abs(c), Math.abs(w)) && Math.abs(p - _) <= oe * Math.max(1, Math.abs(p), Math.abs(_));
}
r(gA, "equals");
var xA = X_;
var bA = K_;
var $ = {};
t($, { add: () => iI, adjoint: () => AA, clone: () => vA, copy: () => wA, create: () => _A, determinant: () => IA, equals: () => sI, exactEquals: () => aI, frob: () => rI, fromQuat: () => ZA, fromQuat2: () => NA, fromRotation: () => BA, fromRotationTranslation: () => Q_, fromRotationTranslationScale: () => qA, fromRotationTranslationScaleOrigin: () => jA, fromScaling: () => RA, fromTranslation: () => FA, fromValues: () => SA, fromXRotation: () => OA, fromYRotation: () => VA, fromZRotation: () => UA, frustum: () => HA, getRotation: () => $A, getScaling: () => ev, getTranslation: () => GA, identity: () => J_, invert: () => MA, lookAt: () => QA, mul: () => lI, multiply: () => Y_, multiplyScalar: () => nI, multiplyScalarAndAdd: () => oI, ortho: () => JA, orthoNO: () => rv, orthoZO: () => YA, perspective: () => WA, perspectiveFromFieldOfView: () => KA, perspectiveNO: () => tv, perspectiveZO: () => XA, rotate: () => kA, rotateX: () => LA, rotateY: () => DA, rotateZ: () => zA, scale: () => EA, set: () => PA, str: () => tI, sub: () => uI, subtract: () => iv, targetTo: () => eI, translate: () => CA, transpose: () => TA });
q();
function _A() {
  var r3 = new we(16);
  return we != Float32Array && (r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0), r3[0] = 1, r3[5] = 1, r3[10] = 1, r3[15] = 1, r3;
}
r(_A, "create");
function vA(r3) {
  var e = new we(16);
  return e[0] = r3[0], e[1] = r3[1], e[2] = r3[2], e[3] = r3[3], e[4] = r3[4], e[5] = r3[5], e[6] = r3[6], e[7] = r3[7], e[8] = r3[8], e[9] = r3[9], e[10] = r3[10], e[11] = r3[11], e[12] = r3[12], e[13] = r3[13], e[14] = r3[14], e[15] = r3[15], e;
}
r(vA, "clone");
function wA(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[3], r3[4] = e[4], r3[5] = e[5], r3[6] = e[6], r3[7] = e[7], r3[8] = e[8], r3[9] = e[9], r3[10] = e[10], r3[11] = e[11], r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15], r3;
}
r(wA, "copy");
function SA(r3, e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g) {
  var x = new we(16);
  return x[0] = r3, x[1] = e, x[2] = t3, x[3] = i, x[4] = n, x[5] = o, x[6] = a, x[7] = s3, x[8] = l, x[9] = c, x[10] = p, x[11] = h, x[12] = f, x[13] = m, x[14] = y, x[15] = g, x;
}
r(SA, "fromValues");
function PA(r3, e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x) {
  return r3[0] = e, r3[1] = t3, r3[2] = i, r3[3] = n, r3[4] = o, r3[5] = a, r3[6] = s3, r3[7] = l, r3[8] = c, r3[9] = p, r3[10] = h, r3[11] = f, r3[12] = m, r3[13] = y, r3[14] = g, r3[15] = x, r3;
}
r(PA, "set");
function J_(r3) {
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(J_, "identity");
function TA(r3, e) {
  if (r3 === e) {
    var t3 = e[1], i = e[2], n = e[3], o = e[6], a = e[7], s3 = e[11];
    r3[1] = e[4], r3[2] = e[8], r3[3] = e[12], r3[4] = t3, r3[6] = e[9], r3[7] = e[13], r3[8] = i, r3[9] = o, r3[11] = e[14], r3[12] = n, r3[13] = a, r3[14] = s3;
  } else r3[0] = e[0], r3[1] = e[4], r3[2] = e[8], r3[3] = e[12], r3[4] = e[1], r3[5] = e[5], r3[6] = e[9], r3[7] = e[13], r3[8] = e[2], r3[9] = e[6], r3[10] = e[10], r3[11] = e[14], r3[12] = e[3], r3[13] = e[7], r3[14] = e[11], r3[15] = e[15];
  return r3;
}
r(TA, "transpose");
function MA(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], c = e[7], p = e[8], h = e[9], f = e[10], m = e[11], y = e[12], g = e[13], x = e[14], b = e[15], w = t3 * s3 - i * a, _ = t3 * l - n * a, S = t3 * c - o * a, P = i * l - n * s3, T = i * c - o * s3, L = n * c - o * l, C = p * g - h * y, E = p * x - f * y, I = p * b - m * y, R = h * x - f * g, z = h * b - m * g, k = f * b - m * x, M = w * k - _ * z + S * R + P * I - T * E + L * C;
  return M ? (M = 1 / M, r3[0] = (s3 * k - l * z + c * R) * M, r3[1] = (n * z - i * k - o * R) * M, r3[2] = (g * L - x * T + b * P) * M, r3[3] = (f * T - h * L - m * P) * M, r3[4] = (l * I - a * k - c * E) * M, r3[5] = (t3 * k - n * I + o * E) * M, r3[6] = (x * S - y * L - b * _) * M, r3[7] = (p * L - f * S + m * _) * M, r3[8] = (a * z - s3 * I + c * C) * M, r3[9] = (i * I - t3 * z - o * C) * M, r3[10] = (y * T - g * S + b * w) * M, r3[11] = (h * S - p * T - m * w) * M, r3[12] = (s3 * E - a * R - l * C) * M, r3[13] = (t3 * R - i * E + n * C) * M, r3[14] = (g * _ - y * P - x * w) * M, r3[15] = (p * P - h * _ + f * w) * M, r3) : null;
}
r(MA, "invert");
function AA(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = e[4], s3 = e[5], l = e[6], c = e[7], p = e[8], h = e[9], f = e[10], m = e[11], y = e[12], g = e[13], x = e[14], b = e[15];
  return r3[0] = s3 * (f * b - m * x) - h * (l * b - c * x) + g * (l * m - c * f), r3[1] = -(i * (f * b - m * x) - h * (n * b - o * x) + g * (n * m - o * f)), r3[2] = i * (l * b - c * x) - s3 * (n * b - o * x) + g * (n * c - o * l), r3[3] = -(i * (l * m - c * f) - s3 * (n * m - o * f) + h * (n * c - o * l)), r3[4] = -(a * (f * b - m * x) - p * (l * b - c * x) + y * (l * m - c * f)), r3[5] = t3 * (f * b - m * x) - p * (n * b - o * x) + y * (n * m - o * f), r3[6] = -(t3 * (l * b - c * x) - a * (n * b - o * x) + y * (n * c - o * l)), r3[7] = t3 * (l * m - c * f) - a * (n * m - o * f) + p * (n * c - o * l), r3[8] = a * (h * b - m * g) - p * (s3 * b - c * g) + y * (s3 * m - c * h), r3[9] = -(t3 * (h * b - m * g) - p * (i * b - o * g) + y * (i * m - o * h)), r3[10] = t3 * (s3 * b - c * g) - a * (i * b - o * g) + y * (i * c - o * s3), r3[11] = -(t3 * (s3 * m - c * h) - a * (i * m - o * h) + p * (i * c - o * s3)), r3[12] = -(a * (h * x - f * g) - p * (s3 * x - l * g) + y * (s3 * f - l * h)), r3[13] = t3 * (h * x - f * g) - p * (i * x - n * g) + y * (i * f - n * h), r3[14] = -(t3 * (s3 * x - l * g) - a * (i * x - n * g) + y * (i * l - n * s3)), r3[15] = t3 * (s3 * f - l * h) - a * (i * f - n * h) + p * (i * l - n * s3), r3;
}
r(AA, "adjoint");
function IA(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2], n = r3[3], o = r3[4], a = r3[5], s3 = r3[6], l = r3[7], c = r3[8], p = r3[9], h = r3[10], f = r3[11], m = r3[12], y = r3[13], g = r3[14], x = r3[15], b = e * a - t3 * o, w = e * s3 - i * o, _ = e * l - n * o, S = t3 * s3 - i * a, P = t3 * l - n * a, T = i * l - n * s3, L = c * y - p * m, C = c * g - h * m, E = c * x - f * m, I = p * g - h * y, R = p * x - f * y, z = h * x - f * g;
  return b * z - w * R + _ * I + S * E - P * C + T * L;
}
r(IA, "determinant");
function Y_(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = e[4], l = e[5], c = e[6], p = e[7], h = e[8], f = e[9], m = e[10], y = e[11], g = e[12], x = e[13], b = e[14], w = e[15], _ = t3[0], S = t3[1], P = t3[2], T = t3[3];
  return r3[0] = _ * i + S * s3 + P * h + T * g, r3[1] = _ * n + S * l + P * f + T * x, r3[2] = _ * o + S * c + P * m + T * b, r3[3] = _ * a + S * p + P * y + T * w, _ = t3[4], S = t3[5], P = t3[6], T = t3[7], r3[4] = _ * i + S * s3 + P * h + T * g, r3[5] = _ * n + S * l + P * f + T * x, r3[6] = _ * o + S * c + P * m + T * b, r3[7] = _ * a + S * p + P * y + T * w, _ = t3[8], S = t3[9], P = t3[10], T = t3[11], r3[8] = _ * i + S * s3 + P * h + T * g, r3[9] = _ * n + S * l + P * f + T * x, r3[10] = _ * o + S * c + P * m + T * b, r3[11] = _ * a + S * p + P * y + T * w, _ = t3[12], S = t3[13], P = t3[14], T = t3[15], r3[12] = _ * i + S * s3 + P * h + T * g, r3[13] = _ * n + S * l + P * f + T * x, r3[14] = _ * o + S * c + P * m + T * b, r3[15] = _ * a + S * p + P * y + T * w, r3;
}
r(Y_, "multiply");
function CA(r3, e, t3) {
  var i = t3[0], n = t3[1], o = t3[2], a, s3, l, c, p, h, f, m, y, g, x, b;
  return e === r3 ? (r3[12] = e[0] * i + e[4] * n + e[8] * o + e[12], r3[13] = e[1] * i + e[5] * n + e[9] * o + e[13], r3[14] = e[2] * i + e[6] * n + e[10] * o + e[14], r3[15] = e[3] * i + e[7] * n + e[11] * o + e[15]) : (a = e[0], s3 = e[1], l = e[2], c = e[3], p = e[4], h = e[5], f = e[6], m = e[7], y = e[8], g = e[9], x = e[10], b = e[11], r3[0] = a, r3[1] = s3, r3[2] = l, r3[3] = c, r3[4] = p, r3[5] = h, r3[6] = f, r3[7] = m, r3[8] = y, r3[9] = g, r3[10] = x, r3[11] = b, r3[12] = a * i + p * n + y * o + e[12], r3[13] = s3 * i + h * n + g * o + e[13], r3[14] = l * i + f * n + x * o + e[14], r3[15] = c * i + m * n + b * o + e[15]), r3;
}
r(CA, "translate");
function EA(r3, e, t3) {
  var i = t3[0], n = t3[1], o = t3[2];
  return r3[0] = e[0] * i, r3[1] = e[1] * i, r3[2] = e[2] * i, r3[3] = e[3] * i, r3[4] = e[4] * n, r3[5] = e[5] * n, r3[6] = e[6] * n, r3[7] = e[7] * n, r3[8] = e[8] * o, r3[9] = e[9] * o, r3[10] = e[10] * o, r3[11] = e[11] * o, r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15], r3;
}
r(EA, "scale");
function kA(r3, e, t3, i) {
  var n = i[0], o = i[1], a = i[2], s3 = Math.hypot(n, o, a), l, c, p, h, f, m, y, g, x, b, w, _, S, P, T, L, C, E, I, R, z, k, M, G;
  return s3 < oe ? null : (s3 = 1 / s3, n *= s3, o *= s3, a *= s3, l = Math.sin(t3), c = Math.cos(t3), p = 1 - c, h = e[0], f = e[1], m = e[2], y = e[3], g = e[4], x = e[5], b = e[6], w = e[7], _ = e[8], S = e[9], P = e[10], T = e[11], L = n * n * p + c, C = o * n * p + a * l, E = a * n * p - o * l, I = n * o * p - a * l, R = o * o * p + c, z = a * o * p + n * l, k = n * a * p + o * l, M = o * a * p - n * l, G = a * a * p + c, r3[0] = h * L + g * C + _ * E, r3[1] = f * L + x * C + S * E, r3[2] = m * L + b * C + P * E, r3[3] = y * L + w * C + T * E, r3[4] = h * I + g * R + _ * z, r3[5] = f * I + x * R + S * z, r3[6] = m * I + b * R + P * z, r3[7] = y * I + w * R + T * z, r3[8] = h * k + g * M + _ * G, r3[9] = f * k + x * M + S * G, r3[10] = m * k + b * M + P * G, r3[11] = y * k + w * M + T * G, e !== r3 && (r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15]), r3);
}
r(kA, "rotate");
function LA(r3, e, t3) {
  var i = Math.sin(t3), n = Math.cos(t3), o = e[4], a = e[5], s3 = e[6], l = e[7], c = e[8], p = e[9], h = e[10], f = e[11];
  return e !== r3 && (r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[3], r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15]), r3[4] = o * n + c * i, r3[5] = a * n + p * i, r3[6] = s3 * n + h * i, r3[7] = l * n + f * i, r3[8] = c * n - o * i, r3[9] = p * n - a * i, r3[10] = h * n - s3 * i, r3[11] = f * n - l * i, r3;
}
r(LA, "rotateX");
function DA(r3, e, t3) {
  var i = Math.sin(t3), n = Math.cos(t3), o = e[0], a = e[1], s3 = e[2], l = e[3], c = e[8], p = e[9], h = e[10], f = e[11];
  return e !== r3 && (r3[4] = e[4], r3[5] = e[5], r3[6] = e[6], r3[7] = e[7], r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15]), r3[0] = o * n - c * i, r3[1] = a * n - p * i, r3[2] = s3 * n - h * i, r3[3] = l * n - f * i, r3[8] = o * i + c * n, r3[9] = a * i + p * n, r3[10] = s3 * i + h * n, r3[11] = l * i + f * n, r3;
}
r(DA, "rotateY");
function zA(r3, e, t3) {
  var i = Math.sin(t3), n = Math.cos(t3), o = e[0], a = e[1], s3 = e[2], l = e[3], c = e[4], p = e[5], h = e[6], f = e[7];
  return e !== r3 && (r3[8] = e[8], r3[9] = e[9], r3[10] = e[10], r3[11] = e[11], r3[12] = e[12], r3[13] = e[13], r3[14] = e[14], r3[15] = e[15]), r3[0] = o * n + c * i, r3[1] = a * n + p * i, r3[2] = s3 * n + h * i, r3[3] = l * n + f * i, r3[4] = c * n - o * i, r3[5] = p * n - a * i, r3[6] = h * n - s3 * i, r3[7] = f * n - l * i, r3;
}
r(zA, "rotateZ");
function FA(r3, e) {
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = e[0], r3[13] = e[1], r3[14] = e[2], r3[15] = 1, r3;
}
r(FA, "fromTranslation");
function RA(r3, e) {
  return r3[0] = e[0], r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = e[1], r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = e[2], r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(RA, "fromScaling");
function BA(r3, e, t3) {
  var i = t3[0], n = t3[1], o = t3[2], a = Math.hypot(i, n, o), s3, l, c;
  return a < oe ? null : (a = 1 / a, i *= a, n *= a, o *= a, s3 = Math.sin(e), l = Math.cos(e), c = 1 - l, r3[0] = i * i * c + l, r3[1] = n * i * c + o * s3, r3[2] = o * i * c - n * s3, r3[3] = 0, r3[4] = i * n * c - o * s3, r3[5] = n * n * c + l, r3[6] = o * n * c + i * s3, r3[7] = 0, r3[8] = i * o * c + n * s3, r3[9] = n * o * c - i * s3, r3[10] = o * o * c + l, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3);
}
r(BA, "fromRotation");
function OA(r3, e) {
  var t3 = Math.sin(e), i = Math.cos(e);
  return r3[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = i, r3[6] = t3, r3[7] = 0, r3[8] = 0, r3[9] = -t3, r3[10] = i, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(OA, "fromXRotation");
function VA(r3, e) {
  var t3 = Math.sin(e), i = Math.cos(e);
  return r3[0] = i, r3[1] = 0, r3[2] = -t3, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = t3, r3[9] = 0, r3[10] = i, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(VA, "fromYRotation");
function UA(r3, e) {
  var t3 = Math.sin(e), i = Math.cos(e);
  return r3[0] = i, r3[1] = t3, r3[2] = 0, r3[3] = 0, r3[4] = -t3, r3[5] = i, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(UA, "fromZRotation");
function Q_(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3], s3 = i + i, l = n + n, c = o + o, p = i * s3, h = i * l, f = i * c, m = n * l, y = n * c, g = o * c, x = a * s3, b = a * l, w = a * c;
  return r3[0] = 1 - (m + g), r3[1] = h + w, r3[2] = f - b, r3[3] = 0, r3[4] = h - w, r3[5] = 1 - (p + g), r3[6] = y + x, r3[7] = 0, r3[8] = f + b, r3[9] = y - x, r3[10] = 1 - (p + m), r3[11] = 0, r3[12] = t3[0], r3[13] = t3[1], r3[14] = t3[2], r3[15] = 1, r3;
}
r(Q_, "fromRotationTranslation");
function NA(r3, e) {
  var t3 = new we(3), i = -e[0], n = -e[1], o = -e[2], a = e[3], s3 = e[4], l = e[5], c = e[6], p = e[7], h = i * i + n * n + o * o + a * a;
  return h > 0 ? (t3[0] = (s3 * a + p * i + l * o - c * n) * 2 / h, t3[1] = (l * a + p * n + c * i - s3 * o) * 2 / h, t3[2] = (c * a + p * o + s3 * n - l * i) * 2 / h) : (t3[0] = (s3 * a + p * i + l * o - c * n) * 2, t3[1] = (l * a + p * n + c * i - s3 * o) * 2, t3[2] = (c * a + p * o + s3 * n - l * i) * 2), Q_(r3, e, t3), r3;
}
r(NA, "fromQuat2");
function GA(r3, e) {
  return r3[0] = e[12], r3[1] = e[13], r3[2] = e[14], r3;
}
r(GA, "getTranslation");
function ev(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[4], a = e[5], s3 = e[6], l = e[8], c = e[9], p = e[10];
  return r3[0] = Math.hypot(t3, i, n), r3[1] = Math.hypot(o, a, s3), r3[2] = Math.hypot(l, c, p), r3;
}
r(ev, "getScaling");
function $A(r3, e) {
  var t3 = new we(3);
  ev(t3, e);
  var i = 1 / t3[0], n = 1 / t3[1], o = 1 / t3[2], a = e[0] * i, s3 = e[1] * n, l = e[2] * o, c = e[4] * i, p = e[5] * n, h = e[6] * o, f = e[8] * i, m = e[9] * n, y = e[10] * o, g = a + p + y, x = 0;
  return g > 0 ? (x = Math.sqrt(g + 1) * 2, r3[3] = 0.25 * x, r3[0] = (h - m) / x, r3[1] = (f - l) / x, r3[2] = (s3 - c) / x) : a > p && a > y ? (x = Math.sqrt(1 + a - p - y) * 2, r3[3] = (h - m) / x, r3[0] = 0.25 * x, r3[1] = (s3 + c) / x, r3[2] = (f + l) / x) : p > y ? (x = Math.sqrt(1 + p - a - y) * 2, r3[3] = (f - l) / x, r3[0] = (s3 + c) / x, r3[1] = 0.25 * x, r3[2] = (h + m) / x) : (x = Math.sqrt(1 + y - a - p) * 2, r3[3] = (s3 - c) / x, r3[0] = (f + l) / x, r3[1] = (h + m) / x, r3[2] = 0.25 * x), r3;
}
r($A, "getRotation");
function qA(r3, e, t3, i) {
  var n = e[0], o = e[1], a = e[2], s3 = e[3], l = n + n, c = o + o, p = a + a, h = n * l, f = n * c, m = n * p, y = o * c, g = o * p, x = a * p, b = s3 * l, w = s3 * c, _ = s3 * p, S = i[0], P = i[1], T = i[2];
  return r3[0] = (1 - (y + x)) * S, r3[1] = (f + _) * S, r3[2] = (m - w) * S, r3[3] = 0, r3[4] = (f - _) * P, r3[5] = (1 - (h + x)) * P, r3[6] = (g + b) * P, r3[7] = 0, r3[8] = (m + w) * T, r3[9] = (g - b) * T, r3[10] = (1 - (h + y)) * T, r3[11] = 0, r3[12] = t3[0], r3[13] = t3[1], r3[14] = t3[2], r3[15] = 1, r3;
}
r(qA, "fromRotationTranslationScale");
function jA(r3, e, t3, i, n) {
  var o = e[0], a = e[1], s3 = e[2], l = e[3], c = o + o, p = a + a, h = s3 + s3, f = o * c, m = o * p, y = o * h, g = a * p, x = a * h, b = s3 * h, w = l * c, _ = l * p, S = l * h, P = i[0], T = i[1], L = i[2], C = n[0], E = n[1], I = n[2], R = (1 - (g + b)) * P, z = (m + S) * P, k = (y - _) * P, M = (m - S) * T, G = (1 - (f + b)) * T, K = (x + w) * T, ne = (y + _) * L, J = (x - w) * L, W = (1 - (f + g)) * L;
  return r3[0] = R, r3[1] = z, r3[2] = k, r3[3] = 0, r3[4] = M, r3[5] = G, r3[6] = K, r3[7] = 0, r3[8] = ne, r3[9] = J, r3[10] = W, r3[11] = 0, r3[12] = t3[0] + C - (R * C + M * E + ne * I), r3[13] = t3[1] + E - (z * C + G * E + J * I), r3[14] = t3[2] + I - (k * C + K * E + W * I), r3[15] = 1, r3;
}
r(jA, "fromRotationTranslationScaleOrigin");
function ZA(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = t3 + t3, s3 = i + i, l = n + n, c = t3 * a, p = i * a, h = i * s3, f = n * a, m = n * s3, y = n * l, g = o * a, x = o * s3, b = o * l;
  return r3[0] = 1 - h - y, r3[1] = p + b, r3[2] = f - x, r3[3] = 0, r3[4] = p - b, r3[5] = 1 - c - y, r3[6] = m + g, r3[7] = 0, r3[8] = f + x, r3[9] = m - g, r3[10] = 1 - c - h, r3[11] = 0, r3[12] = 0, r3[13] = 0, r3[14] = 0, r3[15] = 1, r3;
}
r(ZA, "fromQuat");
function HA(r3, e, t3, i, n, o, a) {
  var s3 = 1 / (t3 - e), l = 1 / (n - i), c = 1 / (o - a);
  return r3[0] = o * 2 * s3, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = o * 2 * l, r3[6] = 0, r3[7] = 0, r3[8] = (t3 + e) * s3, r3[9] = (n + i) * l, r3[10] = (a + o) * c, r3[11] = -1, r3[12] = 0, r3[13] = 0, r3[14] = a * o * 2 * c, r3[15] = 0, r3;
}
r(HA, "frustum");
function tv(r3, e, t3, i, n) {
  var o = 1 / Math.tan(e / 2), a;
  return r3[0] = o / t3, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = o, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[11] = -1, r3[12] = 0, r3[13] = 0, r3[15] = 0, n != null && n !== 1 / 0 ? (a = 1 / (i - n), r3[10] = (n + i) * a, r3[14] = 2 * n * i * a) : (r3[10] = -1, r3[14] = -2 * i), r3;
}
r(tv, "perspectiveNO");
var WA = tv;
function XA(r3, e, t3, i, n) {
  var o = 1 / Math.tan(e / 2), a;
  return r3[0] = o / t3, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = o, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[11] = -1, r3[12] = 0, r3[13] = 0, r3[15] = 0, n != null && n !== 1 / 0 ? (a = 1 / (i - n), r3[10] = n * a, r3[14] = n * i * a) : (r3[10] = -1, r3[14] = -i), r3;
}
r(XA, "perspectiveZO");
function KA(r3, e, t3, i) {
  var n = Math.tan(e.upDegrees * Math.PI / 180), o = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), s3 = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (a + s3), c = 2 / (n + o);
  return r3[0] = l, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = c, r3[6] = 0, r3[7] = 0, r3[8] = -((a - s3) * l * 0.5), r3[9] = (n - o) * c * 0.5, r3[10] = i / (t3 - i), r3[11] = -1, r3[12] = 0, r3[13] = 0, r3[14] = i * t3 / (t3 - i), r3[15] = 0, r3;
}
r(KA, "perspectiveFromFieldOfView");
function rv(r3, e, t3, i, n, o, a) {
  var s3 = 1 / (e - t3), l = 1 / (i - n), c = 1 / (o - a);
  return r3[0] = -2 * s3, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = -2 * l, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 2 * c, r3[11] = 0, r3[12] = (e + t3) * s3, r3[13] = (n + i) * l, r3[14] = (a + o) * c, r3[15] = 1, r3;
}
r(rv, "orthoNO");
var JA = rv;
function YA(r3, e, t3, i, n, o, a) {
  var s3 = 1 / (e - t3), l = 1 / (i - n), c = 1 / (o - a);
  return r3[0] = -2 * s3, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = -2 * l, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = c, r3[11] = 0, r3[12] = (e + t3) * s3, r3[13] = (n + i) * l, r3[14] = o * c, r3[15] = 1, r3;
}
r(YA, "orthoZO");
function QA(r3, e, t3, i) {
  var n, o, a, s3, l, c, p, h, f, m, y = e[0], g = e[1], x = e[2], b = i[0], w = i[1], _ = i[2], S = t3[0], P = t3[1], T = t3[2];
  return Math.abs(y - S) < oe && Math.abs(g - P) < oe && Math.abs(x - T) < oe ? J_(r3) : (p = y - S, h = g - P, f = x - T, m = 1 / Math.hypot(p, h, f), p *= m, h *= m, f *= m, n = w * f - _ * h, o = _ * p - b * f, a = b * h - w * p, m = Math.hypot(n, o, a), m ? (m = 1 / m, n *= m, o *= m, a *= m) : (n = 0, o = 0, a = 0), s3 = h * a - f * o, l = f * n - p * a, c = p * o - h * n, m = Math.hypot(s3, l, c), m ? (m = 1 / m, s3 *= m, l *= m, c *= m) : (s3 = 0, l = 0, c = 0), r3[0] = n, r3[1] = s3, r3[2] = p, r3[3] = 0, r3[4] = o, r3[5] = l, r3[6] = h, r3[7] = 0, r3[8] = a, r3[9] = c, r3[10] = f, r3[11] = 0, r3[12] = -(n * y + o * g + a * x), r3[13] = -(s3 * y + l * g + c * x), r3[14] = -(p * y + h * g + f * x), r3[15] = 1, r3);
}
r(QA, "lookAt");
function eI(r3, e, t3, i) {
  var n = e[0], o = e[1], a = e[2], s3 = i[0], l = i[1], c = i[2], p = n - t3[0], h = o - t3[1], f = a - t3[2], m = p * p + h * h + f * f;
  m > 0 && (m = 1 / Math.sqrt(m), p *= m, h *= m, f *= m);
  var y = l * f - c * h, g = c * p - s3 * f, x = s3 * h - l * p;
  return m = y * y + g * g + x * x, m > 0 && (m = 1 / Math.sqrt(m), y *= m, g *= m, x *= m), r3[0] = y, r3[1] = g, r3[2] = x, r3[3] = 0, r3[4] = h * x - f * g, r3[5] = f * y - p * x, r3[6] = p * g - h * y, r3[7] = 0, r3[8] = p, r3[9] = h, r3[10] = f, r3[11] = 0, r3[12] = n, r3[13] = o, r3[14] = a, r3[15] = 1, r3;
}
r(eI, "targetTo");
function tI(r3) {
  return "mat4(" + r3[0] + ", " + r3[1] + ", " + r3[2] + ", " + r3[3] + ", " + r3[4] + ", " + r3[5] + ", " + r3[6] + ", " + r3[7] + ", " + r3[8] + ", " + r3[9] + ", " + r3[10] + ", " + r3[11] + ", " + r3[12] + ", " + r3[13] + ", " + r3[14] + ", " + r3[15] + ")";
}
r(tI, "str");
function rI(r3) {
  return Math.hypot(r3[0], r3[1], r3[2], r3[3], r3[4], r3[5], r3[6], r3[7], r3[8], r3[9], r3[10], r3[11], r3[12], r3[13], r3[14], r3[15]);
}
r(rI, "frob");
function iI(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3[2] = e[2] + t3[2], r3[3] = e[3] + t3[3], r3[4] = e[4] + t3[4], r3[5] = e[5] + t3[5], r3[6] = e[6] + t3[6], r3[7] = e[7] + t3[7], r3[8] = e[8] + t3[8], r3[9] = e[9] + t3[9], r3[10] = e[10] + t3[10], r3[11] = e[11] + t3[11], r3[12] = e[12] + t3[12], r3[13] = e[13] + t3[13], r3[14] = e[14] + t3[14], r3[15] = e[15] + t3[15], r3;
}
r(iI, "add");
function iv(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3[2] = e[2] - t3[2], r3[3] = e[3] - t3[3], r3[4] = e[4] - t3[4], r3[5] = e[5] - t3[5], r3[6] = e[6] - t3[6], r3[7] = e[7] - t3[7], r3[8] = e[8] - t3[8], r3[9] = e[9] - t3[9], r3[10] = e[10] - t3[10], r3[11] = e[11] - t3[11], r3[12] = e[12] - t3[12], r3[13] = e[13] - t3[13], r3[14] = e[14] - t3[14], r3[15] = e[15] - t3[15], r3;
}
r(iv, "subtract");
function nI(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3[2] = e[2] * t3, r3[3] = e[3] * t3, r3[4] = e[4] * t3, r3[5] = e[5] * t3, r3[6] = e[6] * t3, r3[7] = e[7] * t3, r3[8] = e[8] * t3, r3[9] = e[9] * t3, r3[10] = e[10] * t3, r3[11] = e[11] * t3, r3[12] = e[12] * t3, r3[13] = e[13] * t3, r3[14] = e[14] * t3, r3[15] = e[15] * t3, r3;
}
r(nI, "multiplyScalar");
function oI(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3[2] = e[2] + t3[2] * i, r3[3] = e[3] + t3[3] * i, r3[4] = e[4] + t3[4] * i, r3[5] = e[5] + t3[5] * i, r3[6] = e[6] + t3[6] * i, r3[7] = e[7] + t3[7] * i, r3[8] = e[8] + t3[8] * i, r3[9] = e[9] + t3[9] * i, r3[10] = e[10] + t3[10] * i, r3[11] = e[11] + t3[11] * i, r3[12] = e[12] + t3[12] * i, r3[13] = e[13] + t3[13] * i, r3[14] = e[14] + t3[14] * i, r3[15] = e[15] + t3[15] * i, r3;
}
r(oI, "multiplyScalarAndAdd");
function aI(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1] && r3[2] === e[2] && r3[3] === e[3] && r3[4] === e[4] && r3[5] === e[5] && r3[6] === e[6] && r3[7] === e[7] && r3[8] === e[8] && r3[9] === e[9] && r3[10] === e[10] && r3[11] === e[11] && r3[12] === e[12] && r3[13] === e[13] && r3[14] === e[14] && r3[15] === e[15];
}
r(aI, "exactEquals");
function sI(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = r3[3], a = r3[4], s3 = r3[5], l = r3[6], c = r3[7], p = r3[8], h = r3[9], f = r3[10], m = r3[11], y = r3[12], g = r3[13], x = r3[14], b = r3[15], w = e[0], _ = e[1], S = e[2], P = e[3], T = e[4], L = e[5], C = e[6], E = e[7], I = e[8], R = e[9], z = e[10], k = e[11], M = e[12], G = e[13], K = e[14], ne = e[15];
  return Math.abs(t3 - w) <= oe * Math.max(1, Math.abs(t3), Math.abs(w)) && Math.abs(i - _) <= oe * Math.max(1, Math.abs(i), Math.abs(_)) && Math.abs(n - S) <= oe * Math.max(1, Math.abs(n), Math.abs(S)) && Math.abs(o - P) <= oe * Math.max(1, Math.abs(o), Math.abs(P)) && Math.abs(a - T) <= oe * Math.max(1, Math.abs(a), Math.abs(T)) && Math.abs(s3 - L) <= oe * Math.max(1, Math.abs(s3), Math.abs(L)) && Math.abs(l - C) <= oe * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(c - E) <= oe * Math.max(1, Math.abs(c), Math.abs(E)) && Math.abs(p - I) <= oe * Math.max(1, Math.abs(p), Math.abs(I)) && Math.abs(h - R) <= oe * Math.max(1, Math.abs(h), Math.abs(R)) && Math.abs(f - z) <= oe * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(m - k) <= oe * Math.max(1, Math.abs(m), Math.abs(k)) && Math.abs(y - M) <= oe * Math.max(1, Math.abs(y), Math.abs(M)) && Math.abs(g - G) <= oe * Math.max(1, Math.abs(g), Math.abs(G)) && Math.abs(x - K) <= oe * Math.max(1, Math.abs(x), Math.abs(K)) && Math.abs(b - ne) <= oe * Math.max(1, Math.abs(b), Math.abs(ne));
}
r(sI, "equals");
var lI = Y_;
var uI = iv;
var gt = {};
t(gt, { add: () => mI, angle: () => RI, bezier: () => II, ceil: () => dI, clone: () => cI, copy: () => hI, create: () => nv, cross: () => TI, dist: () => qI, distance: () => uv, div: () => $I, divide: () => lv, dot: () => hv, equals: () => UI, exactEquals: () => VI, floor: () => yI, forEach: () => WI, fromValues: () => pI, hermite: () => AI, inverse: () => SI, len: () => ZI, length: () => ov, lerp: () => MI, max: () => xI, min: () => gI, mul: () => GI, multiply: () => sv, negate: () => wI, normalize: () => PI, random: () => CI, rotateX: () => DI, rotateY: () => zI, rotateZ: () => FI, round: () => bI, scale: () => _I, scaleAndAdd: () => vI, set: () => fI, sqrDist: () => jI, sqrLen: () => HI, squaredDistance: () => cv, squaredLength: () => pv, str: () => OI, sub: () => NI, subtract: () => av, transformMat3: () => kI, transformMat4: () => EI, transformQuat: () => LI, zero: () => BI });
q();
function nv() {
  var r3 = new we(3);
  return we != Float32Array && (r3[0] = 0, r3[1] = 0, r3[2] = 0), r3;
}
r(nv, "create");
function cI(r3) {
  var e = new we(3);
  return e[0] = r3[0], e[1] = r3[1], e[2] = r3[2], e;
}
r(cI, "clone");
function ov(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2];
  return Math.hypot(e, t3, i);
}
r(ov, "length");
function pI(r3, e, t3) {
  var i = new we(3);
  return i[0] = r3, i[1] = e, i[2] = t3, i;
}
r(pI, "fromValues");
function hI(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3;
}
r(hI, "copy");
function fI(r3, e, t3, i) {
  return r3[0] = e, r3[1] = t3, r3[2] = i, r3;
}
r(fI, "set");
function mI(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3[2] = e[2] + t3[2], r3;
}
r(mI, "add");
function av(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3[2] = e[2] - t3[2], r3;
}
r(av, "subtract");
function sv(r3, e, t3) {
  return r3[0] = e[0] * t3[0], r3[1] = e[1] * t3[1], r3[2] = e[2] * t3[2], r3;
}
r(sv, "multiply");
function lv(r3, e, t3) {
  return r3[0] = e[0] / t3[0], r3[1] = e[1] / t3[1], r3[2] = e[2] / t3[2], r3;
}
r(lv, "divide");
function dI(r3, e) {
  return r3[0] = Math.ceil(e[0]), r3[1] = Math.ceil(e[1]), r3[2] = Math.ceil(e[2]), r3;
}
r(dI, "ceil");
function yI(r3, e) {
  return r3[0] = Math.floor(e[0]), r3[1] = Math.floor(e[1]), r3[2] = Math.floor(e[2]), r3;
}
r(yI, "floor");
function gI(r3, e, t3) {
  return r3[0] = Math.min(e[0], t3[0]), r3[1] = Math.min(e[1], t3[1]), r3[2] = Math.min(e[2], t3[2]), r3;
}
r(gI, "min");
function xI(r3, e, t3) {
  return r3[0] = Math.max(e[0], t3[0]), r3[1] = Math.max(e[1], t3[1]), r3[2] = Math.max(e[2], t3[2]), r3;
}
r(xI, "max");
function bI(r3, e) {
  return r3[0] = Math.round(e[0]), r3[1] = Math.round(e[1]), r3[2] = Math.round(e[2]), r3;
}
r(bI, "round");
function _I(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3[2] = e[2] * t3, r3;
}
r(_I, "scale");
function vI(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3[2] = e[2] + t3[2] * i, r3;
}
r(vI, "scaleAndAdd");
function uv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1], n = e[2] - r3[2];
  return Math.hypot(t3, i, n);
}
r(uv, "distance");
function cv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1], n = e[2] - r3[2];
  return t3 * t3 + i * i + n * n;
}
r(cv, "squaredDistance");
function pv(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2];
  return e * e + t3 * t3 + i * i;
}
r(pv, "squaredLength");
function wI(r3, e) {
  return r3[0] = -e[0], r3[1] = -e[1], r3[2] = -e[2], r3;
}
r(wI, "negate");
function SI(r3, e) {
  return r3[0] = 1 / e[0], r3[1] = 1 / e[1], r3[2] = 1 / e[2], r3;
}
r(SI, "inverse");
function PI(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = t3 * t3 + i * i + n * n;
  return o > 0 && (o = 1 / Math.sqrt(o)), r3[0] = e[0] * o, r3[1] = e[1] * o, r3[2] = e[2] * o, r3;
}
r(PI, "normalize");
function hv(r3, e) {
  return r3[0] * e[0] + r3[1] * e[1] + r3[2] * e[2];
}
r(hv, "dot");
function TI(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = t3[0], s3 = t3[1], l = t3[2];
  return r3[0] = n * l - o * s3, r3[1] = o * a - i * l, r3[2] = i * s3 - n * a, r3;
}
r(TI, "cross");
function MI(r3, e, t3, i) {
  var n = e[0], o = e[1], a = e[2];
  return r3[0] = n + i * (t3[0] - n), r3[1] = o + i * (t3[1] - o), r3[2] = a + i * (t3[2] - a), r3;
}
r(MI, "lerp");
function AI(r3, e, t3, i, n, o) {
  var a = o * o, s3 = a * (2 * o - 3) + 1, l = a * (o - 2) + o, c = a * (o - 1), p = a * (3 - 2 * o);
  return r3[0] = e[0] * s3 + t3[0] * l + i[0] * c + n[0] * p, r3[1] = e[1] * s3 + t3[1] * l + i[1] * c + n[1] * p, r3[2] = e[2] * s3 + t3[2] * l + i[2] * c + n[2] * p, r3;
}
r(AI, "hermite");
function II(r3, e, t3, i, n, o) {
  var a = 1 - o, s3 = a * a, l = o * o, c = s3 * a, p = 3 * o * s3, h = 3 * l * a, f = l * o;
  return r3[0] = e[0] * c + t3[0] * p + i[0] * h + n[0] * f, r3[1] = e[1] * c + t3[1] * p + i[1] * h + n[1] * f, r3[2] = e[2] * c + t3[2] * p + i[2] * h + n[2] * f, r3;
}
r(II, "bezier");
function CI(r3, e) {
  e = e || 1;
  var t3 = qt() * 2 * Math.PI, i = qt() * 2 - 1, n = Math.sqrt(1 - i * i) * e;
  return r3[0] = Math.cos(t3) * n, r3[1] = Math.sin(t3) * n, r3[2] = i * e, r3;
}
r(CI, "random");
function EI(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = t3[3] * i + t3[7] * n + t3[11] * o + t3[15];
  return a = a || 1, r3[0] = (t3[0] * i + t3[4] * n + t3[8] * o + t3[12]) / a, r3[1] = (t3[1] * i + t3[5] * n + t3[9] * o + t3[13]) / a, r3[2] = (t3[2] * i + t3[6] * n + t3[10] * o + t3[14]) / a, r3;
}
r(EI, "transformMat4");
function kI(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2];
  return r3[0] = i * t3[0] + n * t3[3] + o * t3[6], r3[1] = i * t3[1] + n * t3[4] + o * t3[7], r3[2] = i * t3[2] + n * t3[5] + o * t3[8], r3;
}
r(kI, "transformMat3");
function LI(r3, e, t3) {
  var i = t3[0], n = t3[1], o = t3[2], a = t3[3], s3 = e[0], l = e[1], c = e[2], p = n * c - o * l, h = o * s3 - i * c, f = i * l - n * s3, m = n * f - o * h, y = o * p - i * f, g = i * h - n * p, x = a * 2;
  return p *= x, h *= x, f *= x, m *= 2, y *= 2, g *= 2, r3[0] = s3 + p + m, r3[1] = l + h + y, r3[2] = c + f + g, r3;
}
r(LI, "transformQuat");
function DI(r3, e, t3, i) {
  var n = [], o = [];
  return n[0] = e[0] - t3[0], n[1] = e[1] - t3[1], n[2] = e[2] - t3[2], o[0] = n[0], o[1] = n[1] * Math.cos(i) - n[2] * Math.sin(i), o[2] = n[1] * Math.sin(i) + n[2] * Math.cos(i), r3[0] = o[0] + t3[0], r3[1] = o[1] + t3[1], r3[2] = o[2] + t3[2], r3;
}
r(DI, "rotateX");
function zI(r3, e, t3, i) {
  var n = [], o = [];
  return n[0] = e[0] - t3[0], n[1] = e[1] - t3[1], n[2] = e[2] - t3[2], o[0] = n[2] * Math.sin(i) + n[0] * Math.cos(i), o[1] = n[1], o[2] = n[2] * Math.cos(i) - n[0] * Math.sin(i), r3[0] = o[0] + t3[0], r3[1] = o[1] + t3[1], r3[2] = o[2] + t3[2], r3;
}
r(zI, "rotateY");
function FI(r3, e, t3, i) {
  var n = [], o = [];
  return n[0] = e[0] - t3[0], n[1] = e[1] - t3[1], n[2] = e[2] - t3[2], o[0] = n[0] * Math.cos(i) - n[1] * Math.sin(i), o[1] = n[0] * Math.sin(i) + n[1] * Math.cos(i), o[2] = n[2], r3[0] = o[0] + t3[0], r3[1] = o[1] + t3[1], r3[2] = o[2] + t3[2], r3;
}
r(FI, "rotateZ");
function RI(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = e[0], a = e[1], s3 = e[2], l = Math.sqrt(t3 * t3 + i * i + n * n), c = Math.sqrt(o * o + a * a + s3 * s3), p = l * c, h = p && hv(r3, e) / p;
  return Math.acos(Math.min(Math.max(h, -1), 1));
}
r(RI, "angle");
function BI(r3) {
  return r3[0] = 0, r3[1] = 0, r3[2] = 0, r3;
}
r(BI, "zero");
function OI(r3) {
  return "vec3(" + r3[0] + ", " + r3[1] + ", " + r3[2] + ")";
}
r(OI, "str");
function VI(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1] && r3[2] === e[2];
}
r(VI, "exactEquals");
function UI(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = e[0], a = e[1], s3 = e[2];
  return Math.abs(t3 - o) <= oe * Math.max(1, Math.abs(t3), Math.abs(o)) && Math.abs(i - a) <= oe * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(n - s3) <= oe * Math.max(1, Math.abs(n), Math.abs(s3));
}
r(UI, "equals");
var NI = av;
var GI = sv;
var $I = lv;
var qI = uv;
var jI = cv;
var ZI = ov;
var HI = pv;
var WI = function() {
  var r3 = nv();
  return function(e, t3, i, n, o, a) {
    var s3, l;
    for (t3 || (t3 = 3), i || (i = 0), n ? l = Math.min(n * t3 + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t3) r3[0] = e[s3], r3[1] = e[s3 + 1], r3[2] = e[s3 + 2], o(r3, r3, a), e[s3] = r3[0], e[s3 + 1] = r3[1], e[s3 + 2] = r3[2];
    return e;
  };
}();
var $e = {};
t($e, { add: () => QI, ceil: () => eC, clone: () => XI, copy: () => JI, create: () => fv, cross: () => pC, dist: () => SC, distance: () => gv, div: () => wC, divide: () => yv, dot: () => cC, equals: () => bC, exactEquals: () => xC, floor: () => tC, forEach: () => AC, fromValues: () => KI, inverse: () => lC, len: () => TC, length: () => bv, lerp: () => hC, max: () => iC, min: () => rC, mul: () => vC, multiply: () => dv, negate: () => sC, normalize: () => uC, random: () => fC, round: () => nC, scale: () => oC, scaleAndAdd: () => aC, set: () => YI, sqrDist: () => PC, sqrLen: () => MC, squaredDistance: () => xv, squaredLength: () => _v, str: () => gC, sub: () => _C, subtract: () => mv, transformMat4: () => mC, transformQuat: () => dC, zero: () => yC });
q();
function fv() {
  var r3 = new we(4);
  return we != Float32Array && (r3[0] = 0, r3[1] = 0, r3[2] = 0, r3[3] = 0), r3;
}
r(fv, "create");
function XI(r3) {
  var e = new we(4);
  return e[0] = r3[0], e[1] = r3[1], e[2] = r3[2], e[3] = r3[3], e;
}
r(XI, "clone");
function KI(r3, e, t3, i) {
  var n = new we(4);
  return n[0] = r3, n[1] = e, n[2] = t3, n[3] = i, n;
}
r(KI, "fromValues");
function JI(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3[2] = e[2], r3[3] = e[3], r3;
}
r(JI, "copy");
function YI(r3, e, t3, i, n) {
  return r3[0] = e, r3[1] = t3, r3[2] = i, r3[3] = n, r3;
}
r(YI, "set");
function QI(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3[2] = e[2] + t3[2], r3[3] = e[3] + t3[3], r3;
}
r(QI, "add");
function mv(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3[2] = e[2] - t3[2], r3[3] = e[3] - t3[3], r3;
}
r(mv, "subtract");
function dv(r3, e, t3) {
  return r3[0] = e[0] * t3[0], r3[1] = e[1] * t3[1], r3[2] = e[2] * t3[2], r3[3] = e[3] * t3[3], r3;
}
r(dv, "multiply");
function yv(r3, e, t3) {
  return r3[0] = e[0] / t3[0], r3[1] = e[1] / t3[1], r3[2] = e[2] / t3[2], r3[3] = e[3] / t3[3], r3;
}
r(yv, "divide");
function eC(r3, e) {
  return r3[0] = Math.ceil(e[0]), r3[1] = Math.ceil(e[1]), r3[2] = Math.ceil(e[2]), r3[3] = Math.ceil(e[3]), r3;
}
r(eC, "ceil");
function tC(r3, e) {
  return r3[0] = Math.floor(e[0]), r3[1] = Math.floor(e[1]), r3[2] = Math.floor(e[2]), r3[3] = Math.floor(e[3]), r3;
}
r(tC, "floor");
function rC(r3, e, t3) {
  return r3[0] = Math.min(e[0], t3[0]), r3[1] = Math.min(e[1], t3[1]), r3[2] = Math.min(e[2], t3[2]), r3[3] = Math.min(e[3], t3[3]), r3;
}
r(rC, "min");
function iC(r3, e, t3) {
  return r3[0] = Math.max(e[0], t3[0]), r3[1] = Math.max(e[1], t3[1]), r3[2] = Math.max(e[2], t3[2]), r3[3] = Math.max(e[3], t3[3]), r3;
}
r(iC, "max");
function nC(r3, e) {
  return r3[0] = Math.round(e[0]), r3[1] = Math.round(e[1]), r3[2] = Math.round(e[2]), r3[3] = Math.round(e[3]), r3;
}
r(nC, "round");
function oC(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3[2] = e[2] * t3, r3[3] = e[3] * t3, r3;
}
r(oC, "scale");
function aC(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3[2] = e[2] + t3[2] * i, r3[3] = e[3] + t3[3] * i, r3;
}
r(aC, "scaleAndAdd");
function gv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1], n = e[2] - r3[2], o = e[3] - r3[3];
  return Math.hypot(t3, i, n, o);
}
r(gv, "distance");
function xv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1], n = e[2] - r3[2], o = e[3] - r3[3];
  return t3 * t3 + i * i + n * n + o * o;
}
r(xv, "squaredDistance");
function bv(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2], n = r3[3];
  return Math.hypot(e, t3, i, n);
}
r(bv, "length");
function _v(r3) {
  var e = r3[0], t3 = r3[1], i = r3[2], n = r3[3];
  return e * e + t3 * t3 + i * i + n * n;
}
r(_v, "squaredLength");
function sC(r3, e) {
  return r3[0] = -e[0], r3[1] = -e[1], r3[2] = -e[2], r3[3] = -e[3], r3;
}
r(sC, "negate");
function lC(r3, e) {
  return r3[0] = 1 / e[0], r3[1] = 1 / e[1], r3[2] = 1 / e[2], r3[3] = 1 / e[3], r3;
}
r(lC, "inverse");
function uC(r3, e) {
  var t3 = e[0], i = e[1], n = e[2], o = e[3], a = t3 * t3 + i * i + n * n + o * o;
  return a > 0 && (a = 1 / Math.sqrt(a)), r3[0] = t3 * a, r3[1] = i * a, r3[2] = n * a, r3[3] = o * a, r3;
}
r(uC, "normalize");
function cC(r3, e) {
  return r3[0] * e[0] + r3[1] * e[1] + r3[2] * e[2] + r3[3] * e[3];
}
r(cC, "dot");
function pC(r3, e, t3, i) {
  var n = t3[0] * i[1] - t3[1] * i[0], o = t3[0] * i[2] - t3[2] * i[0], a = t3[0] * i[3] - t3[3] * i[0], s3 = t3[1] * i[2] - t3[2] * i[1], l = t3[1] * i[3] - t3[3] * i[1], c = t3[2] * i[3] - t3[3] * i[2], p = e[0], h = e[1], f = e[2], m = e[3];
  return r3[0] = h * c - f * l + m * s3, r3[1] = -(p * c) + f * a - m * o, r3[2] = p * l - h * a + m * n, r3[3] = -(p * s3) + h * o - f * n, r3;
}
r(pC, "cross");
function hC(r3, e, t3, i) {
  var n = e[0], o = e[1], a = e[2], s3 = e[3];
  return r3[0] = n + i * (t3[0] - n), r3[1] = o + i * (t3[1] - o), r3[2] = a + i * (t3[2] - a), r3[3] = s3 + i * (t3[3] - s3), r3;
}
r(hC, "lerp");
function fC(r3, e) {
  e = e || 1;
  var t3, i, n, o, a, s3;
  do
    t3 = qt() * 2 - 1, i = qt() * 2 - 1, a = t3 * t3 + i * i;
  while (a >= 1);
  do
    n = qt() * 2 - 1, o = qt() * 2 - 1, s3 = n * n + o * o;
  while (s3 >= 1);
  var l = Math.sqrt((1 - a) / s3);
  return r3[0] = e * t3, r3[1] = e * i, r3[2] = e * n * l, r3[3] = e * o * l, r3;
}
r(fC, "random");
function mC(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = e[3];
  return r3[0] = t3[0] * i + t3[4] * n + t3[8] * o + t3[12] * a, r3[1] = t3[1] * i + t3[5] * n + t3[9] * o + t3[13] * a, r3[2] = t3[2] * i + t3[6] * n + t3[10] * o + t3[14] * a, r3[3] = t3[3] * i + t3[7] * n + t3[11] * o + t3[15] * a, r3;
}
r(mC, "transformMat4");
function dC(r3, e, t3) {
  var i = e[0], n = e[1], o = e[2], a = t3[0], s3 = t3[1], l = t3[2], c = t3[3], p = c * i + s3 * o - l * n, h = c * n + l * i - a * o, f = c * o + a * n - s3 * i, m = -a * i - s3 * n - l * o;
  return r3[0] = p * c + m * -a + h * -l - f * -s3, r3[1] = h * c + m * -s3 + f * -a - p * -l, r3[2] = f * c + m * -l + p * -s3 - h * -a, r3[3] = e[3], r3;
}
r(dC, "transformQuat");
function yC(r3) {
  return r3[0] = 0, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3;
}
r(yC, "zero");
function gC(r3) {
  return "vec4(" + r3[0] + ", " + r3[1] + ", " + r3[2] + ", " + r3[3] + ")";
}
r(gC, "str");
function xC(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1] && r3[2] === e[2] && r3[3] === e[3];
}
r(xC, "exactEquals");
function bC(r3, e) {
  var t3 = r3[0], i = r3[1], n = r3[2], o = r3[3], a = e[0], s3 = e[1], l = e[2], c = e[3];
  return Math.abs(t3 - a) <= oe * Math.max(1, Math.abs(t3), Math.abs(a)) && Math.abs(i - s3) <= oe * Math.max(1, Math.abs(i), Math.abs(s3)) && Math.abs(n - l) <= oe * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - c) <= oe * Math.max(1, Math.abs(o), Math.abs(c));
}
r(bC, "equals");
var _C = mv;
var vC = dv;
var wC = yv;
var SC = gv;
var PC = xv;
var TC = bv;
var MC = _v;
var AC = function() {
  var r3 = fv();
  return function(e, t3, i, n, o, a) {
    var s3, l;
    for (t3 || (t3 = 4), i || (i = 0), n ? l = Math.min(n * t3 + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t3) r3[0] = e[s3], r3[1] = e[s3 + 1], r3[2] = e[s3 + 2], r3[3] = e[s3 + 3], o(r3, r3, a), e[s3] = r3[0], e[s3 + 1] = r3[1], e[s3 + 2] = r3[2], e[s3 + 3] = r3[3];
    return e;
  };
}();
var nn = {};
t(nn, { add: () => LC, angle: () => YC, ceil: () => DC, clone: () => IC, copy: () => EC, create: () => vv, cross: () => qC, dist: () => sE, distance: () => Tv, div: () => aE, divide: () => Pv, dot: () => $C, equals: () => rE, exactEquals: () => tE, floor: () => zC, forEach: () => cE, fromValues: () => CC, inverse: () => NC, len: () => iE, length: () => Av, lerp: () => jC, max: () => RC, min: () => FC, mul: () => oE, multiply: () => Sv, negate: () => UC, normalize: () => GC, random: () => ZC, rotate: () => JC, round: () => BC, scale: () => OC, scaleAndAdd: () => VC, set: () => kC, sqrDist: () => lE, sqrLen: () => uE, squaredDistance: () => Mv, squaredLength: () => Iv, str: () => eE, sub: () => nE, subtract: () => wv, transformMat2: () => HC, transformMat2d: () => WC, transformMat3: () => XC, transformMat4: () => KC, zero: () => QC });
q();
function vv() {
  var r3 = new we(2);
  return we != Float32Array && (r3[0] = 0, r3[1] = 0), r3;
}
r(vv, "create");
function IC(r3) {
  var e = new we(2);
  return e[0] = r3[0], e[1] = r3[1], e;
}
r(IC, "clone");
function CC(r3, e) {
  var t3 = new we(2);
  return t3[0] = r3, t3[1] = e, t3;
}
r(CC, "fromValues");
function EC(r3, e) {
  return r3[0] = e[0], r3[1] = e[1], r3;
}
r(EC, "copy");
function kC(r3, e, t3) {
  return r3[0] = e, r3[1] = t3, r3;
}
r(kC, "set");
function LC(r3, e, t3) {
  return r3[0] = e[0] + t3[0], r3[1] = e[1] + t3[1], r3;
}
r(LC, "add");
function wv(r3, e, t3) {
  return r3[0] = e[0] - t3[0], r3[1] = e[1] - t3[1], r3;
}
r(wv, "subtract");
function Sv(r3, e, t3) {
  return r3[0] = e[0] * t3[0], r3[1] = e[1] * t3[1], r3;
}
r(Sv, "multiply");
function Pv(r3, e, t3) {
  return r3[0] = e[0] / t3[0], r3[1] = e[1] / t3[1], r3;
}
r(Pv, "divide");
function DC(r3, e) {
  return r3[0] = Math.ceil(e[0]), r3[1] = Math.ceil(e[1]), r3;
}
r(DC, "ceil");
function zC(r3, e) {
  return r3[0] = Math.floor(e[0]), r3[1] = Math.floor(e[1]), r3;
}
r(zC, "floor");
function FC(r3, e, t3) {
  return r3[0] = Math.min(e[0], t3[0]), r3[1] = Math.min(e[1], t3[1]), r3;
}
r(FC, "min");
function RC(r3, e, t3) {
  return r3[0] = Math.max(e[0], t3[0]), r3[1] = Math.max(e[1], t3[1]), r3;
}
r(RC, "max");
function BC(r3, e) {
  return r3[0] = Math.round(e[0]), r3[1] = Math.round(e[1]), r3;
}
r(BC, "round");
function OC(r3, e, t3) {
  return r3[0] = e[0] * t3, r3[1] = e[1] * t3, r3;
}
r(OC, "scale");
function VC(r3, e, t3, i) {
  return r3[0] = e[0] + t3[0] * i, r3[1] = e[1] + t3[1] * i, r3;
}
r(VC, "scaleAndAdd");
function Tv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1];
  return Math.hypot(t3, i);
}
r(Tv, "distance");
function Mv(r3, e) {
  var t3 = e[0] - r3[0], i = e[1] - r3[1];
  return t3 * t3 + i * i;
}
r(Mv, "squaredDistance");
function Av(r3) {
  var e = r3[0], t3 = r3[1];
  return Math.hypot(e, t3);
}
r(Av, "length");
function Iv(r3) {
  var e = r3[0], t3 = r3[1];
  return e * e + t3 * t3;
}
r(Iv, "squaredLength");
function UC(r3, e) {
  return r3[0] = -e[0], r3[1] = -e[1], r3;
}
r(UC, "negate");
function NC(r3, e) {
  return r3[0] = 1 / e[0], r3[1] = 1 / e[1], r3;
}
r(NC, "inverse");
function GC(r3, e) {
  var t3 = e[0], i = e[1], n = t3 * t3 + i * i;
  return n > 0 && (n = 1 / Math.sqrt(n)), r3[0] = e[0] * n, r3[1] = e[1] * n, r3;
}
r(GC, "normalize");
function $C(r3, e) {
  return r3[0] * e[0] + r3[1] * e[1];
}
r($C, "dot");
function qC(r3, e, t3) {
  var i = e[0] * t3[1] - e[1] * t3[0];
  return r3[0] = r3[1] = 0, r3[2] = i, r3;
}
r(qC, "cross");
function jC(r3, e, t3, i) {
  var n = e[0], o = e[1];
  return r3[0] = n + i * (t3[0] - n), r3[1] = o + i * (t3[1] - o), r3;
}
r(jC, "lerp");
function ZC(r3, e) {
  e = e || 1;
  var t3 = qt() * 2 * Math.PI;
  return r3[0] = Math.cos(t3) * e, r3[1] = Math.sin(t3) * e, r3;
}
r(ZC, "random");
function HC(r3, e, t3) {
  var i = e[0], n = e[1];
  return r3[0] = t3[0] * i + t3[2] * n, r3[1] = t3[1] * i + t3[3] * n, r3;
}
r(HC, "transformMat2");
function WC(r3, e, t3) {
  var i = e[0], n = e[1];
  return r3[0] = t3[0] * i + t3[2] * n + t3[4], r3[1] = t3[1] * i + t3[3] * n + t3[5], r3;
}
r(WC, "transformMat2d");
function XC(r3, e, t3) {
  var i = e[0], n = e[1];
  return r3[0] = t3[0] * i + t3[3] * n + t3[6], r3[1] = t3[1] * i + t3[4] * n + t3[7], r3;
}
r(XC, "transformMat3");
function KC(r3, e, t3) {
  var i = e[0], n = e[1];
  return r3[0] = t3[0] * i + t3[4] * n + t3[12], r3[1] = t3[1] * i + t3[5] * n + t3[13], r3;
}
r(KC, "transformMat4");
function JC(r3, e, t3, i) {
  var n = e[0] - t3[0], o = e[1] - t3[1], a = Math.sin(i), s3 = Math.cos(i);
  return r3[0] = n * s3 - o * a + t3[0], r3[1] = n * a + o * s3 + t3[1], r3;
}
r(JC, "rotate");
function YC(r3, e) {
  var t3 = r3[0], i = r3[1], n = e[0], o = e[1], a = Math.sqrt(t3 * t3 + i * i) * Math.sqrt(n * n + o * o), s3 = a && (t3 * n + i * o) / a;
  return Math.acos(Math.min(Math.max(s3, -1), 1));
}
r(YC, "angle");
function QC(r3) {
  return r3[0] = 0, r3[1] = 0, r3;
}
r(QC, "zero");
function eE(r3) {
  return "vec2(" + r3[0] + ", " + r3[1] + ")";
}
r(eE, "str");
function tE(r3, e) {
  return r3[0] === e[0] && r3[1] === e[1];
}
r(tE, "exactEquals");
function rE(r3, e) {
  var t3 = r3[0], i = r3[1], n = e[0], o = e[1];
  return Math.abs(t3 - n) <= oe * Math.max(1, Math.abs(t3), Math.abs(n)) && Math.abs(i - o) <= oe * Math.max(1, Math.abs(i), Math.abs(o));
}
r(rE, "equals");
var iE = Av;
var nE = wv;
var oE = Sv;
var aE = Pv;
var sE = Tv;
var lE = Mv;
var uE = Iv;
var cE = function() {
  var r3 = vv();
  return function(e, t3, i, n, o, a) {
    var s3, l;
    for (t3 || (t3 = 2), i || (i = 0), n ? l = Math.min(n * t3 + i, e.length) : l = e.length, s3 = i; s3 < l; s3 += t3) r3[0] = e[s3], r3[1] = e[s3 + 1], o(r3, r3, a), e[s3] = r3[0], e[s3 + 1] = r3[1];
    return e;
  };
}();
var Cv = u(ge(), 1);
var gm = class gm2 extends Ge {
  constructor(e) {
    super(e, Z_);
  }
  createBucket(e) {
    return new ui(e);
  }
  queryRadius(e) {
    let t3 = e;
    return ci("circle-radius", this, t3) + ci("circle-stroke-width", this, t3) + Er(this.paint.get("circle-translate"));
  }
  queryIntersectsFeature(e, t3, i, n, o, a, s3, l) {
    let c = kr(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, s3), p = this.paint.get("circle-radius").evaluate(t3, i), h = this.paint.get("circle-stroke-width").evaluate(t3, i), f = p + h, m = this.paint.get("circle-pitch-alignment") === "map", y = m ? c : pE(c, l), g = m ? f * s3 : f;
    for (let x of n) for (let b of x) {
      let w = m ? b : Ev(b, l), _ = g, S = $e.transformMat4([], [b.x, b.y, 0, 1], l);
      if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? _ *= S[3] / a.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (_ *= a.cameraToCenterDistance / S[3]), V_(y, w, _)) return true;
    }
    return false;
  }
};
r(gm, "CircleStyleLayer");
var kl = gm;
function Ev(r3, e) {
  let t3 = $e.transformMat4([], [r3.x, r3.y, 0, 1], e);
  return new Cv.default(t3[0] / t3[3], t3[1] / t3[3]);
}
r(Ev, "projectPoint");
function pE(r3, e) {
  return r3.map((t3) => Ev(t3, e));
}
r(pE, "projectQueryGeometry");
q();
q();
var xm = class xm2 extends ui {
};
r(xm, "HeatmapBucket");
var Vo = xm;
N("HeatmapBucket", Vo, { omit: ["layers"] });
q();
var kv;
var hE = r(() => kv = kv || new De({ "heatmap-radius": new H(A.paint_heatmap["heatmap-radius"]), "heatmap-weight": new H(A.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new j(A.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ni(A.paint_heatmap["heatmap-color"]), "heatmap-opacity": new j(A.paint_heatmap["heatmap-opacity"]) }), "getPaint");
var Lv = { get paint() {
  return hE();
} };
q();
q();
function bm(r3, { width: e, height: t3 }, i, n) {
  if (!n) n = new Uint8Array(e * t3 * i);
  else if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);
  else if (n.length !== e * t3 * i) throw new RangeError(`mismatched image size. expected: ${n.length} but got: ${e * t3 * i}`);
  return r3.width = e, r3.height = t3, r3.data = n, r3;
}
r(bm, "createImage");
function Dv(r3, { width: e, height: t3 }, i) {
  if (e === r3.width && t3 === r3.height) return;
  let n = bm({}, { width: e, height: t3 }, i);
  _m(r3, n, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r3.width, e), height: Math.min(r3.height, t3) }, i), r3.width = e, r3.height = t3, r3.data = n.data;
}
r(Dv, "resizeImage");
function _m(r3, e, t3, i, n, o) {
  if (n.width === 0 || n.height === 0) return e;
  if (n.width > r3.width || n.height > r3.height || t3.x > r3.width - n.width || t3.y > r3.height - n.height) throw new RangeError("out of range source coordinates for image copy");
  if (n.width > e.width || n.height > e.height || i.x > e.width - n.width || i.y > e.height - n.height) throw new RangeError("out of range destination coordinates for image copy");
  let a = r3.data, s3 = e.data;
  if (a === s3) throw new Error("srcData equals dstData, so image is already copied");
  for (let l = 0; l < n.height; l++) {
    let c = ((t3.y + l) * r3.width + t3.x) * o, p = ((i.y + l) * e.width + i.x) * o;
    for (let h = 0; h < n.width * o; h++) s3[p + h] = a[c + h];
  }
  return e;
}
r(_m, "copyImage");
var Ll = class Ll2 {
  constructor(e, t3) {
    bm(this, e, 1, t3);
  }
  resize(e) {
    Dv(this, e, 1);
  }
  clone() {
    return new Ll2({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t3, i, n, o) {
    _m(e, t3, i, n, o, 1);
  }
};
r(Ll, "AlphaImage");
var pi = Ll;
var Dl = class Dl2 {
  constructor(e, t3) {
    bm(this, e, 4, t3);
  }
  resize(e) {
    Dv(this, e, 4);
  }
  replace(e, t3) {
    t3 ? this.data.set(e) : e instanceof Uint8ClampedArray ? this.data = new Uint8Array(e.buffer) : this.data = e;
  }
  clone() {
    return new Dl2({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t3, i, n, o) {
    _m(e, t3, i, n, o, 4);
  }
};
r(Dl, "RGBAImage");
var Se = Dl;
N("AlphaImage", pi);
N("RGBAImage", Se);
function zl(r3) {
  let e = {}, t3 = r3.resolution || 256, i = r3.clips ? r3.clips.length : 1, n = r3.image || new Se({ width: t3, height: i });
  if (!Xx(t3)) throw new Error(`width is not a power of 2 - ${t3}`);
  let o = r((a, s3, l) => {
    e[r3.evaluationKey] = l;
    let c = r3.expression.evaluate(e);
    n.data[a + s3 + 0] = Math.floor(c.r * 255 / c.a), n.data[a + s3 + 1] = Math.floor(c.g * 255 / c.a), n.data[a + s3 + 2] = Math.floor(c.b * 255 / c.a), n.data[a + s3 + 3] = Math.floor(c.a * 255);
  }, "renderPixel");
  if (r3.clips) for (let a = 0, s3 = 0; a < i; ++a, s3 += t3 * 4) for (let l = 0, c = 0; l < t3; l++, c += 4) {
    let p = l / (t3 - 1), { start: h, end: f } = r3.clips[a], m = h * (1 - p) + f * p;
    o(s3, c, m);
  }
  else for (let a = 0, s3 = 0; a < t3; a++, s3 += 4) {
    let l = a / (t3 - 1);
    o(0, s3, l);
  }
  return n;
}
r(zl, "renderColorRamp");
var vm = class vm2 extends Ge {
  createBucket(e) {
    return new Vo(e);
  }
  constructor(e) {
    super(e, Lv), this._updateColorRamp();
  }
  _handleSpecialPaintPropertyUpdate(e) {
    e === "heatmap-color" && this._updateColorRamp();
  }
  _updateColorRamp() {
    let e = this._transitionablePaint._values["heatmap-color"].value.expression;
    this.colorRamp = zl({ expression: e, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
  }
  resize() {
    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    return false;
  }
  hasOffscreenPass() {
    return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
  }
};
r(vm, "HeatmapStyleLayer");
var Fl = vm;
q();
q();
var zv;
var fE = r(() => zv = zv || new De({ "hillshade-illumination-direction": new j(A.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new j(A.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new j(A.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new j(A.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new j(A.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new j(A.paint_hillshade["hillshade-accent-color"]) }), "getPaint");
var Fv = { get paint() {
  return fE();
} };
var wm = class wm2 extends Ge {
  constructor(e) {
    super(e, Fv);
  }
  hasOffscreenPass() {
    return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
  }
};
r(wm, "HillshadeStyleLayer");
var Rl = wm;
q();
q();
q();
var mE = _e([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: Rv, size: nO, alignment: oO } = mE;
var Gv = u(Am(), 1);
q();
q();
function Im(r3, e, t3, i, n) {
  Nv(r3, e, t3 || 0, i || r3.length - 1, n || EE);
}
r(Im, "quickselect");
function Nv(r3, e, t3, i, n) {
  for (; i > t3; ) {
    if (i - t3 > 600) {
      var o = i - t3 + 1, a = e - t3 + 1, s3 = Math.log(o), l = 0.5 * Math.exp(2 * s3 / 3), c = 0.5 * Math.sqrt(s3 * l * (o - l) / o) * (a - o / 2 < 0 ? -1 : 1), p = Math.max(t3, Math.floor(e - a * l / o + c)), h = Math.min(i, Math.floor(e + (o - a) * l / o + c));
      Nv(r3, e, p, h, n);
    }
    var f = r3[e], m = t3, y = i;
    for ($o(r3, t3, e), n(r3[i], f) > 0 && $o(r3, t3, i); m < y; ) {
      for ($o(r3, m, y), m++, y--; n(r3[m], f) < 0; ) m++;
      for (; n(r3[y], f) > 0; ) y--;
    }
    n(r3[t3], f) === 0 ? $o(r3, t3, y) : (y++, $o(r3, y, i)), y <= e && (t3 = y + 1), e <= y && (i = y - 1);
  }
}
r(Nv, "quickselectStep");
function $o(r3, e, t3) {
  var i = r3[e];
  r3[e] = r3[t3], r3[t3] = i;
}
r($o, "swap");
function EE(r3, e) {
  return r3 < e ? -1 : r3 > e ? 1 : 0;
}
r(EE, "defaultCompare");
function qo(r3, e) {
  let t3 = r3.length;
  if (t3 <= 1) return [r3];
  let i = [], n, o;
  for (let a = 0; a < t3; a++) {
    let s3 = Qx(r3[a]);
    s3 !== 0 && (r3[a].area = Math.abs(s3), o === void 0 && (o = s3 < 0), o === s3 < 0 ? (n && i.push(n), n = [r3[a]]) : n.push(r3[a]));
  }
  if (n && i.push(n), e > 1) for (let a = 0; a < i.length; a++) i[a].length <= e || (Im(i[a], e, 1, i[a].length - 1, kE), i[a] = i[a].slice(0, e));
  return i;
}
r(qo, "classifyRings");
function kE(r3, e) {
  return e.area - r3.area;
}
r(kE, "compareAreas");
q();
function an(r3, e, t3) {
  let i = t3.patternDependencies, n = false;
  for (let o of e) {
    let a = o.paint.get(`${r3}-pattern`);
    a.isConstant() || (n = true);
    let s3 = a.constantOr(null);
    s3 && (n = true, i[s3.to] = true, i[s3.from] = true);
  }
  return n;
}
r(an, "hasPattern");
function sn(r3, e, t3, i, n) {
  let o = n.patternDependencies;
  for (let a of e) {
    let l = a.paint.get(`${r3}-pattern`).value;
    if (l.kind !== "constant") {
      let c = l.evaluate({ zoom: i - 1 }, t3, {}, n.availableImages), p = l.evaluate({ zoom: i }, t3, {}, n.availableImages), h = l.evaluate({ zoom: i + 1 }, t3, {}, n.availableImages);
      c = c && c.name ? c.name : c, p = p && p.name ? p.name : p, h = h && h.name ? h.name : h, o[c] = true, o[p] = true, o[h] = true, t3.patterns[a.id] = { min: c, mid: p, max: h };
    }
  }
  return t3;
}
r(sn, "addPatternDependencies");
var LE = 500;
var Cm = class Cm2 {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new fl(), this.indexArray = new rt(), this.indexArray2 = new Ar(), this.programConfigurations = new mt(e.layers, e.zoom), this.segments = new me(), this.segments2 = new me(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
  }
  populate(e, t3, i) {
    this.hasPattern = an("fill", this.layers, t3);
    let n = this.layers[0].layout.get("fill-sort-key"), o = !n.isConstant(), a = [];
    for (let { feature: s3, id: l, index: c, sourceLayerIndex: p } of e) {
      let h = this.layers[0]._featureFilter.needGeometry, f = yt(s3, h);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), f, i)) continue;
      let m = o ? n.evaluate(f, {}, i, t3.availableImages) : void 0, y = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: p, index: c, geometry: h ? f.geometry : dt(s3), patterns: {}, sortKey: m };
      a.push(y);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: c, sourceLayerIndex: p } = s3;
      if (this.hasPattern) {
        let f = sn("fill", this.layers, s3, this.zoom, t3);
        this.patternFeatures.push(f);
      } else this.addFeature(s3, l, c, i, {});
      let h = e[c].feature;
      t3.featureIndex.insert(h, l, c, p, this.index);
    }
  }
  update(e, t3, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t3, this.stateDependentLayers, i);
  }
  addFeatures(e, t3, i) {
    for (let n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t3, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Rv), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
  }
  addFeature(e, t3, i, n, o) {
    for (let a of qo(t3, LE)) {
      let s3 = 0;
      for (let m of a) s3 += m.length;
      let l = this.segments.prepareSegment(s3, this.layoutVertexArray, this.indexArray), c = l.vertexLength, p = [], h = [];
      for (let m of a) {
        if (m.length === 0) continue;
        m !== a[0] && h.push(p.length / 2);
        let y = this.segments2.prepareSegment(m.length, this.layoutVertexArray, this.indexArray2), g = y.vertexLength;
        this.layoutVertexArray.emplaceBack(m[0].x, m[0].y), this.indexArray2.emplaceBack(g + m.length - 1, g), p.push(m[0].x), p.push(m[0].y);
        for (let x = 1; x < m.length; x++) this.layoutVertexArray.emplaceBack(m[x].x, m[x].y), this.indexArray2.emplaceBack(g + x - 1, g + x), p.push(m[x].x), p.push(m[x].y);
        y.vertexLength += m.length, y.primitiveLength += m.length;
      }
      let f = (0, Gv.default)(p, h);
      for (let m = 0; m < f.length; m += 3) this.indexArray.emplaceBack(c + f[m], c + f[m + 1], c + f[m + 2]);
      l.vertexLength += s3, l.primitiveLength += f.length / 3;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
};
r(Cm, "FillBucket");
var jo = Cm;
N("FillBucket", jo, { omit: ["layers", "patternFeatures"] });
q();
var $v;
var DE = r(() => $v = $v || new De({ "fill-sort-key": new H(A.layout_fill["fill-sort-key"]) }), "getLayout");
var qv;
var zE = r(() => qv = qv || new De({ "fill-antialias": new j(A.paint_fill["fill-antialias"]), "fill-opacity": new H(A.paint_fill["fill-opacity"]), "fill-color": new H(A.paint_fill["fill-color"]), "fill-outline-color": new H(A.paint_fill["fill-outline-color"]), "fill-translate": new j(A.paint_fill["fill-translate"]), "fill-translate-anchor": new j(A.paint_fill["fill-translate-anchor"]), "fill-pattern": new or(A.paint_fill["fill-pattern"]) }), "getPaint");
var jv = { get paint() {
  return zE();
}, get layout() {
  return DE();
} };
var Em = class Em2 extends Ge {
  constructor(e) {
    super(e, jv);
  }
  recalculate(e, t3) {
    super.recalculate(e, t3);
    let i = this.paint._values["fill-outline-color"];
    i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
  }
  createBucket(e) {
    return new jo(e);
  }
  queryRadius() {
    return Er(this.paint.get("fill-translate"));
  }
  queryIntersectsFeature(e, t3, i, n, o, a, s3) {
    let l = kr(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, s3);
    return Cl(l, n);
  }
  isTileClipped() {
    return true;
  }
};
r(Em, "FillStyleLayer");
var Nl = Em;
q();
q();
q();
var FE = _e([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4);
var Zv = _e([{ name: "a_centroid", components: 2, type: "Int16" }], 4);
var { members: Hv, size: r4, alignment: i4 } = FE;
var Qv = u(Am(), 1);
var e0 = u(Zo(), 1);
var HE = e0.default.VectorTileFeature.types;
var WE = 500;
var Dm = Math.pow(2, 13);
function Ho(r3, e, t3, i, n, o, a, s3) {
  r3.emplaceBack(e, t3, Math.floor(i * Dm) * 2 + a, n * Dm * 2, o * Dm * 2, Math.round(s3));
}
r(Ho, "addVertex");
var zm = class zm2 {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new ml(), this.centroidVertexArray = new Mr(), this.indexArray = new rt(), this.programConfigurations = new mt(e.layers, e.zoom), this.segments = new me(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
  }
  populate(e, t3, i) {
    this.features = [], this.hasPattern = an("fill-extrusion", this.layers, t3);
    for (let { feature: n, id: o, index: a, sourceLayerIndex: s3 } of e) {
      let l = this.layers[0]._featureFilter.needGeometry, c = yt(n, l);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), c, i)) continue;
      let p = { id: o, sourceLayerIndex: s3, index: a, geometry: l ? c.geometry : dt(n), properties: n.properties, type: n.type, patterns: {} };
      this.hasPattern ? this.features.push(sn("fill-extrusion", this.layers, p, this.zoom, t3)) : this.addFeature(p, p.geometry, a, i, {}), t3.featureIndex.insert(n, p.geometry, a, s3, this.index, true);
    }
  }
  addFeatures(e, t3, i) {
    for (let n of this.features) {
      let { geometry: o } = n;
      this.addFeature(n, o, n.index, t3, i);
    }
  }
  update(e, t3, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t3, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Hv), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Zv.members, true), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
  }
  addFeature(e, t3, i, n, o) {
    let a = { x: 0, y: 0, vertexCount: 0 };
    for (let s3 of qo(t3, WE)) {
      let l = 0;
      for (let y of s3) l += y.length;
      let c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
      for (let y of s3) {
        if (y.length === 0 || KE(y)) continue;
        let g = 0;
        for (let x = 0; x < y.length; x++) {
          let b = y[x];
          if (x >= 1) {
            let w = y[x - 1];
            if (!XE(b, w)) {
              c.vertexLength + 4 > me.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              let _ = b.sub(w)._perp()._unit(), S = w.dist(b);
              g + S > 32768 && (g = 0), Ho(this.layoutVertexArray, b.x, b.y, _.x, _.y, 0, 0, g), Ho(this.layoutVertexArray, b.x, b.y, _.x, _.y, 0, 1, g), a.x += 2 * b.x, a.y += 2 * b.y, a.vertexCount += 2, g += S, Ho(this.layoutVertexArray, w.x, w.y, _.x, _.y, 0, 0, g), Ho(this.layoutVertexArray, w.x, w.y, _.x, _.y, 0, 1, g), a.x += 2 * w.x, a.y += 2 * w.y, a.vertexCount += 2;
              let P = c.vertexLength;
              this.indexArray.emplaceBack(P, P + 2, P + 1), this.indexArray.emplaceBack(P + 1, P + 2, P + 3), c.vertexLength += 4, c.primitiveLength += 2;
            }
          }
        }
      }
      if (c.vertexLength + l > me.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(l, this.layoutVertexArray, this.indexArray)), HE[e.type] !== "Polygon") continue;
      let p = [], h = [], f = c.vertexLength;
      for (let y of s3) if (y.length !== 0) {
        y !== s3[0] && h.push(p.length / 2);
        for (let g = 0; g < y.length; g++) {
          let x = y[g];
          Ho(this.layoutVertexArray, x.x, x.y, 0, 0, 1, 1, 0), a.x += x.x, a.y += x.y, a.vertexCount += 1, p.push(x.x), p.push(x.y);
        }
      }
      let m = (0, Qv.default)(p, h);
      for (let y = 0; y < m.length; y += 3) this.indexArray.emplaceBack(f + m[y], f + m[y + 2], f + m[y + 1]);
      c.primitiveLength += m.length / 3, c.vertexLength += l;
    }
    for (let s3 = 0; s3 < a.vertexCount; s3++) this.centroidVertexArray.emplaceBack(Math.floor(a.x / a.vertexCount), Math.floor(a.y / a.vertexCount));
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
};
r(zm, "FillExtrusionBucket");
var Wo = zm;
N("FillExtrusionBucket", Wo, { omit: ["layers", "features"] });
function XE(r3, e) {
  return r3.x === e.x && (r3.x < 0 || r3.x > 8192) || r3.y === e.y && (r3.y < 0 || r3.y > 8192);
}
r(XE, "isBoundaryEdge");
function KE(r3) {
  return r3.every((e) => e.x < 0) || r3.every((e) => e.x > 8192) || r3.every((e) => e.y < 0) || r3.every((e) => e.y > 8192);
}
r(KE, "isEntirelyOutside");
q();
var t0;
var JE = r(() => t0 = t0 || new De({ "fill-extrusion-opacity": new j(A["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new H(A["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new j(A["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new j(A["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new or(A["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new H(A["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new H(A["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new j(A["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }), "getPaint");
var r0 = { get paint() {
  return JE();
} };
var $l = u(ge(), 1);
var Fm = class Fm2 extends Ge {
  constructor(e) {
    super(e, r0);
  }
  createBucket(e) {
    return new Wo(e);
  }
  queryRadius() {
    return Er(this.paint.get("fill-extrusion-translate"));
  }
  is3D() {
    return true;
  }
  queryIntersectsFeature(e, t3, i, n, o, a, s3, l) {
    let c = kr(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, s3), p = this.paint.get("fill-extrusion-height").evaluate(t3, i), h = this.paint.get("fill-extrusion-base").evaluate(t3, i), f = ek(c, l, a, 0), m = QE(n, h, p, l), y = m[0], g = m[1];
    return YE(y, g, f);
  }
};
r(Fm, "FillExtrusionStyleLayer");
var ql = Fm;
function Xo(r3, e) {
  return r3.x * e.x + r3.y * e.y;
}
r(Xo, "dot");
function i0(r3, e) {
  if (r3.length === 1) {
    let t3 = 0, i = e[t3++], n;
    for (; !n || i.equals(n); ) if (n = e[t3++], !n) return 1 / 0;
    for (; t3 < e.length; t3++) {
      let o = e[t3], a = r3[0], s3 = n.sub(i), l = o.sub(i), c = a.sub(i), p = Xo(s3, s3), h = Xo(s3, l), f = Xo(l, l), m = Xo(c, s3), y = Xo(c, l), g = p * f - h * h, x = (f * m - h * y) / g, b = (p * y - h * m) / g, w = 1 - x - b, _ = i.z * w + n.z * x + o.z * b;
      if (isFinite(_)) return _;
    }
    return 1 / 0;
  } else {
    let t3 = 1 / 0;
    for (let i of e) t3 = Math.min(t3, i.z);
    return t3;
  }
}
r(i0, "getIntersectionDistance");
function YE(r3, e, t3) {
  let i = 1 / 0;
  Cl(t3, e) && (i = i0(t3, e[0]));
  for (let n = 0; n < e.length; n++) {
    let o = e[n], a = r3[n];
    for (let s3 = 0; s3 < o.length - 1; s3++) {
      let l = o[s3], c = o[s3 + 1], p = a[s3], h = a[s3 + 1], f = [l, c, h, p, l];
      Il(t3, f) && (i = Math.min(i, i0(t3, f)));
    }
  }
  return i === 1 / 0 ? false : i;
}
r(YE, "checkIntersection");
function QE(r3, e, t3, i) {
  let n = [], o = [], a = i[8] * e, s3 = i[9] * e, l = i[10] * e, c = i[11] * e, p = i[8] * t3, h = i[9] * t3, f = i[10] * t3, m = i[11] * t3;
  for (let y of r3) {
    let g = [], x = [];
    for (let b of y) {
      let w = b.x, _ = b.y, S = i[0] * w + i[4] * _ + i[12], P = i[1] * w + i[5] * _ + i[13], T = i[2] * w + i[6] * _ + i[14], L = i[3] * w + i[7] * _ + i[15], C = S + a, E = P + s3, I = T + l, R = L + c, z = S + p, k = P + h, M = T + f, G = L + m, K = new $l.default(C / R, E / R);
      K.z = I / R, g.push(K);
      let ne = new $l.default(z / G, k / G);
      ne.z = M / G, x.push(ne);
    }
    n.push(g), o.push(x);
  }
  return [n, o];
}
r(QE, "projectExtrusion");
function ek(r3, e, t3, i) {
  let n = [];
  for (let o of r3) {
    let a = [o.x, o.y, i, 1];
    $e.transformMat4(a, a, e), n.push(new $l.default(a[0] / a[3], a[1] / a[3]));
  }
  return n;
}
r(ek, "projectQueryGeometry");
q();
q();
q();
var tk = _e([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4);
var { members: n0, size: Q4, alignment: e5 } = tk;
q();
var rk = _e([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]);
var { members: o0, size: n5, alignment: o5 } = rk;
var l0 = u(Zo(), 1);
var ik = l0.default.VectorTileFeature.types;
var a0 = 63;
var nk = Math.cos(75 / 2 * (Math.PI / 180));
var ok = 15;
var ak = 20;
var sk = 15;
var u0 = 1 / 2;
var s0 = Math.pow(2, sk - 1) / u0;
var Rm = class Rm2 {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
      this.gradients[t3.id] = {};
    }), this.layoutVertexArray = new dl(), this.layoutVertexArray2 = new yl(), this.indexArray = new rt(), this.programConfigurations = new mt(e.layers, e.zoom), this.segments = new me(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
  }
  populate(e, t3, i) {
    this.hasPattern = an("line", this.layers, t3);
    let n = this.layers[0].layout.get("line-sort-key"), o = !n.isConstant(), a = [];
    for (let { feature: s3, id: l, index: c, sourceLayerIndex: p } of e) {
      let h = this.layers[0]._featureFilter.needGeometry, f = yt(s3, h);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), f, i)) continue;
      let m = o ? n.evaluate(f, {}, i) : void 0, y = { id: l, properties: s3.properties, type: s3.type, sourceLayerIndex: p, index: c, geometry: h ? f.geometry : dt(s3), patterns: {}, sortKey: m };
      a.push(y);
    }
    o && a.sort((s3, l) => s3.sortKey - l.sortKey);
    for (let s3 of a) {
      let { geometry: l, index: c, sourceLayerIndex: p } = s3;
      if (this.hasPattern) {
        let f = sn("line", this.layers, s3, this.zoom, t3);
        this.patternFeatures.push(f);
      } else this.addFeature(s3, l, c, i, {});
      let h = e[c].feature;
      t3.featureIndex.insert(h, l, c, p, this.index);
    }
  }
  update(e, t3, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t3, this.stateDependentLayers, i);
  }
  addFeatures(e, t3, i) {
    for (let n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, t3, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, o0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, n0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  lineFeatureClips(e) {
    if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) {
      let t3 = +e.properties.mapbox_clip_start, i = +e.properties.mapbox_clip_end;
      return { start: t3, end: i };
    }
  }
  addFeature(e, t3, i, n, o) {
    let a = this.layers[0].layout, s3 = a.get("line-join").evaluate(e, {}), l = a.get("line-cap"), c = a.get("line-miter-limit"), p = a.get("line-round-limit");
    this.lineClips = this.lineFeatureClips(e);
    for (let h of t3) this.addLine(h, e, s3, l, c, p);
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o, n);
  }
  addLine(e, t3, i, n, o, a) {
    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
      this.lineClipsArray.push(this.lineClips);
      for (let b = 0; b < e.length - 1; b++) this.totalDistance += e[b].dist(e[b + 1]);
      this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
    }
    let s3 = ik[t3.type] === "Polygon", l = e.length;
    for (; l >= 2 && e[l - 1].equals(e[l - 2]); ) l--;
    let c = 0;
    for (; c < l - 1 && e[c].equals(e[c + 1]); ) c++;
    if (l < (s3 ? 3 : 2)) return;
    i === "bevel" && (o = 1.05);
    let p = this.overscaling <= 16 ? ok * 8192 / (512 * this.overscaling) : 0, h = this.segments.prepareSegment(l * 10, this.layoutVertexArray, this.indexArray), f, m, y, g, x;
    this.e1 = this.e2 = -1, s3 && (f = e[l - 2], x = e[c].sub(f)._unit()._perp());
    for (let b = c; b < l; b++) {
      if (y = b === l - 1 ? s3 ? e[c + 1] : void 0 : e[b + 1], y && e[b].equals(y)) continue;
      x && (g = x), f && (m = f), f = e[b], x = y ? y.sub(f)._unit()._perp() : g, g = g || x;
      let w = g.add(x);
      (w.x !== 0 || w.y !== 0) && w._unit();
      let _ = g.x * x.x + g.y * x.y, S = w.x * x.x + w.y * x.y, P = S !== 0 ? 1 / S : 1 / 0, T = 2 * Math.sqrt(2 - 2 * S), L = S < nk && m && y, C = g.x * x.y - g.y * x.x > 0;
      if (L && b > c) {
        let R = f.dist(m);
        if (R > 2 * p) {
          let z = f.sub(f.sub(m)._mult(p / R)._round());
          this.updateDistance(m, z), this.addCurrentVertex(z, g, 0, 0, h), m = z;
        }
      }
      let E = m && y, I = E ? i : s3 ? "butt" : n;
      if (E && I === "round" && (P < a ? I = "miter" : P <= 2 && (I = "fakeround")), I === "miter" && P > o && (I = "bevel"), I === "bevel" && (P > 2 && (I = "flipbevel"), P < o && (I = "miter")), m && this.updateDistance(m, f), I === "miter") w._mult(P), this.addCurrentVertex(f, w, 0, 0, h);
      else if (I === "flipbevel") {
        if (P > 100) w = x.mult(-1);
        else {
          let R = P * g.add(x).mag() / g.sub(x).mag();
          w._perp()._mult(R * (C ? -1 : 1));
        }
        this.addCurrentVertex(f, w, 0, 0, h), this.addCurrentVertex(f, w.mult(-1), 0, 0, h);
      } else if (I === "bevel" || I === "fakeround") {
        let R = -Math.sqrt(P * P - 1), z = C ? R : 0, k = C ? 0 : R;
        if (m && this.addCurrentVertex(f, g, z, k, h), I === "fakeround") {
          let M = Math.round(T * 180 / Math.PI / ak);
          for (let G = 1; G < M; G++) {
            let K = G / M;
            if (K !== 0.5) {
              let J = K - 0.5, W = 1.0904 + _ * (-3.2452 + _ * (3.55645 - _ * 1.43519)), Je = 0.848013 + _ * (-1.06021 + _ * 0.215638);
              K = K + K * J * (K - 1) * (W * J * J + Je);
            }
            let ne = x.sub(g)._mult(K)._add(g)._unit()._mult(C ? -1 : 1);
            this.addHalfVertex(f, ne.x, ne.y, false, C, 0, h);
          }
        }
        y && this.addCurrentVertex(f, x, -z, -k, h);
      } else if (I === "butt") this.addCurrentVertex(f, w, 0, 0, h);
      else if (I === "square") {
        let R = m ? 1 : -1;
        this.addCurrentVertex(f, w, R, R, h);
      } else I === "round" && (m && (this.addCurrentVertex(f, g, 0, 0, h), this.addCurrentVertex(f, g, 1, 1, h, true)), y && (this.addCurrentVertex(f, x, -1, -1, h, true), this.addCurrentVertex(f, x, 0, 0, h)));
      if (L && b < l - 1) {
        let R = f.dist(y);
        if (R > 2 * p) {
          let z = f.add(y.sub(f)._mult(p / R)._round());
          this.updateDistance(f, z), this.addCurrentVertex(z, x, 0, 0, h), f = z;
        }
      }
    }
  }
  addCurrentVertex(e, t3, i, n, o, a = false) {
    let s3 = t3.x + t3.y * i, l = t3.y - t3.x * i, c = -t3.x + t3.y * n, p = -t3.y - t3.x * n;
    this.addHalfVertex(e, s3, l, a, false, i, o), this.addHalfVertex(e, c, p, a, true, -n, o), this.distance > s0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, t3, i, n, o, a));
  }
  addHalfVertex({ x: e, y: t3 }, i, n, o, a, s3, l) {
    let p = (this.lineClips ? this.scaledDistance * (s0 - 1) : this.scaledDistance) * u0;
    if (this.layoutVertexArray.emplaceBack((e << 1) + (o ? 1 : 0), (t3 << 1) + (a ? 1 : 0), Math.round(a0 * i) + 128, Math.round(a0 * n) + 128, (s3 === 0 ? 0 : s3 < 0 ? -1 : 1) + 1 | (p & 63) << 2, p >> 6), this.lineClips) {
      let f = this.scaledDistance - this.lineClips.start, m = this.lineClips.end - this.lineClips.start, y = f / m;
      this.layoutVertexArray2.emplaceBack(y, this.lineClipsArray.length);
    }
    let h = l.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, h), l.primitiveLength++), a ? this.e2 = h : this.e1 = h;
  }
  updateScaledDistance() {
    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
  }
  updateDistance(e, t3) {
    this.distance += e.dist(t3), this.updateScaledDistance();
  }
};
r(Rm, "LineBucket");
var Ko = Rm;
N("LineBucket", Ko, { omit: ["layers", "patternFeatures"] });
q();
var c0;
var lk = r(() => c0 = c0 || new De({ "line-cap": new j(A.layout_line["line-cap"]), "line-join": new H(A.layout_line["line-join"]), "line-miter-limit": new j(A.layout_line["line-miter-limit"]), "line-round-limit": new j(A.layout_line["line-round-limit"]), "line-sort-key": new H(A.layout_line["line-sort-key"]) }), "getLayout");
var p0;
var uk = r(() => p0 = p0 || new De({ "line-opacity": new H(A.paint_line["line-opacity"]), "line-color": new H(A.paint_line["line-color"]), "line-translate": new j(A.paint_line["line-translate"]), "line-translate-anchor": new j(A.paint_line["line-translate-anchor"]), "line-width": new H(A.paint_line["line-width"]), "line-gap-width": new H(A.paint_line["line-gap-width"]), "line-offset": new H(A.paint_line["line-offset"]), "line-blur": new H(A.paint_line["line-blur"]), "line-dasharray": new ii(A.paint_line["line-dasharray"]), "line-pattern": new or(A.paint_line["line-pattern"]), "line-gradient": new ni(A.paint_line["line-gradient"]) }), "getPaint");
var Bm = { get paint() {
  return uk();
}, get layout() {
  return lk();
} };
var Vm = class Vm2 extends H {
  possiblyEvaluate(e, t3) {
    return t3 = new ye(Math.floor(t3.zoom), { now: t3.now, fadeDuration: t3.fadeDuration, zoomHistory: t3.zoomHistory, transition: t3.transition }), super.possiblyEvaluate(e, t3);
  }
  evaluate(e, t3, i, n) {
    return t3 = V({}, t3, { zoom: Math.floor(t3.zoom) }), super.evaluate(e, t3, i, n);
  }
};
r(Vm, "LineFloorwidthProperty");
var Om = Vm;
var jl;
var Um = class Um2 extends Ge {
  constructor(e) {
    super(e, Bm), this.gradientVersion = 0, jl || (jl = new Om(Bm.paint.properties["line-width"].specification), jl.useIntegerZoom = true);
  }
  _handleSpecialPaintPropertyUpdate(e) {
    if (e === "line-gradient") {
      let t3 = this.gradientExpression();
      ti(t3) ? this.stepInterpolant = t3._styleExpression.expression instanceof Vi : this.stepInterpolant = false, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
    }
  }
  gradientExpression() {
    return this._transitionablePaint._values["line-gradient"].value.expression;
  }
  recalculate(e, t3) {
    super.recalculate(e, t3), this.paint._values["line-floorwidth"] = jl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
  }
  createBucket(e) {
    return new Ko(e);
  }
  queryRadius(e) {
    let t3 = e, i = h0(ci("line-width", this, t3), ci("line-gap-width", this, t3)), n = ci("line-offset", this, t3);
    return i / 2 + Math.abs(n) + Er(this.paint.get("line-translate"));
  }
  queryIntersectsFeature(e, t3, i, n, o, a, s3) {
    let l = kr(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, s3), c = s3 / 2 * h0(this.paint.get("line-width").evaluate(t3, i), this.paint.get("line-gap-width").evaluate(t3, i)), p = this.paint.get("line-offset").evaluate(t3, i);
    return p && (n = $_(n, p * s3)), U_(l, n, c);
  }
  isTileClipped() {
    return true;
  }
};
r(Um, "LineStyleLayer");
var Zl = Um;
function h0(r3, e) {
  return e > 0 ? e + 2 * r3 : r3;
}
r(h0, "getLineWidth");
q();
q();
q();
var f0 = _e([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4);
var m0 = _e([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
var X5 = _e([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
var d0 = _e([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
var K5 = _e([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
var Nm = _e([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4);
var y0 = _e([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
var J5 = _e([{ name: "triangle", components: 3, type: "Uint16" }]);
var Y5 = _e([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]);
var Q5 = _e([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]);
var eV = _e([{ type: "Float32", name: "offsetX" }]);
var tV = _e([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
var rV = _e([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
var Qo = u(ge(), 1);
q();
function ck(r3, e, t3) {
  let i = e.layout.get("text-transform").evaluate(t3, {});
  return i === "uppercase" ? r3 = r3.toLocaleUpperCase() : i === "lowercase" && (r3 = r3.toLocaleLowerCase()), nr.applyArabicShaping && (r3 = nr.applyArabicShaping(r3)), r3;
}
r(ck, "transformTextInternal");
function g0(r3, e, t3) {
  return r3.sections.forEach((i) => {
    i.text = ck(i.text, e, t3);
  }), r3;
}
r(g0, "transformText");
q();
function x0(r3) {
  let e = {}, t3 = {}, i = [], n = 0;
  function o(c) {
    i.push(r3[c]), n++;
  }
  r(o, "add");
  function a(c, p, h) {
    let f = t3[c];
    return delete t3[c], t3[p] = f, i[f].geometry[0].pop(), i[f].geometry[0] = i[f].geometry[0].concat(h[0]), f;
  }
  r(a, "mergeFromRight");
  function s3(c, p, h) {
    let f = e[p];
    return delete e[p], e[c] = f, i[f].geometry[0].shift(), i[f].geometry[0] = h[0].concat(i[f].geometry[0]), f;
  }
  r(s3, "mergeFromLeft");
  function l(c, p, h) {
    let f = h ? p[0][p[0].length - 1] : p[0][0];
    return `${c}:${f.x}:${f.y}`;
  }
  r(l, "getKey");
  for (let c = 0; c < r3.length; c++) {
    let p = r3[c], h = p.geometry, f = p.text ? p.text.toString() : null;
    if (!f) {
      o(c);
      continue;
    }
    let m = l(f, h), y = l(f, h, true);
    if (m in t3 && y in e && t3[m] !== e[y]) {
      let g = s3(m, y, h), x = a(m, y, i[g].geometry);
      delete e[m], delete t3[y], t3[l(f, i[x].geometry, true)] = x, i[g].geometry = null;
    } else m in t3 ? a(m, y, h) : y in e ? s3(m, y, h) : (o(c), e[m] = n - 1, t3[y] = n - 1);
  }
  return i.filter((c) => c.geometry);
}
r(x0, "mergeLines");
q();
q();
var b0 = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
q();
var Lr = 24;
q();
var A0 = u(qm(), 1);
var M0 = 3;
function Ik(r3, e, t3) {
  r3 === 1 && t3.readMessage(Ck, e);
}
r(Ik, "readFontstacks");
function Ck(r3, e, t3) {
  if (r3 === 3) {
    let { id: i, bitmap: n, width: o, height: a, left: s3, top: l, advance: c } = t3.readMessage(Ek, {});
    e.push({ id: i, bitmap: new pi({ width: o + 2 * M0, height: a + 2 * M0 }, n), metrics: { width: o, height: a, left: s3, top: l, advance: c } });
  }
}
r(Ck, "readFontstack");
function Ek(r3, e, t3) {
  r3 === 1 ? e.id = t3.readVarint() : r3 === 2 ? e.bitmap = t3.readBytes() : r3 === 3 ? e.width = t3.readVarint() : r3 === 4 ? e.height = t3.readVarint() : r3 === 5 ? e.left = t3.readSVarint() : r3 === 6 ? e.top = t3.readSVarint() : r3 === 7 && (e.advance = t3.readVarint());
}
r(Ek, "readGlyph");
function I0(r3) {
  return new A0.default(r3).readFields(Ik, []);
}
r(I0, "parseGlyphPbf");
q();
q();
function Jo(r3) {
  let e = 0, t3 = 0;
  for (let s3 of r3) e += s3.w * s3.h, t3 = Math.max(t3, s3.w);
  r3.sort((s3, l) => l.h - s3.h);
  let n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), t3), h: 1 / 0 }], o = 0, a = 0;
  for (let s3 of r3) for (let l = n.length - 1; l >= 0; l--) {
    let c = n[l];
    if (!(s3.w > c.w || s3.h > c.h)) {
      if (s3.x = c.x, s3.y = c.y, a = Math.max(a, s3.y + s3.h), o = Math.max(o, s3.x + s3.w), s3.w === c.w && s3.h === c.h) {
        let p = n.pop();
        l < n.length && (n[l] = p);
      } else s3.h === c.h ? (c.x += s3.w, c.w -= s3.w) : s3.w === c.w ? (c.y += s3.h, c.h -= s3.h) : (n.push({ x: c.x + s3.w, y: c.y, w: c.w - s3.w, h: s3.h }), c.y += s3.h, c.h -= s3.h);
      break;
    }
  }
  return { w: o, h: a, fill: e / (o * a) || 0 };
}
r(Jo, "potpack");
var xt = 1;
var Zm = class Zm2 {
  constructor(e, { pixelRatio: t3, version: i, stretchX: n, stretchY: o, content: a }) {
    this.paddedRect = e, this.pixelRatio = t3, this.stretchX = n, this.stretchY = o, this.content = a, this.version = i;
  }
  get tl() {
    return [this.paddedRect.x + xt, this.paddedRect.y + xt];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - xt, this.paddedRect.y + this.paddedRect.h - xt];
  }
  get tlbr() {
    return this.tl.concat(this.br);
  }
  get displaySize() {
    return [(this.paddedRect.w - xt * 2) / this.pixelRatio, (this.paddedRect.h - xt * 2) / this.pixelRatio];
  }
};
r(Zm, "ImagePosition");
var pn = Zm;
var Hm = class Hm2 {
  constructor(e, t3) {
    let i = {}, n = {};
    this.haveRenderCallbacks = [];
    let o = [];
    this.addImages(e, i, o), this.addImages(t3, n, o);
    let { w: a, h: s3 } = Jo(o), l = new Se({ width: a || 1, height: s3 || 1 });
    for (let c in e) {
      let p = e[c], h = i[c].paddedRect;
      Se.copy(p.data, l, { x: 0, y: 0 }, { x: h.x + xt, y: h.y + xt }, p.data);
    }
    for (let c in t3) {
      let p = t3[c], h = n[c].paddedRect, f = h.x + xt, m = h.y + xt, y = p.data.width, g = p.data.height;
      Se.copy(p.data, l, { x: 0, y: 0 }, { x: f, y: m }, p.data), Se.copy(p.data, l, { x: 0, y: g - 1 }, { x: f, y: m - 1 }, { width: y, height: 1 }), Se.copy(p.data, l, { x: 0, y: 0 }, { x: f, y: m + g }, { width: y, height: 1 }), Se.copy(p.data, l, { x: y - 1, y: 0 }, { x: f - 1, y: m }, { width: 1, height: g }), Se.copy(p.data, l, { x: 0, y: 0 }, { x: f + y, y: m }, { width: 1, height: g });
    }
    this.image = l, this.iconPositions = i, this.patternPositions = n;
  }
  addImages(e, t3, i) {
    for (let n in e) {
      let o = e[n], a = { x: 0, y: 0, w: o.data.width + 2 * xt, h: o.data.height + 2 * xt };
      i.push(a), t3[n] = new pn(a, o), o.hasRenderCallback && this.haveRenderCallbacks.push(n);
    }
  }
  patchUpdatedImages(e, t3) {
    e.dispatchRenderCallbacks(this.haveRenderCallbacks);
    for (let i in e.updatedImages) this.patchUpdatedImage(this.iconPositions[i], e.getImage(i), t3), this.patchUpdatedImage(this.patternPositions[i], e.getImage(i), t3);
  }
  patchUpdatedImage(e, t3, i) {
    if (!e || !t3 || e.version === t3.version) return;
    e.version = t3.version;
    let [n, o] = e.tl;
    i.update(t3.data, void 0, { x: n, y: o });
  }
};
r(Hm, "ImageAtlas");
var jm = Hm;
N("ImagePosition", pn);
N("ImageAtlas", jm);
var fi = ((n) => (n[n.none = 0] = "none", n[n.horizontal = 1] = "horizontal", n[n.vertical = 2] = "vertical", n[n.horizontalOnly = 3] = "horizontalOnly", n))(fi || {});
function Xl(r3) {
  let e = 0.5, t3 = 0.5;
  switch (r3) {
    case "right":
    case "top-right":
    case "bottom-right":
      e = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      e = 0;
      break;
  }
  switch (r3) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      t3 = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      t3 = 0;
      break;
  }
  return { horizontalAlign: e, verticalAlign: t3 };
}
r(Xl, "getAnchorAlignment");
var k0 = u(Zo(), 1);
q();
var C0 = 255;
var Yo = 128;
var Kl = C0 * Yo;
function Wm(r3, e) {
  let { expression: t3 } = e;
  if (t3.kind === "constant") return { kind: "constant", layoutSize: t3.evaluate(new ye(r3 + 1)) };
  if (t3.kind === "source") return { kind: "source" };
  {
    let { zoomStops: i, interpolationType: n } = t3, o = 0;
    for (; o < i.length && i[o] <= r3; ) o++;
    o = Math.max(0, o - 1);
    let a = o;
    for (; a < i.length && i[a] < r3 + 1; ) a++;
    a = Math.min(i.length - 1, a);
    let s3 = i[o], l = i[a];
    if (t3.kind === "composite") return { kind: "composite", minZoom: s3, maxZoom: l, interpolationType: n };
    let c = t3.evaluate(new ye(s3)), p = t3.evaluate(new ye(l));
    return { kind: "camera", minZoom: s3, maxZoom: l, minSize: c, maxSize: p, interpolationType: n };
  }
}
r(Wm, "getSizeData");
function hn(r3, { uSize: e, uSizeT: t3 }, { lowerSize: i, upperSize: n }) {
  return r3.kind === "source" ? i / Yo : r3.kind === "composite" ? Pe.number(i / Yo, n / Yo, t3) : e;
}
r(hn, "evaluateSizeForFeature");
function mi(r3, e) {
  let t3 = 0, i = 0;
  if (r3.kind === "constant") i = r3.layoutSize;
  else if (r3.kind !== "source") {
    let { interpolationType: n, minZoom: o, maxZoom: a } = r3, s3 = n ? Ae(vt.interpolationFactor(n, e, o, a), 0, 1) : 0;
    r3.kind === "camera" ? i = Pe.number(r3.minSize, r3.maxSize, s3) : t3 = s3;
  }
  return { uSizeT: t3, uSize: i };
}
r(mi, "evaluateSizeForZoom");
q();
function fn(r3, e, t3) {
  let i = "never", n = r3.get(e);
  return n ? i = n : r3.get(t3) && (i = "always"), i;
}
r(fn, "getOverlapMode");
var Lk = k0.default.VectorTileFeature.types;
var Dk = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
function Jl(r3, e, t3, i, n, o, a, s3, l, c, p, h, f) {
  let m = s3 ? Math.min(Kl, Math.round(s3[0])) : 0, y = s3 ? Math.min(Kl, Math.round(s3[1])) : 0;
  r3.emplaceBack(e, t3, Math.round(i * 32), Math.round(n * 32), o, a, (m << 1) + (l ? 1 : 0), y, c * 16, p * 16, h * 256, f * 256);
}
r(Jl, "addVertex");
function di(r3, e, t3) {
  r3.emplaceBack(e.x, e.y, t3), r3.emplaceBack(e.x, e.y, t3), r3.emplaceBack(e.x, e.y, t3), r3.emplaceBack(e.x, e.y, t3);
}
r(di, "addDynamicAttributes");
function zk(r3) {
  for (let e of r3.sections) if (M_(e.text)) return true;
  return false;
}
r(zk, "containsRTLText");
var Xm = class Xm2 {
  constructor(e) {
    this.layoutVertexArray = new gl(), this.indexArray = new rt(), this.programConfigurations = e, this.segments = new me(), this.dynamicLayoutVertexArray = new xl(), this.opacityVertexArray = new bl(), this.hasVisibleVertices = false, this.placedSymbolArray = new Mo();
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
  }
  upload(e, t3, i, n) {
    this.isEmpty() || (i && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, f0.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t3), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, m0.members, true), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Dk, true), this.opacityVertexBuffer.itemSize = 1), (i || n) && this.programConfigurations.upload(e));
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
  }
};
r(Xm, "SymbolBuffers");
var ea = Xm;
N("SymbolBuffers", ea);
var Km = class Km2 {
  constructor(e, t3, i) {
    this.layoutVertexArray = new e(), this.layoutAttributes = t3, this.indexArray = new i(), this.segments = new me(), this.collisionVertexArray = new vl();
  }
  upload(e) {
    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, d0.members, true);
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
  }
};
r(Km, "CollisionBuffers");
var ta = Km;
N("CollisionBuffers", ta);
var Jm = class Jm2 {
  constructor(e) {
    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((l) => l.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = $.identity([]), this.placementViewportMatrix = $.identity([]);
    let i = this.layers[0]._unevaluatedLayout._values;
    this.textSizeData = Wm(this.zoom, i["text-size"]), this.iconSizeData = Wm(this.zoom, i["icon-size"]);
    let n = this.layers[0].layout, o = n.get("symbol-sort-key"), a = n.get("symbol-z-order");
    this.canOverlap = fn(n, "text-overlap", "text-allow-overlap") !== "never" || fn(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = a !== "viewport-y" && !o.isConstant();
    let s3 = a === "viewport-y" || a === "auto" && !this.sortFeaturesByKey;
    this.sortFeaturesByY = s3 && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map((l) => fi[l])), this.stateDependentLayerIds = this.layers.filter((l) => l.isStateDependent()).map((l) => l.id), this.sourceID = e.sourceID;
  }
  createArrays() {
    this.text = new ea(new mt(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new ea(new mt(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new Io(), this.lineVertexArray = new Co(), this.symbolInstances = new Ao(), this.textAnchorOffsets = new Eo();
  }
  calculateGlyphDependencies(e, t3, i, n, o) {
    for (let a = 0; a < e.length; a++) if (t3[e.charCodeAt(a)] = true, (i || n) && o) {
      let s3 = b0[e.charAt(a)];
      s3 && (t3[s3.charCodeAt(0)] = true);
    }
  }
  populate(e, t3, i) {
    let n = this.layers[0], o = n.layout, a = o.get("text-font"), s3 = o.get("text-field"), l = o.get("icon-image"), c = (s3.value.kind !== "constant" || s3.value.value instanceof wt && !s3.value.value.isEmpty() || s3.value.value.toString().length > 0) && (a.value.kind !== "constant" || a.value.value.length > 0), p = l.value.kind !== "constant" || !!l.value.value || Object.keys(l.parameters).length > 0, h = o.get("symbol-sort-key");
    if (this.features = [], !c && !p) return;
    let f = t3.iconDependencies, m = t3.glyphDependencies, y = t3.availableImages, g = new ye(this.zoom);
    for (let { feature: x, id: b, index: w, sourceLayerIndex: _ } of e) {
      let S = n._featureFilter.needGeometry, P = yt(x, S);
      if (!n._featureFilter.filter(g, P, i)) continue;
      S || (P.geometry = dt(x));
      let T;
      if (c) {
        let I = n.getValueAndResolveTokens("text-field", P, i, y), R = wt.factory(I), z = this.hasRTLText = this.hasRTLText || zk(R);
        (!z || nr.getRTLTextPluginStatus() === "unavailable" || z && nr.isParsed()) && (T = g0(R, n, P));
      }
      let L;
      if (p) {
        let I = n.getValueAndResolveTokens("icon-image", P, i, y);
        I instanceof ft ? L = I : L = ft.fromString(I);
      }
      if (!T && !L) continue;
      let C = this.sortFeaturesByKey ? h.evaluate(P, {}, i) : void 0, E = { id: b, text: T, icon: L, index: w, sourceLayerIndex: _, geometry: P.geometry, properties: x.properties, type: Lk[x.type], sortKey: C };
      if (this.features.push(E), L && (f[L.name] = true), T) {
        let I = a.evaluate(P, {}, i).join(","), R = o.get("text-rotation-alignment") !== "viewport" && o.get("symbol-placement") !== "point";
        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(2) >= 0;
        for (let z of T.sections) if (z.image) f[z.image.name] = true;
        else {
          let k = Ph(T.toString()), M = z.fontStack || I, G = m[M] = m[M] || {};
          this.calculateGlyphDependencies(z.text, G, R, this.allowVerticalPlacement, k);
        }
      }
    }
    o.get("symbol-placement") === "line" && (this.features = x0(this.features)), this.sortFeaturesByKey && this.features.sort((x, b) => x.sortKey - b.sortKey);
  }
  update(e, t3, i) {
    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t3, this.layers, i), this.icon.programConfigurations.updatePaintArrays(e, t3, this.layers, i));
  }
  isEmpty() {
    return this.symbolInstances.length === 0 && !this.hasRTLText;
  }
  uploadPending() {
    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
  }
  upload(e) {
    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
  }
  destroyDebugData() {
    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
  }
  destroy() {
    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
  }
  addToLineVertexArray(e, t3) {
    let i = this.lineVertexArray.length;
    if (e.segment !== void 0) {
      let n = e.dist(t3[e.segment + 1]), o = e.dist(t3[e.segment]), a = {};
      for (let s3 = e.segment + 1; s3 < t3.length; s3++) a[s3] = { x: t3[s3].x, y: t3[s3].y, tileUnitDistanceFromAnchor: n }, s3 < t3.length - 1 && (n += t3[s3 + 1].dist(t3[s3]));
      for (let s3 = e.segment || 0; s3 >= 0; s3--) a[s3] = { x: t3[s3].x, y: t3[s3].y, tileUnitDistanceFromAnchor: o }, s3 > 0 && (o += t3[s3 - 1].dist(t3[s3]));
      for (let s3 = 0; s3 < t3.length; s3++) {
        let l = a[s3];
        this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);
      }
    }
    return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i };
  }
  addSymbols(e, t3, i, n, o, a, s3, l, c, p, h, f) {
    let m = e.indexArray, y = e.layoutVertexArray, g = e.segments.prepareSegment(4 * t3.length, y, m, this.canOverlap ? a.sortKey : void 0), x = this.glyphOffsetArray.length, b = g.vertexLength, w = this.allowVerticalPlacement && s3 === 2 ? Math.PI / 2 : 0, _ = a.text && a.text.sections;
    for (let S = 0; S < t3.length; S++) {
      let { tl: P, tr: T, bl: L, br: C, tex: E, pixelOffsetTL: I, pixelOffsetBR: R, minFontScaleX: z, minFontScaleY: k, glyphOffset: M, isSDF: G, sectionIndex: K } = t3[S], ne = g.vertexLength, J = M[1];
      Jl(y, l.x, l.y, P.x, J + P.y, E.x, E.y, i, G, I.x, I.y, z, k), Jl(y, l.x, l.y, T.x, J + T.y, E.x + E.w, E.y, i, G, R.x, I.y, z, k), Jl(y, l.x, l.y, L.x, J + L.y, E.x, E.y + E.h, i, G, I.x, R.y, z, k), Jl(y, l.x, l.y, C.x, J + C.y, E.x + E.w, E.y + E.h, i, G, R.x, R.y, z, k), di(e.dynamicLayoutVertexArray, l, w), m.emplaceBack(ne, ne + 1, ne + 2), m.emplaceBack(ne + 1, ne + 2, ne + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(M[0]), (S === t3.length - 1 || K !== t3[S + 1].sectionIndex) && e.programConfigurations.populatePaintArrays(y.length, a, a.index, {}, f, _ && _[K]);
    }
    e.placedSymbolArray.emplaceBack(l.x, l.y, x, this.glyphOffsetArray.length - x, b, c, p, l.segment, i ? i[0] : 0, i ? i[1] : 0, n[0], n[1], s3, 0, false, 0, h);
  }
  _addCollisionDebugVertex(e, t3, i, n, o, a) {
    return t3.emplaceBack(0, 0), e.emplaceBack(i.x, i.y, n, o, Math.round(a.x), Math.round(a.y));
  }
  addCollisionDebugVertices(e, t3, i, n, o, a, s3) {
    let l = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), c = l.vertexLength, p = o.layoutVertexArray, h = o.collisionVertexArray, f = s3.anchorX, m = s3.anchorY;
    this._addCollisionDebugVertex(p, h, a, f, m, new Qo.default(e, t3)), this._addCollisionDebugVertex(p, h, a, f, m, new Qo.default(i, t3)), this._addCollisionDebugVertex(p, h, a, f, m, new Qo.default(i, n)), this._addCollisionDebugVertex(p, h, a, f, m, new Qo.default(e, n)), l.vertexLength += 4;
    let y = o.indexArray;
    y.emplaceBack(c, c + 1), y.emplaceBack(c + 1, c + 2), y.emplaceBack(c + 2, c + 3), y.emplaceBack(c + 3, c), l.primitiveLength += 4;
  }
  addDebugCollisionBoxes(e, t3, i, n) {
    for (let o = e; o < t3; o++) {
      let a = this.collisionBoxArray.get(o), s3 = a.x1, l = a.y1, c = a.x2, p = a.y2;
      this.addCollisionDebugVertices(s3, l, c, p, n ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, i);
    }
  }
  generateCollisionDebugBuffers() {
    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ta(Lo, Nm.members, Ar), this.iconCollisionBox = new ta(Lo, Nm.members, Ar);
    for (let e = 0; e < this.symbolInstances.length; e++) {
      let t3 = this.symbolInstances.get(e);
      this.addDebugCollisionBoxes(t3.textBoxStartIndex, t3.textBoxEndIndex, t3, true), this.addDebugCollisionBoxes(t3.verticalTextBoxStartIndex, t3.verticalTextBoxEndIndex, t3, true), this.addDebugCollisionBoxes(t3.iconBoxStartIndex, t3.iconBoxEndIndex, t3, false), this.addDebugCollisionBoxes(t3.verticalIconBoxStartIndex, t3.verticalIconBoxEndIndex, t3, false);
    }
  }
  _deserializeCollisionBoxesForSymbol(e, t3, i, n, o, a, s3, l, c) {
    let p = {};
    for (let h = t3; h < i; h++) {
      let f = e.get(h);
      p.textBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p.textFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = n; h < o; h++) {
      let f = e.get(h);
      p.verticalTextBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p.verticalTextFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = a; h < s3; h++) {
      let f = e.get(h);
      p.iconBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p.iconFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = l; h < c; h++) {
      let f = e.get(h);
      p.verticalIconBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p.verticalIconFeatureIndex = f.featureIndex;
      break;
    }
    return p;
  }
  deserializeCollisionBoxes(e) {
    this.collisionArrays = [];
    for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
      let i = this.symbolInstances.get(t3);
      this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex));
    }
  }
  hasTextData() {
    return this.text.segments.get().length > 0;
  }
  hasIconData() {
    return this.icon.segments.get().length > 0;
  }
  hasDebugData() {
    return this.textCollisionBox && this.iconCollisionBox;
  }
  hasTextCollisionBoxData() {
    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
  }
  hasIconCollisionBoxData() {
    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
  }
  addIndicesForPlacedSymbol(e, t3) {
    let i = e.placedSymbolArray.get(t3), n = i.vertexStartIndex + i.numGlyphs * 4;
    for (let o = i.vertexStartIndex; o < n; o += 4) e.indexArray.emplaceBack(o, o + 1, o + 2), e.indexArray.emplaceBack(o + 1, o + 2, o + 3);
  }
  getSortedSymbolIndexes(e) {
    if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
    let t3 = Math.sin(e), i = Math.cos(e), n = [], o = [], a = [];
    for (let s3 = 0; s3 < this.symbolInstances.length; ++s3) {
      a.push(s3);
      let l = this.symbolInstances.get(s3);
      n.push(Math.round(t3 * l.anchorX + i * l.anchorY) | 0), o.push(l.featureIndex);
    }
    return a.sort((s3, l) => n[s3] - n[l] || o[l] - o[s3]), a;
  }
  addToSortKeyRanges(e, t3) {
    let i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
    i && i.sortKey === t3 ? i.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: t3, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
  }
  sortFeatures(e) {
    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
      this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
      for (let t3 of this.symbolInstanceIndexes) {
        let i = this.symbolInstances.get(t3);
        this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach((n, o, a) => {
          n >= 0 && a.indexOf(n) === o && this.addIndicesForPlacedSymbol(this.text, n);
        }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);
      }
      this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
    }
  }
};
r(Jm, "SymbolBucket");
var Ot = Jm;
N("SymbolBucket", Ot, { omit: ["layers", "collisionBoxArray", "features", "compareText"] });
Ot.MAX_GLYPHS = 65535;
Ot.addDynamicAttributes = di;
q();
function L0(r3, e) {
  return e.replace(/{([^{}]+)}/g, (t3, i) => r3 && i in r3 ? String(r3[i]) : "");
}
r(L0, "resolveTokens");
q();
var D0;
var Fk = r(() => D0 = D0 || new De({ "symbol-placement": new j(A.layout_symbol["symbol-placement"]), "symbol-spacing": new j(A.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new j(A.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new H(A.layout_symbol["symbol-sort-key"]), "symbol-z-order": new j(A.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new j(A.layout_symbol["icon-allow-overlap"]), "icon-overlap": new j(A.layout_symbol["icon-overlap"]), "icon-ignore-placement": new j(A.layout_symbol["icon-ignore-placement"]), "icon-optional": new j(A.layout_symbol["icon-optional"]), "icon-rotation-alignment": new j(A.layout_symbol["icon-rotation-alignment"]), "icon-size": new H(A.layout_symbol["icon-size"]), "icon-text-fit": new j(A.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new j(A.layout_symbol["icon-text-fit-padding"]), "icon-image": new H(A.layout_symbol["icon-image"]), "icon-rotate": new H(A.layout_symbol["icon-rotate"]), "icon-padding": new H(A.layout_symbol["icon-padding"]), "icon-keep-upright": new j(A.layout_symbol["icon-keep-upright"]), "icon-offset": new H(A.layout_symbol["icon-offset"]), "icon-anchor": new H(A.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new j(A.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new j(A.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new j(A.layout_symbol["text-rotation-alignment"]), "text-field": new H(A.layout_symbol["text-field"]), "text-font": new H(A.layout_symbol["text-font"]), "text-size": new H(A.layout_symbol["text-size"]), "text-max-width": new H(A.layout_symbol["text-max-width"]), "text-line-height": new j(A.layout_symbol["text-line-height"]), "text-letter-spacing": new H(A.layout_symbol["text-letter-spacing"]), "text-justify": new H(A.layout_symbol["text-justify"]), "text-radial-offset": new H(A.layout_symbol["text-radial-offset"]), "text-variable-anchor": new j(A.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new H(A.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new H(A.layout_symbol["text-anchor"]), "text-max-angle": new j(A.layout_symbol["text-max-angle"]), "text-writing-mode": new j(A.layout_symbol["text-writing-mode"]), "text-rotate": new H(A.layout_symbol["text-rotate"]), "text-padding": new j(A.layout_symbol["text-padding"]), "text-keep-upright": new j(A.layout_symbol["text-keep-upright"]), "text-transform": new H(A.layout_symbol["text-transform"]), "text-offset": new H(A.layout_symbol["text-offset"]), "text-allow-overlap": new j(A.layout_symbol["text-allow-overlap"]), "text-overlap": new j(A.layout_symbol["text-overlap"]), "text-ignore-placement": new j(A.layout_symbol["text-ignore-placement"]), "text-optional": new j(A.layout_symbol["text-optional"]) }), "getLayout");
var z0;
var Rk = r(() => z0 = z0 || new De({ "icon-opacity": new H(A.paint_symbol["icon-opacity"]), "icon-color": new H(A.paint_symbol["icon-color"]), "icon-halo-color": new H(A.paint_symbol["icon-halo-color"]), "icon-halo-width": new H(A.paint_symbol["icon-halo-width"]), "icon-halo-blur": new H(A.paint_symbol["icon-halo-blur"]), "icon-translate": new j(A.paint_symbol["icon-translate"]), "icon-translate-anchor": new j(A.paint_symbol["icon-translate-anchor"]), "text-opacity": new H(A.paint_symbol["text-opacity"]), "text-color": new H(A.paint_symbol["text-color"], { runtimeType: Ct, getOverride: (r3) => r3.textColor, hasOverride: (r3) => !!r3.textColor }), "text-halo-color": new H(A.paint_symbol["text-halo-color"]), "text-halo-width": new H(A.paint_symbol["text-halo-width"]), "text-halo-blur": new H(A.paint_symbol["text-halo-blur"]), "text-translate": new j(A.paint_symbol["text-translate"]), "text-translate-anchor": new j(A.paint_symbol["text-translate-anchor"]) }), "getPaint");
var Yl = { get paint() {
  return Rk();
}, get layout() {
  return Fk();
} };
q();
var Ym = class Ym2 {
  constructor(e) {
    if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
    this.type = e.property.overrides ? e.property.overrides.runtimeType : Ni, this.defaultValue = e;
  }
  evaluate(e) {
    if (e.formattedSection) {
      let t3 = this.defaultValue.property.overrides;
      if (t3 && t3.hasOverride(e.formattedSection)) return t3.getOverride(e.formattedSection);
    }
    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
  }
  eachChild(e) {
    if (!this.defaultValue.isConstant()) {
      let t3 = this.defaultValue.value;
      e(t3._styleExpression.expression);
    }
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return null;
  }
};
r(Ym, "FormatSectionOverride");
var ra = Ym;
N("FormatSectionOverride", ra, { omit: ["defaultValue"] });
var ia = class ia2 extends Ge {
  constructor(e) {
    super(e, Yl);
  }
  recalculate(e, t3) {
    if (super.recalculate(e, t3), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
      let i = this.layout.get("text-writing-mode");
      if (i) {
        let n = [];
        for (let o of i) n.indexOf(o) < 0 && n.push(o);
        this.layout._values["text-writing-mode"] = n;
      } else this.layout._values["text-writing-mode"] = ["horizontal"];
    }
    this._setPaintOverrides();
  }
  getValueAndResolveTokens(e, t3, i, n) {
    let o = this.layout.get(e).evaluate(t3, {}, i, n), a = this._unevaluatedLayout._values[e];
    return !a.isDataDriven() && !ti(a.value) && o ? L0(t3.properties, o) : o;
  }
  createBucket(e) {
    return new Ot(e);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    throw new Error("Should take a different path in FeatureIndex");
  }
  _setPaintOverrides() {
    for (let e of Yl.paint.overridableProperties) {
      if (!ia2.hasPaintOverride(this.layout, e)) continue;
      let t3 = this.paint.get(e), i = new ra(t3), n = new Jr(i, t3.property.specification), o = null;
      t3.value.kind === "constant" || t3.value.kind === "source" ? o = new _r("source", n) : o = new vr("composite", n, t3.value.zoomStops), this.paint._values[e] = new at(t3.property, o, t3.parameters);
    }
  }
  _handleOverridablePaintPropertyUpdate(e, t3, i) {
    return !this.layout || t3.isDataDriven() || i.isDataDriven() ? false : ia2.hasPaintOverride(this.layout, e);
  }
  static hasPaintOverride(e, t3) {
    let i = e.get("text-field"), n = Yl.paint.properties[t3], o = false, a = r((s3) => {
      for (let l of s3) if (n.overrides && n.overrides.hasOverride(l)) {
        o = true;
        return;
      }
    }, "checkSections");
    if (i.value.kind === "constant" && i.value.value instanceof wt) a(i.value.value.sections);
    else if (i.value.kind === "source") {
      let s3 = r((c) => {
        if (!o) if (c instanceof xr && Ze(c.value) === Gi) {
          let p = c.value;
          a(p.sections);
        } else c instanceof Wn ? a(c.sections) : c.eachChild(s3);
      }, "checkExpression"), l = i.value;
      l._styleExpression && s3(l._styleExpression.expression);
    }
    return o;
  }
};
r(ia, "SymbolStyleLayer");
var Ql = ia;
q();
q();
var F0;
var Bk = r(() => F0 = F0 || new De({ "background-color": new j(A.paint_background["background-color"]), "background-pattern": new ii(A.paint_background["background-pattern"]), "background-opacity": new j(A.paint_background["background-opacity"]) }), "getPaint");
var R0 = { get paint() {
  return Bk();
} };
var Qm = class Qm2 extends Ge {
  constructor(e) {
    super(e, R0);
  }
};
r(Qm, "BackgroundStyleLayer");
var eu = Qm;
q();
q();
var B0;
var Ok = r(() => B0 = B0 || new De({ "raster-opacity": new j(A.paint_raster["raster-opacity"]), "raster-hue-rotate": new j(A.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new j(A.paint_raster["raster-brightness-min"]), "raster-brightness-max": new j(A.paint_raster["raster-brightness-max"]), "raster-saturation": new j(A.paint_raster["raster-saturation"]), "raster-contrast": new j(A.paint_raster["raster-contrast"]), "raster-resampling": new j(A.paint_raster["raster-resampling"]), "raster-fade-duration": new j(A.paint_raster["raster-fade-duration"]) }), "getPaint");
var O0 = { get paint() {
  return Ok();
} };
var ed = class ed2 extends Ge {
  constructor(e) {
    super(e, O0);
  }
};
r(ed, "RasterStyleLayer");
var tu = ed;
q();
function V0(r3) {
  let e = [], t3 = r3.id;
  return t3 === void 0 && e.push({ message: `layers.${t3}: missing required property "id"` }), r3.render === void 0 && e.push({ message: `layers.${t3}: missing required method "render"` }), r3.renderingMode && r3.renderingMode !== "2d" && r3.renderingMode !== "3d" && e.push({ message: `layers.${t3}: property "renderingMode" must be either "2d" or "3d"` }), e;
}
r(V0, "validateCustomStyleLayer");
var td = class td2 extends Ge {
  constructor(t3) {
    super(t3, {});
    this.onAdd = (t4) => {
      this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
    };
    this.onRemove = (t4) => {
      this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
    };
    this.implementation = t3;
  }
  is3D() {
    return this.implementation.renderingMode === "3d";
  }
  hasOffscreenPass() {
    return this.implementation.prerender !== void 0;
  }
  recalculate() {
  }
  updateTransitions() {
  }
  hasTransition() {
    return false;
  }
  serialize() {
    throw new Error("Custom layers cannot be serialized");
  }
};
r(td, "CustomStyleLayer");
var ru = td;
function iu(r3) {
  if (r3.type === "custom") return new ru(r3);
  switch (r3.type) {
    case "background":
      return new eu(r3);
    case "circle":
      return new kl(r3);
    case "fill":
      return new Nl(r3);
    case "fill-extrusion":
      return new ql(r3);
    case "heatmap":
      return new Fl(r3);
    case "hillshade":
      return new Rl(r3);
    case "line":
      return new Zl(r3);
    case "raster":
      return new tu(r3);
    case "symbol":
      return new Ql(r3);
  }
}
r(iu, "createStyleLayer");
q();
q();
function mn(r3) {
  let e = [];
  if (typeof r3 == "string") e.push({ id: "default", url: r3 });
  else if (r3 && r3.length > 0) {
    let t3 = [];
    for (let { id: i, url: n } of r3) {
      let o = `${i}${n}`;
      t3.indexOf(o) === -1 && (t3.push(o), e.push({ id: i, url: n }));
    }
  }
  return e;
}
r(mn, "coerceSpriteToArray");
async function U0(r3, e, t3, i) {
  let n = mn(r3), o = t3 > 1 ? "@2x" : "", a = {}, s3 = {};
  for (let { id: l, url: c } of n) {
    let p = e.transformRequest(e.normalizeSpriteURL(c, o, ".json"), "SpriteJSON");
    a[l] = yr(p, i);
    let h = e.transformRequest(e.normalizeSpriteURL(c, o, ".png"), "SpriteImage");
    s3[l] = st.getImage(h, i);
  }
  return await Promise.all([...Object.values(a), ...Object.values(s3)]), Vk(a, s3);
}
r(U0, "loadSprite");
async function Vk(r3, e) {
  let t3 = {};
  for (let i in r3) {
    t3[i] = {};
    let n = Y.getImageCanvasContext((await e[i]).data), o = (await r3[i]).data;
    for (let a in o) {
      let { width: s3, height: l, x: c, y: p, sdf: h, pixelRatio: f, stretchX: m, stretchY: y, content: g } = o[a], x = { width: s3, height: l, x: c, y: p, context: n };
      t3[i][a] = { data: null, pixelRatio: f, sdf: h, stretchX: m, stretchY: y, content: g, spriteData: x };
    }
  }
  return t3;
}
r(Vk, "doOnceCompleted");
q();
q();
var rd = class rd2 {
  constructor(e, t3, i, n) {
    this.context = e, this.format = i, this.texture = e.gl.createTexture(), this.update(t3, n);
  }
  update(e, t3, i) {
    let { width: n, height: o } = e, a = (!this.size || this.size[0] !== n || this.size[1] !== o) && !i, { context: s3 } = this, { gl: l } = s3;
    if (this.useMipmap = !!(t3 && t3.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), s3.pixelStoreUnpackFlipY.set(false), s3.pixelStoreUnpack.set(1), s3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!t3 || t3.premultiply !== false)), a) this.size = [n, o], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ht(e) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e) : l.texImage2D(l.TEXTURE_2D, 0, this.format, n, o, 0, this.format, l.UNSIGNED_BYTE, e.data);
    else {
      let { x: c, y: p } = i || { x: 0, y: 0 };
      e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ht(e) ? l.texSubImage2D(l.TEXTURE_2D, 0, c, p, l.RGBA, l.UNSIGNED_BYTE, e) : l.texSubImage2D(l.TEXTURE_2D, 0, c, p, n, o, l.RGBA, l.UNSIGNED_BYTE, e.data);
    }
    this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D);
  }
  bind(e, t3, i) {
    let { context: n } = this, { gl: o } = n;
    o.bindTexture(o.TEXTURE_2D, this.texture), i === o.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo() && (i = o.LINEAR), e !== this.filter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, i || e), this.filter = e), t3 !== this.wrap && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, t3), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, t3), this.wrap = t3);
  }
  isSizePowerOfTwo() {
    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
  }
  destroy() {
    let { gl: e } = this.context;
    e.deleteTexture(this.texture), this.texture = null;
  }
};
r(rd, "Texture");
var ve = rd;
q();
function N0(r3) {
  let { userImage: e } = r3;
  return e && e.render && e.render() ? (r3.data.replace(new Uint8Array(e.data.buffer)), true) : false;
}
r(N0, "renderStyleImage");
var nu = 1;
var id = class id2 extends de {
  constructor() {
    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new Se({ width: 1, height: 1 }), this.dirty = true;
  }
  isLoaded() {
    return this.loaded;
  }
  setLoaded(e) {
    if (this.loaded !== e && (this.loaded = e, e)) {
      for (let { ids: t3, promiseResolve: i } of this.requestors) i(this._getImagesForIds(t3));
      this.requestors = [];
    }
  }
  getImage(e) {
    let t3 = this.images[e];
    if (t3 && !t3.data && t3.spriteData) {
      let i = t3.spriteData;
      t3.data = new Se({ width: i.width, height: i.height }, i.context.getImageData(i.x, i.y, i.width, i.height).data), t3.spriteData = null;
    }
    return t3;
  }
  addImage(e, t3) {
    if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
    this._validate(e, t3) && (this.images[e] = t3);
  }
  _validate(e, t3) {
    let i = true, n = t3.data || t3.spriteData;
    return this._validateStretch(t3.stretchX, n && n.width) || (this.fire(new Z(new Error(`Image "${e}" has invalid "stretchX" value`))), i = false), this._validateStretch(t3.stretchY, n && n.height) || (this.fire(new Z(new Error(`Image "${e}" has invalid "stretchY" value`))), i = false), this._validateContent(t3.content, t3) || (this.fire(new Z(new Error(`Image "${e}" has invalid "content" value`))), i = false), i;
  }
  _validateStretch(e, t3) {
    if (!e) return true;
    let i = 0;
    for (let n of e) {
      if (n[0] < i || n[1] < n[0] || t3 < n[1]) return false;
      i = n[1];
    }
    return true;
  }
  _validateContent(e, t3) {
    if (!e) return true;
    if (e.length !== 4) return false;
    let i = t3.spriteData, n = i && i.width || t3.data.width, o = i && i.height || t3.data.height;
    return !(e[0] < 0 || n < e[0] || e[1] < 0 || o < e[1] || e[2] < 0 || n < e[2] || e[3] < 0 || o < e[3] || e[2] < e[0] || e[3] < e[1]);
  }
  updateImage(e, t3, i = true) {
    let n = this.getImage(e);
    if (i && (n.data.width !== t3.data.width || n.data.height !== t3.data.height)) throw new Error(`size mismatch between old image (${n.data.width}x${n.data.height}) and new image (${t3.data.width}x${t3.data.height}).`);
    t3.version = n.version + 1, this.images[e] = t3, this.updatedImages[e] = true;
  }
  removeImage(e) {
    let t3 = this.images[e];
    delete this.images[e], delete this.patterns[e], t3.userImage && t3.userImage.onRemove && t3.userImage.onRemove();
  }
  listImages() {
    return Object.keys(this.images);
  }
  getImages(e) {
    return new Promise((t3, i) => {
      let n = true;
      if (!this.isLoaded()) for (let o of e) this.images[o] || (n = false);
      this.isLoaded() || n ? t3(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: t3 });
    });
  }
  _getImagesForIds(e) {
    let t3 = {};
    for (let i of e) {
      let n = this.getImage(i);
      n || (this.fire(new F("styleimagemissing", { id: i })), n = this.getImage(i)), n ? t3[i] = { data: n.data.clone(), pixelRatio: n.pixelRatio, sdf: n.sdf, version: n.version, stretchX: n.stretchX, stretchY: n.stretchY, content: n.content, hasRenderCallback: !!(n.userImage && n.userImage.render) } : ke(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
    }
    return t3;
  }
  getPixelSize() {
    let { width: e, height: t3 } = this.atlasImage;
    return { width: e, height: t3 };
  }
  getPattern(e) {
    let t3 = this.patterns[e], i = this.getImage(e);
    if (!i) return null;
    if (t3 && t3.position.version === i.version) return t3.position;
    if (t3) t3.position.version = i.version;
    else {
      let n = i.data.width + nu * 2, o = i.data.height + nu * 2, a = { w: n, h: o, x: 0, y: 0 }, s3 = new pn(a, i);
      this.patterns[e] = { bin: a, position: s3 };
    }
    return this._updatePatternAtlas(), this.patterns[e].position;
  }
  bind(e) {
    let t3 = e.gl;
    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new ve(e, this.atlasImage, t3.RGBA), this.atlasTexture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE);
  }
  _updatePatternAtlas() {
    let e = [];
    for (let o in this.patterns) e.push(this.patterns[o].bin);
    let { w: t3, h: i } = Jo(e), n = this.atlasImage;
    n.resize({ width: t3 || 1, height: i || 1 });
    for (let o in this.patterns) {
      let { bin: a } = this.patterns[o], s3 = a.x + nu, l = a.y + nu, c = this.getImage(o).data, p = c.width, h = c.height;
      Se.copy(c, n, { x: 0, y: 0 }, { x: s3, y: l }, { width: p, height: h }), Se.copy(c, n, { x: 0, y: h - 1 }, { x: s3, y: l - 1 }, { width: p, height: 1 }), Se.copy(c, n, { x: 0, y: 0 }, { x: s3, y: l + h }, { width: p, height: 1 }), Se.copy(c, n, { x: p - 1, y: 0 }, { x: s3 - 1, y: l }, { width: 1, height: h }), Se.copy(c, n, { x: 0, y: 0 }, { x: s3 + p, y: l }, { width: 1, height: h });
    }
    this.dirty = true;
  }
  beginFrame() {
    this.callbackDispatchedThisFrame = {};
  }
  dispatchRenderCallbacks(e) {
    for (let t3 of e) {
      if (this.callbackDispatchedThisFrame[t3]) continue;
      this.callbackDispatchedThisFrame[t3] = true;
      let i = this.getImage(t3);
      i || ke(`Image with ID: "${t3}" was not found`), N0(i) && this.updateImage(t3, i);
    }
  }
};
r(id, "ImageManager");
var ou = id;
q();
q();
async function G0(r3, e, t3, i) {
  let n = e * 256, o = n + 255, a = i.transformRequest(t3.replace("{fontstack}", r3).replace("{range}", `${n}-${o}`), "Glyphs"), s3 = await lb(a, new AbortController());
  if (!s3 || !s3.data) throw new Error(`Could not load glyph range. range: ${e}, ${n}-${o}`);
  let l = {};
  for (let c of I0(s3.data)) l[c.id] = c;
  return l;
}
r(G0, "loadGlyphRange");
q();
var nd = class nd2 {
  constructor({ fontSize: e = 24, buffer: t3 = 3, radius: i = 8, cutoff: n = 0.25, fontFamily: o = "sans-serif", fontWeight: a = "normal", fontStyle: s3 = "normal" } = {}) {
    this.buffer = t3, this.cutoff = n, this.radius = i;
    let l = this.size = e + t3 * 4, c = this._createCanvas(l), p = this.ctx = c.getContext("2d", { willReadFrequently: true });
    p.font = `${s3} ${a} ${e}px ${o}`, p.textBaseline = "alphabetic", p.textAlign = "left", p.fillStyle = "black", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);
  }
  _createCanvas(e) {
    let t3 = document.createElement("canvas");
    return t3.width = t3.height = e, t3;
  }
  draw(e) {
    let { width: t3, actualBoundingBoxAscent: i, actualBoundingBoxDescent: n, actualBoundingBoxLeft: o, actualBoundingBoxRight: a } = this.ctx.measureText(e), s3 = Math.ceil(i), l = 0, c = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - o))), p = Math.min(this.size - this.buffer, s3 + Math.ceil(n)), h = c + 2 * this.buffer, f = p + 2 * this.buffer, m = Math.max(h * f, 0), y = new Uint8ClampedArray(m), g = { data: y, width: h, height: f, glyphWidth: c, glyphHeight: p, glyphTop: s3, glyphLeft: l, glyphAdvance: t3 };
    if (c === 0 || p === 0) return g;
    let { ctx: x, buffer: b, gridInner: w, gridOuter: _ } = this;
    x.clearRect(b, b, c, p), x.fillText(e, b, b + s3);
    let S = x.getImageData(b, b, c, p);
    _.fill(1e20, 0, m), w.fill(0, 0, m);
    for (let P = 0; P < p; P++) for (let T = 0; T < c; T++) {
      let L = S.data[4 * (P * c + T) + 3] / 255;
      if (L === 0) continue;
      let C = (P + b) * h + T + b;
      if (L === 1) _[C] = 0, w[C] = 1e20;
      else {
        let E = 0.5 - L;
        _[C] = E > 0 ? E * E : 0, w[C] = E < 0 ? E * E : 0;
      }
    }
    $0(_, 0, 0, h, f, h, this.f, this.v, this.z), $0(w, b, b, c, p, h, this.f, this.v, this.z);
    for (let P = 0; P < m; P++) {
      let T = Math.sqrt(_[P]) - Math.sqrt(w[P]);
      y[P] = Math.round(255 - 255 * (T / this.radius + this.cutoff));
    }
    return g;
  }
};
r(nd, "TinySDF");
var na = nd;
function $0(r3, e, t3, i, n, o, a, s3, l) {
  for (let c = e; c < e + i; c++) q0(r3, t3 * o + c, o, n, a, s3, l);
  for (let c = t3; c < t3 + n; c++) q0(r3, c * o + e, 1, i, a, s3, l);
}
r($0, "edt");
function q0(r3, e, t3, i, n, o, a) {
  o[0] = 0, a[0] = -1e20, a[1] = 1e20, n[0] = r3[e];
  for (let s3 = 1, l = 0, c = 0; s3 < i; s3++) {
    n[s3] = r3[e + s3 * t3];
    let p = s3 * s3;
    do {
      let h = o[l];
      c = (n[s3] - n[h] + p - h * h) / (s3 - h) / 2;
    } while (c <= a[l] && --l > -1);
    l++, o[l] = s3, a[l] = c, a[l + 1] = 1e20;
  }
  for (let s3 = 0, l = 0; s3 < i; s3++) {
    for (; a[l + 1] < s3; ) l++;
    let c = o[l], p = s3 - c;
    r3[e + s3 * t3] = n[c] + p * p;
  }
}
r(q0, "edt1d");
var yi = class yi2 {
  constructor(e, t3) {
    this.requestManager = e, this.localIdeographFontFamily = t3, this.entries = {};
  }
  setURL(e) {
    this.url = e;
  }
  async getGlyphs(e) {
    let t3 = [];
    for (let o in e) for (let a of e[o]) t3.push(this._getAndCacheGlyphsPromise(o, a));
    let i = await Promise.all(t3), n = {};
    for (let { stack: o, id: a, glyph: s3 } of i) n[o] || (n[o] = {}), n[o][a] = s3 && { id: s3.id, bitmap: s3.bitmap.clone(), metrics: s3.metrics };
    return n;
  }
  async _getAndCacheGlyphsPromise(e, t3) {
    let i = this.entries[e];
    i || (i = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
    let n = i.glyphs[t3];
    if (n !== void 0) return { stack: e, id: t3, glyph: n };
    if (n = this._tinySDF(i, e, t3), n) return i.glyphs[t3] = n, { stack: e, id: t3, glyph: n };
    let o = Math.floor(t3 / 256);
    if (o * 256 > 65535) throw new Error("glyphs > 65535 not supported");
    if (i.ranges[o]) return { stack: e, id: t3, glyph: n };
    if (!this.url) throw new Error("glyphsUrl is not set");
    if (!i.requests[o]) {
      let s3 = yi2.loadGlyphRange(e, o, this.url, this.requestManager);
      i.requests[o] = s3;
    }
    let a = await i.requests[o];
    for (let s3 in a) this._doesCharSupportLocalGlyph(+s3) || (i.glyphs[+s3] = a[+s3]);
    return i.ranges[o] = true, { stack: e, id: t3, glyph: a[t3] || null };
  }
  _doesCharSupportLocalGlyph(e) {
    return !!this.localIdeographFontFamily && (he["CJK Unified Ideographs"](e) || he["Hangul Syllables"](e) || he.Hiragana(e) || he.Katakana(e));
  }
  _tinySDF(e, t3, i) {
    let n = this.localIdeographFontFamily;
    if (!n || !this._doesCharSupportLocalGlyph(i)) return;
    let o = 2, a = e.tinySDF;
    if (!a) {
      let p = "400";
      /bold/i.test(t3) ? p = "900" : /medium/i.test(t3) ? p = "500" : /light/i.test(t3) && (p = "200"), a = e.tinySDF = new yi2.TinySDF({ fontSize: 24 * o, buffer: 3 * o, radius: 8 * o, cutoff: 0.25, fontFamily: n, fontWeight: p });
    }
    let s3 = a.draw(String.fromCharCode(i));
    return { id: i, bitmap: new pi({ width: s3.width || 30 * o, height: s3.height || 30 * o }, s3.data), metrics: { width: s3.glyphWidth / o || 24, height: s3.glyphHeight / o || 24, left: s3.glyphLeft / o + 0.5 || 0, top: s3.glyphTop / o - 27.5 || -8, advance: s3.glyphAdvance / o || 24, isDoubleResolution: true } };
  }
};
r(yi, "GlyphManager"), yi.loadGlyphRange = G0, yi.TinySDF = na;
var au = yi;
q();
var sd = class sd2 {
  constructor() {
    this.specification = A.light.position;
  }
  possiblyEvaluate(e, t3) {
    return eb(e.expression.evaluate(t3));
  }
  interpolate(e, t3, i) {
    return { x: Pe.number(e.x, t3.x, i), y: Pe.number(e.y, t3.y, i), z: Pe.number(e.z, t3.z, i) };
  }
};
r(sd, "LightPositionProperty");
var ad = sd;
var j0 = "-transition";
var od;
var ld = class ld2 extends de {
  constructor(e) {
    super(), od = od || new De({ anchor: new j(A.light.anchor), position: new ad(), color: new j(A.light.color), intensity: new j(A.light.intensity) }), this._transitionable = new Ki(od), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
  }
  getLight() {
    return this._transitionable.serialize();
  }
  setLight(e, t3 = {}) {
    if (!this._validate(__, e, t3)) for (let i in e) {
      let n = e[i];
      i.endsWith(j0) ? this._transitionable.setTransition(i.slice(0, -j0.length), n) : this._transitionable.setValue(i, n);
    }
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  _validate(e, t3, i) {
    return i && i.validate === false ? false : ji(this, e.call(Ne, { value: t3, style: { glyphs: true, sprite: true }, styleSpec: A }));
  }
};
r(ld, "Light");
var su = ld;
q();
var ud = class ud2 {
  constructor(e, t3) {
    this.width = e, this.height = t3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
  }
  getDash(e, t3) {
    let i = e.join(",") + String(t3);
    return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(e, t3)), this.dashEntry[i];
  }
  getDashRanges(e, t3, i) {
    let n = e.length % 2 === 1, o = [], a = n ? -e[e.length - 1] * i : 0, s3 = e[0] * i, l = true;
    o.push({ left: a, right: s3, isDash: l, zeroLength: e[0] === 0 });
    let c = e[0];
    for (let p = 1; p < e.length; p++) {
      l = !l;
      let h = e[p];
      a = c * i, c += h, s3 = c * i, o.push({ left: a, right: s3, isDash: l, zeroLength: h === 0 });
    }
    return o;
  }
  addRoundDash(e, t3, i) {
    let n = t3 / 2;
    for (let o = -i; o <= i; o++) {
      let a = this.nextRow + i + o, s3 = this.width * a, l = 0, c = e[l];
      for (let p = 0; p < this.width; p++) {
        p / c.right > 1 && (c = e[++l]);
        let h = Math.abs(p - c.left), f = Math.abs(p - c.right), m = Math.min(h, f), y, g = o / i * (n + 1);
        if (c.isDash) {
          let x = n - Math.abs(g);
          y = Math.sqrt(m * m + x * x);
        } else y = n - Math.sqrt(m * m + g * g);
        this.data[s3 + p] = Math.max(0, Math.min(255, y + 128));
      }
    }
  }
  addRegularDash(e) {
    for (let s3 = e.length - 1; s3 >= 0; --s3) {
      let l = e[s3], c = e[s3 + 1];
      l.zeroLength ? e.splice(s3, 1) : c && c.isDash === l.isDash && (c.left = l.left, e.splice(s3, 1));
    }
    let t3 = e[0], i = e[e.length - 1];
    t3.isDash === i.isDash && (t3.left = i.left - this.width, i.right = t3.right + this.width);
    let n = this.width * this.nextRow, o = 0, a = e[o];
    for (let s3 = 0; s3 < this.width; s3++) {
      s3 / a.right > 1 && (a = e[++o]);
      let l = Math.abs(s3 - a.left), c = Math.abs(s3 - a.right), p = Math.min(l, c), h = a.isDash ? p : -p;
      this.data[n + s3] = Math.max(0, Math.min(255, h + 128));
    }
  }
  addDash(e, t3) {
    let i = t3 ? 7 : 0, n = 2 * i + 1;
    if (this.nextRow + n > this.height) return ke("LineAtlas out of space"), null;
    let o = 0;
    for (let s3 = 0; s3 < e.length; s3++) o += e[s3];
    if (o !== 0) {
      let s3 = this.width / o, l = this.getDashRanges(e, this.width, s3);
      t3 ? this.addRoundDash(l, s3, i) : this.addRegularDash(l);
    }
    let a = { y: (this.nextRow + i + 0.5) / this.height, height: 2 * i / this.height, width: o };
    return this.nextRow += n, this.dirty = true, a;
  }
  bind(e) {
    let t3 = e.gl;
    this.texture ? (t3.bindTexture(t3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t3.texSubImage2D(t3.TEXTURE_2D, 0, 0, 0, this.width, this.height, t3.ALPHA, t3.UNSIGNED_BYTE, this.data))) : (this.texture = t3.createTexture(), t3.bindTexture(t3.TEXTURE_2D, this.texture), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_WRAP_S, t3.REPEAT), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_WRAP_T, t3.REPEAT), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_MIN_FILTER, t3.LINEAR), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_MAG_FILTER, t3.LINEAR), t3.texImage2D(t3.TEXTURE_2D, 0, t3.ALPHA, this.width, this.height, 0, t3.ALPHA, t3.UNSIGNED_BYTE, this.data));
  }
};
r(ud, "LineAtlas");
var lu = ud;
q();
q();
q();
var cd = class cd2 {
  constructor(e) {
    this._methodToThrottle = e, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
      this._triggered = false, this._methodToThrottle();
    });
  }
  trigger() {
    this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
      this._triggered = false, this._methodToThrottle();
    }, 0));
  }
  remove() {
    delete this._channel, this._methodToThrottle = () => {
    };
  }
};
r(cd, "ThrottledInvoker");
var uu = cd;
var pd = class pd2 {
  constructor(e, t3) {
    this.target = e, this.mapId = t3, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new uu(() => this.process()), this.subscription = ab(this.target, "message", (i) => this.receive(i), false), this.globalScope = tr(self) ? e : window;
  }
  registerMessageHandler(e, t3) {
    this.messageHandlers[e] = t3;
  }
  sendAsync(e, t3) {
    return new Promise((i, n) => {
      let o = Math.round(Math.random() * 1e18).toString(36).substring(0, 10);
      this.resolveRejects[o] = { resolve: i, reject: n }, t3 && t3.signal.addEventListener("abort", () => {
        delete this.resolveRejects[o];
        let l = { id: o, type: "<cancel>", origin: location.origin, targetMapId: e.targetMapId, sourceMapId: this.mapId };
        this.target.postMessage(l);
      }, { once: true });
      let a = [], s3 = { ...e, id: o, sourceMapId: this.mapId, origin: location.origin, data: Zi(e.data, a) };
      this.target.postMessage(s3, { transfer: a });
    });
  }
  receive(e) {
    let t3 = e.data, i = t3.id;
    if (!(t3.origin !== "file://" && location.origin !== "file://" && t3.origin !== location.origin) && !(t3.targetMapId && this.mapId !== t3.targetMapId)) {
      if (t3.type === "<cancel>") {
        delete this.tasks[i];
        let n = this.abortControllers[i];
        delete this.abortControllers[i], n && n.abort();
        return;
      }
      if (tr(self) || t3.mustQueue) {
        this.tasks[i] = t3, this.taskQueue.push(i), this.invoker.trigger();
        return;
      }
      this.processTask(i, t3);
    }
  }
  process() {
    if (this.taskQueue.length === 0) return;
    let e = this.taskQueue.shift(), t3 = this.tasks[e];
    delete this.tasks[e], this.taskQueue.length > 0 && this.invoker.trigger(), t3 && this.processTask(e, t3);
  }
  async processTask(e, t3) {
    if (t3.type === "<response>") {
      let o = this.resolveRejects[e];
      if (delete this.resolveRejects[e], !o) return;
      t3.error ? o.reject(Hi(t3.error)) : o.resolve(Hi(t3.data));
      return;
    }
    if (!this.messageHandlers[t3.type]) {
      this.completeTask(e, new Error(`Could not find a registered handler for ${t3.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
      return;
    }
    let i = Hi(t3.data), n = new AbortController();
    this.abortControllers[e] = n;
    try {
      let o = await this.messageHandlers[t3.type](t3.sourceMapId, i, n);
      this.completeTask(e, null, o);
    } catch (o) {
      this.completeTask(e, o);
    }
  }
  completeTask(e, t3, i) {
    let n = [];
    delete this.abortControllers[e];
    let o = { id: e, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t3 ? Zi(t3) : null, data: Zi(i, n) };
    this.target.postMessage(o, { transfer: n });
  }
  remove() {
    this.invoker.remove(), this.subscription.unsubscribe();
  }
};
r(pd, "Actor");
var cu = pd;
q();
q();
q();
q();
var Z0 = '(()=>{var by=Object.create;var Ba=Object.defineProperty;var vy=Object.getOwnPropertyDescriptor;var Py=Object.getOwnPropertyNames;var Sy=Object.getPrototypeOf,wy=Object.prototype.hasOwnProperty;var Ae=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ll=(e,t)=>{for(var r in t)Ba(e,r,{get:t[r],enumerable:!0})},Ay=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Py(t))!wy.call(e,i)&&i!==r&&Ba(e,i,{get:()=>t[i],enumerable:!(n=vy(t,i))||n.enumerable});return e};var Z=(e,t,r)=>(r=e!=null?by(Sy(e)):{},Ay(t||!e||!e.__esModule?Ba(r,"default",{value:e,enumerable:!0}):r,e));var he=Ae((l0,Dl)=>{"use strict";Dl.exports=or;function or(e,t){this.x=e,this.y=t}or.prototype={clone:function(){return new or(this.x,this.y)},add:function(e){return this.clone()._add(e)},sub:function(e){return this.clone()._sub(e)},multByPoint:function(e){return this.clone()._multByPoint(e)},divByPoint:function(e){return this.clone()._divByPoint(e)},mult:function(e){return this.clone()._mult(e)},div:function(e){return this.clone()._div(e)},rotate:function(e){return this.clone()._rotate(e)},rotateAround:function(e,t){return this.clone()._rotateAround(e,t)},matMult:function(e){return this.clone()._matMult(e)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(e){return this.x===e.x&&this.y===e.y},dist:function(e){return Math.sqrt(this.distSqr(e))},distSqr:function(e){var t=e.x-this.x,r=e.y-this.y;return t*t+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(e){return Math.atan2(this.y-e.y,this.x-e.x)},angleWith:function(e){return this.angleWithSep(e.x,e.y)},angleWithSep:function(e,t){return Math.atan2(this.x*t-this.y*e,this.x*e+this.y*t)},_matMult:function(e){var t=e[0]*this.x+e[1]*this.y,r=e[2]*this.x+e[3]*this.y;return this.x=t,this.y=r,this},_add:function(e){return this.x+=e.x,this.y+=e.y,this},_sub:function(e){return this.x-=e.x,this.y-=e.y,this},_mult:function(e){return this.x*=e,this.y*=e,this},_div:function(e){return this.x/=e,this.y/=e,this},_multByPoint:function(e){return this.x*=e.x,this.y*=e.y,this},_divByPoint:function(e){return this.x/=e.x,this.y/=e.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var e=this.y;return this.y=this.x,this.x=-e,this},_rotate:function(e){var t=Math.cos(e),r=Math.sin(e),n=t*this.x-r*this.y,i=r*this.x+t*this.y;return this.x=n,this.y=i,this},_rotateAround:function(e,t){var r=Math.cos(e),n=Math.sin(e),i=t.x+r*(this.x-t.x)-n*(this.y-t.y),o=t.y+n*(this.x-t.x)+r*(this.y-t.y);return this.x=i,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}};or.convert=function(e){return e instanceof or?e:Array.isArray(e)?new or(e[0],e[1]):e}});var zl=Ae((u0,Bl)=>{"use strict";Bl.exports=Vl;function Vl(e,t,r,n){this.cx=3*e,this.bx=3*(r-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*t,this.by=3*(n-t)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=t,this.p2x=r,this.p2y=n}Vl.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,t){if(t===void 0&&(t=1e-6),e<0)return 0;if(e>1)return 1;for(var r=e,n=0;n<8;n++){var i=this.sampleCurveX(r)-e;if(Math.abs(i)<t)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=e,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-e)<t));n++)e>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(e,t){return this.sampleCurveY(this.solveCurveX(e,t))}}});var Ac=Ae(($v,As)=>{function sd(e,t){var r,n,i,o,a,s,l,u,c,p;for(r=e.length&3,n=e.length-r,i=t,a=3432918353,l=461845907,p=0;p<n;)c=e.charCodeAt(p)&255|(e.charCodeAt(++p)&255)<<8|(e.charCodeAt(++p)&255)<<16|(e.charCodeAt(++p)&255)<<24,++p,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c,i=i<<13|i>>>19,o=(i&65535)*5+(((i>>>16)*5&65535)<<16)&4294967295,i=(o&65535)+27492+(((o>>>16)+58964&65535)<<16);switch(c=0,r){case 3:c^=(e.charCodeAt(p+2)&255)<<16;case 2:c^=(e.charCodeAt(p+1)&255)<<8;case 1:c^=e.charCodeAt(p)&255,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c}return i^=e.length,i^=i>>>16,i=(i&65535)*2246822507+(((i>>>16)*2246822507&65535)<<16)&4294967295,i^=i>>>13,i=(i&65535)*3266489909+(((i>>>16)*3266489909&65535)<<16)&4294967295,i^=i>>>16,i>>>0}typeof As<"u"&&(As.exports=sd)});var _c=Ae((Gv,_s)=>{function ld(e,t){for(var r=e.length,n=t^r,i=0,o;r>=4;)o=e.charCodeAt(i)&255|(e.charCodeAt(++i)&255)<<8|(e.charCodeAt(++i)&255)<<16|(e.charCodeAt(++i)&255)<<24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),o^=o>>>24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)^o,r-=4,++i;switch(r){case 3:n^=(e.charCodeAt(i+2)&255)<<16;case 2:n^=(e.charCodeAt(i+1)&255)<<8;case 1:n^=e.charCodeAt(i)&255,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)}return n^=n>>>13,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16),n^=n>>>15,n>>>0}typeof _s!==void 0&&(_s.exports=ld)});var Is=Ae((qv,Mo)=>{var Ic=Ac(),ud=_c();Mo.exports=Ic;Mo.exports.murmur3=Ic;Mo.exports.murmur2=ud});var Os=Ae((BP,Rs)=>{"use strict";Rs.exports=Go;Rs.exports.default=Go;function Go(e,t,r){r=r||2;var n=t&&t.length,i=n?t[0]*r:e.length,o=fp(e,0,i,r,!0),a=[];if(!o||o.next===o.prev)return a;var s,l,u,c,p,f,y;if(n&&(o=Hg(e,t,o,r)),e.length>80*r){s=u=e[0],l=c=e[1];for(var m=r;m<i;m+=r)p=e[m],f=e[m+1],p<s&&(s=p),f<l&&(l=f),p>u&&(u=p),f>c&&(c=f);y=Math.max(u-s,c-l),y=y!==0?32767/y:0}return Zn(o,a,r,s,l,y,0),a}function fp(e,t,r,n,i){var o,a;if(i===zs(e,t,r,n)>0)for(o=t;o<r;o+=n)a=pp(o,e[o],e[o+1],a);else for(o=r-n;o>=t;o-=n)a=pp(o,e[o],e[o+1],a);return a&&qo(a,a.next)&&(Hn(a),a=a.next),a}function Qt(e,t){if(!e)return e;t||(t=e);var r=e,n;do if(n=!1,!r.steiner&&(qo(r,r.next)||oe(r.prev,r,r.next)===0)){if(Hn(r),r=t=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==t);return t}function Zn(e,t,r,n,i,o,a){if(e){!a&&o&&ex(e,n,i,o);for(var s=e,l,u;e.prev!==e.next;){if(l=e.prev,u=e.next,o?Jg(e,n,i,o):jg(e)){t.push(l.i/r|0),t.push(e.i/r|0),t.push(u.i/r|0),Hn(e),e=u.next,s=u.next;continue}if(e=u,e===s){a?a===1?(e=Zg(Qt(e),t,r),Zn(e,t,r,n,i,o,2)):a===2&&Wg(e,t,r,n,i,o):Zn(Qt(e),t,r,n,i,o,1);break}}}}function jg(e){var t=e.prev,r=e,n=e.next;if(oe(t,r,n)>=0)return!1;for(var i=t.x,o=r.x,a=n.x,s=t.y,l=r.y,u=n.y,c=i<o?i<a?i:a:o<a?o:a,p=s<l?s<u?s:u:l<u?l:u,f=i>o?i>a?i:a:o>a?o:a,y=s>l?s>u?s:u:l>u?l:u,m=n.next;m!==t;){if(m.x>=c&&m.x<=f&&m.y>=p&&m.y<=y&&Ar(i,s,o,l,a,u,m.x,m.y)&&oe(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Jg(e,t,r,n){var i=e.prev,o=e,a=e.next;if(oe(i,o,a)>=0)return!1;for(var s=i.x,l=o.x,u=a.x,c=i.y,p=o.y,f=a.y,y=s<l?s<u?s:u:l<u?l:u,m=c<p?c<f?c:f:p<f?p:f,h=s>l?s>u?s:u:l>u?l:u,d=c>p?c>f?c:f:p>f?p:f,g=Vs(y,m,t,r,n),b=Vs(h,d,t,r,n),x=e.prevZ,v=e.nextZ;x&&x.z>=g&&v&&v.z<=b;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ar(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0||(x=x.prevZ,v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ar(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;x&&x.z>=g;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ar(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;v&&v.z<=b;){if(v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ar(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function Zg(e,t,r){var n=e;do{var i=n.prev,o=n.next.next;!qo(i,o)&&yp(i,n,n.next,o)&&Wn(i,o)&&Wn(o,i)&&(t.push(i.i/r|0),t.push(n.i/r|0),t.push(o.i/r|0),Hn(n),Hn(n.next),n=e=o),n=n.next}while(n!==e);return Qt(n)}function Wg(e,t,r,n,i,o){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&nx(a,s)){var l=mp(a,s);a=Qt(a,a.next),l=Qt(l,l.next),Zn(a,t,r,n,i,o,0),Zn(l,t,r,n,i,o,0);return}s=s.next}a=a.next}while(a!==e)}function Hg(e,t,r,n){var i=[],o,a,s,l,u;for(o=0,a=t.length;o<a;o++)s=t[o]*n,l=o<a-1?t[o+1]*n:e.length,u=fp(e,s,l,n,!1),u===u.next&&(u.steiner=!0),i.push(rx(u));for(i.sort(Xg),o=0;o<i.length;o++)r=Kg(i[o],r);return r}function Xg(e,t){return e.x-t.x}function Kg(e,t){var r=Yg(e,t);if(!r)return t;var n=mp(r,e);return Qt(n,n.next),Qt(r,r.next)}function Yg(e,t){var r=t,n=e.x,i=e.y,o=-1/0,a;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=n&&s>o&&(o=s,a=r.x<r.next.x?r:r.next,s===n))return a}r=r.next}while(r!==t);if(!a)return null;var l=a,u=a.x,c=a.y,p=1/0,f;r=a;do n>=r.x&&r.x>=u&&n!==r.x&&Ar(i<c?n:o,i,u,c,i<c?o:n,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(n-r.x),Wn(r,e)&&(f<p||f===p&&(r.x>a.x||r.x===a.x&&Qg(a,r)))&&(a=r,p=f)),r=r.next;while(r!==l);return a}function Qg(e,t){return oe(e.prev,e,t.prev)<0&&oe(t.next,e,e.next)<0}function ex(e,t,r,n){var i=e;do i.z===0&&(i.z=Vs(i.x,i.y,t,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,tx(i)}function tx(e){var t,r,n,i,o,a,s,l,u=1;do{for(r=e,e=null,o=null,a=0;r;){for(a++,n=r,s=0,t=0;t<u&&(s++,n=n.nextZ,!!n);t++);for(l=u;s>0||l>0&&n;)s!==0&&(l===0||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,l--),o?o.nextZ=i:e=i,i.prevZ=o,o=i;r=n}o.nextZ=null,u*=2}while(a>1);return e}function Vs(e,t,r,n,i){return e=(e-r)*i|0,t=(t-n)*i|0,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1}function rx(e){var t=e,r=e;do(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next;while(t!==e);return r}function Ar(e,t,r,n,i,o,a,s){return(i-a)*(t-s)>=(e-a)*(o-s)&&(e-a)*(n-s)>=(r-a)*(t-s)&&(r-a)*(o-s)>=(i-a)*(n-s)}function nx(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!ix(e,t)&&(Wn(e,t)&&Wn(t,e)&&ox(e,t)&&(oe(e.prev,e,t.prev)||oe(e,t.prev,t))||qo(e,t)&&oe(e.prev,e,e.next)>0&&oe(t.prev,t,t.next)>0)}function oe(e,t,r){return(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y)}function qo(e,t){return e.x===t.x&&e.y===t.y}function yp(e,t,r,n){var i=$o(oe(e,t,r)),o=$o(oe(e,t,n)),a=$o(oe(r,n,e)),s=$o(oe(r,n,t));return!!(i!==o&&a!==s||i===0&&Uo(e,r,t)||o===0&&Uo(e,n,t)||a===0&&Uo(r,e,n)||s===0&&Uo(r,t,n))}function Uo(e,t,r){return t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y)}function $o(e){return e>0?1:e<0?-1:0}function ix(e,t){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&yp(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1}function Wn(e,t){return oe(e.prev,e,e.next)<0?oe(e,t,e.next)>=0&&oe(e,e.prev,t)>=0:oe(e,t,e.prev)<0||oe(e,e.next,t)<0}function ox(e,t){var r=e,n=!1,i=(e.x+t.x)/2,o=(e.y+t.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==e);return n}function mp(e,t){var r=new Bs(e.i,e.x,e.y),n=new Bs(t.i,t.x,t.y),i=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function pp(e,t,r,n){var i=new Bs(e,t,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Hn(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Bs(e,t,r){this.i=e,this.x=t,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Go.deviation=function(e,t,r,n){var i=t&&t.length,o=i?t[0]*r:e.length,a=Math.abs(zs(e,0,o,r));if(i)for(var s=0,l=t.length;s<l;s++){var u=t[s]*r,c=s<l-1?t[s+1]*r:e.length;a-=Math.abs(zs(e,u,c,r))}var p=0;for(s=0;s<n.length;s+=3){var f=n[s]*r,y=n[s+1]*r,m=n[s+2]*r;p+=Math.abs((e[f]-e[m])*(e[y+1]-e[f+1])-(e[f]-e[y])*(e[m+1]-e[f+1]))}return a===0&&p===0?0:Math.abs((p-a)/a)};function zs(e,t,r,n){for(var i=0,o=t,a=r-n;o<r;o+=n)i+=(e[a]-e[o])*(e[o+1]+e[a+1]),a=o;return i}Go.flatten=function(e){for(var t=e[0][0].length,r={vertices:[],holes:[],dimensions:t},n=0,i=0;i<e.length;i++){for(var o=0;o<e[i].length;o++)for(var a=0;a<t;a++)r.vertices.push(e[i][o][a]);i>0&&(n+=e[i-1].length,r.holes.push(n))}return r}});var Us=Ae((bS,Sp)=>{"use strict";var fx=he();Sp.exports=Cr;function Cr(e,t,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=e,this._geometry=-1,this._keys=n,this._values=i,e.readFields(yx,this,t)}function yx(e,t,r){e==1?t.id=r.readVarint():e==2?mx(r,t):e==3?t.type=r.readVarint():e==4&&(t._geometry=r.pos)}function mx(e,t){for(var r=e.readVarint()+e.pos;e.pos<r;){var n=t._keys[e.readVarint()],i=t._values[e.readVarint()];t.properties[n]=i}}Cr.types=["Unknown","Point","LineString","Polygon"];Cr.prototype.loadGeometry=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=[],s;e.pos<t;){if(n<=0){var l=e.readVarint();r=l&7,n=l>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),r===1&&(s&&a.push(s),s=[]),s.push(new fx(i,o));else if(r===7)s&&s.push(s[0].clone());else throw new Error("unknown command "+r)}return s&&a.push(s),a};Cr.prototype.bbox=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=1/0,s=-1/0,l=1/0,u=-1/0;e.pos<t;){if(n<=0){var c=e.readVarint();r=c&7,n=c>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),i<a&&(a=i),i>s&&(s=i),o<l&&(l=o),o>u&&(u=o);else if(r!==7)throw new Error("unknown command "+r)}return[a,l,s,u]};Cr.prototype.toGeoJSON=function(e,t,r){var n=this.extent*Math.pow(2,r),i=this.extent*e,o=this.extent*t,a=this.loadGeometry(),s=Cr.types[this.type],l,u;function c(y){for(var m=0;m<y.length;m++){var h=y[m],d=180-(h.y+o)*360/n;y[m]=[(h.x+i)*360/n-180,360/Math.PI*Math.atan(Math.exp(d*Math.PI/180))-90]}}switch(this.type){case 1:var p=[];for(l=0;l<a.length;l++)p[l]=a[l][0];a=p,c(a);break;case 2:for(l=0;l<a.length;l++)c(a[l]);break;case 3:for(a=hx(a),l=0;l<a.length;l++)for(u=0;u<a[l].length;u++)c(a[l][u]);break}a.length===1?a=a[0]:s="Multi"+s;var f={type:"Feature",geometry:{type:s,coordinates:a},properties:this.properties};return"id"in this&&(f.id=this.id),f};function hx(e){var t=e.length;if(t<=1)return[e];for(var r=[],n,i,o=0;o<t;o++){var a=dx(e[o]);a!==0&&(i===void 0&&(i=a<0),i===a<0?(n&&r.push(n),n=[e[o]]):n.push(e[o]))}return n&&r.push(n),r}function dx(e){for(var t=0,r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}});var $s=Ae((vS,Ap)=>{"use strict";var gx=Us();Ap.exports=wp;function wp(e,t){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=e,this._keys=[],this._values=[],this._features=[],e.readFields(xx,this,t),this.length=this._features.length}function xx(e,t,r){e===15?t.version=r.readVarint():e===1?t.name=r.readString():e===5?t.extent=r.readVarint():e===2?t._features.push(r.pos):e===3?t._keys.push(r.readString()):e===4&&t._values.push(bx(r))}function bx(e){for(var t=null,r=e.readVarint()+e.pos;e.pos<r;){var n=e.readVarint()>>3;t=n===1?e.readString():n===2?e.readFloat():n===3?e.readDouble():n===4?e.readVarint64():n===5?e.readVarint():n===6?e.readSVarint():n===7?e.readBoolean():null}return t}wp.prototype.feature=function(e){if(e<0||e>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[e];var t=this._pbf.readVarint()+this._pbf.pos;return new gx(this._pbf,t,this.extent,this._keys,this._values)}});var Ip=Ae((PS,_p)=>{"use strict";var vx=$s();_p.exports=Px;function Px(e,t){this.layers=e.readFields(Sx,{},t)}function Sx(e,t,r){if(e===3){var n=new vx(r,r.readVarint()+r.pos);n.length&&(t[n.name]=n)}}});var Tt=Ae((SS,Jo)=>{Jo.exports.VectorTile=Ip();Jo.exports.VectorTileFeature=Us();Jo.exports.VectorTileLayer=$s()});var Zp=Ae(Zs=>{Zs.read=function(e,t,r,n,i){var o,a,s=i*8-n-1,l=(1<<s)-1,u=l>>1,c=-7,p=r?i-1:0,f=r?-1:1,y=e[t+p];for(p+=f,o=y&(1<<-c)-1,y>>=-c,c+=s;c>0;o=o*256+e[t+p],p+=f,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=a*256+e[t+p],p+=f,c-=8);if(o===0)o=1-u;else{if(o===l)return a?NaN:(y?-1:1)*(1/0);a=a+Math.pow(2,n),o=o-u}return(y?-1:1)*a*Math.pow(2,o-n)};Zs.write=function(e,t,r,n,i,o){var a,s,l,u=o*8-i-1,c=(1<<u)-1,p=c>>1,f=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=n?0:o-1,m=n?1:-1,h=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),a+p>=1?t+=f/l:t+=f*Math.pow(2,1-p),t*l>=2&&(a++,l/=2),a+p>=c?(s=0,a=c):a+p>=1?(s=(t*l-1)*Math.pow(2,i),a=a+p):(s=t*Math.pow(2,p-1)*Math.pow(2,i),a=0));i>=8;e[r+y]=s&255,y+=m,s/=256,i-=8);for(a=a<<i|s,u+=i;u>0;e[r+y]=a&255,y+=m,a/=256,u-=8);e[r+y-m]|=h*128}});var Qn=Ae((i2,Yp)=>{"use strict";Yp.exports=J;var Ko=Zp();function J(e){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(e)?e:new Uint8Array(e||0),this.pos=0,this.type=0,this.length=this.buf.length}J.Varint=0;J.Fixed64=1;J.Bytes=2;J.Fixed32=5;var Ws=65536*65536,Wp=1/Ws,Ux=12,Kp=typeof TextDecoder>"u"?null:new TextDecoder("utf8");J.prototype={destroy:function(){this.buf=null},readFields:function(e,t,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,o=this.pos;this.type=n&7,e(i,t,this),this.pos===o&&this.skip(n)}return t},readMessage:function(e,t){return this.readFields(e,t,this.readVarint()+this.pos)},readFixed32:function(){var e=Yo(this.buf,this.pos);return this.pos+=4,e},readSFixed32:function(){var e=Xp(this.buf,this.pos);return this.pos+=4,e},readFixed64:function(){var e=Yo(this.buf,this.pos)+Yo(this.buf,this.pos+4)*Ws;return this.pos+=8,e},readSFixed64:function(){var e=Yo(this.buf,this.pos)+Xp(this.buf,this.pos+4)*Ws;return this.pos+=8,e},readFloat:function(){var e=Ko.read(this.buf,this.pos,!0,23,4);return this.pos+=4,e},readDouble:function(){var e=Ko.read(this.buf,this.pos,!0,52,8);return this.pos+=8,e},readVarint:function(e){var t=this.buf,r,n;return n=t[this.pos++],r=n&127,n<128||(n=t[this.pos++],r|=(n&127)<<7,n<128)||(n=t[this.pos++],r|=(n&127)<<14,n<128)||(n=t[this.pos++],r|=(n&127)<<21,n<128)?r:(n=t[this.pos],r|=(n&15)<<28,$x(r,e,this))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var e=this.readVarint();return e%2===1?(e+1)/-2:e/2},readBoolean:function(){return!!this.readVarint()},readString:function(){var e=this.readVarint()+this.pos,t=this.pos;return this.pos=e,e-t>=Ux&&Kp?rb(this.buf,t,e):tb(this.buf,t,e)},readBytes:function(){var e=this.readVarint()+this.pos,t=this.buf.subarray(this.pos,e);return this.pos=e,t},readPackedVarint:function(e,t){if(this.type!==J.Bytes)return e.push(this.readVarint(t));var r=ct(this);for(e=e||[];this.pos<r;)e.push(this.readVarint(t));return e},readPackedSVarint:function(e){if(this.type!==J.Bytes)return e.push(this.readSVarint());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSVarint());return e},readPackedBoolean:function(e){if(this.type!==J.Bytes)return e.push(this.readBoolean());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readBoolean());return e},readPackedFloat:function(e){if(this.type!==J.Bytes)return e.push(this.readFloat());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFloat());return e},readPackedDouble:function(e){if(this.type!==J.Bytes)return e.push(this.readDouble());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readDouble());return e},readPackedFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed32());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFixed32());return e},readPackedSFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed32());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed32());return e},readPackedFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed64());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readFixed64());return e},readPackedSFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed64());var t=ct(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed64());return e},skip:function(e){var t=e&7;if(t===J.Varint)for(;this.buf[this.pos++]>127;);else if(t===J.Bytes)this.pos=this.readVarint()+this.pos;else if(t===J.Fixed32)this.pos+=4;else if(t===J.Fixed64)this.pos+=8;else throw new Error("Unimplemented type: "+t)},writeTag:function(e,t){this.writeVarint(e<<3|t)},realloc:function(e){for(var t=this.length||16;t<this.pos+e;)t*=2;if(t!==this.length){var r=new Uint8Array(t);r.set(this.buf),this.buf=r,this.length=t}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(e){this.realloc(4),Er(this.buf,e,this.pos),this.pos+=4},writeSFixed32:function(e){this.realloc(4),Er(this.buf,e,this.pos),this.pos+=4},writeFixed64:function(e){this.realloc(8),Er(this.buf,e&-1,this.pos),Er(this.buf,Math.floor(e*Wp),this.pos+4),this.pos+=8},writeSFixed64:function(e){this.realloc(8),Er(this.buf,e&-1,this.pos),Er(this.buf,Math.floor(e*Wp),this.pos+4),this.pos+=8},writeVarint:function(e){if(e=+e||0,e>268435455||e<0){Gx(e,this);return}this.realloc(4),this.buf[this.pos++]=e&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=e>>>7&127)))},writeSVarint:function(e){this.writeVarint(e<0?-e*2-1:e*2)},writeBoolean:function(e){this.writeVarint(!!e)},writeString:function(e){e=String(e),this.realloc(e.length*4),this.pos++;var t=this.pos;this.pos=nb(this.buf,e,this.pos);var r=this.pos-t;r>=128&&Hp(t,r,this),this.pos=t-1,this.writeVarint(r),this.pos+=r},writeFloat:function(e){this.realloc(4),Ko.write(this.buf,e,this.pos,!0,23,4),this.pos+=4},writeDouble:function(e){this.realloc(8),Ko.write(this.buf,e,this.pos,!0,52,8),this.pos+=8},writeBytes:function(e){var t=e.length;this.writeVarint(t),this.realloc(t);for(var r=0;r<t;r++)this.buf[this.pos++]=e[r]},writeRawMessage:function(e,t){this.pos++;var r=this.pos;e(t,this);var n=this.pos-r;n>=128&&Hp(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(e,t,r){this.writeTag(e,J.Bytes),this.writeRawMessage(t,r)},writePackedVarint:function(e,t){t.length&&this.writeMessage(e,Jx,t)},writePackedSVarint:function(e,t){t.length&&this.writeMessage(e,Zx,t)},writePackedBoolean:function(e,t){t.length&&this.writeMessage(e,Xx,t)},writePackedFloat:function(e,t){t.length&&this.writeMessage(e,Wx,t)},writePackedDouble:function(e,t){t.length&&this.writeMessage(e,Hx,t)},writePackedFixed32:function(e,t){t.length&&this.writeMessage(e,Kx,t)},writePackedSFixed32:function(e,t){t.length&&this.writeMessage(e,Yx,t)},writePackedFixed64:function(e,t){t.length&&this.writeMessage(e,Qx,t)},writePackedSFixed64:function(e,t){t.length&&this.writeMessage(e,eb,t)},writeBytesField:function(e,t){this.writeTag(e,J.Bytes),this.writeBytes(t)},writeFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeFixed32(t)},writeSFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeSFixed32(t)},writeFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeFixed64(t)},writeSFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeSFixed64(t)},writeVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeVarint(t)},writeSVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeSVarint(t)},writeStringField:function(e,t){this.writeTag(e,J.Bytes),this.writeString(t)},writeFloatField:function(e,t){this.writeTag(e,J.Fixed32),this.writeFloat(t)},writeDoubleField:function(e,t){this.writeTag(e,J.Fixed64),this.writeDouble(t)},writeBooleanField:function(e,t){this.writeVarintField(e,!!t)}};function $x(e,t,r){var n=r.buf,i,o;if(o=n[r.pos++],i=(o&112)>>4,o<128||(o=n[r.pos++],i|=(o&127)<<3,o<128)||(o=n[r.pos++],i|=(o&127)<<10,o<128)||(o=n[r.pos++],i|=(o&127)<<17,o<128)||(o=n[r.pos++],i|=(o&127)<<24,o<128)||(o=n[r.pos++],i|=(o&1)<<31,o<128))return Mr(e,i,t);throw new Error("Expected varint not more than 10 bytes")}function ct(e){return e.type===J.Bytes?e.readVarint()+e.pos:e.pos+1}function Mr(e,t,r){return r?t*4294967296+(e>>>0):(t>>>0)*4294967296+(e>>>0)}function Gx(e,t){var r,n;if(e>=0?(r=e%4294967296|0,n=e/4294967296|0):(r=~(-e%4294967296),n=~(-e/4294967296),r^4294967295?r=r+1|0:(r=0,n=n+1|0)),e>=18446744073709552e3||e<-18446744073709552e3)throw new Error("Given varint doesn\'t fit into 10 bytes");t.realloc(10),qx(r,n,t),jx(n,t)}function qx(e,t,r){r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos]=e&127}function jx(e,t){var r=(e&7)<<4;t.buf[t.pos++]|=r|((e>>>=3)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127)))))}function Hp(e,t,r){var n=t<=16383?1:t<=2097151?2:t<=268435455?3:Math.floor(Math.log(t)/(Math.LN2*7));r.realloc(n);for(var i=r.pos-1;i>=e;i--)r.buf[i+n]=r.buf[i]}function Jx(e,t){for(var r=0;r<e.length;r++)t.writeVarint(e[r])}function Zx(e,t){for(var r=0;r<e.length;r++)t.writeSVarint(e[r])}function Wx(e,t){for(var r=0;r<e.length;r++)t.writeFloat(e[r])}function Hx(e,t){for(var r=0;r<e.length;r++)t.writeDouble(e[r])}function Xx(e,t){for(var r=0;r<e.length;r++)t.writeBoolean(e[r])}function Kx(e,t){for(var r=0;r<e.length;r++)t.writeFixed32(e[r])}function Yx(e,t){for(var r=0;r<e.length;r++)t.writeSFixed32(e[r])}function Qx(e,t){for(var r=0;r<e.length;r++)t.writeFixed64(e[r])}function eb(e,t){for(var r=0;r<e.length;r++)t.writeSFixed64(e[r])}function Yo(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+e[t+3]*16777216}function Er(e,t,r){e[r]=t,e[r+1]=t>>>8,e[r+2]=t>>>16,e[r+3]=t>>>24}function Xp(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+(e[t+3]<<24)}function tb(e,t,r){for(var n="",i=t;i<r;){var o=e[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s>r)break;var l,u,c;s===1?o<128&&(a=o):s===2?(l=e[i+1],(l&192)===128&&(a=(o&31)<<6|l&63,a<=127&&(a=null))):s===3?(l=e[i+1],u=e[i+2],(l&192)===128&&(u&192)===128&&(a=(o&15)<<12|(l&63)<<6|u&63,(a<=2047||a>=55296&&a<=57343)&&(a=null))):s===4&&(l=e[i+1],u=e[i+2],c=e[i+3],(l&192)===128&&(u&192)===128&&(c&192)===128&&(a=(o&15)<<18|(l&63)<<12|(u&63)<<6|c&63,(a<=65535||a>=1114112)&&(a=null))),a===null?(a=65533,s=1):a>65535&&(a-=65536,n+=String.fromCharCode(a>>>10&1023|55296),a=56320|a&1023),n+=String.fromCharCode(a),i+=s}return n}function rb(e,t,r){return Kp.decode(e.subarray(t,r))}function nb(e,t,r){for(var n=0,i,o;n<t.length;n++){if(i=t.charCodeAt(n),i>55295&&i<57344)if(o)if(i<56320){e[r++]=239,e[r++]=191,e[r++]=189,o=i;continue}else i=o-55296<<10|i-56320|65536,o=null;else{i>56319||n+1===t.length?(e[r++]=239,e[r++]=191,e[r++]=189):o=i;continue}else o&&(e[r++]=239,e[r++]=191,e[r++]=189,o=null);i<128?e[r++]=i:(i<2048?e[r++]=i>>6|192:(i<65536?e[r++]=i>>12|224:(e[r++]=i>>18|240,e[r++]=i>>12&63|128),e[r++]=i>>6&63|128),e[r++]=i&63|128)}return r}});var Wf=Ae((tT,Zf)=>{Zf.exports=Pa;function Pa(e,t){var r=e&&e.type,n;if(r==="FeatureCollection")for(n=0;n<e.features.length;n++)Pa(e.features[n],t);else if(r==="GeometryCollection")for(n=0;n<e.geometries.length;n++)Pa(e.geometries[n],t);else if(r==="Feature")Pa(e.geometry,t);else if(r==="Polygon")jf(e.coordinates,t);else if(r==="MultiPolygon")for(n=0;n<e.coordinates.length;n++)jf(e.coordinates[n],t);return e}function jf(e,t){if(e.length!==0){Jf(e[0],t);for(var r=1;r<e.length;r++)Jf(e[r],!t)}}function Jf(e,t){for(var r=0,n=0,i=0,o=e.length,a=o-1;i<o;a=i++){var s=(e[i][0]-e[a][0])*(e[a][1]+e[i][1]),l=r+s;n+=Math.abs(r)>=Math.abs(s)?r-l+s:s-l+r,r=l}r+n>=0!=!!t&&e.reverse()}});var Yf=Ae((iT,Kf)=>{"use strict";var Ob=he(),Nb=Tt().VectorTileFeature;Kf.exports=Xf;function Xf(e,t){this.options=t||{},this.features=e,this.length=e.length}Xf.prototype.feature=function(e){return new wa(this.features[e],this.options.extent)};function wa(e,t){this.id=typeof e.id=="number"?e.id:void 0,this.type=e.type,this.rawGeometry=e.type===1?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096}wa.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var r=e[t],n=[],i=0;i<r.length;i++)n.push(new Ob(r[i][0],r[i][1]));this.geometry.push(n)}return this.geometry};wa.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,n=1/0,i=-1/0,o=0;o<e.length;o++)for(var a=e[o],s=0;s<a.length;s++){var l=a[s];t=Math.min(t,l.x),r=Math.max(r,l.x),n=Math.min(n,l.y),i=Math.max(i,l.y)}return[t,n,r,i]};wa.prototype.toGeoJSON=Nb.prototype.toGeoJSON});var ty=Ae((oT,di)=>{var Ub=Qn(),ey=Yf();di.exports=yl;di.exports.fromVectorTileJs=yl;di.exports.fromGeojsonVt=$b;di.exports.GeoJSONWrapper=ey;function yl(e){var t=new Ub;return Gb(e,t),t.finish()}function $b(e,t){t=t||{};var r={};for(var n in e)r[n]=new ey(e[n].features,t),r[n].name=n,r[n].version=t.version,r[n].extent=t.extent;return yl({layers:r})}function Gb(e,t){for(var r in e.layers)t.writeMessage(3,qb,e.layers[r])}function qb(e,t){t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var r,n={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)n.feature=e.feature(r),t.writeMessage(2,jb,n);var i=n.keys;for(r=0;r<i.length;r++)t.writeStringField(3,i[r]);var o=n.values;for(r=0;r<o.length;r++)t.writeMessage(4,Wb,o[r])}function jb(e,t){var r=e.feature;r.id!==void 0&&t.writeVarintField(1,r.id),t.writeMessage(2,Jb,e),t.writeVarintField(3,r.type),t.writeMessage(4,Zb,r)}function Jb(e,t){var r=e.feature,n=e.keys,i=e.values,o=e.keycache,a=e.valuecache;for(var s in r.properties){var l=r.properties[s],u=o[s];if(l!==null){typeof u>"u"&&(n.push(s),u=n.length-1,o[s]=u),t.writeVarint(u);var c=typeof l;c!=="string"&&c!=="boolean"&&c!=="number"&&(l=JSON.stringify(l));var p=c+":"+l,f=a[p];typeof f>"u"&&(i.push(l),f=i.length-1,a[p]=f),t.writeVarint(f)}}}function fl(e,t){return(t<<3)+(e&7)}function Qf(e){return e<<1^e>>31}function Zb(e,t){for(var r=e.loadGeometry(),n=e.type,i=0,o=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;n===1&&(u=l.length),t.writeVarint(fl(1,u));for(var c=n===3?l.length-1:l.length,p=0;p<c;p++){p===1&&n!==1&&t.writeVarint(fl(2,c-1));var f=l[p].x-i,y=l[p].y-o;t.writeVarint(Qf(f)),t.writeVarint(Qf(y)),i+=f,o+=y}n===3&&t.writeVarint(fl(7,1))}}function Wb(e,t){var r=typeof e;r==="string"?t.writeStringField(1,e):r==="boolean"?t.writeBooleanField(7,e):r==="number"&&(e%1!==0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e))}});var _y=Z(he(),1),Ul=Z(zl(),1);var za;function Rl(){return za==null&&(za=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")&&typeof createImageBitmap=="function"),za}var Ii;function Ol(){if(Ii==null&&(Ii=!1,Rl())){let r=new OffscreenCanvas(5,5).getContext("2d",{willReadFrequently:!0});if(r){for(let i=0;i<5*5;i++){let o=i*4;r.fillStyle=`rgb(${o},${o+1},${o+2})`,r.fillRect(i%5,Math.floor(i/5),1,1)}let n=r.getImageData(0,0,5,5).data;for(let i=0;i<5*5*4;i++)if(i%4!==3&&n[i]!==i){Ii=!0;break}}}return Ii||!1}function $l(e){if(e<=0)return 0;if(e>=1)return 1;let t=e*e,r=t*e;return 4*(e<.5?r:3*(e-t)+r-.75)}function Iy(e,t,r,n){let i=new Ul.default(e,t,r,n);return function(o){return i.solve(o)}}var m0=Iy(.25,.1,.25,1);function it(e,t,r){return Math.min(r,Math.max(t,e))}function Gl(e,t,r){let n=r-t,i=((e-t)%n+n)%n+t;return i===t?r:i}function Pe(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}function ql(e){return Math.log(e)/Math.LN2%1===0}function Gr(e,t,r){let n={};for(let i in e)n[i]=t.call(r||this,e[i],i,e);return n}function jl(e,t,r){let n={};for(let i in e)t.call(r||this,e[i],i,e)&&(n[i]=e[i]);return n}function nt(e){return Array.isArray(e)?e.map(nt):typeof e=="object"&&e?Gr(e,nt):e}function Jl(e,t){for(let r=0;r<e.length;r++)if(t.indexOf(e[r])>=0)return!0;return!1}var Nl={};function fe(e){Nl[e]||(typeof console<"u"&&console.warn(e),Nl[e]=!0)}function ot(e,t,r){return(r.y-e.y)*(t.x-e.x)>(t.y-e.y)*(r.x-e.x)}function Zl(e){let t=0;for(let r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}function at(e){return typeof WorkerGlobalScope<"u"&&typeof e<"u"&&e instanceof WorkerGlobalScope}function qr(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap}function Ty(e,t,r,n,i){let o=Math.max(-t,0)*4,l=(Math.max(0,r)-r)*n*4+o,u=n*4,c=Math.max(0,t),p=Math.max(0,r),f=Math.min(e.width,t+n),y=Math.min(e.height,r+i);return{rect:{x:c,y:p,width:f-c,height:y-p},layout:[{offset:l,stride:u}]}}async function Cy(e,t,r,n,i){if(typeof VideoFrame>"u")throw new Error("VideoFrame not supported");let o=new VideoFrame(e,{timestamp:0});try{let a=o==null?void 0:o.format;if(!a||!(a.startsWith("BGR")||a.startsWith("RGB")))throw new Error(`Unrecognized format ${a}`);let s=a.startsWith("BGR"),l=new Uint8ClampedArray(n*i*4);if(await o.copyTo(l,Ty(e,t,r,n,i)),s)for(let u=0;u<l.length;u+=4){let c=l[u];l[u]=l[u+2],l[u+2]=c}return l}finally{o.close()}}var Ur,$r;function ky(e,t,r,n,i){let o=e.width,a=e.height;(!Ur||!$r)&&(Ur=new OffscreenCanvas(o,a),$r=Ur.getContext("2d",{willReadFrequently:!0})),Ur.width=o,Ur.height=a,$r.drawImage(e,0,0,o,a);let s=$r.getImageData(t,r,n,i);return $r.clearRect(0,0,o,a),s.data}async function Wl(e,t,r,n,i){if(Ol())try{return await Cy(e,t,r,n,i)}catch{}return ky(e,t,r,n,i)}function Hl(e,t,r,n){return e.addEventListener(t,r,n),{unsubscribe:()=>{e.removeEventListener(t,r,n)}}}var Dt=class e{constructor(t,r,n){let i=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;let a=new Int32Array(this.arrayBuffer);t=a[0],r=a[1],n=a[2],this.d=r+2*n;for(let u=0;u<this.d*this.d;u++){let c=a[3+u],p=a[3+u+1];i.push(c===p?null:a.subarray(c,p))}let s=a[3+i.length],l=a[3+i.length+1];this.keys=a.subarray(s,l),this.bboxes=a.subarray(l),this.insert=this._insertReadonly}else{this.d=r+2*n;for(let a=0;a<this.d*this.d;a++)i.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=t,this.padding=n,this.scale=r/t,this.uid=0;let o=n/r*t;this.min=-o,this.max=t+o}insert(t,r,n,i,o){this._forEachCell(r,n,i,o,this._insertCell,this.uid++,void 0,void 0),this.keys.push(t),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i),this.bboxes.push(o)}_insertReadonly(){throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")}_insertCell(t,r,n,i,o,a){this.cells[o].push(a)}query(t,r,n,i,o){let a=this.min,s=this.max;if(t<=a&&r<=a&&s<=n&&s<=i&&!o)return Array.prototype.slice.call(this.keys);{let l=[],u={};return this._forEachCell(t,r,n,i,this._queryCell,l,u,o),l}}_queryCell(t,r,n,i,o,a,s,l){let u=this.cells[o];if(u!==null){let c=this.keys,p=this.bboxes;for(let f=0;f<u.length;f++){let y=u[f];if(s[y]===void 0){let m=y*4;(l?l(p[m+0],p[m+1],p[m+2],p[m+3]):t<=p[m+2]&&r<=p[m+3]&&n>=p[m+0]&&i>=p[m+1])?(s[y]=!0,a.push(c[y])):s[y]=!1}}}}_forEachCell(t,r,n,i,o,a,s,l){let u=this._convertToCellCoord(t),c=this._convertToCellCoord(r),p=this._convertToCellCoord(n),f=this._convertToCellCoord(i);for(let y=u;y<=p;y++)for(let m=c;m<=f;m++){let h=this.d*m+y;if(!(l&&!l(this._convertFromCellCoord(y),this._convertFromCellCoord(m),this._convertFromCellCoord(y+1),this._convertFromCellCoord(m+1)))&&o.call(this,t,r,n,i,h,a,s,l))return}}_convertFromCellCoord(t){return(t-this.padding)/this.scale}_convertToCellCoord(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))}toArrayBuffer(){if(this.arrayBuffer)return this.arrayBuffer;let t=this.cells,r=3+this.cells.length+1+1,n=0;for(let a=0;a<this.cells.length;a++)n+=this.cells[a].length;let i=new Int32Array(r+n+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;let o=r;for(let a=0;a<t.length;a++){let s=t[a];i[3+a]=o,i.set(s,o),o+=s.length}return i[3+t.length]=o,i.set(this.keys,o),o+=this.keys.length,i[3+t.length+1]=o,i.set(this.bboxes,o),o+=this.bboxes.length,i.buffer}static serialize(t,r){let n=t.toArrayBuffer();return r&&r.push(n),{buffer:n}}static deserialize(t){return new e(t.buffer)}};var My=8,Ey={version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},sky:{type:"sky"},projection:{type:"projection"},terrain:{type:"terrain"},sources:{required:!0,type:"sources"},sprite:{type:"sprite"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},Fy={"*":{type:"source"}},Ly=["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],Dy={type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Vy={type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},By={type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{},custom:{}},default:"mapbox"},redFactor:{type:"number",default:1},blueFactor:{type:"number",default:1},greenFactor:{type:"number",default:1},baseShift:{type:"number",default:0},volatile:{type:"boolean",default:!1},"*":{type:"*"}},zy={type:{required:!0,type:"enum",values:{geojson:{}}},data:{required:!0,type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},Ry={type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Oy={type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Ny={id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},Uy=["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],$y={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Gy={"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},qy={"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},jy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Jy={"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Zy={"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image",{"!":"icon-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"padding",default:[2],units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},"viewport-glyph":{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-variable-anchor-offset":{type:"variableAnchorOffsetCollection",requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field",{"!":"text-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Wy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Hy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Xy={type:"array",value:"*"},Ky={type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},Yy={type:"enum",values:{Point:{},LineString:{},Polygon:{}}},Qy={type:"array",minimum:0,maximum:24,value:["number","color"],length:2},em={type:"array",value:"*",minimum:1},tm={anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},rm={"sky-color":{type:"color","property-type":"data-constant",default:"#88C6FC",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-ground-blend":{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-fog-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"sky-horizon-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"atmosphere-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},nm={source:{type:"string",required:!0},exaggeration:{type:"number",minimum:0,default:1}},im={type:{type:"enum",default:"mercator",values:{mercator:{},globe:{}}}},om=["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],am={"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},sm={"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},lm={"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},um={"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},cm={"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},pm={"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},fm={"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},ym={"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},mm={duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},hm={"*":{type:"string"}},S={$version:My,$root:Ey,sources:Fy,source:Ly,source_vector:Dy,source_raster:Vy,source_raster_dem:By,source_geojson:zy,source_video:Ry,source_image:Oy,layer:Ny,layout:Uy,layout_background:$y,layout_fill:Gy,layout_circle:qy,layout_heatmap:jy,"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:Jy,layout_symbol:Zy,layout_raster:Wy,layout_hillshade:Hy,filter:Xy,filter_operator:Ky,geometry_type:Yy,function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:Qy,expression:em,light:tm,sky:rm,terrain:nm,projection:im,paint:om,paint_fill:am,"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:sm,paint_circle:lm,paint_heatmap:um,paint_symbol:cm,paint_raster:pm,paint_hillshade:fm,paint_background:ym,transition:mm,"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:hm},dm=["type","source","source-layer","minzoom","maxzoom","filter","layout"];var M=class{constructor(t,r,n,i){this.message=(t?`${t}: `:"")+n,i&&(this.identifier=i),r!=null&&r.__line__&&(this.line=r.__line__)}};function cr(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}var Be=class extends Error{constructor(t,r){super(r),this.message=r,this.key=t}},Ja=class e{constructor(t,r=[]){this.parent=t,this.bindings={};for(let[n,i]of r)this.bindings[n]=i}concat(t){return new e(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(`${t} not found in scope.`)}has(t){return this.bindings[t]?!0:this.parent?this.parent.has(t):!1}},yr={kind:"null"},L={kind:"number"},G={kind:"string"},U={kind:"boolean"},Re={kind:"color"},lr={kind:"object"},$={kind:"value"},gm={kind:"error"},ji={kind:"collator"},mr={kind:"formatted"},Ji={kind:"padding"},un={kind:"resolvedImage"},Zi={kind:"variableAnchorOffsetCollection"};function Ee(e,t){return{kind:"array",itemType:e,N:t}}function te(e){if(e.kind==="array"){let t=te(e.itemType);return typeof e.N=="number"?`array<${t}, ${e.N}>`:e.itemType.kind==="value"?"array":`array<${t}>`}else return e.kind}var xm=[yr,L,G,U,Re,mr,lr,Ee($),Ji,un,Zi];function Hr(e,t){if(t.kind==="error")return null;if(e.kind==="array"){if(t.kind==="array"&&(t.N===0&&t.itemType.kind==="value"||!Hr(e.itemType,t.itemType))&&(typeof e.N!="number"||e.N===t.N))return null}else{if(e.kind===t.kind)return null;if(e.kind==="value"){for(let r of xm)if(!Hr(r,t))return null}}return`Expected ${te(e)} but found ${te(t)} instead.`}function us(e,t){return t.some(r=>r.kind===e.kind)}function Xr(e,t){return t.some(r=>r==="null"?e===null:r==="array"?Array.isArray(e):r==="object"?e&&!Array.isArray(e)&&typeof e=="object":r===typeof e)}function jr(e,t){return e.kind==="array"&&t.kind==="array"?e.itemType.kind===t.itemType.kind&&typeof e.N=="number":e.kind===t.kind}var du=.96422,gu=1,xu=.82521,bu=4/29,ur=6/29,vu=3*ur*ur,bm=ur*ur*ur,vm=Math.PI/180,Pm=180/Math.PI;function Pu(e){return e=e%360,e<0&&(e+=360),e}function Su([e,t,r,n]){e=Ra(e),t=Ra(t),r=Ra(r);let i,o,a=Oa((.2225045*e+.7168786*t+.0606169*r)/gu);e===t&&t===r?i=o=a:(i=Oa((.4360747*e+.3850649*t+.1430804*r)/du),o=Oa((.0139322*e+.0971045*t+.7141733*r)/xu));let s=116*a-16;return[s<0?0:s,500*(i-a),200*(a-o),n]}function Ra(e){return e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4)}function Oa(e){return e>bm?Math.pow(e,1/3):e/vu+bu}function wu([e,t,r,n]){let i=(e+16)/116,o=isNaN(t)?i:i+t/500,a=isNaN(r)?i:i-r/200;return i=gu*Ua(i),o=du*Ua(o),a=xu*Ua(a),[Na(3.1338561*o-1.6168667*i-.4906146*a),Na(-.9787684*o+1.9161415*i+.033454*a),Na(.0719453*o-.2289914*i+1.4052427*a),n]}function Na(e){return e=e<=.00304?12.92*e:1.055*Math.pow(e,1/2.4)-.055,e<0?0:e>1?1:e}function Ua(e){return e>ur?e*e*e:vu*(e-bu)}function Sm(e){let[t,r,n,i]=Su(e),o=Math.sqrt(r*r+n*n);return[Math.round(o*1e4)?Pu(Math.atan2(n,r)*Pm):NaN,o,t,i]}function wm([e,t,r,n]){return e=isNaN(e)?0:e*vm,wu([r,Math.cos(e)*t,Math.sin(e)*t,n])}function Am([e,t,r,n]){e=Pu(e),t/=100,r/=100;function i(o){let a=(o+e/30)%12,s=t*Math.min(r,1-r);return r-s*Math.max(-1,Math.min(a-3,9-a,1))}return[i(0),i(8),i(4),n]}function _m(e){if(e=e.toLowerCase().trim(),e==="transparent")return[0,0,0,0];let t=Im[e];if(t){let[i,o,a]=t;return[i/255,o/255,a/255,1]}if(e.startsWith("#")&&/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)){let o=e.length<6?1:2,a=1;return[Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+=o)),Ti(e.slice(a,a+o)||"ff")]}if(e.startsWith("rgb")){let i=/^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,o=e.match(i);if(o){let[a,s,l,u,c,p,f,y,m,h,d,g]=o,b=[u||" ",f||" ",h].join("");if(b==="  "||b==="  /"||b===",,"||b===",,,"){let x=[l,p,m].join(""),v=x==="%%%"?100:x===""?255:0;if(v){let P=[ar(+s/v,0,1),ar(+c/v,0,1),ar(+y/v,0,1),d?Xl(+d,g):1];if(Kl(P))return P}}return}}let r=/^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,n=e.match(r);if(n){let[i,o,a,s,l,u,c,p,f]=n,y=[a||" ",l||" ",c].join("");if(y==="  "||y==="  /"||y===",,"||y===",,,"){let m=[+o,ar(+s,0,100),ar(+u,0,100),p?Xl(+p,f):1];if(Kl(m))return Am(m)}}}function Ti(e){return parseInt(e.padEnd(2,e),16)/255}function Xl(e,t){return ar(t?e/100:e,0,1)}function ar(e,t,r){return Math.min(Math.max(t,e),r)}function Kl(e){return!e.some(Number.isNaN)}var Im={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},W=class e{constructor(t,r,n,i=1,o=!0){this.r=t,this.g=r,this.b=n,this.a=i,o||(this.r*=i,this.g*=i,this.b*=i,i||this.overwriteGetter("rgb",[t,r,n,i]))}static parse(t){if(t instanceof e)return t;if(typeof t!="string")return;let r=_m(t);if(r)return new e(...r,!1)}get rgb(){let{r:t,g:r,b:n,a:i}=this,o=i||1/0;return this.overwriteGetter("rgb",[t/o,r/o,n/o,i])}get hcl(){return this.overwriteGetter("hcl",Sm(this.rgb))}get lab(){return this.overwriteGetter("lab",Su(this.rgb))}overwriteGetter(t,r){return Object.defineProperty(this,t,{value:r}),r}toString(){let[t,r,n,i]=this.rgb;return`rgba(${[t,r,n].map(o=>Math.round(o*255)).join(",")},${i})`}};W.black=new W(0,0,0,1);W.white=new W(1,1,1,1);W.transparent=new W(0,0,0,0);W.red=new W(1,0,0,1);var Kr=class{constructor(t,r,n){t?this.sensitivity=r?"variant":"case":this.sensitivity=r?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(t,r){return this.collator.compare(t,r)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}},Yr=class{constructor(t,r,n,i,o){this.text=t,this.image=r,this.scale=n,this.fontStack=i,this.textColor=o}},Fe=class e{constructor(t){this.sections=t}static fromString(t){return new e([new Yr(t,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(t=>t.text.length!==0||t.image&&t.image.name.length!==0)}static factory(t){return t instanceof e?t:e.fromString(t)}toString(){return this.sections.length===0?"":this.sections.map(t=>t.text).join("")}},Ze=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(typeof t=="number")return new e([t,t,t,t]);if(Array.isArray(t)&&!(t.length<1||t.length>4)){for(let r of t)if(typeof r!="number")return;switch(t.length){case 1:t=[t[0],t[0],t[0],t[0]];break;case 2:t=[t[0],t[1],t[0],t[1]];break;case 3:t=[t[0],t[1],t[2],t[1]];break}return new e(t)}}toString(){return JSON.stringify(this.values)}},Tm=new Set(["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"]),Ne=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(!(!Array.isArray(t)||t.length<1||t.length%2!==0)){for(let r=0;r<t.length;r+=2){let n=t[r],i=t[r+1];if(typeof n!="string"||!Tm.has(n)||!Array.isArray(i)||i.length!==2||typeof i[0]!="number"||typeof i[1]!="number")return}return new e(t)}}toString(){return JSON.stringify(this.values)}},Te=class e{constructor(t){this.name=t.name,this.available=t.available}toString(){return this.name}static fromString(t){return t?new e({name:t,available:!1}):null}};function Au(e,t,r,n){return typeof e=="number"&&e>=0&&e<=255&&typeof t=="number"&&t>=0&&t<=255&&typeof r=="number"&&r>=0&&r<=255?typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:`Invalid rgba value [${[e,t,r,n].join(", ")}]: \'a\' must be between 0 and 1.`:`Invalid rgba value [${(typeof n=="number"?[e,t,r,n]:[e,t,r]).join(", ")}]: \'r\', \'g\', and \'b\' must be between 0 and 255.`}function Qr(e){if(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number"||e instanceof W||e instanceof Kr||e instanceof Fe||e instanceof Ze||e instanceof Ne||e instanceof Te)return!0;if(Array.isArray(e)){for(let t of e)if(!Qr(t))return!1;return!0}else if(typeof e=="object"){for(let t in e)if(!Qr(e[t]))return!1;return!0}else return!1}function ue(e){if(e===null)return yr;if(typeof e=="string")return G;if(typeof e=="boolean")return U;if(typeof e=="number")return L;if(e instanceof W)return Re;if(e instanceof Kr)return ji;if(e instanceof Fe)return mr;if(e instanceof Ze)return Ji;if(e instanceof Ne)return Zi;if(e instanceof Te)return un;if(Array.isArray(e)){let t=e.length,r;for(let n of e){let i=ue(n);if(!r)r=i;else{if(r===i)continue;r=$;break}}return Ee(r||$,t)}else return lr}function Zr(e){let t=typeof e;return e===null?"":t==="string"||t==="number"||t==="boolean"?String(e):e instanceof W||e instanceof Fe||e instanceof Ze||e instanceof Ne||e instanceof Te?e.toString():JSON.stringify(e)}var mt=class e{constructor(t,r){this.type=t,this.value=r}static parse(t,r){if(t.length!==2)return r.error(`\'literal\' expression requires exactly one argument, but found ${t.length-1} instead.`);if(!Qr(t[1]))return r.error("invalid value");let n=t[1],i=ue(n),o=r.expectedType;return i.kind==="array"&&i.N===0&&o&&o.kind==="array"&&(typeof o.N!="number"||o.N===0)&&(i=o),new e(i,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}},ie=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t}toJSON(){return this.message}},Ci={string:G,number:L,boolean:U,object:lr},je=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=1,i,o=t[0];if(o==="array"){let s;if(t.length>2){let u=t[1];if(typeof u!="string"||!(u in Ci)||u==="object")return r.error(\'The item type argument of "array" must be one of string, number, boolean\',1);s=Ci[u],n++}else s=$;let l;if(t.length>3){if(t[2]!==null&&(typeof t[2]!="number"||t[2]<0||t[2]!==Math.floor(t[2])))return r.error(\'The length argument to "array" must be a positive integer literal\',2);l=t[2],n++}i=Ee(s,l)}else{if(!Ci[o])throw new Error(`Types doesn\'t contain name = ${o}`);i=Ci[o]}let a=[];for(;n<t.length;n++){let s=r.parse(t[n],n,$);if(!s)return null;a.push(s)}return new e(i,a)}evaluate(t){for(let r=0;r<this.args.length;r++){let n=this.args[r].evaluate(t);if(Hr(this.type,ue(n))){if(r===this.args.length-1)throw new ie(`Expected value to be of type ${te(this.type)}, but found ${te(ue(n))} instead.`)}else return n}throw new Error}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Yl={"to-boolean":U,"to-color":Re,"to-number":L,"to-string":G},yt=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[0];if(!Yl[n])throw new Error(`Can\'t parse ${n} as it is not part of the known types`);if((n==="to-boolean"||n==="to-string")&&t.length!==2)return r.error("Expected one argument.");let i=Yl[n],o=[];for(let a=1;a<t.length;a++){let s=r.parse(t[a],a,$);if(!s)return null;o.push(s)}return new e(i,o)}evaluate(t){switch(this.type.kind){case"boolean":return!!this.args[0].evaluate(t);case"color":{let r,n;for(let i of this.args){if(r=i.evaluate(t),n=null,r instanceof W)return r;if(typeof r=="string"){let o=t.parseColor(r);if(o)return o}else if(Array.isArray(r)&&(r.length<3||r.length>4?n=`Invalid rbga value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.`:n=Au(r[0],r[1],r[2],r[3]),!n))return new W(r[0]/255,r[1]/255,r[2]/255,r[3])}throw new ie(n||`Could not parse color from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"padding":{let r;for(let n of this.args){r=n.evaluate(t);let i=Ze.parse(r);if(i)return i}throw new ie(`Could not parse padding from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"variableAnchorOffsetCollection":{let r;for(let n of this.args){r=n.evaluate(t);let i=Ne.parse(r);if(i)return i}throw new ie(`Could not parse variableAnchorOffsetCollection from value \'${typeof r=="string"?r:JSON.stringify(r)}\'`)}case"number":{let r=null;for(let n of this.args){if(r=n.evaluate(t),r===null)return 0;let i=Number(r);if(!isNaN(i))return i}throw new ie(`Could not convert ${JSON.stringify(r)} to number.`)}case"formatted":return Fe.fromString(Zr(this.args[0].evaluate(t)));case"resolvedImage":return Te.fromString(Zr(this.args[0].evaluate(t)));default:return Zr(this.args[0].evaluate(t))}}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Cm=["Unknown","Point","LineString","Polygon"],Fi=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Cm[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(t){let r=this._parseColorCache[t];return r||(r=this._parseColorCache[t]=W.parse(t)),r}},Li=class e{constructor(t,r,n=[],i,o=new Ja,a=[]){this.registry=t,this.path=n,this.key=n.map(s=>`[${s}]`).join(""),this.scope=o,this.errors=a,this.expectedType=i,this._isConstant=r}parse(t,r,n,i,o={}){return r?this.concat(r,n,i)._parse(t,o):this._parse(t,o)}_parse(t,r){(t===null||typeof t=="string"||typeof t=="boolean"||typeof t=="number")&&(t=["literal",t]);function n(i,o,a){return a==="assert"?new je(o,[i]):a==="coerce"?new yt(o,[i]):i}if(Array.isArray(t)){if(t.length===0)return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');let i=t[0];if(typeof i!="string")return this.error(`Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;let o=this.registry[i];if(o){let a=o.parse(t,this);if(!a)return null;if(this.expectedType){let s=this.expectedType,l=a.type;if((s.kind==="string"||s.kind==="number"||s.kind==="boolean"||s.kind==="object"||s.kind==="array")&&l.kind==="value")a=n(a,s,r.typeAnnotation||"assert");else if((s.kind==="color"||s.kind==="formatted"||s.kind==="resolvedImage")&&(l.kind==="value"||l.kind==="string"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="padding"&&(l.kind==="value"||l.kind==="number"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="variableAnchorOffsetCollection"&&(l.kind==="value"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(this.checkSubtype(s,l))return null}if(!(a instanceof mt)&&a.type.kind!=="resolvedImage"&&this._isConstant(a)){let s=new Fi;try{a=new mt(a.type,a.evaluate(s))}catch(l){return this.error(l.message),null}}return a}return this.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,0)}else return typeof t>"u"?this.error("\'undefined\' value invalid. Use null instead."):typeof t=="object"?this.error(\'Bare objects invalid. Use ["literal", {...}] instead.\'):this.error(`Expected an array, but found ${typeof t} instead.`)}concat(t,r,n){let i=typeof t=="number"?this.path.concat(t):this.path,o=n?this.scope.concat(n):this.scope;return new e(this.registry,this._isConstant,i,r||null,o,this.errors)}error(t,...r){let n=`${this.key}${r.map(i=>`[${i}]`).join("")}`;this.errors.push(new Be(n,t))}checkSubtype(t,r){let n=Hr(t,r);return n&&this.error(n),n}},Di=class e{constructor(t,r){this.type=r.type,this.bindings=[].concat(t),this.result=r}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(let r of this.bindings)t(r[1]);t(this.result)}static parse(t,r){if(t.length<4)return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);let n=[];for(let o=1;o<t.length-1;o+=2){let a=t[o];if(typeof a!="string")return r.error(`Expected string, but found ${typeof a} instead.`,o);if(/[^a-zA-Z0-9_]/.test(a))return r.error("Variable names must contain only alphanumeric characters or \'_\'.",o);let s=r.parse(t[o+1],o+1);if(!s)return null;n.push([a,s])}let i=r.parse(t[t.length-1],t.length-1,r.expectedType,n);return i?new e(n,i):null}outputDefined(){return this.result.outputDefined()}},Vi=class e{constructor(t,r){this.type=r.type,this.name=t,this.boundExpression=r}static parse(t,r){if(t.length!==2||typeof t[1]!="string")return r.error("\'var\' expression requires exactly one string literal argument.");let n=t[1];return r.scope.has(n)?new e(n,r.scope.get(n)):r.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return!1}},Za=class e{constructor(t,r,n){this.type=t,this.index=r,this.input=n}static parse(t,r){if(t.length!==3)return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);let n=r.parse(t[1],1,L),i=r.parse(t[2],2,Ee(r.expectedType||$));if(!n||!i)return null;let o=i.type;return new e(o.itemType,n,i)}evaluate(t){let r=this.index.evaluate(t),n=this.input.evaluate(t);if(r<0)throw new ie(`Array index out of bounds: ${r} < 0.`);if(r>=n.length)throw new ie(`Array index out of bounds: ${r} > ${n.length-1}.`);if(r!==Math.floor(r))throw new ie(`Array index must be an integer, but found ${r} instead.`);return n[r]}eachChild(t){t(this.index),t(this.input)}outputDefined(){return!1}},Wa=class e{constructor(t,r){this.type=U,this.needle=t,this.haystack=r}static parse(t,r){if(t.length!==3)return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);return!n||!i?null:us(n.type,[U,G,L,yr,$])?new e(n,i):r.error(`Expected first argument to be of type boolean, string, number or null, but found ${te(n.type)} instead`)}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!n)return!1;if(!Xr(r,["boolean","string","number","null"]))throw new ie(`Expected first argument to be of type boolean, string, number or null, but found ${te(ue(r))} instead.`);if(!Xr(n,["string","array"]))throw new ie(`Expected second argument to be of type array or string, but found ${te(ue(n))} instead.`);return n.indexOf(r)>=0}eachChild(t){t(this.needle),t(this.haystack)}outputDefined(){return!0}},Ha=class e{constructor(t,r,n){this.type=L,this.needle=t,this.haystack=r,this.fromIndex=n}static parse(t,r){if(t.length<=2||t.length>=5)return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);if(!n||!i)return null;if(!us(n.type,[U,G,L,yr,$]))return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${te(n.type)} instead`);if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n,i,o):null}else return new e(n,i)}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!Xr(r,["boolean","string","number","null"]))throw new ie(`Expected first argument to be of type boolean, string, number or null, but found ${te(ue(r))} instead.`);if(!Xr(n,["string","array"]))throw new ie(`Expected second argument to be of type array or string, but found ${te(ue(n))} instead.`);if(this.fromIndex){let i=this.fromIndex.evaluate(t);return n.indexOf(r,i)}return n.indexOf(r)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex)}outputDefined(){return!1}},Xa=class e{constructor(t,r,n,i,o,a){this.inputType=t,this.type=r,this.input=n,this.cases=i,this.outputs=o,this.otherwise=a}static parse(t,r){if(t.length<5)return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if(t.length%2!==1)return r.error("Expected an even number of arguments.");let n,i;r.expectedType&&r.expectedType.kind!=="value"&&(i=r.expectedType);let o={},a=[];for(let u=2;u<t.length-1;u+=2){let c=t[u],p=t[u+1];Array.isArray(c)||(c=[c]);let f=r.concat(u);if(c.length===0)return f.error("Expected at least one branch label.");for(let m of c){if(typeof m!="number"&&typeof m!="string")return f.error("Branch labels must be numbers or strings.");if(typeof m=="number"&&Math.abs(m)>Number.MAX_SAFE_INTEGER)return f.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if(typeof m=="number"&&Math.floor(m)!==m)return f.error("Numeric branch labels must be integer values.");if(!n)n=ue(m);else if(f.checkSubtype(n,ue(m)))return null;if(typeof o[String(m)]<"u")return f.error("Branch labels must be unique.");o[String(m)]=a.length}let y=r.parse(p,u,i);if(!y)return null;i=i||y.type,a.push(y)}let s=r.parse(t[1],1,$);if(!s)return null;let l=r.parse(t[t.length-1],t.length-1,i);return!l||s.type.kind!=="value"&&r.concat(1).checkSubtype(n,s.type)?null:new e(n,i,s,o,a,l)}evaluate(t){let r=this.input.evaluate(t);return(ue(r)===this.inputType&&this.outputs[this.cases[r]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise)}outputDefined(){return this.outputs.every(t=>t.outputDefined())&&this.otherwise.outputDefined()}},Ka=class e{constructor(t,r,n){this.type=t,this.branches=r,this.otherwise=n}static parse(t,r){if(t.length<4)return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);if(t.length%2!==0)return r.error("Expected an odd number of arguments.");let n;r.expectedType&&r.expectedType.kind!=="value"&&(n=r.expectedType);let i=[];for(let a=1;a<t.length-1;a+=2){let s=r.parse(t[a],a,U);if(!s)return null;let l=r.parse(t[a+1],a+1,n);if(!l)return null;i.push([s,l]),n=n||l.type}let o=r.parse(t[t.length-1],t.length-1,n);if(!o)return null;if(!n)throw new Error("Can\'t infer output type");return new e(n,i,o)}evaluate(t){for(let[r,n]of this.branches)if(r.evaluate(t))return n.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(let[r,n]of this.branches)t(r),t(n);t(this.otherwise)}outputDefined(){return this.branches.every(([t,r])=>r.outputDefined())&&this.otherwise.outputDefined()}},Ya=class e{constructor(t,r,n,i){this.type=t,this.input=r,this.beginIndex=n,this.endIndex=i}static parse(t,r){if(t.length<=2||t.length>=5)return r.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);let n=r.parse(t[1],1,$),i=r.parse(t[2],2,L);if(!n||!i)return null;if(!us(n.type,[Ee($),G,$]))return r.error(`Expected first argument to be of type array or string, but found ${te(n.type)} instead`);if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n.type,n,i,o):null}else return new e(n.type,n,i)}evaluate(t){let r=this.input.evaluate(t),n=this.beginIndex.evaluate(t);if(!Xr(r,["string","array"]))throw new ie(`Expected first argument to be of type array or string, but found ${te(ue(r))} instead.`);if(this.endIndex){let i=this.endIndex.evaluate(t);return r.slice(n,i)}return r.slice(n)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex)}outputDefined(){return!1}};function Wi(e,t){let r=e.length-1,n=0,i=r,o=0,a,s;for(;n<=i;)if(o=Math.floor((n+i)/2),a=e[o],s=e[o+1],a<=t){if(o===r||t<s)return o;n=o+1}else if(a>t)i=o-1;else throw new ie("Input is not a number.");return 0}var pr=class e{constructor(t,r,n){this.type=t,this.input=r,this.labels=[],this.outputs=[];for(let[i,o]of n)this.labels.push(i),this.outputs.push(o)}static parse(t,r){if(t.length-1<4)return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=[],o=null;r.expectedType&&r.expectedType.kind!=="value"&&(o=r.expectedType);for(let a=1;a<t.length;a+=2){let s=a===1?-1/0:t[a],l=t[a+1],u=a,c=a+1;if(typeof s!="number")return r.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',u);if(i.length&&i[i.length-1][0]>=s)return r.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\',u);let p=r.parse(l,c,o);if(!p)return null;o=o||p.type,i.push([s,p])}return new e(o,n,i)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Wi(r,i);return n[a].evaluate(t)}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function km(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Mm=_u;function _u(e,t,r,n){this.cx=3*e,this.bx=3*(r-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*t,this.by=3*(n-t)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=t,this.p2x=r,this.p2y=n}_u.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,t){if(t===void 0&&(t=1e-6),e<0)return 0;if(e>1)return 1;for(var r=e,n=0;n<8;n++){var i=this.sampleCurveX(r)-e;if(Math.abs(i)<t)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=e,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-e)<t));n++)e>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(e,t){return this.sampleCurveY(this.solveCurveX(e,t))}};var Em=km(Mm);function Fm(e){return e==="rgb"||e==="hcl"||e==="lab"}function zt(e,t,r){return e+r*(t-e)}function Lm(e,t,r,n="rgb"){switch(n){case"rgb":{let[i,o,a,s]=Bi(e.rgb,t.rgb,r);return new W(i,o,a,s,!1)}case"hcl":{let[i,o,a,s]=e.hcl,[l,u,c,p]=t.hcl,f,y;if(!isNaN(i)&&!isNaN(l)){let b=l-i;l>i&&b>180?b-=360:l<i&&i-l>180&&(b+=360),f=i+r*b}else isNaN(i)?isNaN(l)?f=NaN:(f=l,(a===1||a===0)&&(y=u)):(f=i,(c===1||c===0)&&(y=o));let[m,h,d,g]=wm([f,y!=null?y:zt(o,u,r),zt(a,c,r),zt(s,p,r)]);return new W(m,h,d,g,!1)}case"lab":{let[i,o,a,s]=wu(Bi(e.lab,t.lab,r));return new W(i,o,a,s,!1)}}}function Bi(e,t,r){return e.map((n,i)=>zt(n,t[i],r))}function Dm(e,t,r){return new Ze(Bi(e.values,t.values,r))}function Vm(e,t,r){let n=e.values,i=t.values;if(n.length!==i.length)throw new ie(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);let o=[];for(let a=0;a<n.length;a+=2){if(n[a]!==i[a])throw new ie(`Cannot interpolate values containing mismatched anchors. from[${a}]: ${n[a]}, to[${a}]: ${i[a]}`);o.push(n[a]);let[s,l]=n[a+1],[u,c]=i[a+1];o.push([zt(s,u,r),zt(l,c,r)])}return new Ne(o)}var Oe={number:zt,color:Lm,array:Bi,padding:Dm,variableAnchorOffsetCollection:Vm},Je=class e{constructor(t,r,n,i,o){this.type=t,this.operator=r,this.interpolation=n,this.input=i,this.labels=[],this.outputs=[];for(let[a,s]of o)this.labels.push(a),this.outputs.push(s)}static interpolationFactor(t,r,n,i){let o=0;if(t.name==="exponential")o=$a(r,t.base,n,i);else if(t.name==="linear")o=$a(r,1,n,i);else if(t.name==="cubic-bezier"){let a=t.controlPoints;o=new Em(a[0],a[1],a[2],a[3]).solve($a(r,1,n,i))}return o}static parse(t,r){let[n,i,o,...a]=t;if(!Array.isArray(i)||i.length===0)return r.error("Expected an interpolation type expression.",1);if(i[0]==="linear")i={name:"linear"};else if(i[0]==="exponential"){let u=i[1];if(typeof u!="number")return r.error("Exponential interpolation requires a numeric base.",1,1);i={name:"exponential",base:u}}else if(i[0]==="cubic-bezier"){let u=i.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);i={name:"cubic-bezier",controlPoints:u}}else return r.error(`Unknown interpolation type ${String(i[0])}`,1,0);if(t.length-1<4)return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");if(o=r.parse(o,2,L),!o)return null;let s=[],l=null;n==="interpolate-hcl"||n==="interpolate-lab"?l=Re:r.expectedType&&r.expectedType.kind!=="value"&&(l=r.expectedType);for(let u=0;u<a.length;u+=2){let c=a[u],p=a[u+1],f=u+3,y=u+4;if(typeof c!="number")return r.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',f);if(s.length&&s[s.length-1][0]>=c)return r.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\',f);let m=r.parse(p,y,l);if(!m)return null;l=l||m.type,s.push([c,m])}return!jr(l,L)&&!jr(l,Re)&&!jr(l,Ji)&&!jr(l,Zi)&&!jr(l,Ee(L))?r.error(`Type ${te(l)} is not interpolatable.`):new e(l,n,i,o,s)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Wi(r,i),s=r[a],l=r[a+1],u=e.interpolationFactor(this.interpolation,i,s,l),c=n[a].evaluate(t),p=n[a+1].evaluate(t);switch(this.operator){case"interpolate":return Oe[this.type.kind](c,p,u);case"interpolate-hcl":return Oe.color(c,p,u,"hcl");case"interpolate-lab":return Oe.color(c,p,u,"lab")}}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function $a(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var zi=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expectected at least one argument.");let n=null,i=r.expectedType;i&&i.kind!=="value"&&(n=i);let o=[];for(let s of t.slice(1)){let l=r.parse(s,1+o.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,o.push(l)}if(!n)throw new Error("No output type");return i&&o.some(s=>Hr(i,s.type))?new e($,o):new e(n,o)}evaluate(t){let r=null,n=0,i;for(let o of this.args)if(n++,r=o.evaluate(t),r&&r instanceof Te&&!r.available&&(i||(i=r.name),r=null,n===this.args.length&&(r=i)),r!==null)break;return r}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}};function Ql(e,t){return e==="=="||e==="!="?t.kind==="boolean"||t.kind==="string"||t.kind==="number"||t.kind==="null"||t.kind==="value":t.kind==="string"||t.kind==="number"||t.kind==="value"}function Bm(e,t,r){return t===r}function zm(e,t,r){return t!==r}function Rm(e,t,r){return t<r}function Om(e,t,r){return t>r}function Nm(e,t,r){return t<=r}function Um(e,t,r){return t>=r}function Iu(e,t,r,n){return n.compare(t,r)===0}function $m(e,t,r,n){return!Iu(e,t,r,n)}function Gm(e,t,r,n){return n.compare(t,r)<0}function qm(e,t,r,n){return n.compare(t,r)>0}function jm(e,t,r,n){return n.compare(t,r)<=0}function Jm(e,t,r,n){return n.compare(t,r)>=0}function hr(e,t,r){let n=e!=="=="&&e!=="!=";return class Tu{constructor(o,a,s){this.type=U,this.lhs=o,this.rhs=a,this.collator=s,this.hasUntypedArgument=o.type.kind==="value"||a.type.kind==="value"}static parse(o,a){if(o.length!==3&&o.length!==4)return a.error("Expected two or three arguments.");let s=o[0],l=a.parse(o[1],1,$);if(!l)return null;if(!Ql(s,l.type))return a.concat(1).error(`"${s}" comparisons are not supported for type \'${te(l.type)}\'.`);let u=a.parse(o[2],2,$);if(!u)return null;if(!Ql(s,u.type))return a.concat(2).error(`"${s}" comparisons are not supported for type \'${te(u.type)}\'.`);if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error(`Cannot compare types \'${te(l.type)}\' and \'${te(u.type)}\'.`);n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new je(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new je(l.type,[u])));let c=null;if(o.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot use collator to compare non-string types.");if(c=a.parse(o[3],3,ji),!c)return null}return new Tu(l,u,c)}evaluate(o){let a=this.lhs.evaluate(o),s=this.rhs.evaluate(o);if(n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new ie(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`)}if(this.collator&&!n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!=="string"||u.kind!=="string")return t(o,a,s)}return this.collator?r(o,a,s,this.collator.evaluate(o)):t(o,a,s)}eachChild(o){o(this.lhs),o(this.rhs),this.collator&&o(this.collator)}outputDefined(){return!0}}}var Zm=hr("==",Bm,Iu),Wm=hr("!=",zm,$m),Hm=hr("<",Rm,Gm),Xm=hr(">",Om,qm),Km=hr("<=",Nm,jm),Ym=hr(">=",Um,Jm),Ri=class e{constructor(t,r,n){this.type=ji,this.locale=n,this.caseSensitive=t,this.diacriticSensitive=r}static parse(t,r){if(t.length!==2)return r.error("Expected one argument.");let n=t[1];if(typeof n!="object"||Array.isArray(n))return r.error("Collator options argument must be an object.");let i=r.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,U);if(!i)return null;let o=r.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,U);if(!o)return null;let a=null;return n.locale&&(a=r.parse(n.locale,1,G),!a)?null:new e(i,o,a)}evaluate(t){return new Kr(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale)}outputDefined(){return!1}},Qa=class e{constructor(t,r,n,i,o){this.type=G,this.number=t,this.locale=r,this.currency=n,this.minFractionDigits=i,this.maxFractionDigits=o}static parse(t,r){if(t.length!==3)return r.error("Expected two arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=t[2];if(typeof i!="object"||Array.isArray(i))return r.error("NumberFormat options argument must be an object.");let o=null;if(i.locale&&(o=r.parse(i.locale,1,G),!o))return null;let a=null;if(i.currency&&(a=r.parse(i.currency,1,G),!a))return null;let s=null;if(i["min-fraction-digits"]&&(s=r.parse(i["min-fraction-digits"],1,L),!s))return null;let l=null;return i["max-fraction-digits"]&&(l=r.parse(i["max-fraction-digits"],1,L),!l)?null:new e(n,o,a,s,l)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits)}outputDefined(){return!1}},en=class e{constructor(t){this.type=mr,this.sections=t}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[1];if(!Array.isArray(n)&&typeof n=="object")return r.error("First argument must be an image or text section.");let i=[],o=!1;for(let a=1;a<=t.length-1;++a){let s=t[a];if(o&&typeof s=="object"&&!Array.isArray(s)){o=!1;let l=null;if(s["font-scale"]&&(l=r.parse(s["font-scale"],1,L),!l))return null;let u=null;if(s["text-font"]&&(u=r.parse(s["text-font"],1,Ee(G)),!u))return null;let c=null;if(s["text-color"]&&(c=r.parse(s["text-color"],1,Re),!c))return null;let p=i[i.length-1];p.scale=l,p.font=u,p.textColor=c}else{let l=r.parse(t[a],1,$);if(!l)return null;let u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return r.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");o=!0,i.push({content:l,scale:null,font:null,textColor:null})}}return new e(i)}evaluate(t){let r=n=>{let i=n.content.evaluate(t);return ue(i)===un?new Yr("",i,null,null,null):new Yr(Zr(i),null,n.scale?n.scale.evaluate(t):null,n.font?n.font.evaluate(t).join(","):null,n.textColor?n.textColor.evaluate(t):null)};return new Fe(this.sections.map(r))}eachChild(t){for(let r of this.sections)t(r.content),r.scale&&t(r.scale),r.font&&t(r.font),r.textColor&&t(r.textColor)}outputDefined(){return!1}},es=class e{constructor(t){this.type=un,this.input=t}static parse(t,r){if(t.length!==2)return r.error("Expected two arguments.");let n=r.parse(t[1],1,G);return n?new e(n):r.error("No image name provided.")}evaluate(t){let r=this.input.evaluate(t),n=Te.fromString(r);return n&&t.availableImages&&(n.available=t.availableImages.indexOf(r)>-1),n}eachChild(t){t(this.input)}outputDefined(){return!1}},ts=class e{constructor(t){this.type=L,this.input=t}static parse(t,r){if(t.length!==2)return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);let n=r.parse(t[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?r.error(`Expected argument of type string or array, but found ${te(n.type)} instead.`):new e(n):null}evaluate(t){let r=this.input.evaluate(t);if(typeof r=="string")return r.length;if(Array.isArray(r))return r.length;throw new ie(`Expected value to be of type string or array, but found ${te(ue(r))} instead.`)}eachChild(t){t(this.input)}outputDefined(){return!1}},Xe=8192;function Qm(e,t){let r=eh(e[0]),n=rh(e[1]),i=Math.pow(2,t.z);return[Math.round(r*i*Xe),Math.round(n*i*Xe)]}function cs(e,t){let r=Math.pow(2,t.z),n=(e[0]/Xe+t.x)/r,i=(e[1]/Xe+t.y)/r;return[th(n),nh(i)]}function eh(e){return(180+e)/360}function th(e){return e*360-180}function rh(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function nh(e){return 360/Math.PI*Math.atan(Math.exp((180-e*360)*Math.PI/180))-90}function cn(e,t){e[0]=Math.min(e[0],t[0]),e[1]=Math.min(e[1],t[1]),e[2]=Math.max(e[2],t[0]),e[3]=Math.max(e[3],t[1])}function tn(e,t){return!(e[0]<=t[0]||e[2]>=t[2]||e[1]<=t[1]||e[3]>=t[3])}function ih(e,t,r){return t[1]>e[1]!=r[1]>e[1]&&e[0]<(r[0]-t[0])*(e[1]-t[1])/(r[1]-t[1])+t[0]}function oh(e,t,r){let n=e[0]-t[0],i=e[1]-t[1],o=e[0]-r[0],a=e[1]-r[1];return n*a-o*i===0&&n*o<=0&&i*a<=0}function Hi(e,t,r,n){let i=[t[0]-e[0],t[1]-e[1]],o=[n[0]-r[0],n[1]-r[1]];return uh(o,i)===0?!1:!!(eu(e,t,r,n)&&eu(r,n,e,t))}function ah(e,t,r){for(let n of r)for(let i=0;i<n.length-1;++i)if(Hi(e,t,n[i],n[i+1]))return!0;return!1}function dr(e,t,r=!1){let n=!1;for(let i of t)for(let o=0;o<i.length-1;o++){if(oh(e,i[o],i[o+1]))return r;ih(e,i[o],i[o+1])&&(n=!n)}return n}function sh(e,t){for(let r of t)if(dr(e,r))return!0;return!1}function Cu(e,t){for(let r of e)if(!dr(r,t))return!1;for(let r=0;r<e.length-1;++r)if(ah(e[r],e[r+1],t))return!1;return!0}function lh(e,t){for(let r of t)if(Cu(e,r))return!0;return!1}function uh(e,t){return e[0]*t[1]-e[1]*t[0]}function eu(e,t,r,n){let i=e[0]-r[0],o=e[1]-r[1],a=t[0]-r[0],s=t[1]-r[1],l=n[0]-r[0],u=n[1]-r[1],c=i*u-l*o,p=a*u-l*s;return c>0&&p<0||c<0&&p>0}function ps(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=[];for(let a=0;a<e[i].length;a++){let s=Qm(e[i][a],r);cn(t,s),o.push(s)}n.push(o)}return n}function ku(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=ps(e[i],t,r);n.push(o)}return n}function Mu(e,t,r,n){if(e[0]<r[0]||e[0]>r[2]){let i=n*.5,o=e[0]-r[0]>i?-n:r[0]-e[0]>i?n:0;o===0&&(o=e[0]-r[2]>i?-n:r[2]-e[0]>i?n:0),e[0]+=o}cn(t,e)}function ch(e){e[0]=e[1]=1/0,e[2]=e[3]=-1/0}function tu(e,t,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of e)for(let l of s){let u=[l.x+o[0],l.y+o[1]];Mu(u,t,r,i),a.push(u)}return a}function ru(e,t,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of e){let l=[];for(let u of s){let c=[u.x+o[0],u.y+o[1]];cn(t,c),l.push(c)}a.push(l)}if(t[2]-t[0]<=i/2){ch(t);for(let s of a)for(let l of s)Mu(l,t,r,i)}return a}function ph(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=ps(t.coordinates,n,i),a=tu(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!dr(s,o))return!1}if(t.type==="MultiPolygon"){let o=ku(t.coordinates,n,i),a=tu(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!sh(s,o))return!1}return!0}function fh(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=ps(t.coordinates,n,i),a=ru(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!Cu(s,o))return!1}if(t.type==="MultiPolygon"){let o=ku(t.coordinates,n,i),a=ru(e.geometry(),r,n,i);if(!tn(r,n))return!1;for(let s of a)if(!lh(s,o))return!1}return!0}var rn=class e{constructor(t,r){this.type=U,this.geojson=t,this.geometries=r}static parse(t,r){if(t.length!==2)return r.error(`\'within\' expression requires exactly one argument, but found ${t.length-1} instead.`);if(Qr(t[1])){let n=t[1];if(n.type==="FeatureCollection"){let i=[];for(let o of n.features){let{type:a,coordinates:s}=o.geometry;a==="Polygon"&&i.push(s),a==="MultiPolygon"&&i.push(...s)}if(i.length){let o={type:"MultiPolygon",coordinates:i};return new e(n,o)}}else if(n.type==="Feature"){let i=n.geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new e(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new e(n,n)}return r.error("\'within\' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(t.geometry()!=null&&t.canonicalID()!=null){if(t.geometryType()==="Point")return ph(t,this.geometries);if(t.geometryType()==="LineString")return fh(t,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}},Oi=class{constructor(t=[],r=yh){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let t=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),t}peek(){return this.data[0]}_up(t){let{data:r,compare:n}=this,i=r[t];for(;t>0;){let o=t-1>>1,a=r[o];if(n(i,a)>=0)break;r[t]=a,t=o}r[t]=i}_down(t){let{data:r,compare:n}=this,i=this.length>>1,o=r[t];for(;t<i;){let a=(t<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[t]=s,t=a}r[t]=o}};function yh(e,t){return e<t?-1:e>t?1:0}function mh(e,t,r,n,i){Eu(e,t,r,n||e.length-1,i||hh)}function Eu(e,t,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=t-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(t-a*l/o+u)),p=Math.min(n,Math.floor(t+(o-a)*l/o+u));Eu(e,t,c,p,i)}var f=e[t],y=r,m=n;for(Jr(e,r,t),i(e[n],f)>0&&Jr(e,r,n);y<m;){for(Jr(e,y,m),y++,m--;i(e[y],f)<0;)y++;for(;i(e[m],f)>0;)m--}i(e[r],f)===0?Jr(e,r,m):(m++,Jr(e,m,n)),m<=t&&(r=m+1),t<=m&&(n=m-1)}}function Jr(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function hh(e,t){return e<t?-1:e>t?1:0}function dh(e,t){if(e.length<=1)return[e];let n=[],i,o;for(let a of e){let s=xh(a);s!==0&&(a.area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[a]):i.push(a))}if(i&&n.push(i),t>1)for(let a=0;a<n.length;a++)n[a].length<=t||(mh(n[a],t,1,n[a].length-1,gh),n[a]=n[a].slice(0,t));return n}function gh(e,t){return t.area-e.area}function xh(e){let t=0;for(let r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}var bh=6378.137,nu=1/298.257223563,iu=nu*(2-nu),ou=Math.PI/180,nn=class{constructor(t){let r=ou*bh*1e3,n=Math.cos(t*ou),i=1/(1-iu*(1-n*n)),o=Math.sqrt(i);this.kx=r*o*n,this.ky=r*o*i*(1-iu)}distance(t,r){let n=this.wrap(t[0]-r[0])*this.kx,i=(t[1]-r[1])*this.ky;return Math.sqrt(n*n+i*i)}pointOnLine(t,r){let n=1/0,i,o,a,s;for(let l=0;l<t.length-1;l++){let u=t[l][0],c=t[l][1],p=this.wrap(t[l+1][0]-u)*this.kx,f=(t[l+1][1]-c)*this.ky,y=0;(p!==0||f!==0)&&(y=(this.wrap(r[0]-u)*this.kx*p+(r[1]-c)*this.ky*f)/(p*p+f*f),y>1?(u=t[l+1][0],c=t[l+1][1]):y>0&&(u+=p/this.kx*y,c+=f/this.ky*y)),p=this.wrap(r[0]-u)*this.kx,f=(r[1]-c)*this.ky;let m=p*p+f*f;m<n&&(n=m,i=u,o=c,a=l,s=y)}return{point:[i,o],index:a,t:Math.max(0,Math.min(1,s))}}wrap(t){for(;t<-180;)t+=360;for(;t>180;)t-=360;return t}},rs=100,ns=50;function Fu(e,t){return t[0]-e[0]}function Ni(e){return e[1]-e[0]+1}function st(e,t){return e[1]>=e[0]&&e[1]<t}function is(e,t){if(e[0]>e[1])return[null,null];let r=Ni(e);if(t){if(r===2)return[e,null];let i=Math.floor(r/2);return[[e[0],e[0]+i],[e[0]+i,e[1]]]}if(r===1)return[e,null];let n=Math.floor(r/2)-1;return[[e[0],e[0]+n],[e[0]+n+1,e[1]]]}function os(e,t){if(!st(t,e.length))return[1/0,1/0,-1/0,-1/0];let r=[1/0,1/0,-1/0,-1/0];for(let n=t[0];n<=t[1];++n)cn(r,e[n]);return r}function as(e){let t=[1/0,1/0,-1/0,-1/0];for(let r of e)for(let n of r)cn(t,n);return t}function au(e){return e[0]!==-1/0&&e[1]!==-1/0&&e[2]!==1/0&&e[3]!==1/0}function fs(e,t,r){if(!au(e)||!au(t))return NaN;let n=0,i=0;return e[2]<t[0]&&(n=t[0]-e[2]),e[0]>t[2]&&(n=e[0]-t[2]),e[1]>t[3]&&(i=e[1]-t[3]),e[3]<t[1]&&(i=t[1]-e[3]),r.distance([0,0],[n,i])}function Bt(e,t,r){let n=r.pointOnLine(t,e);return r.distance(e,n.point)}function ys(e,t,r,n,i){let o=Math.min(Bt(e,[r,n],i),Bt(t,[r,n],i)),a=Math.min(Bt(r,[e,t],i),Bt(n,[e,t],i));return Math.min(o,a)}function vh(e,t,r,n,i){if(!(st(t,e.length)&&st(n,r.length)))return 1/0;let a=1/0;for(let s=t[0];s<t[1];++s){let l=e[s],u=e[s+1];for(let c=n[0];c<n[1];++c){let p=r[c],f=r[c+1];if(Hi(l,u,p,f))return 0;a=Math.min(a,ys(l,u,p,f,i))}}return a}function Ph(e,t,r,n,i){if(!(st(t,e.length)&&st(n,r.length)))return NaN;let a=1/0;for(let s=t[0];s<=t[1];++s)for(let l=n[0];l<=n[1];++l)if(a=Math.min(a,i.distance(e[s],r[l])),a===0)return a;return a}function Sh(e,t,r){if(dr(e,t,!0))return 0;let n=1/0;for(let i of t){let o=i[0],a=i[i.length-1];if(o!==a&&(n=Math.min(n,Bt(e,[a,o],r)),n===0))return n;let s=r.pointOnLine(i,e);if(n=Math.min(n,r.distance(e,s.point)),n===0)return n}return n}function wh(e,t,r,n){if(!st(t,e.length))return NaN;for(let o=t[0];o<=t[1];++o)if(dr(e[o],r,!0))return 0;let i=1/0;for(let o=t[0];o<t[1];++o){let a=e[o],s=e[o+1];for(let l of r)for(let u=0,c=l.length,p=c-1;u<c;p=u++){let f=l[p],y=l[u];if(Hi(a,s,f,y))return 0;i=Math.min(i,ys(a,s,f,y,n))}}return i}function su(e,t){for(let r of e)for(let n of r)if(dr(n,t,!0))return!0;return!1}function Ah(e,t,r,n=1/0){let i=as(e),o=as(t);if(n!==1/0&&fs(i,o,r)>=n)return n;if(tn(i,o)){if(su(e,t))return 0}else if(su(t,e))return 0;let a=1/0;for(let s of e)for(let l=0,u=s.length,c=u-1;l<u;c=l++){let p=s[c],f=s[l];for(let y of t)for(let m=0,h=y.length,d=h-1;m<h;d=m++){let g=y[d],b=y[m];if(Hi(p,f,g,b))return 0;a=Math.min(a,ys(p,f,g,b,r))}}return a}function lu(e,t,r,n,i,o){if(!o)return;let a=fs(os(n,o),i,r);a<t&&e.push([a,o,[0,0]])}function ki(e,t,r,n,i,o,a){if(!o||!a)return;let s=fs(os(n,o),os(i,a),r);s<t&&e.push([s,o,a])}function Ui(e,t,r,n,i=1/0){let o=Math.min(n.distance(e[0],r[0][0]),i);if(o===0)return o;let a=new Oi([[0,[0,e.length-1],[0,0]]],Fu),s=as(r);for(;a.length>0;){let l=a.pop();if(l[0]>=o)continue;let u=l[1],c=t?ns:rs;if(Ni(u)<=c){if(!st(u,e.length))return NaN;if(t){let p=wh(e,u,r,n);if(isNaN(p)||p===0)return p;o=Math.min(o,p)}else for(let p=u[0];p<=u[1];++p){let f=Sh(e[p],r,n);if(o=Math.min(o,f),o===0)return 0}}else{let p=is(u,t);lu(a,o,n,e,s,p[0]),lu(a,o,n,e,s,p[1])}}return o}function $i(e,t,r,n,i,o=1/0){let a=Math.min(o,i.distance(e[0],r[0]));if(a===0)return a;let s=new Oi([[0,[0,e.length-1],[0,r.length-1]]],Fu);for(;s.length>0;){let l=s.pop();if(l[0]>=a)continue;let u=l[1],c=l[2],p=t?ns:rs,f=n?ns:rs;if(Ni(u)<=p&&Ni(c)<=f){if(!st(u,e.length)&&st(c,r.length))return NaN;let y;if(t&&n)y=vh(e,u,r,c,i),a=Math.min(a,y);else if(t&&!n){let m=e.slice(u[0],u[1]+1);for(let h=c[0];h<=c[1];++h)if(y=Bt(r[h],m,i),a=Math.min(a,y),a===0)return a}else if(!t&&n){let m=r.slice(c[0],c[1]+1);for(let h=u[0];h<=u[1];++h)if(y=Bt(e[h],m,i),a=Math.min(a,y),a===0)return a}else y=Ph(e,u,r,c,i),a=Math.min(a,y)}else{let y=is(u,t),m=is(c,n);ki(s,a,i,e,r,y[0],m[0]),ki(s,a,i,e,r,y[0],m[1]),ki(s,a,i,e,r,y[1],m[0]),ki(s,a,i,e,r,y[1],m[1])}}return a}function _h(e,t){let r=e.geometry(),n=r.flat().map(a=>cs([a.x,a.y],e.canonical));if(r.length===0)return NaN;let i=new nn(n[0][1]),o=1/0;for(let a of t){switch(a.type){case"Point":o=Math.min(o,$i(n,!1,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,$i(n,!1,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,Ui(n,!1,a.coordinates,i,o));break}if(o===0)return o}return o}function Ih(e,t){let r=e.geometry(),n=r.flat().map(a=>cs([a.x,a.y],e.canonical));if(r.length===0)return NaN;let i=new nn(n[0][1]),o=1/0;for(let a of t){switch(a.type){case"Point":o=Math.min(o,$i(n,!0,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,$i(n,!0,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,Ui(n,!0,a.coordinates,i,o));break}if(o===0)return o}return o}function Th(e,t){let r=e.geometry();if(r.length===0||r[0].length===0)return NaN;let n=dh(r,0).map(a=>a.map(s=>s.map(l=>cs([l.x,l.y],e.canonical)))),i=new nn(n[0][0][0][1]),o=1/0;for(let a of t)for(let s of n){switch(a.type){case"Point":o=Math.min(o,Ui([a.coordinates],!1,s,i,o));break;case"LineString":o=Math.min(o,Ui(a.coordinates,!0,s,i,o));break;case"Polygon":o=Math.min(o,Ah(s,a.coordinates,i,o));break}if(o===0)return o}return o}function Ga(e){return e.type==="MultiPolygon"?e.coordinates.map(t=>({type:"Polygon",coordinates:t})):e.type==="MultiLineString"?e.coordinates.map(t=>({type:"LineString",coordinates:t})):e.type==="MultiPoint"?e.coordinates.map(t=>({type:"Point",coordinates:t})):[e]}var on=class e{constructor(t,r){this.type=L,this.geojson=t,this.geometries=r}static parse(t,r){if(t.length!==2)return r.error(`\'distance\' expression requires exactly one argument, but found ${t.length-1} instead.`);if(Qr(t[1])){let n=t[1];if(n.type==="FeatureCollection")return new e(n,n.features.map(i=>Ga(i.geometry)).flat());if(n.type==="Feature")return new e(n,Ga(n.geometry));if("type"in n&&"coordinates"in n)return new e(n,Ga(n))}return r.error("\'distance\' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(t.geometry()!=null&&t.canonicalID()!=null){if(t.geometryType()==="Point")return _h(t,this.geometries);if(t.geometryType()==="LineString")return Ih(t,this.geometries);if(t.geometryType()==="Polygon")return Th(t,this.geometries)}return NaN}eachChild(){}outputDefined(){return!0}},Ut={"==":Zm,"!=":Wm,">":Xm,"<":Hm,">=":Ym,"<=":Km,array:je,at:Za,boolean:je,case:Ka,coalesce:zi,collator:Ri,format:en,image:es,in:Wa,"index-of":Ha,interpolate:Je,"interpolate-hcl":Je,"interpolate-lab":Je,length:ts,let:Di,literal:mt,match:Xa,number:je,"number-format":Qa,object:je,slice:Ya,step:pr,string:je,"to-boolean":yt,"to-color":yt,"to-number":yt,"to-string":yt,var:Vi,within:rn,distance:on},Ke=class e{constructor(t,r,n,i){this.name=t,this.type=r,this._evaluate=n,this.args=i}evaluate(t){return this._evaluate(t,this.args)}eachChild(t){this.args.forEach(t)}outputDefined(){return!1}static parse(t,r){let n=t[0],i=e.definitions[n];if(!i)return r.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,0);let o=Array.isArray(i)?i[0]:i.type,a=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=a.filter(([u])=>!Array.isArray(u)||u.length===t.length-1),l=null;for(let[u,c]of s){l=new Li(r.registry,Gi,r.path,null,r.scope);let p=[],f=!1;for(let y=1;y<t.length;y++){let m=t[y],h=Array.isArray(u)?u[y-1]:u.type,d=l.parse(m,1+p.length,h);if(!d){f=!0;break}p.push(d)}if(!f){if(Array.isArray(u)&&u.length!==p.length){l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);continue}for(let y=0;y<p.length;y++){let m=Array.isArray(u)?u[y]:u.type,h=p[y];l.concat(y+1).checkSubtype(m,h.type)}if(l.errors.length===0)return new e(n,o,c,p)}}if(s.length===1)r.errors.push(...l.errors);else{let c=(s.length?s:a).map(([f])=>kh(f)).join(" | "),p=[];for(let f=1;f<t.length;f++){let y=r.parse(t[f],1+p.length);if(!y)return null;p.push(te(y.type))}r.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`)}return null}static register(t,r){e.definitions=r;for(let n in r)t[n]=e}};function uu(e,[t,r,n,i]){t=t.evaluate(e),r=r.evaluate(e),n=n.evaluate(e);let o=i?i.evaluate(e):1,a=Au(t,r,n,o);if(a)throw new ie(a);return new W(t/255,r/255,n/255,o,!1)}function cu(e,t){return e in t}function qa(e,t){let r=t[e];return typeof r>"u"?null:r}function Ch(e,t,r,n){for(;r<=n;){let i=r+n>>1;if(t[i]===e)return!0;t[i]>e?n=i-1:r=i+1}return!1}function Vt(e){return{type:e}}Ke.register(Ut,{error:[gm,[G],(e,[t])=>{throw new ie(t.evaluate(e))}],typeof:[G,[$],(e,[t])=>te(ue(t.evaluate(e)))],"to-rgba":[Ee(L,4),[Re],(e,[t])=>{let[r,n,i,o]=t.evaluate(e).rgb;return[r*255,n*255,i*255,o]}],rgb:[Re,[L,L,L],uu],rgba:[Re,[L,L,L,L],uu],has:{type:U,overloads:[[[G],(e,[t])=>cu(t.evaluate(e),e.properties())],[[G,lr],(e,[t,r])=>cu(t.evaluate(e),r.evaluate(e))]]},get:{type:$,overloads:[[[G],(e,[t])=>qa(t.evaluate(e),e.properties())],[[G,lr],(e,[t,r])=>qa(t.evaluate(e),r.evaluate(e))]]},"feature-state":[$,[G],(e,[t])=>qa(t.evaluate(e),e.featureState||{})],properties:[lr,[],e=>e.properties()],"geometry-type":[G,[],e=>e.geometryType()],id:[$,[],e=>e.id()],zoom:[L,[],e=>e.globals.zoom],"heatmap-density":[L,[],e=>e.globals.heatmapDensity||0],"line-progress":[L,[],e=>e.globals.lineProgress||0],accumulated:[$,[],e=>e.globals.accumulated===void 0?null:e.globals.accumulated],"+":[L,Vt(L),(e,t)=>{let r=0;for(let n of t)r+=n.evaluate(e);return r}],"*":[L,Vt(L),(e,t)=>{let r=1;for(let n of t)r*=n.evaluate(e);return r}],"-":{type:L,overloads:[[[L,L],(e,[t,r])=>t.evaluate(e)-r.evaluate(e)],[[L],(e,[t])=>-t.evaluate(e)]]},"/":[L,[L,L],(e,[t,r])=>t.evaluate(e)/r.evaluate(e)],"%":[L,[L,L],(e,[t,r])=>t.evaluate(e)%r.evaluate(e)],ln2:[L,[],()=>Math.LN2],pi:[L,[],()=>Math.PI],e:[L,[],()=>Math.E],"^":[L,[L,L],(e,[t,r])=>Math.pow(t.evaluate(e),r.evaluate(e))],sqrt:[L,[L],(e,[t])=>Math.sqrt(t.evaluate(e))],log10:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN10],ln:[L,[L],(e,[t])=>Math.log(t.evaluate(e))],log2:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN2],sin:[L,[L],(e,[t])=>Math.sin(t.evaluate(e))],cos:[L,[L],(e,[t])=>Math.cos(t.evaluate(e))],tan:[L,[L],(e,[t])=>Math.tan(t.evaluate(e))],asin:[L,[L],(e,[t])=>Math.asin(t.evaluate(e))],acos:[L,[L],(e,[t])=>Math.acos(t.evaluate(e))],atan:[L,[L],(e,[t])=>Math.atan(t.evaluate(e))],min:[L,Vt(L),(e,t)=>Math.min(...t.map(r=>r.evaluate(e)))],max:[L,Vt(L),(e,t)=>Math.max(...t.map(r=>r.evaluate(e)))],abs:[L,[L],(e,[t])=>Math.abs(t.evaluate(e))],round:[L,[L],(e,[t])=>{let r=t.evaluate(e);return r<0?-Math.round(-r):Math.round(r)}],floor:[L,[L],(e,[t])=>Math.floor(t.evaluate(e))],ceil:[L,[L],(e,[t])=>Math.ceil(t.evaluate(e))],"filter-==":[U,[G,$],(e,[t,r])=>e.properties()[t.value]===r.value],"filter-id-==":[U,[$],(e,[t])=>e.id()===t.value],"filter-type-==":[U,[G],(e,[t])=>e.geometryType()===t.value],"filter-<":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<n}],"filter->":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>n}],"filter-<=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<=n}],"filter->=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>=n}],"filter-has":[U,[$],(e,[t])=>t.value in e.properties()],"filter-has-id":[U,[],e=>e.id()!==null&&e.id()!==void 0],"filter-type-in":[U,[Ee(G)],(e,[t])=>t.value.indexOf(e.geometryType())>=0],"filter-id-in":[U,[Ee($)],(e,[t])=>t.value.indexOf(e.id())>=0],"filter-in-small":[U,[G,Ee($)],(e,[t,r])=>r.value.indexOf(e.properties()[t.value])>=0],"filter-in-large":[U,[G,Ee($)],(e,[t,r])=>Ch(e.properties()[t.value],r.value,0,r.value.length-1)],all:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)&&r.evaluate(e)],[Vt(U),(e,t)=>{for(let r of t)if(!r.evaluate(e))return!1;return!0}]]},any:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)||r.evaluate(e)],[Vt(U),(e,t)=>{for(let r of t)if(r.evaluate(e))return!0;return!1}]]},"!":[U,[U],(e,[t])=>!t.evaluate(e)],"is-supported-script":[U,[G],(e,[t])=>{let r=e.globals&&e.globals.isSupportedScript;return r?r(t.evaluate(e)):!0}],upcase:[G,[G],(e,[t])=>t.evaluate(e).toUpperCase()],downcase:[G,[G],(e,[t])=>t.evaluate(e).toLowerCase()],concat:[G,Vt($),(e,t)=>t.map(r=>Zr(r.evaluate(e))).join("")],"resolved-locale":[G,[ji],(e,[t])=>t.evaluate(e).resolvedLocale()]});function kh(e){return Array.isArray(e)?`(${e.map(te).join(", ")})`:`(${te(e.type)}...)`}function Gi(e){if(e instanceof Vi)return Gi(e.boundExpression);if(e instanceof Ke&&e.name==="error")return!1;if(e instanceof Ri)return!1;if(e instanceof rn)return!1;if(e instanceof on)return!1;let t=e instanceof yt||e instanceof je,r=!0;return e.eachChild(n=>{t?r=r&&Gi(n):r=r&&n instanceof mt}),r?Xi(e)&&Ki(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"]):!1}function Xi(e){if(e instanceof Ke){if(e.name==="get"&&e.args.length===1)return!1;if(e.name==="feature-state")return!1;if(e.name==="has"&&e.args.length===1)return!1;if(e.name==="properties"||e.name==="geometry-type"||e.name==="id")return!1;if(/^filter-/.test(e.name))return!1}if(e instanceof rn||e instanceof on)return!1;let t=!0;return e.eachChild(r=>{t&&!Xi(r)&&(t=!1)}),t}function an(e){if(e instanceof Ke&&e.name==="feature-state")return!1;let t=!0;return e.eachChild(r=>{t&&!an(r)&&(t=!1)}),t}function Ki(e,t){if(e instanceof Ke&&t.indexOf(e.name)>=0)return!1;let r=!0;return e.eachChild(n=>{r&&!Ki(n,t)&&(r=!1)}),r}function ss(e){return{result:"success",value:e}}function sr(e){return{result:"error",value:e}}function ht(e){return e["property-type"]==="data-driven"||e["property-type"]==="cross-faded-data-driven"}function Lu(e){return!!e.expression&&e.expression.parameters.indexOf("zoom")>-1}function ms(e){return!!e.expression&&e.expression.interpolated}function j(e){return e instanceof Number?"number":e instanceof String?"string":e instanceof Boolean?"boolean":Array.isArray(e)?"array":e===null?"null":typeof e}function Yi(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function Mh(e){return e}function Du(e,t){let r=t.type==="color",n=e.stops&&typeof e.stops[0][0]=="object",i=n||e.property!==void 0,o=n||!i,a=e.type||(ms(t)?"exponential":"interval");if(r||t.type==="padding"){let c=r?W.parse:Ze.parse;e=cr({},e),e.stops&&(e.stops=e.stops.map(p=>[p[0],c(p[1])])),e.default?e.default=c(e.default):e.default=c(t.default)}if(e.colorSpace&&!Fm(e.colorSpace))throw new Error(`Unknown color space: "${e.colorSpace}"`);let s,l,u;if(a==="exponential")s=pu;else if(a==="interval")s=Fh;else if(a==="categorical"){s=Eh,l=Object.create(null);for(let c of e.stops)l[c[0]]=c[1];u=typeof e.stops[0][0]}else if(a==="identity")s=Lh;else throw new Error(`Unknown function type "${a}"`);if(n){let c={},p=[];for(let m=0;m<e.stops.length;m++){let h=e.stops[m],d=h[0].zoom;c[d]===void 0&&(c[d]={zoom:d,type:e.type,property:e.property,default:e.default,stops:[]},p.push(d)),c[d].stops.push([h[0].value,h[1]])}let f=[];for(let m of p)f.push([c[m].zoom,Du(c[m],t)]);let y={name:"linear"};return{kind:"composite",interpolationType:y,interpolationFactor:Je.interpolationFactor.bind(void 0,y),zoomStops:f.map(m=>m[0]),evaluate({zoom:m},h){return pu({stops:f,base:e.base},t,m).evaluate(m,h)}}}else if(o){let c=a==="exponential"?{name:"exponential",base:e.base!==void 0?e.base:1}:null;return{kind:"camera",interpolationType:c,interpolationFactor:Je.interpolationFactor.bind(void 0,c),zoomStops:e.stops.map(p=>p[0]),evaluate:({zoom:p})=>s(e,t,p,l,u)}}else return{kind:"source",evaluate(c,p){let f=p&&p.properties?p.properties[e.property]:void 0;return f===void 0?pn(e.default,t.default):s(e,t,f,l,u)}}}function pn(e,t,r){if(e!==void 0)return e;if(t!==void 0)return t;if(r!==void 0)return r}function Eh(e,t,r,n,i){let o=typeof r===i?n[r]:void 0;return pn(o,e.default,t.default)}function Fh(e,t,r){if(j(r)!=="number")return pn(e.default,t.default);let n=e.stops.length;if(n===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[n-1][0])return e.stops[n-1][1];let i=Wi(e.stops.map(o=>o[0]),r);return e.stops[i][1]}function pu(e,t,r){let n=e.base!==void 0?e.base:1;if(j(r)!=="number")return pn(e.default,t.default);let i=e.stops.length;if(i===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[i-1][0])return e.stops[i-1][1];let o=Wi(e.stops.map(c=>c[0]),r),a=Dh(r,n,e.stops[o][0],e.stops[o+1][0]),s=e.stops[o][1],l=e.stops[o+1][1],u=Oe[t.type]||Mh;return typeof s.evaluate=="function"?{evaluate(...c){let p=s.evaluate.apply(void 0,c),f=l.evaluate.apply(void 0,c);if(!(p===void 0||f===void 0))return u(p,f,a,e.colorSpace)}}:u(s,l,a,e.colorSpace)}function Lh(e,t,r){switch(t.type){case"color":r=W.parse(r);break;case"formatted":r=Fe.fromString(r.toString());break;case"resolvedImage":r=Te.fromString(r.toString());break;case"padding":r=Ze.parse(r);break;default:j(r)!==t.type&&(t.type!=="enum"||!t.values[r])&&(r=void 0)}return pn(r,e.default,t.default)}function Dh(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var Rt=class{constructor(t,r){this.expression=t,this._warningHistory={},this._evaluator=new Fi,this._defaultValue=r?Bh(r):null,this._enumValues=r&&r.type==="enum"?r.values:null}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._evaluator.globals=t,this._evaluator.feature=r,this._evaluator.featureState=n,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)}evaluate(t,r,n,i,o,a){this._evaluator.globals=t,this._evaluator.feature=r||null,this._evaluator.featureState=n||null,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a||null;try{let s=this.expression.evaluate(this._evaluator);if(s==null||typeof s=="number"&&s!==s)return this._defaultValue;if(this._enumValues&&!(s in this._enumValues))throw new ie(`Expected value to be one of ${Object.keys(this._enumValues).map(l=>JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);return s}catch(s){return this._warningHistory[s.message]||(this._warningHistory[s.message]=!0,typeof console<"u"&&console.warn(s.message)),this._defaultValue}}};function $t(e){return Array.isArray(e)&&e.length>0&&typeof e[0]=="string"&&e[0]in Ut}function Gt(e,t){let r=new Li(Ut,Gi,[],t?Vh(t):void 0),n=r.parse(e,void 0,void 0,void 0,t&&t.type==="string"?{typeAnnotation:"coerce"}:void 0);return n?ss(new Rt(n,t)):sr(r.errors)}var dt=class{constructor(t,r){this.kind=t,this._styleExpression=r,this.isStateDependent=t!=="constant"&&!an(r.expression)}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}},gt=class{constructor(t,r,n,i){this.kind=t,this.zoomStops=n,this._styleExpression=r,this.isStateDependent=t!=="camera"&&!an(r.expression),this.interpolationType=i}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}interpolationFactor(t,r,n){return this.interpolationType?Je.interpolationFactor(this.interpolationType,t,r,n):0}};function Vu(e,t){let r=Gt(e,t);if(r.result==="error")return r;let n=r.value.expression,i=Xi(n);if(!i&&!ht(t))return sr([new Be("","data expressions not supported")]);let o=Ki(n,["zoom"]);if(!o&&!Lu(t))return sr([new Be("","zoom expressions not supported")]);let a=Ei(n);if(!a&&!o)return sr([new Be("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);if(a instanceof Be)return sr([a]);if(a instanceof Je&&!ms(t))return sr([new Be("",\'"interpolate" expressions cannot be used with this property\')]);if(!a)return ss(i?new dt("constant",r.value):new dt("source",r.value));let s=a instanceof Je?a.interpolation:void 0;return ss(i?new gt("camera",r.value,a.labels,s):new gt("composite",r.value,a.labels,s))}var sn=class e{constructor(t,r){this._parameters=t,this._specification=r,cr(this,Du(this._parameters,this._specification))}static deserialize(t){return new e(t._parameters,t._specification)}static serialize(t){return{_parameters:t._parameters,_specification:t._specification}}};function Bu(e,t){if(Yi(e))return new sn(e,t);if($t(e)){let r=Vu(e,t);if(r.result==="error")throw new Error(r.value.map(n=>`${n.key}: ${n.message}`).join(", "));return r.value}else{let r=e;return t.type==="color"&&typeof e=="string"?r=W.parse(e):t.type==="padding"&&(typeof e=="number"||Array.isArray(e))?r=Ze.parse(e):t.type==="variableAnchorOffsetCollection"&&Array.isArray(e)&&(r=Ne.parse(e)),{kind:"constant",evaluate:()=>r}}}function Ei(e){let t=null;if(e instanceof Di)t=Ei(e.result);else if(e instanceof zi){for(let r of e.args)if(t=Ei(r),t)break}else(e instanceof pr||e instanceof Je)&&e.input instanceof Ke&&e.input.name==="zoom"&&(t=e);return t instanceof Be||e.eachChild(r=>{let n=Ei(r);n instanceof Be?t=n:!t&&n?t=new Be("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\'):t&&n&&t!==n&&(t=new Be("",\'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'))}),t}function Vh(e){let t={color:Re,string:G,number:L,enum:G,boolean:U,formatted:mr,padding:Ji,resolvedImage:un,variableAnchorOffsetCollection:Zi};return e.type==="array"?Ee(t[e.value]||$,e.length):t[e.type]}function Bh(e){return e.type==="color"&&Yi(e.default)?new W(0,0,0,0):e.type==="color"?W.parse(e.default)||null:e.type==="padding"?Ze.parse(e.default)||null:e.type==="variableAnchorOffsetCollection"?Ne.parse(e.default)||null:e.default===void 0?null:e.default}function hs(e){if(e===!0||e===!1)return!0;if(!Array.isArray(e)||e.length===0)return!1;switch(e[0]){case"has":return e.length>=2&&e[1]!=="$id"&&e[1]!=="$type";case"in":return e.length>=3&&(typeof e[1]!="string"||Array.isArray(e[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return e.length!==3||Array.isArray(e[1])||Array.isArray(e[2]);case"any":case"all":for(let t of e.slice(1))if(!hs(t)&&typeof t!="boolean")return!1;return!0;default:return!0}}var zh={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function fn(e){if(e==null)return{filter:()=>!0,needGeometry:!1};hs(e)||(e=qi(e));let t=Gt(e,zh);if(t.result==="error")throw new Error(t.value.map(r=>`${r.key}: ${r.message}`).join(", "));{let r=zu(e);return{filter:(n,i,o)=>t.value.evaluate(n,i,{},o),needGeometry:r}}}function Rh(e,t){return e<t?-1:e>t?1:0}function zu(e){if(!Array.isArray(e))return!1;if(e[0]==="within"||e[0]==="distance")return!0;for(let t=1;t<e.length;t++)if(zu(e[t]))return!0;return!1}function qi(e){if(!e)return!0;let t=e[0];return e.length<=1?t!=="any":t==="=="?ja(e[1],e[2],"=="):t==="!="?Mi(ja(e[1],e[2],"==")):t==="<"||t===">"||t==="<="||t===">="?ja(e[1],e[2],t):t==="any"?Oh(e.slice(1)):t==="all"?["all"].concat(e.slice(1).map(qi)):t==="none"?["all"].concat(e.slice(1).map(qi).map(Mi)):t==="in"?fu(e[1],e.slice(2)):t==="!in"?Mi(fu(e[1],e.slice(2))):t==="has"?yu(e[1]):t==="!has"?Mi(yu(e[1])):!0}function ja(e,t,r){switch(e){case"$type":return[`filter-type-${r}`,t];case"$id":return[`filter-id-${r}`,t];default:return[`filter-${r}`,e,t]}}function Oh(e){return["any"].concat(e.map(qi))}function fu(e,t){if(t.length===0)return!1;switch(e){case"$type":return["filter-type-in",["literal",t]];case"$id":return["filter-id-in",["literal",t]];default:return t.length>200&&!t.some(r=>typeof r!=typeof t[0])?["filter-in-large",e,["literal",t.sort(Rh)]]:["filter-in-small",e,["literal",t]]}}function yu(e){switch(e){case"$type":return!0;case"$id":return["filter-has-id"];default:return["filter-has",e]}}function Mi(e){return["!",e]}function ls(e){let t=typeof e;if(t==="number"||t==="boolean"||t==="string"||e===void 0||e===null)return JSON.stringify(e);if(Array.isArray(e)){let i="[";for(let o of e)i+=`${ls(o)},`;return`${i}]`}let r=Object.keys(e).sort(),n="{";for(let i=0;i<r.length;i++)n+=`${JSON.stringify(r[i])}:${ls(e[r[i]])},`;return`${n}}`}function Nh(e){let t="";for(let r of dm)t+=`/${ls(e[r])}`;return t}function Ru(e,t){let r={};for(let i=0;i<e.length;i++){let o=t&&t[e[i].id]||Nh(e[i]);t&&(t[e[i].id]=o);let a=r[o];a||(a=r[o]=[]),a.push(e[i])}let n=[];for(let i in r)n.push(r[i]);return n}function Ou(e){let t=e.key,r=e.value;return r?[new M(t,r,"constants have been deprecated as of v8")]:[]}function ae(e){return e instanceof Number||e instanceof String||e instanceof Boolean?e.valueOf():e}function Ot(e){if(Array.isArray(e))return e.map(Ot);if(e instanceof Object&&!(e instanceof Number||e instanceof String||e instanceof Boolean)){let t={};for(let r in e)t[r]=Ot(e[r]);return t}return ae(e)}function ze(e){let t=e.key,r=e.value,n=e.valueSpec||{},i=e.objectElementValidators||{},o=e.style,a=e.styleSpec,s=e.validateSpec,l=[],u=j(r);if(u!=="object")return[new M(t,r,`object expected, ${u} found`)];for(let c in r){let p=c.split(".")[0],f=n[p]||n["*"],y;if(i[p])y=i[p];else if(n[p])y=s;else if(i["*"])y=i["*"];else if(n["*"])y=s;else{l.push(new M(t,r[c],`unknown property "${c}"`));continue}l=l.concat(y({key:(t&&`${t}.`)+c,value:r[c],valueSpec:f,style:o,styleSpec:a,object:r,objectKey:c,validateSpec:s},r))}for(let c in n)i[c]||n[c].required&&n[c].default===void 0&&r[c]===void 0&&l.push(new M(t,r,`missing required property "${c}"`));return l}function ds(e){let t=e.value,r=e.valueSpec,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.key,s=e.arrayElementValidator||n;if(j(t)!=="array")return[new M(a,t,`array expected, ${j(t)} found`)];if(r.length&&t.length!==r.length)return[new M(a,t,`array length ${r.length} expected, length ${t.length} found`)];if(r["min-length"]&&t.length<r["min-length"])return[new M(a,t,`array length at least ${r["min-length"]} expected, length ${t.length} found`)];let l={type:r.value,values:r.values};o.$version<7&&(l.function=r.function),j(r.value)==="object"&&(l=r.value);let u=[];for(let c=0;c<t.length;c++)u=u.concat(s({array:t,arrayIndex:c,value:t[c],valueSpec:l,validateSpec:e.validateSpec,style:i,styleSpec:o,key:`${a}[${c}]`}));return u}function gs(e){let t=e.key,r=e.value,n=e.valueSpec,i=j(r);return i==="number"&&r!==r&&(i="NaN"),i!=="number"?[new M(t,r,`number expected, ${i} found`)]:"minimum"in n&&r<n.minimum?[new M(t,r,`${r} is less than the minimum value ${n.minimum}`)]:"maximum"in n&&r>n.maximum?[new M(t,r,`${r} is greater than the maximum value ${n.maximum}`)]:[]}function Nu(e){let t=e.valueSpec,r=ae(e.value.type),n,i={},o,a,s=r!=="categorical"&&e.value.property===void 0,l=!s,u=j(e.value.stops)==="array"&&j(e.value.stops[0])==="array"&&j(e.value.stops[0][0])==="object",c=ze({key:e.key,value:e.value,valueSpec:e.styleSpec.function,validateSpec:e.validateSpec,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{stops:p,default:m}});return r==="identity"&&s&&c.push(new M(e.key,e.value,\'missing required property "property"\')),r!=="identity"&&!e.value.stops&&c.push(new M(e.key,e.value,\'missing required property "stops"\')),r==="exponential"&&e.valueSpec.expression&&!ms(e.valueSpec)&&c.push(new M(e.key,e.value,"exponential functions not supported")),e.styleSpec.$version>=8&&(l&&!ht(e.valueSpec)?c.push(new M(e.key,e.value,"property functions not supported")):s&&!Lu(e.valueSpec)&&c.push(new M(e.key,e.value,"zoom functions not supported"))),(r==="categorical"||u)&&e.value.property===void 0&&c.push(new M(e.key,e.value,\'"property" property is required\')),c;function p(h){if(r==="identity")return[new M(h.key,h.value,\'identity function may not have a "stops" property\')];let d=[],g=h.value;return d=d.concat(ds({key:h.key,value:g,valueSpec:h.valueSpec,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,arrayElementValidator:f})),j(g)==="array"&&g.length===0&&d.push(new M(h.key,g,"array must have at least one stop")),d}function f(h){let d=[],g=h.value,b=h.key;if(j(g)!=="array")return[new M(b,g,`array expected, ${j(g)} found`)];if(g.length!==2)return[new M(b,g,`array length 2 expected, length ${g.length} found`)];if(u){if(j(g[0])!=="object")return[new M(b,g,`object expected, ${j(g[0])} found`)];if(g[0].zoom===void 0)return[new M(b,g,"object stop key must have zoom")];if(g[0].value===void 0)return[new M(b,g,"object stop key must have value")];if(a&&a>ae(g[0].zoom))return[new M(b,g[0].zoom,"stop zoom values must appear in ascending order")];ae(g[0].zoom)!==a&&(a=ae(g[0].zoom),o=void 0,i={}),d=d.concat(ze({key:`${b}[0]`,value:g[0],valueSpec:{zoom:{}},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,objectElementValidators:{zoom:gs,value:y}}))}else d=d.concat(y({key:`${b}[0]`,value:g[0],valueSpec:{},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec},g));return $t(Ot(g[1]))?d.concat([new M(`${b}[1]`,g[1],"expressions are not allowed in function stops.")]):d.concat(h.validateSpec({key:`${b}[1]`,value:g[1],valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec}))}function y(h,d){let g=j(h.value),b=ae(h.value),x=h.value!==null?h.value:d;if(!n)n=g;else if(g!==n)return[new M(h.key,x,`${g} stop domain type must match previous stop domain type ${n}`)];if(g!=="number"&&g!=="string"&&g!=="boolean")return[new M(h.key,x,"stop domain value must be a number, string, or boolean")];if(g!=="number"&&r!=="categorical"){let v=`number expected, ${g} found`;return ht(t)&&r===void 0&&(v+=\'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\'),[new M(h.key,x,v)]}return r==="categorical"&&g==="number"&&(!isFinite(b)||Math.floor(b)!==b)?[new M(h.key,x,`integer expected, found ${b}`)]:r!=="categorical"&&g==="number"&&o!==void 0&&b<o?[new M(h.key,x,"stop domain values must appear in ascending order")]:(o=b,r==="categorical"&&b in i?[new M(h.key,x,"stop domain values must be unique")]:(i[b]=!0,[]))}function m(h){return h.validateSpec({key:h.key,value:h.value,valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec})}}function fr(e){let t=(e.expressionContext==="property"?Vu:Gt)(Ot(e.value),e.valueSpec);if(t.result==="error")return t.value.map(n=>new M(`${e.key}${n.key}`,e.value,n.message));let r=t.value.expression||t.value._styleExpression.expression;if(e.expressionContext==="property"&&e.propertyKey==="text-font"&&!r.outputDefined())return[new M(e.key,e.value,`Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)];if(e.expressionContext==="property"&&e.propertyType==="layout"&&!an(r))return[new M(e.key,e.value,\'"feature-state" data expressions are not supported with layout properties.\')];if(e.expressionContext==="filter"&&!an(r))return[new M(e.key,e.value,\'"feature-state" data expressions are not supported with filters.\')];if(e.expressionContext&&e.expressionContext.indexOf("cluster")===0){if(!Ki(r,["zoom","feature-state"]))return[new M(e.key,e.value,\'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];if(e.expressionContext==="cluster-initial"&&!Xi(r))return[new M(e.key,e.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return[]}function Uh(e){let t=e.value,r=e.key,n=j(t);return n!=="boolean"?[new M(r,t,`boolean expected, ${n} found`)]:[]}function $h(e){let t=e.key,r=e.value,n=j(r);return n!=="string"?[new M(t,r,`color expected, ${n} found`)]:W.parse(String(r))?[]:[new M(t,r,`color expected, "${r}" found`)]}function ln(e){let t=e.key,r=e.value,n=e.valueSpec,i=[];return Array.isArray(n.values)?n.values.indexOf(ae(r))===-1&&i.push(new M(t,r,`expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)):Object.keys(n.values).indexOf(ae(r))===-1&&i.push(new M(t,r,`expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)),i}function xs(e){return hs(Ot(e.value))?fr(cr({},e,{expressionContext:"filter",valueSpec:{value:"boolean"}})):Uu(e)}function Uu(e){let t=e.value,r=e.key;if(j(t)!=="array")return[new M(r,t,`array expected, ${j(t)} found`)];let n=e.styleSpec,i,o=[];if(t.length<1)return[new M(r,t,"filter array must have at least 1 element")];switch(o=o.concat(ln({key:`${r}[0]`,value:t[0],valueSpec:n.filter_operator,style:e.style,styleSpec:e.styleSpec})),ae(t[0])){case"<":case"<=":case">":case">=":t.length>=2&&ae(t[1])==="$type"&&o.push(new M(r,t,`"$type" cannot be use with operator "${t[0]}"`));case"==":case"!=":t.length!==3&&o.push(new M(r,t,`filter array for operator "${t[0]}" must have 3 elements`));case"in":case"!in":t.length>=2&&(i=j(t[1]),i!=="string"&&o.push(new M(`${r}[1]`,t[1],`string expected, ${i} found`)));for(let a=2;a<t.length;a++)i=j(t[a]),ae(t[1])==="$type"?o=o.concat(ln({key:`${r}[${a}]`,value:t[a],valueSpec:n.geometry_type,style:e.style,styleSpec:e.styleSpec})):i!=="string"&&i!=="number"&&i!=="boolean"&&o.push(new M(`${r}[${a}]`,t[a],`string, number, or boolean expected, ${i} found`));break;case"any":case"all":case"none":for(let a=1;a<t.length;a++)o=o.concat(Uu({key:`${r}[${a}]`,value:t[a],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":i=j(t[1]),t.length!==2?o.push(new M(r,t,`filter array for "${t[0]}" operator must have 2 elements`)):i!=="string"&&o.push(new M(`${r}[1]`,t[1],`string expected, ${i} found`));break}return o}function $u(e,t){let r=e.key,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.value,s=e.objectKey,l=o[`${t}_${e.layerType}`];if(!l)return[];let u=s.match(/^(.*)-transition$/);if(t==="paint"&&u&&l[u[1]]&&l[u[1]].transition)return n({key:r,value:a,valueSpec:o.transition,style:i,styleSpec:o});let c=e.valueSpec||l[s];if(!c)return[new M(r,a,`unknown property "${s}"`)];let p;if(j(a)==="string"&&ht(c)&&!c.tokens&&(p=/^{([^}]+)}$/.exec(a)))return[new M(r,a,`"${s}" does not support interpolation syntax\nUse an identity property function instead: \\`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\\`.`)];let f=[];return e.layerType==="symbol"&&(s==="text-field"&&i&&!i.glyphs&&f.push(new M(r,a,\'use of "text-field" requires a style "glyphs" property\')),s==="text-font"&&Yi(Ot(a))&&ae(a.type)==="identity"&&f.push(new M(r,a,\'"text-font" does not support identity functions\'))),f.concat(n({key:e.key,value:a,valueSpec:c,style:i,styleSpec:o,expressionContext:"property",propertyType:t,propertyKey:s}))}function Gu(e){return $u(e,"paint")}function qu(e){return $u(e,"layout")}function ju(e){let t=[],r=e.value,n=e.key,i=e.style,o=e.styleSpec;!r.type&&!r.ref&&t.push(new M(n,r,\'either "type" or "ref" is required\'));let a=ae(r.type),s=ae(r.ref);if(r.id){let l=ae(r.id);for(let u=0;u<e.arrayIndex;u++){let c=i.layers[u];ae(c.id)===l&&t.push(new M(n,r.id,`duplicate layer id "${r.id}", previously used at line ${c.id.__line__}`))}}if("ref"in r){["type","source","source-layer","filter","layout"].forEach(u=>{u in r&&t.push(new M(n,r[u],`"${u}" is prohibited for ref layers`))});let l;i.layers.forEach(u=>{ae(u.id)===s&&(l=u)}),l?l.ref?t.push(new M(n,r.ref,"ref cannot reference another ref layer")):a=ae(l.type):t.push(new M(n,r.ref,`ref layer "${s}" not found`))}else if(a!=="background")if(!r.source)t.push(new M(n,r,\'missing required property "source"\'));else{let l=i.sources&&i.sources[r.source],u=l&&ae(l.type);l?u==="vector"&&a==="raster"?t.push(new M(n,r.source,`layer "${r.id}" requires a raster source`)):u!=="raster-dem"&&a==="hillshade"?t.push(new M(n,r.source,`layer "${r.id}" requires a raster-dem source`)):u==="raster"&&a!=="raster"?t.push(new M(n,r.source,`layer "${r.id}" requires a vector source`)):u==="vector"&&!r["source-layer"]?t.push(new M(n,r,`layer "${r.id}" must specify a "source-layer"`)):u==="raster-dem"&&a!=="hillshade"?t.push(new M(n,r.source,"raster-dem source can only be used with layer type \'hillshade\'.")):a==="line"&&r.paint&&r.paint["line-gradient"]&&(u!=="geojson"||!l.lineMetrics)&&t.push(new M(n,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)):t.push(new M(n,r.source,`source "${r.source}" not found`))}return t=t.concat(ze({key:n,value:r,valueSpec:o.layer,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,objectElementValidators:{"*"(){return[]},type(){return e.validateSpec({key:`${n}.type`,value:r.type,valueSpec:o.layer.type,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,object:r,objectKey:"type"})},filter:xs,layout(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return qu(cr({layerType:a},u))}}})},paint(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Gu(cr({layerType:a},u))}}})}}})),t}function Nt(e){let t=e.value,r=e.key,n=j(t);return n!=="string"?[new M(r,t,`string expected, ${n} found`)]:[]}function Gh(e){var t;let r=(t=e.sourceName)!==null&&t!==void 0?t:"",n=e.value,i=e.styleSpec,o=i.source_raster_dem,a=e.style,s=[],l=j(n);if(n===void 0)return s;if(l!=="object")return s.push(new M("source_raster_dem",n,`object expected, ${l} found`)),s;let c=ae(n.encoding)==="custom",p=["redFactor","greenFactor","blueFactor","baseShift"],f=e.value.encoding?`"${e.value.encoding}"`:"Default";for(let y in n)!c&&p.includes(y)?s.push(new M(y,n[y],`In "${r}": "${y}" is only valid when "encoding" is set to "custom". ${f} encoding found`)):o[y]?s=s.concat(e.validateSpec({key:y,value:n[y],valueSpec:o[y],validateSpec:e.validateSpec,style:a,styleSpec:i})):s.push(new M(y,n[y],`unknown property "${y}"`));return s}var mu={promoteId:qh};function Ju(e){let t=e.value,r=e.key,n=e.styleSpec,i=e.style,o=e.validateSpec;if(!t.type)return[new M(r,t,\'"type" is required\')];let a=ae(t.type),s;switch(a){case"vector":case"raster":return s=ze({key:r,value:t,valueSpec:n[`source_${a.replace("-","_")}`],style:e.style,styleSpec:n,objectElementValidators:mu,validateSpec:o}),s;case"raster-dem":return s=Gh({sourceName:r,value:t,style:e.style,styleSpec:n,validateSpec:o}),s;case"geojson":if(s=ze({key:r,value:t,valueSpec:n.source_geojson,style:i,styleSpec:n,validateSpec:o,objectElementValidators:mu}),t.cluster)for(let l in t.clusterProperties){let[u,c]=t.clusterProperties[l],p=typeof u=="string"?[u,["accumulated"],["get",l]]:u;s.push(...fr({key:`${r}.${l}.map`,value:c,validateSpec:o,expressionContext:"cluster-map"})),s.push(...fr({key:`${r}.${l}.reduce`,value:p,validateSpec:o,expressionContext:"cluster-reduce"}))}return s;case"video":return ze({key:r,value:t,valueSpec:n.source_video,style:i,validateSpec:o,styleSpec:n});case"image":return ze({key:r,value:t,valueSpec:n.source_image,style:i,validateSpec:o,styleSpec:n});case"canvas":return[new M(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return ln({key:`${r}.type`,value:t.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,validateSpec:o,styleSpec:n})}}function qh({key:e,value:t}){if(j(t)==="string")return Nt({key:e,value:t});{let r=[];for(let n in t)r.push(...Nt({key:`${e}.${n}`,value:t[n]}));return r}}function Zu(e){let t=e.value,r=e.styleSpec,n=r.light,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new M("light",t,`object expected, ${a} found`)]),o;for(let s in t){let l=s.match(/^(.*)-transition$/);l&&n[l[1]]&&n[l[1]].transition?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:r.transition,validateSpec:e.validateSpec,style:i,styleSpec:r})):n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,t[s],`unknown property "${s}"`)])}return o}function Wu(e){let t=e.value,r=e.styleSpec,n=r.sky,i=e.style,o=j(t);if(t===void 0)return[];if(o!=="object")return[new M("sky",t,`object expected, ${o} found`)];let a=[];for(let s in t)n[s]?a=a.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,t[s],`unknown property "${s}"`)]);return a}function Hu(e){let t=e.value,r=e.styleSpec,n=r.terrain,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new M("terrain",t,`object expected, ${a} found`)]),o;for(let s in t)n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,t[s],`unknown property "${s}"`)]);return o}function jh(e){return Nt(e).length===0?[]:fr(e)}function Jh(e){return Nt(e).length===0?[]:fr(e)}function Zh(e){let t=e.key,r=e.value;if(j(r)==="array"){if(r.length<1||r.length>4)return[new M(t,r,`padding requires 1 to 4 values; ${r.length} values found`)];let i={type:"number"},o=[];for(let a=0;a<r.length;a++)o=o.concat(e.validateSpec({key:`${t}[${a}]`,value:r[a],validateSpec:e.validateSpec,valueSpec:i}));return o}else return gs({key:t,value:r,valueSpec:{}})}function Wh(e){let t=e.key,r=e.value,n=j(r),i=e.styleSpec;if(n!=="array"||r.length<1||r.length%2!==0)return[new M(t,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];let o=[];for(let a=0;a<r.length;a+=2)o=o.concat(ln({key:`${t}[${a}]`,value:r[a],valueSpec:i.layout_symbol["text-anchor"]})),o=o.concat(ds({key:`${t}[${a+1}]`,value:r[a+1],valueSpec:{length:2,value:"number"},validateSpec:e.validateSpec,style:e.style,styleSpec:i}));return o}function Xu(e){let t=[],r=e.value,n=e.key;if(Array.isArray(r)){let i=[],o=[];for(let a in r){r[a].id&&i.includes(r[a].id)&&t.push(new M(n,r,`all the sprites\' ids must be unique, but ${r[a].id} is duplicated`)),i.push(r[a].id),r[a].url&&o.includes(r[a].url)&&t.push(new M(n,r,`all the sprites\' URLs must be unique, but ${r[a].url} is duplicated`)),o.push(r[a].url);let s={id:{type:"string",required:!0},url:{type:"string",required:!0}};t=t.concat(ze({key:`${n}[${a}]`,value:r[a],valueSpec:s,validateSpec:e.validateSpec}))}return t}else return Nt({key:n,value:r})}function Hh(e){let t=e.value,r=e.styleSpec,n=r.projection,i=e.style,o=j(t);if(t===void 0)return[];if(o!=="object")return[new M("projection",t,`object expected, ${o} found`)];let a=[];for(let s in t)n[s]?a=a.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,t[s],`unknown property "${s}"`)]);return a}var hu={"*"(){return[]},array:ds,boolean:Uh,number:gs,color:$h,constants:Ou,enum:ln,filter:xs,function:Nu,layer:ju,object:ze,source:Ju,light:Zu,sky:Wu,terrain:Hu,projection:Hh,string:Nt,formatted:jh,resolvedImage:Jh,padding:Zh,variableAnchorOffsetCollection:Wh,sprite:Xu};function Wr(e){let t=e.value,r=e.valueSpec,n=e.styleSpec;return e.validateSpec=Wr,r.expression&&Yi(ae(t))?Nu(e):r.expression&&$t(Ot(t))?fr(e):r.type&&hu[r.type]?hu[r.type](e):ze(cr({},e,{valueSpec:r.type?n[r.type]:r}))}function Ku(e){let t=e.value,r=e.key,n=Nt(e);return n.length||(t.indexOf("{fontstack}")===-1&&n.push(new M(r,t,\'"glyphs" url must include a "{fontstack}" token\')),t.indexOf("{range}")===-1&&n.push(new M(r,t,\'"glyphs" url must include a "{range}" token\'))),n}function Ue(e,t=S){let r=[];return r=r.concat(Wr({key:"",value:e,valueSpec:t.$root,styleSpec:t,style:e,validateSpec:Wr,objectElementValidators:{glyphs:Ku,"*"(){return[]}}})),e.constants&&(r=r.concat(Ou({key:"constants",value:e.constants,style:e,styleSpec:t,validateSpec:Wr}))),Yu(r)}Ue.source=Qe(Ye(Ju));Ue.sprite=Qe(Ye(Xu));Ue.glyphs=Qe(Ye(Ku));Ue.light=Qe(Ye(Zu));Ue.sky=Qe(Ye(Wu));Ue.terrain=Qe(Ye(Hu));Ue.layer=Qe(Ye(ju));Ue.filter=Qe(Ye(xs));Ue.paintProperty=Qe(Ye(Gu));Ue.layoutProperty=Qe(Ye(qu));function Ye(e){return function(t){return e({...t,validateSpec:Wr})}}function Yu(e){return[].concat(e).sort((t,r)=>t.line-r.line)}function Qe(e){return function(...t){return Yu(e.apply(this,t))}}var Qu="AbortError";function ec(e){return e.message===Qu}function bs(){return new Error(Qu)}var Qi={MAX_PARALLEL_IMAGE_REQUESTS:16,MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME:8,MAX_TILE_CACHE_ZOOM_LEVELS:5,REGISTERED_PROTOCOLS:{},WORKER_URL:""};function tc(e){return Qi.REGISTERED_PROTOCOLS[e.substring(0,e.indexOf("://"))]}function rc(e,t){Qi.REGISTERED_PROTOCOLS[e]=t}function nc(e){delete Qi.REGISTERED_PROTOCOLS[e]}var ic="global-dispatcher",gr=class extends Error{constructor(t,r,n,i){super(`AJAXError: ${r} (${t}): ${n}`),this.status=t,this.statusText=r,this.url=n,this.body=i}},ac=()=>at(self)?self.worker&&self.worker.referrer:(window.location.protocol==="blob:"?window.parent:window).location.href,Xh=e=>/^file:/.test(e)||/^file:/.test(ac())&&!/^\\w+:/.test(e);async function Kh(e,t){let r=new Request(e.url,{method:e.method||"GET",body:e.body,credentials:e.credentials,headers:e.headers,cache:e.cache,referrer:ac(),signal:t.signal});e.type==="json"&&r.headers.set("Accept","application/json");let n=await fetch(r);if(!n.ok){let a=await n.blob();throw new gr(n.status,n.statusText,e.url,a)}let i;e.type==="arrayBuffer"||e.type==="image"?i=n.arrayBuffer():e.type==="json"?i=n.json():i=n.text();let o=await i;if(t.signal.aborted)throw bs();return{data:o,cacheControl:n.headers.get("Cache-Control"),expires:n.headers.get("Expires")}}function Yh(e,t){return new Promise((r,n)=>{let i=new XMLHttpRequest;i.open(e.method||"GET",e.url,!0),(e.type==="arrayBuffer"||e.type==="image")&&(i.responseType="arraybuffer");for(let o in e.headers)i.setRequestHeader(o,e.headers[o]);e.type==="json"&&(i.responseType="text",i.setRequestHeader("Accept","application/json")),i.withCredentials=e.credentials==="include",i.onerror=()=>{n(new Error(i.statusText))},i.onload=()=>{if(!t.signal.aborted)if((i.status>=200&&i.status<300||i.status===0)&&i.response!==null){let o=i.response;if(e.type==="json")try{o=JSON.parse(i.response)}catch(a){n(a);return}r({data:o,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires")})}else{let o=new Blob([i.response],{type:i.getResponseHeader("Content-Type")});n(new gr(i.status,i.statusText,e.url,o))}},t.signal.addEventListener("abort",()=>{i.abort(),n(bs())}),i.send(e.body)})}var sc=function(e,t){if(/:\\/\\//.test(e.url)&&!/^https?:|^file:/.test(e.url)){let r=tc(e.url);if(r)return r(e,t);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:e,targetMapId:ic},t)}if(!Xh(e.url)){if(fetch&&Request&&AbortController&&Object.prototype.hasOwnProperty.call(Request.prototype,"signal"))return Kh(e,t);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:e,mustQueue:!0,targetMapId:ic},t)}return Yh(e,t)},lc=(e,t)=>sc(Pe(e,{type:"json"}),t),uc=(e,t)=>sc(Pe(e,{type:"arrayBuffer"}),t);var xt={};function C(e,t,r={}){if(xt[e])throw new Error(`${e} is already registered.`);Object.defineProperty(t,"_classRegistryKey",{value:e,writeable:!1}),xt[e]={klass:t,omit:r.omit||[],shallow:r.shallow||[]}}C("Object",Object);C("TransferableGridIndex",Dt);C("Color",W);C("Error",Error);C("AJAXError",gr);C("ResolvedImage",Te);C("StylePropertyFunction",sn);C("StyleExpression",Rt,{omit:["_evaluator"]});C("ZoomDependentExpression",gt);C("ZoomConstantExpression",dt);C("CompoundExpression",Ke,{omit:["_evaluate"]});for(let e in Ut)Ut[e]._classRegistryKey||C(`Expression_${e}`,Ut[e]);function cc(e){return e&&typeof ArrayBuffer<"u"&&(e instanceof ArrayBuffer||e.constructor&&e.constructor.name==="ArrayBuffer")}function xr(e,t){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob||e instanceof Error)return e;if(cc(e)||qr(e))return t&&t.push(e),e;if(ArrayBuffer.isView(e)){let r=e;return t&&t.push(r.buffer),r}if(e instanceof ImageData)return t&&t.push(e.data.buffer),e;if(Array.isArray(e)){let r=[];for(let n of e)r.push(xr(n,t));return r}if(typeof e=="object"){let r=e.constructor,n=r._classRegistryKey;if(!n)throw new Error(`can\'t serialize object of unregistered class ${r.name}`);if(!xt[n])throw new Error(`${n} is not registered.`);let i=r.serialize?r.serialize(e,t):{};if(r.serialize){if(t&&i===t[t.length-1])throw new Error("statically serialized object won\'t survive transfer of $name property")}else{for(let o in e){if(!e.hasOwnProperty(o)||xt[n].omit.indexOf(o)>=0)continue;let a=e[o];i[o]=xt[n].shallow.indexOf(o)>=0?a:xr(a,t)}e instanceof Error&&(i.message=e.message)}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return n!=="Object"&&(i.$name=n),i}throw new Error(`can\'t serialize object of type ${typeof e}`)}function br(e){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob||e instanceof Error||cc(e)||qr(e)||ArrayBuffer.isView(e)||e instanceof ImageData)return e;if(Array.isArray(e))return e.map(br);if(typeof e=="object"){let t=e.$name||"Object";if(!xt[t])throw new Error(`can\'t deserialize unregistered class ${t}`);let{klass:r}=xt[t];if(!r)throw new Error(`can\'t deserialize unregistered class ${t}`);if(r.deserialize)return r.deserialize(e);let n=Object.create(r.prototype);for(let i of Object.keys(e)){if(i==="$name")continue;let o=e[i];n[i]=xt[t].shallow.indexOf(i)>=0?o:br(o)}return n}throw new Error(`can\'t deserialize object of type ${typeof e}`)}var eo=class{constructor(t){this._methodToThrottle=t,this._triggered=!1,typeof MessageChannel<"u"&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._methodToThrottle()})}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(()=>{this._triggered=!1,this._methodToThrottle()},0))}remove(){delete this._channel,this._methodToThrottle=()=>{}}};var to=class{constructor(t,r){this.target=t,this.mapId=r,this.resolveRejects={},this.tasks={},this.taskQueue=[],this.abortControllers={},this.messageHandlers={},this.invoker=new eo(()=>this.process()),this.subscription=Hl(this.target,"message",n=>this.receive(n),!1),this.globalScope=at(self)?t:window}registerMessageHandler(t,r){this.messageHandlers[t]=r}sendAsync(t,r){return new Promise((n,i)=>{let o=Math.round(Math.random()*1e18).toString(36).substring(0,10);this.resolveRejects[o]={resolve:n,reject:i},r&&r.signal.addEventListener("abort",()=>{delete this.resolveRejects[o];let l={id:o,type:"<cancel>",origin:location.origin,targetMapId:t.targetMapId,sourceMapId:this.mapId};this.target.postMessage(l)},{once:!0});let a=[],s={...t,id:o,sourceMapId:this.mapId,origin:location.origin,data:xr(t.data,a)};this.target.postMessage(s,{transfer:a})})}receive(t){let r=t.data,n=r.id;if(!(r.origin!=="file://"&&location.origin!=="file://"&&r.origin!==location.origin)&&!(r.targetMapId&&this.mapId!==r.targetMapId)){if(r.type==="<cancel>"){delete this.tasks[n];let i=this.abortControllers[n];delete this.abortControllers[n],i&&i.abort();return}if(at(self)||r.mustQueue){this.tasks[n]=r,this.taskQueue.push(n),this.invoker.trigger();return}this.processTask(n,r)}}process(){if(this.taskQueue.length===0)return;let t=this.taskQueue.shift(),r=this.tasks[t];delete this.tasks[t],this.taskQueue.length>0&&this.invoker.trigger(),r&&this.processTask(t,r)}async processTask(t,r){if(r.type==="<response>"){let o=this.resolveRejects[t];if(delete this.resolveRejects[t],!o)return;r.error?o.reject(br(r.error)):o.resolve(br(r.data));return}if(!this.messageHandlers[r.type]){this.completeTask(t,new Error(`Could not find a registered handler for ${r.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));return}let n=br(r.data),i=new AbortController;this.abortControllers[t]=i;try{let o=await this.messageHandlers[r.type](r.sourceMapId,n,i);this.completeTask(t,null,o)}catch(o){this.completeTask(t,o)}}completeTask(t,r,n){let i=[];delete this.abortControllers[t];let o={id:t,type:"<response>",sourceMapId:this.mapId,origin:location.origin,error:r?xr(r):null,data:xr(n,i)};this.target.postMessage(o,{transfer:i})}remove(){this.invoker.remove(),this.subscription.unsubscribe()}};function pc(e,t,r){r[e]&&r[e].indexOf(t)!==-1||(r[e]=r[e]||[],r[e].push(t))}function vs(e,t,r){if(r&&r[e]){let n=r[e].indexOf(t);n!==-1&&r[e].splice(n,1)}}var ro=class{constructor(t,r={}){Pe(this,r),this.type=t}},yn=class extends ro{constructor(t,r={}){super("error",Pe({error:t},r))}},no=class{on(t,r){return this._listeners=this._listeners||{},pc(t,r,this._listeners),this}off(t,r){return vs(t,r,this._listeners),vs(t,r,this._oneTimeListeners),this}once(t,r){return r?(this._oneTimeListeners=this._oneTimeListeners||{},pc(t,r,this._oneTimeListeners),this):new Promise(n=>this.once(t,n))}fire(t,r){typeof t=="string"&&(t=new ro(t,r||{}));let n=t.type;if(this.listens(n)){t.target=this;let i=this._listeners&&this._listeners[n]?this._listeners[n].slice():[];for(let s of i)s.call(this,t);let o=this._oneTimeListeners&&this._oneTimeListeners[n]?this._oneTimeListeners[n].slice():[];for(let s of o)vs(n,s,this._oneTimeListeners),s.call(this,t);let a=this._eventedParent;a&&(Pe(t,typeof this._eventedParentData=="function"?this._eventedParentData():this._eventedParentData),a.fire(t))}else t instanceof yn&&console.error(t.error);return this}listens(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)}setEventedParent(t,r){return this._eventedParent=t,this._eventedParentData=r,this}};var bt=Ue,j0=bt.source,J0=bt.light,Z0=bt.terrain,W0=bt.filter,fc=bt.paintProperty,yc=bt.layoutProperty;function mc(e,t){let r=!1;if(t&&t.length)for(let n of t)e.fire(new yn(new Error(n.message))),r=!0;return r}var io=class{constructor(){this.first=!0}update(t,r){let n=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=n,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=n,!0):(this.lastFloorZoom>n?(this.lastIntegerZoom=n+1,this.lastIntegerZoomTime=r):this.lastFloorZoom<n&&(this.lastIntegerZoom=n,this.lastIntegerZoomTime=r),t!==this.lastZoom?(this.lastZoom=t,this.lastFloorZoom=n,!0):!1)}};var D={"Latin-1 Supplement":e=>e>=128&&e<=255,Arabic:e=>e>=1536&&e<=1791,"Arabic Supplement":e=>e>=1872&&e<=1919,"Arabic Extended-A":e=>e>=2208&&e<=2303,"Hangul Jamo":e=>e>=4352&&e<=4607,"Unified Canadian Aboriginal Syllabics":e=>e>=5120&&e<=5759,Khmer:e=>e>=6016&&e<=6143,"Unified Canadian Aboriginal Syllabics Extended":e=>e>=6320&&e<=6399,"General Punctuation":e=>e>=8192&&e<=8303,"Letterlike Symbols":e=>e>=8448&&e<=8527,"Number Forms":e=>e>=8528&&e<=8591,"Miscellaneous Technical":e=>e>=8960&&e<=9215,"Control Pictures":e=>e>=9216&&e<=9279,"Optical Character Recognition":e=>e>=9280&&e<=9311,"Enclosed Alphanumerics":e=>e>=9312&&e<=9471,"Geometric Shapes":e=>e>=9632&&e<=9727,"Miscellaneous Symbols":e=>e>=9728&&e<=9983,"Miscellaneous Symbols and Arrows":e=>e>=11008&&e<=11263,"CJK Radicals Supplement":e=>e>=11904&&e<=12031,"Kangxi Radicals":e=>e>=12032&&e<=12255,"Ideographic Description Characters":e=>e>=12272&&e<=12287,"CJK Symbols and Punctuation":e=>e>=12288&&e<=12351,Hiragana:e=>e>=12352&&e<=12447,Katakana:e=>e>=12448&&e<=12543,Bopomofo:e=>e>=12544&&e<=12591,"Hangul Compatibility Jamo":e=>e>=12592&&e<=12687,Kanbun:e=>e>=12688&&e<=12703,"Bopomofo Extended":e=>e>=12704&&e<=12735,"CJK Strokes":e=>e>=12736&&e<=12783,"Katakana Phonetic Extensions":e=>e>=12784&&e<=12799,"Enclosed CJK Letters and Months":e=>e>=12800&&e<=13055,"CJK Compatibility":e=>e>=13056&&e<=13311,"CJK Unified Ideographs Extension A":e=>e>=13312&&e<=19903,"Yijing Hexagram Symbols":e=>e>=19904&&e<=19967,"CJK Unified Ideographs":e=>e>=19968&&e<=40959,"Yi Syllables":e=>e>=40960&&e<=42127,"Yi Radicals":e=>e>=42128&&e<=42191,"Hangul Jamo Extended-A":e=>e>=43360&&e<=43391,"Hangul Syllables":e=>e>=44032&&e<=55215,"Hangul Jamo Extended-B":e=>e>=55216&&e<=55295,"Private Use Area":e=>e>=57344&&e<=63743,"CJK Compatibility Ideographs":e=>e>=63744&&e<=64255,"Arabic Presentation Forms-A":e=>e>=64336&&e<=65023,"Vertical Forms":e=>e>=65040&&e<=65055,"CJK Compatibility Forms":e=>e>=65072&&e<=65103,"Small Form Variants":e=>e>=65104&&e<=65135,"Arabic Presentation Forms-B":e=>e>=65136&&e<=65279,"Halfwidth and Fullwidth Forms":e=>e>=65280&&e<=65519};function mn(e){for(let t of e)if(oo(t.charCodeAt(0)))return!0;return!1}function hc(e){for(let t of e)if(!Qh(t.charCodeAt(0)))return!1;return!0}function Qh(e){return!(D.Arabic(e)||D["Arabic Supplement"](e)||D["Arabic Extended-A"](e)||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e))}function dc(e){return e<11904?!1:!!(D["Bopomofo Extended"](e)||D.Bopomofo(e)||D["CJK Compatibility Forms"](e)||D["CJK Compatibility Ideographs"](e)||D["CJK Compatibility"](e)||D["CJK Radicals Supplement"](e)||D["CJK Strokes"](e)||D["CJK Symbols and Punctuation"](e)||D["CJK Unified Ideographs Extension A"](e)||D["CJK Unified Ideographs"](e)||D["Enclosed CJK Letters and Months"](e)||D["Halfwidth and Fullwidth Forms"](e)||D.Hiragana(e)||D["Ideographic Description Characters"](e)||D["Kangxi Radicals"](e)||D["Katakana Phonetic Extensions"](e)||D.Katakana(e)||D["Vertical Forms"](e)||D["Yi Radicals"](e)||D["Yi Syllables"](e))}function oo(e){return e===746||e===747?!0:e<4352?!1:!!(D["Bopomofo Extended"](e)||D.Bopomofo(e)||D["CJK Compatibility Forms"](e)&&!(e>=65097&&e<=65103)||D["CJK Compatibility Ideographs"](e)||D["CJK Compatibility"](e)||D["CJK Radicals Supplement"](e)||D["CJK Strokes"](e)||D["CJK Symbols and Punctuation"](e)&&!(e>=12296&&e<=12305)&&!(e>=12308&&e<=12319)&&e!==12336||D["CJK Unified Ideographs Extension A"](e)||D["CJK Unified Ideographs"](e)||D["Enclosed CJK Letters and Months"](e)||D["Hangul Compatibility Jamo"](e)||D["Hangul Jamo Extended-A"](e)||D["Hangul Jamo Extended-B"](e)||D["Hangul Jamo"](e)||D["Hangul Syllables"](e)||D.Hiragana(e)||D["Ideographic Description Characters"](e)||D.Kanbun(e)||D["Kangxi Radicals"](e)||D["Katakana Phonetic Extensions"](e)||D.Katakana(e)&&e!==12540||D["Halfwidth and Fullwidth Forms"](e)&&e!==65288&&e!==65289&&e!==65293&&!(e>=65306&&e<=65310)&&e!==65339&&e!==65341&&e!==65343&&!(e>=65371&&e<=65503)&&e!==65507&&!(e>=65512&&e<=65519)||D["Small Form Variants"](e)&&!(e>=65112&&e<=65118)&&!(e>=65123&&e<=65126)||D["Unified Canadian Aboriginal Syllabics"](e)||D["Unified Canadian Aboriginal Syllabics Extended"](e)||D["Vertical Forms"](e)||D["Yijing Hexagram Symbols"](e)||D["Yi Syllables"](e)||D["Yi Radicals"](e))}function ed(e){return!!(D["Latin-1 Supplement"](e)&&(e===167||e===169||e===174||e===177||e===188||e===189||e===190||e===215||e===247)||D["General Punctuation"](e)&&(e===8214||e===8224||e===8225||e===8240||e===8241||e===8251||e===8252||e===8258||e===8263||e===8264||e===8265||e===8273)||D["Letterlike Symbols"](e)||D["Number Forms"](e)||D["Miscellaneous Technical"](e)&&(e>=8960&&e<=8967||e>=8972&&e<=8991||e>=8996&&e<=9e3||e===9003||e>=9085&&e<=9114||e>=9150&&e<=9165||e===9167||e>=9169&&e<=9179||e>=9186&&e<=9215)||D["Control Pictures"](e)&&e!==9251||D["Optical Character Recognition"](e)||D["Enclosed Alphanumerics"](e)||D["Geometric Shapes"](e)||D["Miscellaneous Symbols"](e)&&!(e>=9754&&e<=9759)||D["Miscellaneous Symbols and Arrows"](e)&&(e>=11026&&e<=11055||e>=11088&&e<=11097||e>=11192&&e<=11243)||D["CJK Symbols and Punctuation"](e)||D.Katakana(e)||D["Private Use Area"](e)||D["CJK Compatibility Forms"](e)||D["Small Form Variants"](e)||D["Halfwidth and Fullwidth Forms"](e)||e===8734||e===8756||e===8757||e>=9984&&e<=10087||e>=10102&&e<=10131||e===65532||e===65533)}function Ps(e){return!(oo(e)||ed(e))}function gc(e){return D.Arabic(e)||D["Arabic Supplement"](e)||D["Arabic Extended-A"](e)||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e)}function xc(e){return e>=1424&&e<=2303||D["Arabic Presentation Forms-A"](e)||D["Arabic Presentation Forms-B"](e)}function td(e,t){return!(!t&&xc(e)||e>=2304&&e<=3583||e>=3840&&e<=4255||D.Khmer(e))}function bc(e){for(let t of e)if(xc(t.charCodeAt(0)))return!0;return!1}function vc(e,t){for(let r of e)if(!td(r.charCodeAt(0),t))return!1;return!0}var Ss=class{constructor(){this.applyArabicShaping=null;this.processBidirectionalText=null;this.processStyledBidirectionalText=null;this.pluginStatus="unavailable";this.pluginURL=null}setState(t){this.pluginStatus=t.pluginStatus,this.pluginURL=t.pluginURL}getState(){return{pluginStatus:this.pluginStatus,pluginURL:this.pluginURL}}setMethods(t){this.applyArabicShaping=t.applyArabicShaping,this.processBidirectionalText=t.processBidirectionalText,this.processStyledBidirectionalText=t.processStyledBidirectionalText}isParsed(){return this.applyArabicShaping!=null&&this.processBidirectionalText!=null&&this.processStyledBidirectionalText!=null}getPluginURL(){return this.pluginURL}getRTLTextPluginStatus(){return this.pluginStatus}},ye=new Ss;var q=class{constructor(t,r){this.zoom=t,r?(this.now=r.now,this.fadeDuration=r.fadeDuration,this.zoomHistory=r.zoomHistory,this.transition=r.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new io,this.transition={})}isSupportedScript(t){return vc(t,ye.getRTLTextPluginStatus()==="loaded")}crossFadingFactor(){return this.fadeDuration===0?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)}getCrossfadeParameters(){let t=this.zoom,r=t-Math.floor(t),n=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:r+(1-r)*n}:{fromScale:.5,toScale:1,t:1-(1-n)*r}}};var vr=class{constructor(t,r){this.property=t,this.value=r,this.expression=Bu(r===void 0?t.specification.default:r,t.specification)}isDataDriven(){return this.expression.kind==="source"||this.expression.kind==="composite"}possiblyEvaluate(t,r,n){return this.property.possiblyEvaluate(this,t,r,n)}},hn=class{constructor(t){this.property=t,this.value=new vr(t,void 0)}transitioned(t,r){return new so(this.property,this.value,r,Pe({},t.transition,this.transition),t.now)}untransitioned(){return new so(this.property,this.value,null,{},0)}},ao=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues)}getValue(t){return nt(this._values[t].value.value)}setValue(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new hn(this._values[t].property)),this._values[t].value=new vr(this._values[t].property,r===null?void 0:nt(r))}getTransition(t){return nt(this._values[t].transition)}setTransition(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new hn(this._values[t].property)),this._values[t].transition=nt(r)||void 0}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n);let i=this.getTransition(r);i!==void 0&&(t[`${r}-transition`]=i)}return t}transitioned(t,r){let n=new lo(this._properties);for(let i of Object.keys(this._values))n._values[i]=this._values[i].transitioned(t,r._values[i]);return n}untransitioned(){let t=new lo(this._properties);for(let r of Object.keys(this._values))t._values[r]=this._values[r].untransitioned();return t}},so=class{constructor(t,r,n,i,o){this.property=t,this.value=r,this.begin=o+i.delay||0,this.end=this.begin+i.duration||0,t.specification.transition&&(i.delay||i.duration)&&(this.prior=n)}possiblyEvaluate(t,r,n){let i=t.now||0,o=this.value.possiblyEvaluate(t,r,n),a=this.prior;if(a){if(i>this.end)return this.prior=null,o;if(this.value.isDataDriven())return this.prior=null,o;if(i<this.begin)return a.possiblyEvaluate(t,r,n);{let s=(i-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,r,n),o,$l(s))}}else return o}},lo=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues)}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}hasTransition(){for(let t of Object.keys(this._values))if(this._values[t].prior)return!0;return!1}},uo=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues)}hasValue(t){return this._values[t].value!==void 0}getValue(t){return nt(this._values[t].value)}setValue(t,r){this._values[t]=new vr(this._values[t].property,r===null?void 0:nt(r))}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n)}return t}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}},Se=class{constructor(t,r,n){this.property=t,this.value=r,this.parameters=n}isConstant(){return this.value.kind==="constant"}constantOr(t){return this.value.kind==="constant"?this.value.value:t}evaluate(t,r,n,i){return this.property.evaluate(this.value,this.parameters,t,r,n,i)}},vt=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues)}get(t){return this._values[t]}},B=class{constructor(t){this.specification=t}possiblyEvaluate(t,r){if(t.isDataDriven())throw new Error("Value should not be data driven");return t.expression.evaluate(r)}interpolate(t,r,n){let i=this.specification.type,o=Oe[i];return o?o(t,r,n):t}},R=class{constructor(t,r){this.specification=t,this.overrides=r}possiblyEvaluate(t,r,n,i){return t.expression.kind==="constant"||t.expression.kind==="camera"?new Se(this,{kind:"constant",value:t.expression.evaluate(r,null,{},n,i)},r):new Se(this,t.expression,r)}interpolate(t,r,n){if(t.value.kind!=="constant"||r.value.kind!=="constant")return t;if(t.value.value===void 0||r.value.value===void 0)return new Se(this,{kind:"constant",value:void 0},t.parameters);let i=this.specification.type,o=Oe[i];if(o){let a=o(t.value.value,r.value.value,n);return new Se(this,{kind:"constant",value:a},t.parameters)}else return t}evaluate(t,r,n,i,o,a){return t.kind==="constant"?t.value:t.evaluate(r,n,i,o,a)}},lt=class extends R{possiblyEvaluate(t,r,n,i){if(t.value===void 0)return new Se(this,{kind:"constant",value:void 0},r);if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i),s=t.property.specification.type==="resolvedImage"&&typeof o!="string"?o.name:o,l=this._calculate(s,s,s,r);return new Se(this,{kind:"constant",value:l},r)}else if(t.expression.kind==="camera"){let o=this._calculate(t.expression.evaluate({zoom:r.zoom-1}),t.expression.evaluate({zoom:r.zoom}),t.expression.evaluate({zoom:r.zoom+1}),r);return new Se(this,{kind:"constant",value:o},r)}else return new Se(this,t.expression,r)}evaluate(t,r,n,i,o,a){if(t.kind==="source"){let s=t.evaluate(r,n,i,o,a);return this._calculate(s,s,s,r)}else return t.kind==="composite"?this._calculate(t.evaluate({zoom:Math.floor(r.zoom)-1},n,i),t.evaluate({zoom:Math.floor(r.zoom)},n,i),t.evaluate({zoom:Math.floor(r.zoom)+1},n,i),r):t.value}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},qt=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){if(t.value!==void 0)if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i);return this._calculate(o,o,o,r)}else return this._calculate(t.expression.evaluate(new q(Math.floor(r.zoom-1),r)),t.expression.evaluate(new q(Math.floor(r.zoom),r)),t.expression.evaluate(new q(Math.floor(r.zoom+1),r)),r)}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},jt=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){return!!t.expression.evaluate(r,null,{},n,i)}interpolate(){return!1}},re=class{constructor(t){this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];for(let r in t){let n=t[r];n.specification.overridable&&this.overridableProperties.push(r);let i=this.defaultPropertyValues[r]=new vr(n,void 0),o=this.defaultTransitionablePropertyValues[r]=new hn(n);this.defaultTransitioningPropertyValues[r]=o.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate({})}}};C("DataDrivenProperty",R);C("DataConstantProperty",B);C("CrossFadedDataDrivenProperty",lt);C("CrossFadedProperty",qt);C("ColorRampProperty",jt);var co="-transition",se=class extends no{constructor(t,r){if(super(),this.id=t.id,this.type=t.type,this._featureFilter={filter:()=>!0,needGeometry:!1},t.type!=="custom"&&(t=t,this.metadata=t.metadata,this.minzoom=t.minzoom,this.maxzoom=t.maxzoom,t.type!=="background"&&(this.source=t.source,this.sourceLayer=t["source-layer"],this.filter=t.filter),r.layout&&(this._unevaluatedLayout=new uo(r.layout)),r.paint)){this._transitionablePaint=new ao(r.paint);for(let n in t.paint)this.setPaintProperty(n,t.paint[n],{validate:!1});for(let n in t.layout)this.setLayoutProperty(n,t.layout[n],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new vt(r.paint)}}getCrossfadeParameters(){return this._crossfadeParameters}getLayoutProperty(t){return t==="visibility"?this.visibility:this._unevaluatedLayout.getValue(t)}setLayoutProperty(t,r,n={}){if(r!=null){let i=`layers.${this.id}.layout.${t}`;if(this._validate(yc,i,t,r,n))return}if(t==="visibility"){this.visibility=r;return}this._unevaluatedLayout.setValue(t,r)}getPaintProperty(t){return t.endsWith(co)?this._transitionablePaint.getTransition(t.slice(0,-co.length)):this._transitionablePaint.getValue(t)}setPaintProperty(t,r,n={}){if(r!=null){let i=`layers.${this.id}.paint.${t}`;if(this._validate(fc,i,t,r,n))return!1}if(t.endsWith(co))return this._transitionablePaint.setTransition(t.slice(0,-co.length),r||void 0),!1;{let i=this._transitionablePaint._values[t],o=i.property.specification["property-type"]==="cross-faded-data-driven",a=i.value.isDataDriven(),s=i.value;this._transitionablePaint.setValue(t,r),this._handleSpecialPaintPropertyUpdate(t);let l=this._transitionablePaint._values[t].value;return l.isDataDriven()||a||o||this._handleOverridablePaintPropertyUpdate(t,s,l)}}_handleSpecialPaintPropertyUpdate(t){}_handleOverridablePaintPropertyUpdate(t,r,n){return!1}isHidden(t){return this.minzoom&&t<this.minzoom||this.maxzoom&&t>=this.maxzoom?!0:this.visibility==="none"}updateTransitions(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint)}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(t,r){t.getCrossfadeParameters&&(this._crossfadeParameters=t.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,void 0,r)),this.paint=this._transitioningPaint.possiblyEvaluate(t,void 0,r)}serialize(){let t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),jl(t,(r,n)=>r!==void 0&&!(n==="layout"&&!Object.keys(r).length)&&!(n==="paint"&&!Object.keys(r).length))}_validate(t,r,n,i,o={}){return o&&o.validate===!1?!1:mc(this,t.call(bt,{key:r,layerType:this.type,objectKey:n,value:i,styleSpec:S,style:{glyphs:!0,sprite:!0}}))}is3D(){return!1}isTileClipped(){return!1}hasOffscreenPass(){return!1}resize(){}isStateDependent(){for(let t in this.paint._values){let r=this.paint.get(t);if(!(!(r instanceof Se)||!ht(r.property.specification))&&(r.value.kind==="source"||r.value.kind==="composite")&&r.value.isStateDependent)return!0}return!1}};var rd={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Pt=class{constructor(t,r){this._structArray=t,this._pos1=r*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8}},nd=128,id=5,ee=class{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0)}static serialize(t,r){return t._trim(),r&&(t.isTransferred=!0,r.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}}static deserialize(t){let r=Object.create(this.prototype);return r.arrayBuffer=t.arrayBuffer,r.length=t.length,r.capacity=t.arrayBuffer.byteLength/r.bytesPerElement,r._refreshViews(),r}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())}clear(){this.length=0}resize(t){this.reserve(t),this.length=t}reserve(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(this.capacity*id),nd),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);let r=this.uint8;this._refreshViews(),r&&this.uint8.set(r)}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}};function Y(e,t=1){let r=0,n=0,i=e.map(a=>{let s=od(a.type),l=r=Pc(r,Math.max(t,s)),u=a.components||1;return n=Math.max(n,s),r+=s*u,{name:a.name,type:a.type,components:u,offset:l}}),o=Pc(r,Math.max(n,t));return{members:i,size:o,alignment:t}}function od(e){return rd[e].BYTES_PER_ELEMENT}function Pc(e,t){return Math.ceil(e/t)*t}var Sc=Z(he(),1),Jt=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.int16[i+0]=r,this.int16[i+1]=n,t}};Jt.prototype.bytesPerElement=4;C("StructArrayLayout2i4",Jt);var dn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.int16[o+0]=r,this.int16[o+1]=n,this.int16[o+2]=i,t}};dn.prototype.bytesPerElement=6;C("StructArrayLayout3i6",dn);var po=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*4;return this.int16[a+0]=r,this.int16[a+1]=n,this.int16[a+2]=i,this.int16[a+3]=o,t}};po.prototype.bytesPerElement=8;C("StructArrayLayout4i8",po);var gn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,t}};gn.prototype.bytesPerElement=12;C("StructArrayLayout2i4i12",gn);var xn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*4,u=t*8;return this.int16[l+0]=r,this.int16[l+1]=n,this.uint8[u+4]=i,this.uint8[u+5]=o,this.uint8[u+6]=a,this.uint8[u+7]=s,t}};xn.prototype.bytesPerElement=8;C("StructArrayLayout2i4ub8",xn);var St=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.float32[i+0]=r,this.float32[i+1]=n,t}};St.prototype.bytesPerElement=8;C("StructArrayLayout2f8",St);var bn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c){let p=this.length;return this.resize(p+1),this.emplace(p,t,r,n,i,o,a,s,l,u,c)}emplace(t,r,n,i,o,a,s,l,u,c,p){let f=t*10;return this.uint16[f+0]=r,this.uint16[f+1]=n,this.uint16[f+2]=i,this.uint16[f+3]=o,this.uint16[f+4]=a,this.uint16[f+5]=s,this.uint16[f+6]=l,this.uint16[f+7]=u,this.uint16[f+8]=c,this.uint16[f+9]=p,t}};bn.prototype.bytesPerElement=20;C("StructArrayLayout10ui20",bn);var vn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f){let y=this.length;return this.resize(y+1),this.emplace(y,t,r,n,i,o,a,s,l,u,c,p,f)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y){let m=t*12;return this.int16[m+0]=r,this.int16[m+1]=n,this.int16[m+2]=i,this.int16[m+3]=o,this.uint16[m+4]=a,this.uint16[m+5]=s,this.uint16[m+6]=l,this.uint16[m+7]=u,this.int16[m+8]=c,this.int16[m+9]=p,this.int16[m+10]=f,this.int16[m+11]=y,t}};vn.prototype.bytesPerElement=24;C("StructArrayLayout4i4ui4i24",vn);var Pn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.float32[o+0]=r,this.float32[o+1]=n,this.float32[o+2]=i,t}};Pn.prototype.bytesPerElement=12;C("StructArrayLayout3f12",Pn);var Sn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.uint32[n+0]=r,t}};Sn.prototype.bytesPerElement=4;C("StructArrayLayout1ul4",Sn);var wn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u){let c=this.length;return this.resize(c+1),this.emplace(c,t,r,n,i,o,a,s,l,u)}emplace(t,r,n,i,o,a,s,l,u,c){let p=t*10,f=t*5;return this.int16[p+0]=r,this.int16[p+1]=n,this.int16[p+2]=i,this.int16[p+3]=o,this.int16[p+4]=a,this.int16[p+5]=s,this.uint32[f+3]=l,this.uint16[p+8]=u,this.uint16[p+9]=c,t}};wn.prototype.bytesPerElement=20;C("StructArrayLayout6i1ul2ui20",wn);var An=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,t,r,n,i,o,a)}emplace(t,r,n,i,o,a,s){let l=t*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,t}};An.prototype.bytesPerElement=12;C("StructArrayLayout2i2i2i12",An);var fo=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,t,r,n,i,o)}emplace(t,r,n,i,o,a){let s=t*4,l=t*8;return this.float32[s+0]=r,this.float32[s+1]=n,this.float32[s+2]=i,this.int16[l+6]=o,this.int16[l+7]=a,t}};fo.prototype.bytesPerElement=16;C("StructArrayLayout2f1f2i16",fo);var _n=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*12,s=t*3;return this.uint8[a+0]=r,this.uint8[a+1]=n,this.float32[s+1]=i,this.float32[s+2]=o,t}};_n.prototype.bytesPerElement=12;C("StructArrayLayout2ub2f12",_n);var In=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*3;return this.uint16[o+0]=r,this.uint16[o+1]=n,this.uint16[o+2]=i,t}};In.prototype.bytesPerElement=6;C("StructArrayLayout3ui6",In);var Tn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g){let b=this.length;return this.resize(b+1),this.emplace(b,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b){let x=t*24,v=t*12,P=t*48;return this.int16[x+0]=r,this.int16[x+1]=n,this.uint16[x+2]=i,this.uint16[x+3]=o,this.uint32[v+2]=a,this.uint32[v+3]=s,this.uint32[v+4]=l,this.uint16[x+10]=u,this.uint16[x+11]=c,this.uint16[x+12]=p,this.float32[v+7]=f,this.float32[v+8]=y,this.uint8[P+36]=m,this.uint8[P+37]=h,this.uint8[P+38]=d,this.uint32[v+10]=g,this.int16[x+22]=b,t}};Tn.prototype.bytesPerElement=48;C("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",Tn);var Cn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k){let V=this.length;return this.resize(V+1),this.emplace(V,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k)}emplace(t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V){let A=t*32,z=t*16;return this.int16[A+0]=r,this.int16[A+1]=n,this.int16[A+2]=i,this.int16[A+3]=o,this.int16[A+4]=a,this.int16[A+5]=s,this.int16[A+6]=l,this.int16[A+7]=u,this.uint16[A+8]=c,this.uint16[A+9]=p,this.uint16[A+10]=f,this.uint16[A+11]=y,this.uint16[A+12]=m,this.uint16[A+13]=h,this.uint16[A+14]=d,this.uint16[A+15]=g,this.uint16[A+16]=b,this.uint16[A+17]=x,this.uint16[A+18]=v,this.uint16[A+19]=P,this.uint16[A+20]=w,this.uint16[A+21]=T,this.uint16[A+22]=F,this.uint32[z+12]=E,this.float32[z+13]=_,this.float32[z+14]=I,this.uint16[A+30]=k,this.uint16[A+31]=V,t}};Cn.prototype.bytesPerElement=64;C("StructArrayLayout8i15ui1ul2f2ui64",Cn);var Zt=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.float32[n+0]=r,t}};Zt.prototype.bytesPerElement=4;C("StructArrayLayout1f4",Zt);var kn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*6,a=t*3;return this.uint16[o+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,t}};kn.prototype.bytesPerElement=12;C("StructArrayLayout1ui2f12",kn);var Mn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,t,r,n)}emplace(t,r,n,i){let o=t*2,a=t*4;return this.uint32[o+0]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,t}};Mn.prototype.bytesPerElement=8;C("StructArrayLayout1ul2ui8",Mn);var En=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t,r){let n=this.length;return this.resize(n+1),this.emplace(n,t,r)}emplace(t,r,n){let i=t*2;return this.uint16[i+0]=r,this.uint16[i+1]=n,t}};En.prototype.bytesPerElement=4;C("StructArrayLayout2ui4",En);var yo=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(t){let r=this.length;return this.resize(r+1),this.emplace(r,t)}emplace(t,r){let n=t*1;return this.uint16[n+0]=r,t}};yo.prototype.bytesPerElement=2;C("StructArrayLayout1ui2",yo);var Pr=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(t,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,t,r,n,i)}emplace(t,r,n,i,o){let a=t*4;return this.float32[a+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,this.float32[a+3]=o,t}};Pr.prototype.bytesPerElement=16;C("StructArrayLayout4f16",Pr);var mo=class extends Pt{get anchorPointX(){return this._structArray.int16[this._pos2+0]}get anchorPointY(){return this._structArray.int16[this._pos2+1]}get x1(){return this._structArray.int16[this._pos2+2]}get y1(){return this._structArray.int16[this._pos2+3]}get x2(){return this._structArray.int16[this._pos2+4]}get y2(){return this._structArray.int16[this._pos2+5]}get featureIndex(){return this._structArray.uint32[this._pos4+3]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+8]}get bucketIndex(){return this._structArray.uint16[this._pos2+9]}get anchorPoint(){return new Sc.default(this.anchorPointX,this.anchorPointY)}};mo.prototype.size=20;var Fn=class extends wn{get(t){return new mo(this,t)}};C("CollisionBoxArray",Fn);var ho=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+2]}get numGlyphs(){return this._structArray.uint16[this._pos2+3]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+2]}get lineStartIndex(){return this._structArray.uint32[this._pos4+3]}get lineLength(){return this._structArray.uint32[this._pos4+4]}get segment(){return this._structArray.uint16[this._pos2+10]}get lowerSize(){return this._structArray.uint16[this._pos2+11]}get upperSize(){return this._structArray.uint16[this._pos2+12]}get lineOffsetX(){return this._structArray.float32[this._pos4+7]}get lineOffsetY(){return this._structArray.float32[this._pos4+8]}get writingMode(){return this._structArray.uint8[this._pos1+36]}get placedOrientation(){return this._structArray.uint8[this._pos1+37]}set placedOrientation(t){this._structArray.uint8[this._pos1+37]=t}get hidden(){return this._structArray.uint8[this._pos1+38]}set hidden(t){this._structArray.uint8[this._pos1+38]=t}get crossTileID(){return this._structArray.uint32[this._pos4+10]}set crossTileID(t){this._structArray.uint32[this._pos4+10]=t}get associatedIconIndex(){return this._structArray.int16[this._pos2+22]}};ho.prototype.size=48;var Ln=class extends Tn{get(t){return new ho(this,t)}};C("PlacedSymbolArray",Ln);var go=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+2]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+3]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+4]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+5]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+6]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+7]}get key(){return this._structArray.uint16[this._pos2+8]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+9]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+10]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+11]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+12]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+13]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+14]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get featureIndex(){return this._structArray.uint16[this._pos2+17]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+18]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+19]}get numIconVertices(){return this._structArray.uint16[this._pos2+20]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+21]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+22]}get crossTileID(){return this._structArray.uint32[this._pos4+12]}set crossTileID(t){this._structArray.uint32[this._pos4+12]=t}get textBoxScale(){return this._structArray.float32[this._pos4+13]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+14]}get textAnchorOffsetStartIndex(){return this._structArray.uint16[this._pos2+30]}get textAnchorOffsetEndIndex(){return this._structArray.uint16[this._pos2+31]}};go.prototype.size=64;var Dn=class extends Cn{get(t){return new go(this,t)}};C("SymbolInstanceArray",Dn);var Vn=class extends Zt{getoffsetX(t){return this.float32[t*1+0]}};C("GlyphOffsetArray",Vn);var Bn=class extends dn{getx(t){return this.int16[t*3+0]}gety(t){return this.int16[t*3+1]}gettileUnitDistanceFromAnchor(t){return this.int16[t*3+2]}};C("SymbolLineVertexArray",Bn);var xo=class extends Pt{get textAnchor(){return this._structArray.uint16[this._pos2+0]}get textOffset0(){return this._structArray.float32[this._pos4+1]}get textOffset1(){return this._structArray.float32[this._pos4+2]}};xo.prototype.size=12;var zn=class extends kn{get(t){return new xo(this,t)}};C("TextAnchorOffsetArray",zn);var bo=class extends Pt{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}};bo.prototype.size=8;var Rn=class extends Mn{get(t){return new bo(this,t)}};C("FeatureIndexArray",Rn);var vo=class extends Jt{};var Po=class extends Jt{},So=class extends Jt{},wo=class extends gn{};var Ao=class extends xn{},_o=class extends St{},ut=class extends bn{},Io=class extends vn{},To=class extends Pn{},Co=class extends Sn{},On=class extends An{};var ko=class extends _n{};var Le=class extends In{},wt=class extends En{};var ad=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:wc,size:Fv,alignment:Lv}=ad;var me=class e{constructor(t=[]){this.segments=t}prepareSegment(t,r,n,i){let o=this.segments[this.segments.length-1];return t>e.MAX_VERTEX_ARRAY_LENGTH&&fe(`Max vertices per segment is ${e.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),(!o||o.vertexLength+t>e.MAX_VERTEX_ARRAY_LENGTH||o.sortKey!==i)&&(o={vertexOffset:r.length,primitiveOffset:n.length,vertexLength:0,primitiveLength:0},i!==void 0&&(o.sortKey=i),this.segments.push(o)),o}get(){return this.segments}destroy(){for(let t of this.segments)for(let r in t.vaos)t.vaos[r].destroy()}static simpleSegment(t,r,n,i){return new e([{vertexOffset:t,primitiveOffset:r,vertexLength:n,primitiveLength:i,vaos:{},sortKey:0}])}};me.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1;C("SegmentVector",me);function ws(e,t){return e=it(Math.floor(e),0,255),t=it(Math.floor(t),0,255),256*e+t}var Nn=Y([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]);var Cc=Z(Is(),1);var Un=class e{constructor(){this.ids=[],this.positions=[],this.indexed=!1}add(t,r,n,i){this.ids.push(Tc(t)),this.positions.push(r,n,i)}getPositions(t){if(!this.indexed)throw new Error("Trying to get index, but feature positions are not indexed");let r=Tc(t),n=0,i=this.ids.length-1;for(;n<i;){let a=n+i>>1;this.ids[a]>=r?i=a:n=a+1}let o=[];for(;this.ids[n]===r;){let a=this.positions[3*n],s=this.positions[3*n+1],l=this.positions[3*n+2];o.push({index:a,start:s,end:l}),n++}return o}static serialize(t,r){let n=new Float64Array(t.ids),i=new Uint32Array(t.positions);return Ts(n,i,0,n.length-1),r&&r.push(n.buffer,i.buffer),{ids:n,positions:i}}static deserialize(t){let r=new e;return r.ids=t.ids,r.positions=t.positions,r.indexed=!0,r}};function Tc(e){let t=+e;return!isNaN(t)&&t<=Number.MAX_SAFE_INTEGER?t:(0,Cc.default)(String(e))}function Ts(e,t,r,n){for(;r<n;){let i=e[r+n>>1],o=r-1,a=n+1;for(;;){do o++;while(e[o]<i);do a--;while(e[a]>i);if(o>=a)break;Eo(e,o,a),Eo(t,3*o,3*a),Eo(t,3*o+1,3*a+1),Eo(t,3*o+2,3*a+2)}a-r<n-a?(Ts(e,t,r,a),r=a+1):(Ts(e,t,a+1,n),n=a)}}function Eo(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}C("FeaturePositionMap",Un);var $n=class{constructor(t,r){this.gl=t.gl,this.location=r}};var Sr=class extends $n{constructor(t,r){super(t,r),this.current=0}set(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t))}};var Fo=class extends $n{constructor(t,r){super(t,r),this.current=[0,0,0,0]}set(t){(t[0]!==this.current[0]||t[1]!==this.current[1]||t[2]!==this.current[2]||t[3]!==this.current[3])&&(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]))}},Lo=class extends $n{constructor(t,r){super(t,r),this.current=W.transparent}set(t){(t.r!==this.current.r||t.g!==this.current.g||t.b!==this.current.b||t.a!==this.current.a)&&(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a))}},Wv=new Float32Array(16);function Cs(e){return[ws(255*e.r,255*e.g),ws(255*e.b,255*e.a)]}var Wt=class{constructor(t,r,n){this.value=t,this.uniformNames=r.map(i=>`u_${i}`),this.type=n}setUniform(t,r,n){t.set(n.constantOr(this.value))}getBinding(t,r,n){return this.type==="color"?new Lo(t,r):new Sr(t,r)}},At=class{constructor(t,r){this.uniformNames=r.map(n=>`u_${n}`),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1}setConstantPatternPositions(t,r){this.pixelRatioFrom=r.pixelRatio,this.pixelRatioTo=t.pixelRatio,this.patternFrom=r.tlbr,this.patternTo=t.tlbr}setUniform(t,r,n,i){let o=i==="u_pattern_to"?this.patternTo:i==="u_pattern_from"?this.patternFrom:i==="u_pixel_ratio_to"?this.pixelRatioTo:i==="u_pixel_ratio_from"?this.pixelRatioFrom:null;o&&t.set(o)}getBinding(t,r,n){return n.substr(0,9)==="u_pattern"?new Fo(t,r):new Sr(t,r)}},We=class{constructor(t,r,n,i){this.expression=t,this.type=n,this.maxValue=0,this.paintVertexAttributes=r.map(o=>({name:`a_${o}`,type:"Float32",components:n==="color"?2:1,offset:0})),this.paintVertexArray=new i}populatePaintArray(t,r,n,i,o){let a=this.paintVertexArray.length,s=this.expression.evaluate(new q(0),r,{},i,[],o);this.paintVertexArray.resize(t),this._setPaintValue(a,t,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:0},n,i);this._setPaintValue(t,r,o)}_setPaintValue(t,r,n){if(this.type==="color"){let i=Cs(n);for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,i[0],i[1])}else{for(let i=t;i<r;i++)this.paintVertexArray.emplace(i,n);this.maxValue=Math.max(this.maxValue,Math.abs(n))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}},De=class{constructor(t,r,n,i,o,a){this.expression=t,this.uniformNames=r.map(s=>`u_${s}_t`),this.type=n,this.useIntegerZoom=i,this.zoom=o,this.maxValue=0,this.paintVertexAttributes=r.map(s=>({name:`a_${s}`,type:"Float32",components:n==="color"?4:2,offset:0})),this.paintVertexArray=new a}populatePaintArray(t,r,n,i,o){let a=this.expression.evaluate(new q(this.zoom),r,{},i,[],o),s=this.expression.evaluate(new q(this.zoom+1),r,{},i,[],o),l=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(l,t,a,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:this.zoom},n,i),a=this.expression.evaluate({zoom:this.zoom+1},n,i);this._setPaintValue(t,r,o,a)}_setPaintValue(t,r,n,i){if(this.type==="color"){let o=Cs(n),a=Cs(i);for(let s=t;s<r;s++)this.paintVertexArray.emplace(s,o[0],o[1],a[0],a[1])}else{for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,n,i);this.maxValue=Math.max(this.maxValue,Math.abs(n),Math.abs(i))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}setUniform(t,r){let n=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,i=it(this.expression.interpolationFactor(n,this.zoom,this.zoom+1),0,1);t.set(i)}getBinding(t,r,n){return new Sr(t,r)}},et=class{constructor(t,r,n,i,o,a){this.expression=t,this.type=r,this.useIntegerZoom=n,this.zoom=i,this.layerId=a,this.zoomInPaintVertexArray=new o,this.zoomOutPaintVertexArray=new o}populatePaintArray(t,r,n){let i=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(t),this.zoomOutPaintVertexArray.resize(t),this._setPaintValues(i,t,r.patterns&&r.patterns[this.layerId],n)}updatePaintArray(t,r,n,i,o){this._setPaintValues(t,r,n.patterns&&n.patterns[this.layerId],o)}_setPaintValues(t,r,n,i){if(!i||!n)return;let{min:o,mid:a,max:s}=n,l=i[o],u=i[a],c=i[s];if(!(!l||!u||!c))for(let p=t;p<r;p++)this.zoomInPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],l.tl[0],l.tl[1],l.br[0],l.br[1],u.pixelRatio,l.pixelRatio),this.zoomOutPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1],u.pixelRatio,c.pixelRatio)}upload(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,Nn.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,Nn.members,this.expression.isStateDependent))}destroy(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy()}},Do=class{constructor(t,r,n){this.binders={},this._buffers=[];let i=[];for(let o in t.paint._values){if(!n(o))continue;let a=t.paint.get(o);if(!(a instanceof Se)||!ht(a.property.specification))continue;let s=cd(o,t.type),l=a.value,u=a.property.specification.type,c=a.property.useIntegerZoom,p=a.property.specification["property-type"],f=p==="cross-faded"||p==="cross-faded-data-driven";if(l.kind==="constant")this.binders[o]=f?new At(l.value,s):new Wt(l.value,s,u),i.push(`/u_${o}`);else if(l.kind==="source"||f){let y=kc(o,u,"source");this.binders[o]=f?new et(l,u,c,r,y,t.id):new We(l,s,u,y),i.push(`/a_${o}`)}else{let y=kc(o,u,"composite");this.binders[o]=new De(l,s,u,c,r,y),i.push(`/z_${o}`)}}this.cacheKey=i.sort().join("")}getMaxValue(t){let r=this.binders[t];return r instanceof We||r instanceof De?r.maxValue:0}populatePaintArrays(t,r,n,i,o){for(let a in this.binders){let s=this.binders[a];(s instanceof We||s instanceof De||s instanceof et)&&s.populatePaintArray(t,r,n,i,o)}}setConstantPatternPositions(t,r){for(let n in this.binders){let i=this.binders[n];i instanceof At&&i.setConstantPatternPositions(t,r)}}updatePaintArrays(t,r,n,i,o){let a=!1;for(let s in t){let l=r.getPositions(s);for(let u of l){let c=n.feature(u.index);for(let p in this.binders){let f=this.binders[p];if((f instanceof We||f instanceof De||f instanceof et)&&f.expression.isStateDependent===!0){let y=i.paint.get(p);f.expression=y.value,f.updatePaintArray(u.start,u.end,c,t[s],o),a=!0}}}}return a}defines(){let t=[];for(let r in this.binders){let n=this.binders[r];(n instanceof Wt||n instanceof At)&&t.push(...n.uniformNames.map(i=>`#define HAS_UNIFORM_${i}`))}return t}getBinderAttributes(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof We||n instanceof De)for(let i=0;i<n.paintVertexAttributes.length;i++)t.push(n.paintVertexAttributes[i].name);else if(n instanceof et)for(let i=0;i<Nn.members.length;i++)t.push(Nn.members[i].name)}return t}getBinderUniforms(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof Wt||n instanceof At||n instanceof De)for(let i of n.uniformNames)t.push(i)}return t}getPaintVertexBuffers(){return this._buffers}getUniforms(t,r){let n=[];for(let i in this.binders){let o=this.binders[i];if(o instanceof Wt||o instanceof At||o instanceof De){for(let a of o.uniformNames)if(r[a]){let s=o.getBinding(t,r[a],a);n.push({name:a,property:i,binding:s})}}}return n}setUniforms(t,r,n,i){for(let{name:o,property:a,binding:s}of r)this.binders[a].setUniform(s,i,n.get(a),o)}updatePaintBuffers(t){this._buffers=[];for(let r in this.binders){let n=this.binders[r];if(t&&n instanceof et){let i=t.fromScale===2?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&this._buffers.push(i)}else(n instanceof We||n instanceof De)&&n.paintVertexBuffer&&this._buffers.push(n.paintVertexBuffer)}}upload(t){for(let r in this.binders){let n=this.binders[r];(n instanceof We||n instanceof De||n instanceof et)&&n.upload(t)}this.updatePaintBuffers()}destroy(){for(let t in this.binders){let r=this.binders[t];(r instanceof We||r instanceof De||r instanceof et)&&r.destroy()}}},Ce=class{constructor(t,r,n=()=>!0){this.programConfigurations={};for(let i of t)this.programConfigurations[i.id]=new Do(i,r,n);this.needsUpload=!1,this._featureMap=new Un,this._bufferOffset=0}populatePaintArrays(t,r,n,i,o,a){for(let s in this.programConfigurations)this.programConfigurations[s].populatePaintArrays(t,r,i,o,a);r.id!==void 0&&this._featureMap.add(r.id,n,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0}updatePaintArrays(t,r,n,i){for(let o of n)this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,this._featureMap,r,o,i)||this.needsUpload}get(t){return this.programConfigurations[t]}upload(t){if(this.needsUpload){for(let r in this.programConfigurations)this.programConfigurations[r].upload(t);this.needsUpload=!1}}destroy(){for(let t in this.programConfigurations)this.programConfigurations[t].destroy()}};function cd(e,t){return{"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[e]||[e.replace(`${t}-`,"").replace(/-/g,"_")]}function pd(e){return{"line-pattern":{source:ut,composite:ut},"fill-pattern":{source:ut,composite:ut},"fill-extrusion-pattern":{source:ut,composite:ut}}[e]}function kc(e,t,r){let n={color:{source:St,composite:Pr},number:{source:Zt,composite:St}},i=pd(e);return i&&i[r]||n[t][r]}C("ConstantBinder",Wt);C("CrossFadedConstantBinder",At);C("SourceExpressionBinder",We);C("CrossFadedCompositeBinder",et);C("CompositeExpressionBinder",De);C("ProgramConfiguration",Do,{omit:["_buffers"]});C("ProgramConfigurationSet",Ce);var fd=15,ks=Math.pow(2,fd-1)-1,Mc=-ks-1;function ke(e){let t=8192/e.extent,r=e.loadGeometry();for(let n=0;n<r.length;n++){let i=r[n];for(let o=0;o<i.length;o++){let a=i[o],s=Math.round(a.x*t),l=Math.round(a.y*t);a.x=it(s,Mc,ks),a.y=it(l,Mc,ks),(s<a.x||s>a.x+1||l<a.y||l>a.y+1)&&fe("Geometry exceeds allowed extent, reduce your vector tile buffer size")}}return r}function $e(e,t){return{type:e.type,id:e.id,properties:e.properties,geometry:t?ke(e):[]}}function Vo(e,t,r,n,i){e.emplaceBack(t*2+(n+1)/2,r*2+(i+1)/2)}var Ht=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new Po,this.indexArray=new Le,this.segments=new me,this.programConfigurations=new Ce(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){let i=this.layers[0],o=[],a=null,s=!1;i.type==="circle"&&(a=i.layout.get("circle-sort-key"),s=!a.isConstant());for(let{feature:l,id:u,index:c,sourceLayerIndex:p}of t){let f=this.layers[0]._featureFilter.needGeometry,y=$e(l,f);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),y,n))continue;let m=s?a.evaluate(y,{},n):void 0,h={id:u,properties:l.properties,type:l.type,sourceLayerIndex:p,index:c,geometry:f?y.geometry:ke(l),patterns:{},sortKey:m};o.push(h)}s&&o.sort((l,u)=>l.sortKey-u.sortKey);for(let l of o){let{geometry:u,index:c,sourceLayerIndex:p}=l,f=t[c].feature;this.addFeature(l,u,c,n),r.featureIndex.insert(f,u,c,p,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,wc),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}addFeature(t,r,n,i){for(let o of r)for(let a of o){let s=a.x,l=a.y;if(s<0||s>=8192||l<0||l>=8192)continue;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),c=u.vertexLength;Vo(this.layoutVertexArray,s,l,-1,-1),Vo(this.layoutVertexArray,s,l,1,-1),Vo(this.layoutVertexArray,s,l,1,1),Vo(this.layoutVertexArray,s,l,-1,1),this.indexArray.emplaceBack(c,c+1,c+2),this.indexArray.emplaceBack(c,c+3,c+2),u.vertexLength+=4,u.primitiveLength+=2}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,{},i)}};C("CircleBucket",Ht,{omit:["layers"]});var Gn=Z(he(),1);function Fc(e,t){for(let r=0;r<e.length;r++)if(wr(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(wr(e,t[r]))return!0;return!!Es(e,t)}function Lc(e,t,r){return!!(wr(e,t)||Ms(t,e,r))}function Bo(e,t){if(e.length===1)return Ec(t,e[0]);for(let r=0;r<t.length;r++){let n=t[r];for(let i=0;i<n.length;i++)if(wr(e,n[i]))return!0}for(let r=0;r<e.length;r++)if(Ec(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(Es(e,t[r]))return!0;return!1}function Dc(e,t,r){for(let n=0;n<t.length;n++){let i=t[n];if(e.length>=3){for(let o=0;o<i.length;o++)if(wr(e,i[o]))return!0}if(yd(e,i,r))return!0}return!1}function yd(e,t,r){if(e.length>1){if(Es(e,t))return!0;for(let n=0;n<t.length;n++)if(Ms(t[n],e,r))return!0}for(let n=0;n<e.length;n++)if(Ms(e[n],t,r))return!0;return!1}function Es(e,t){if(e.length===0||t.length===0)return!1;for(let r=0;r<e.length-1;r++){let n=e[r],i=e[r+1];for(let o=0;o<t.length-1;o++){let a=t[o],s=t[o+1];if(md(n,i,a,s))return!0}}return!1}function md(e,t,r,n){return ot(e,r,n)!==ot(t,r,n)&&ot(e,t,r)!==ot(e,t,n)}function Ms(e,t,r){let n=r*r;if(t.length===1)return e.distSqr(t[0])<n;for(let i=1;i<t.length;i++){let o=t[i-1],a=t[i];if(Fs(e,o,a)<n)return!0}return!1}function Fs(e,t,r){let n=t.distSqr(r);if(n===0)return e.distSqr(t);let i=((e.x-t.x)*(r.x-t.x)+(e.y-t.y)*(r.y-t.y))/n;return i<0?e.distSqr(t):i>1?e.distSqr(r):e.distSqr(r.sub(t)._mult(i)._add(t))}function Ec(e,t){let r=!1,n,i,o;for(let a=0;a<e.length;a++){n=e[a];for(let s=0,l=n.length-1;s<n.length;l=s++)i=n[s],o=n[l],i.y>t.y!=o.y>t.y&&t.x<(o.x-i.x)*(t.y-i.y)/(o.y-i.y)+i.x&&(r=!r)}return r}function wr(e,t){let r=!1;for(let n=0,i=e.length-1;n<e.length;i=n++){let o=e[n],a=e[i];o.y>t.y!=a.y>t.y&&t.x<(a.x-o.x)*(t.y-o.y)/(a.y-o.y)+o.x&&(r=!r)}return r}function Vc(e,t,r,n,i){for(let a of e)if(t<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return!0;let o=[new Gn.default(t,r),new Gn.default(t,i),new Gn.default(n,i),new Gn.default(n,r)];if(e.length>2){for(let a of o)if(wr(e,a))return!0}for(let a=0;a<e.length-1;a++){let s=e[a],l=e[a+1];if(hd(s,l,o))return!0}return!1}function hd(e,t,r){let n=r[0],i=r[2];if(e.x<n.x&&t.x<n.x||e.x>i.x&&t.x>i.x||e.y<n.y&&t.y<n.y||e.y>i.y&&t.y>i.y)return!1;let o=ot(e,t,r[0]);return o!==ot(e,t,r[1])||o!==ot(e,t,r[2])||o!==ot(e,t,r[3])}var zo=Z(he(),1);function Xt(e,t,r){let n=t.paint.get(e).value;return n.kind==="constant"?n.value:r.programConfigurations.get(t.id).getMaxValue(e)}function _t(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function It(e,t,r,n,i){if(!t[0]&&!t[1])return e;let o=zo.default.convert(t)._mult(i);r==="viewport"&&o._rotate(-n);let a=[];for(let s=0;s<e.length;s++){let l=e[s];a.push(l.sub(o))}return a}function Bc(e,t){let r=[];for(let n=0;n<e.length;n++){let i=e[n],o=[];for(let a=0;a<i.length;a++){let s=i[a-1],l=i[a],u=i[a+1],c=a===0?new zo.default(0,0):l.sub(s)._unit()._perp(),p=a===i.length-1?new zo.default(0,0):u.sub(l)._unit()._perp(),f=c._add(p)._unit(),y=f.x*p.x+f.y*p.y;y!==0&&f._mult(1/y),o.push(f._mult(t)._add(l))}r.push(o)}return r}var zc,dd=()=>zc=zc||new re({"circle-sort-key":new R(S.layout_circle["circle-sort-key"])}),Rc,gd=()=>Rc=Rc||new re({"circle-radius":new R(S.paint_circle["circle-radius"]),"circle-color":new R(S.paint_circle["circle-color"]),"circle-blur":new R(S.paint_circle["circle-blur"]),"circle-opacity":new R(S.paint_circle["circle-opacity"]),"circle-translate":new B(S.paint_circle["circle-translate"]),"circle-translate-anchor":new B(S.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new B(S.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new B(S.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new R(S.paint_circle["circle-stroke-width"]),"circle-stroke-color":new R(S.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new R(S.paint_circle["circle-stroke-opacity"])}),Oc={get paint(){return gd()},get layout(){return dd()}};var Q=1e-6,Ge=typeof Float32Array<"u"?Float32Array:Array,qn=Math.random;var N1=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var jn={};Ll(jn,{add:()=>tg,adjoint:()=>_d,clone:()=>bd,copy:()=>vd,create:()=>xd,determinant:()=>Id,equals:()=>og,exactEquals:()=>ig,frob:()=>eg,fromQuat:()=>qd,fromQuat2:()=>Od,fromRotation:()=>Vd,fromRotationTranslation:()=>Gc,fromRotationTranslationScale:()=>$d,fromRotationTranslationScaleOrigin:()=>Gd,fromScaling:()=>Dd,fromTranslation:()=>Ld,fromValues:()=>Pd,fromXRotation:()=>Bd,fromYRotation:()=>zd,fromZRotation:()=>Rd,frustum:()=>jd,getRotation:()=>Ud,getScaling:()=>qc,getTranslation:()=>Nd,identity:()=>Uc,invert:()=>Ad,lookAt:()=>Kd,mul:()=>ag,multiply:()=>$c,multiplyScalar:()=>rg,multiplyScalarAndAdd:()=>ng,ortho:()=>Hd,orthoNO:()=>Jc,orthoZO:()=>Xd,perspective:()=>Jd,perspectiveFromFieldOfView:()=>Wd,perspectiveNO:()=>jc,perspectiveZO:()=>Zd,rotate:()=>kd,rotateX:()=>Md,rotateY:()=>Ed,rotateZ:()=>Fd,scale:()=>Cd,set:()=>Sd,str:()=>Qd,sub:()=>sg,subtract:()=>Zc,targetTo:()=>Yd,translate:()=>Td,transpose:()=>wd});function xd(){var e=new Ge(16);return Ge!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function bd(e){var t=new Ge(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function vd(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Pd(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){var d=new Ge(16);return d[0]=e,d[1]=t,d[2]=r,d[3]=n,d[4]=i,d[5]=o,d[6]=a,d[7]=s,d[8]=l,d[9]=u,d[10]=c,d[11]=p,d[12]=f,d[13]=y,d[14]=m,d[15]=h,d}function Sd(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=o,e[5]=a,e[6]=s,e[7]=l,e[8]=u,e[9]=c,e[10]=p,e[11]=f,e[12]=y,e[13]=m,e[14]=h,e[15]=d,e}function Uc(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function wd(e,t){if(e===t){var r=t[1],n=t[2],i=t[3],o=t[6],a=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=o,e[11]=t[14],e[12]=i,e[13]=a,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function Ad(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15],b=r*s-n*a,x=r*l-i*a,v=r*u-o*a,P=n*l-i*s,w=n*u-o*s,T=i*u-o*l,F=c*h-p*m,E=c*d-f*m,_=c*g-y*m,I=p*d-f*h,k=p*g-y*h,V=f*g-y*d,A=b*V-x*k+v*I+P*_-w*E+T*F;return A?(A=1/A,e[0]=(s*V-l*k+u*I)*A,e[1]=(i*k-n*V-o*I)*A,e[2]=(h*T-d*w+g*P)*A,e[3]=(f*w-p*T-y*P)*A,e[4]=(l*_-a*V-u*E)*A,e[5]=(r*V-i*_+o*E)*A,e[6]=(d*v-m*T-g*x)*A,e[7]=(c*T-f*v+y*x)*A,e[8]=(a*k-s*_+u*F)*A,e[9]=(n*_-r*k-o*F)*A,e[10]=(m*w-h*v+g*b)*A,e[11]=(p*v-c*w-y*b)*A,e[12]=(s*E-a*I-l*F)*A,e[13]=(r*I-n*E+i*F)*A,e[14]=(h*x-m*P-d*b)*A,e[15]=(c*P-p*x+f*b)*A,e):null}function _d(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15];return e[0]=s*(f*g-y*d)-p*(l*g-u*d)+h*(l*y-u*f),e[1]=-(n*(f*g-y*d)-p*(i*g-o*d)+h*(i*y-o*f)),e[2]=n*(l*g-u*d)-s*(i*g-o*d)+h*(i*u-o*l),e[3]=-(n*(l*y-u*f)-s*(i*y-o*f)+p*(i*u-o*l)),e[4]=-(a*(f*g-y*d)-c*(l*g-u*d)+m*(l*y-u*f)),e[5]=r*(f*g-y*d)-c*(i*g-o*d)+m*(i*y-o*f),e[6]=-(r*(l*g-u*d)-a*(i*g-o*d)+m*(i*u-o*l)),e[7]=r*(l*y-u*f)-a*(i*y-o*f)+c*(i*u-o*l),e[8]=a*(p*g-y*h)-c*(s*g-u*h)+m*(s*y-u*p),e[9]=-(r*(p*g-y*h)-c*(n*g-o*h)+m*(n*y-o*p)),e[10]=r*(s*g-u*h)-a*(n*g-o*h)+m*(n*u-o*s),e[11]=-(r*(s*y-u*p)-a*(n*y-o*p)+c*(n*u-o*s)),e[12]=-(a*(p*d-f*h)-c*(s*d-l*h)+m*(s*f-l*p)),e[13]=r*(p*d-f*h)-c*(n*d-i*h)+m*(n*f-i*p),e[14]=-(r*(s*d-l*h)-a*(n*d-i*h)+m*(n*l-i*s)),e[15]=r*(s*f-l*p)-a*(n*f-i*p)+c*(n*l-i*s),e}function Id(e){var t=e[0],r=e[1],n=e[2],i=e[3],o=e[4],a=e[5],s=e[6],l=e[7],u=e[8],c=e[9],p=e[10],f=e[11],y=e[12],m=e[13],h=e[14],d=e[15],g=t*a-r*o,b=t*s-n*o,x=t*l-i*o,v=r*s-n*a,P=r*l-i*a,w=n*l-i*s,T=u*m-c*y,F=u*h-p*y,E=u*d-f*y,_=c*h-p*m,I=c*d-f*m,k=p*d-f*h;return g*k-b*I+x*_+v*E-P*F+w*T}function $c(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=t[8],f=t[9],y=t[10],m=t[11],h=t[12],d=t[13],g=t[14],b=t[15],x=r[0],v=r[1],P=r[2],w=r[3];return e[0]=x*n+v*s+P*p+w*h,e[1]=x*i+v*l+P*f+w*d,e[2]=x*o+v*u+P*y+w*g,e[3]=x*a+v*c+P*m+w*b,x=r[4],v=r[5],P=r[6],w=r[7],e[4]=x*n+v*s+P*p+w*h,e[5]=x*i+v*l+P*f+w*d,e[6]=x*o+v*u+P*y+w*g,e[7]=x*a+v*c+P*m+w*b,x=r[8],v=r[9],P=r[10],w=r[11],e[8]=x*n+v*s+P*p+w*h,e[9]=x*i+v*l+P*f+w*d,e[10]=x*o+v*u+P*y+w*g,e[11]=x*a+v*c+P*m+w*b,x=r[12],v=r[13],P=r[14],w=r[15],e[12]=x*n+v*s+P*p+w*h,e[13]=x*i+v*l+P*f+w*d,e[14]=x*o+v*u+P*y+w*g,e[15]=x*a+v*c+P*m+w*b,e}function Td(e,t,r){var n=r[0],i=r[1],o=r[2],a,s,l,u,c,p,f,y,m,h,d,g;return t===e?(e[12]=t[0]*n+t[4]*i+t[8]*o+t[12],e[13]=t[1]*n+t[5]*i+t[9]*o+t[13],e[14]=t[2]*n+t[6]*i+t[10]*o+t[14],e[15]=t[3]*n+t[7]*i+t[11]*o+t[15]):(a=t[0],s=t[1],l=t[2],u=t[3],c=t[4],p=t[5],f=t[6],y=t[7],m=t[8],h=t[9],d=t[10],g=t[11],e[0]=a,e[1]=s,e[2]=l,e[3]=u,e[4]=c,e[5]=p,e[6]=f,e[7]=y,e[8]=m,e[9]=h,e[10]=d,e[11]=g,e[12]=a*n+c*i+m*o+t[12],e[13]=s*n+p*i+h*o+t[13],e[14]=l*n+f*i+d*o+t[14],e[15]=u*n+y*i+g*o+t[15]),e}function Cd(e,t,r){var n=r[0],i=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function kd(e,t,r,n){var i=n[0],o=n[1],a=n[2],s=Math.hypot(i,o,a),l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V,A,z;return s<Q?null:(s=1/s,i*=s,o*=s,a*=s,l=Math.sin(r),u=Math.cos(r),c=1-u,p=t[0],f=t[1],y=t[2],m=t[3],h=t[4],d=t[5],g=t[6],b=t[7],x=t[8],v=t[9],P=t[10],w=t[11],T=i*i*c+u,F=o*i*c+a*l,E=a*i*c-o*l,_=i*o*c-a*l,I=o*o*c+u,k=a*o*c+i*l,V=i*a*c+o*l,A=o*a*c-i*l,z=a*a*c+u,e[0]=p*T+h*F+x*E,e[1]=f*T+d*F+v*E,e[2]=y*T+g*F+P*E,e[3]=m*T+b*F+w*E,e[4]=p*_+h*I+x*k,e[5]=f*_+d*I+v*k,e[6]=y*_+g*I+P*k,e[7]=m*_+b*I+w*k,e[8]=p*V+h*A+x*z,e[9]=f*V+d*A+v*z,e[10]=y*V+g*A+P*z,e[11]=m*V+b*A+w*z,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function Md(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[4],a=t[5],s=t[6],l=t[7],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*i+u*n,e[5]=a*i+c*n,e[6]=s*i+p*n,e[7]=l*i+f*n,e[8]=u*i-o*n,e[9]=c*i-a*n,e[10]=p*i-s*n,e[11]=f*i-l*n,e}function Ed(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i-u*n,e[1]=a*i-c*n,e[2]=s*i-p*n,e[3]=l*i-f*n,e[8]=o*n+u*i,e[9]=a*n+c*i,e[10]=s*n+p*i,e[11]=l*n+f*i,e}function Fd(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[4],c=t[5],p=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i+u*n,e[1]=a*i+c*n,e[2]=s*i+p*n,e[3]=l*i+f*n,e[4]=u*i-o*n,e[5]=c*i-a*n,e[6]=p*i-s*n,e[7]=f*i-l*n,e}function Ld(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function Dd(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Vd(e,t,r){var n=r[0],i=r[1],o=r[2],a=Math.hypot(n,i,o),s,l,u;return a<Q?null:(a=1/a,n*=a,i*=a,o*=a,s=Math.sin(t),l=Math.cos(t),u=1-l,e[0]=n*n*u+l,e[1]=i*n*u+o*s,e[2]=o*n*u-i*s,e[3]=0,e[4]=n*i*u-o*s,e[5]=i*i*u+l,e[6]=o*i*u+n*s,e[7]=0,e[8]=n*o*u+i*s,e[9]=i*o*u-n*s,e[10]=o*o*u+l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function Bd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function zd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Rd(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Gc(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=n+n,l=i+i,u=o+o,c=n*s,p=n*l,f=n*u,y=i*l,m=i*u,h=o*u,d=a*s,g=a*l,b=a*u;return e[0]=1-(y+h),e[1]=p+b,e[2]=f-g,e[3]=0,e[4]=p-b,e[5]=1-(c+h),e[6]=m+d,e[7]=0,e[8]=f+g,e[9]=m-d,e[10]=1-(c+y),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Od(e,t){var r=new Ge(3),n=-t[0],i=-t[1],o=-t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=n*n+i*i+o*o+a*a;return p>0?(r[0]=(s*a+c*n+l*o-u*i)*2/p,r[1]=(l*a+c*i+u*n-s*o)*2/p,r[2]=(u*a+c*o+s*i-l*n)*2/p):(r[0]=(s*a+c*n+l*o-u*i)*2,r[1]=(l*a+c*i+u*n-s*o)*2,r[2]=(u*a+c*o+s*i-l*n)*2),Gc(e,t,r),e}function Nd(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function qc(e,t){var r=t[0],n=t[1],i=t[2],o=t[4],a=t[5],s=t[6],l=t[8],u=t[9],c=t[10];return e[0]=Math.hypot(r,n,i),e[1]=Math.hypot(o,a,s),e[2]=Math.hypot(l,u,c),e}function Ud(e,t){var r=new Ge(3);qc(r,t);var n=1/r[0],i=1/r[1],o=1/r[2],a=t[0]*n,s=t[1]*i,l=t[2]*o,u=t[4]*n,c=t[5]*i,p=t[6]*o,f=t[8]*n,y=t[9]*i,m=t[10]*o,h=a+c+m,d=0;return h>0?(d=Math.sqrt(h+1)*2,e[3]=.25*d,e[0]=(p-y)/d,e[1]=(f-l)/d,e[2]=(s-u)/d):a>c&&a>m?(d=Math.sqrt(1+a-c-m)*2,e[3]=(p-y)/d,e[0]=.25*d,e[1]=(s+u)/d,e[2]=(f+l)/d):c>m?(d=Math.sqrt(1+c-a-m)*2,e[3]=(f-l)/d,e[0]=(s+u)/d,e[1]=.25*d,e[2]=(p+y)/d):(d=Math.sqrt(1+m-a-c)*2,e[3]=(s-u)/d,e[0]=(f+l)/d,e[1]=(p+y)/d,e[2]=.25*d),e}function $d(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3],l=i+i,u=o+o,c=a+a,p=i*l,f=i*u,y=i*c,m=o*u,h=o*c,d=a*c,g=s*l,b=s*u,x=s*c,v=n[0],P=n[1],w=n[2];return e[0]=(1-(m+d))*v,e[1]=(f+x)*v,e[2]=(y-b)*v,e[3]=0,e[4]=(f-x)*P,e[5]=(1-(p+d))*P,e[6]=(h+g)*P,e[7]=0,e[8]=(y+b)*w,e[9]=(h-g)*w,e[10]=(1-(p+m))*w,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Gd(e,t,r,n,i){var o=t[0],a=t[1],s=t[2],l=t[3],u=o+o,c=a+a,p=s+s,f=o*u,y=o*c,m=o*p,h=a*c,d=a*p,g=s*p,b=l*u,x=l*c,v=l*p,P=n[0],w=n[1],T=n[2],F=i[0],E=i[1],_=i[2],I=(1-(h+g))*P,k=(y+v)*P,V=(m-x)*P,A=(y-v)*w,z=(1-(f+g))*w,O=(d+b)*w,N=(m+x)*T,K=(d-b)*T,xe=(1-(f+h))*T;return e[0]=I,e[1]=k,e[2]=V,e[3]=0,e[4]=A,e[5]=z,e[6]=O,e[7]=0,e[8]=N,e[9]=K,e[10]=xe,e[11]=0,e[12]=r[0]+F-(I*F+A*E+N*_),e[13]=r[1]+E-(k*F+z*E+K*_),e[14]=r[2]+_-(V*F+O*E+xe*_),e[15]=1,e}function qd(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r+r,s=n+n,l=i+i,u=r*a,c=n*a,p=n*s,f=i*a,y=i*s,m=i*l,h=o*a,d=o*s,g=o*l;return e[0]=1-p-m,e[1]=c+g,e[2]=f-d,e[3]=0,e[4]=c-g,e[5]=1-u-m,e[6]=y+h,e[7]=0,e[8]=f+d,e[9]=y-h,e[10]=1-u-p,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function jd(e,t,r,n,i,o,a){var s=1/(r-t),l=1/(i-n),u=1/(o-a);return e[0]=o*2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o*2*l,e[6]=0,e[7]=0,e[8]=(r+t)*s,e[9]=(i+n)*l,e[10]=(a+o)*u,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*o*2*u,e[15]=0,e}function jc(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=(i+n)*a,e[14]=2*i*n*a):(e[10]=-1,e[14]=-2*n),e}var Jd=jc;function Zd(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=i*a,e[14]=i*n*a):(e[10]=-1,e[14]=-n),e}function Wd(e,t,r,n){var i=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(a+s),u=2/(i+o);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=u,e[6]=0,e[7]=0,e[8]=-((a-s)*l*.5),e[9]=(i-o)*u*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}function Jc(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=(a+o)*u,e[15]=1,e}var Hd=Jc;function Xd(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=o*u,e[15]=1,e}function Kd(e,t,r,n){var i,o,a,s,l,u,c,p,f,y,m=t[0],h=t[1],d=t[2],g=n[0],b=n[1],x=n[2],v=r[0],P=r[1],w=r[2];return Math.abs(m-v)<Q&&Math.abs(h-P)<Q&&Math.abs(d-w)<Q?Uc(e):(c=m-v,p=h-P,f=d-w,y=1/Math.hypot(c,p,f),c*=y,p*=y,f*=y,i=b*f-x*p,o=x*c-g*f,a=g*p-b*c,y=Math.hypot(i,o,a),y?(y=1/y,i*=y,o*=y,a*=y):(i=0,o=0,a=0),s=p*a-f*o,l=f*i-c*a,u=c*o-p*i,y=Math.hypot(s,l,u),y?(y=1/y,s*=y,l*=y,u*=y):(s=0,l=0,u=0),e[0]=i,e[1]=s,e[2]=c,e[3]=0,e[4]=o,e[5]=l,e[6]=p,e[7]=0,e[8]=a,e[9]=u,e[10]=f,e[11]=0,e[12]=-(i*m+o*h+a*d),e[13]=-(s*m+l*h+u*d),e[14]=-(c*m+p*h+f*d),e[15]=1,e)}function Yd(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=n[0],l=n[1],u=n[2],c=i-r[0],p=o-r[1],f=a-r[2],y=c*c+p*p+f*f;y>0&&(y=1/Math.sqrt(y),c*=y,p*=y,f*=y);var m=l*f-u*p,h=u*c-s*f,d=s*p-l*c;return y=m*m+h*h+d*d,y>0&&(y=1/Math.sqrt(y),m*=y,h*=y,d*=y),e[0]=m,e[1]=h,e[2]=d,e[3]=0,e[4]=p*d-f*h,e[5]=f*m-c*d,e[6]=c*h-p*m,e[7]=0,e[8]=c,e[9]=p,e[10]=f,e[11]=0,e[12]=i,e[13]=o,e[14]=a,e[15]=1,e}function Qd(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function eg(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function tg(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e}function Zc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e}function rg(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12]*r,e[13]=t[13]*r,e[14]=t[14]*r,e[15]=t[15]*r,e}function ng(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e[9]=t[9]+r[9]*n,e[10]=t[10]+r[10]*n,e[11]=t[11]+r[11]*n,e[12]=t[12]+r[12]*n,e[13]=t[13]+r[13]*n,e[14]=t[14]+r[14]*n,e[15]=t[15]+r[15]*n,e}function ig(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function og(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],l=e[6],u=e[7],c=e[8],p=e[9],f=e[10],y=e[11],m=e[12],h=e[13],d=e[14],g=e[15],b=t[0],x=t[1],v=t[2],P=t[3],w=t[4],T=t[5],F=t[6],E=t[7],_=t[8],I=t[9],k=t[10],V=t[11],A=t[12],z=t[13],O=t[14],N=t[15];return Math.abs(r-b)<=Q*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(n-x)<=Q*Math.max(1,Math.abs(n),Math.abs(x))&&Math.abs(i-v)<=Q*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(o-P)<=Q*Math.max(1,Math.abs(o),Math.abs(P))&&Math.abs(a-w)<=Q*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(s-T)<=Q*Math.max(1,Math.abs(s),Math.abs(T))&&Math.abs(l-F)<=Q*Math.max(1,Math.abs(l),Math.abs(F))&&Math.abs(u-E)<=Q*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(c-_)<=Q*Math.max(1,Math.abs(c),Math.abs(_))&&Math.abs(p-I)<=Q*Math.max(1,Math.abs(p),Math.abs(I))&&Math.abs(f-k)<=Q*Math.max(1,Math.abs(f),Math.abs(k))&&Math.abs(y-V)<=Q*Math.max(1,Math.abs(y),Math.abs(V))&&Math.abs(m-A)<=Q*Math.max(1,Math.abs(m),Math.abs(A))&&Math.abs(h-z)<=Q*Math.max(1,Math.abs(h),Math.abs(z))&&Math.abs(d-O)<=Q*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(g-N)<=Q*Math.max(1,Math.abs(g),Math.abs(N))}var ag=$c,sg=Zc;var Kt={};Ll(Kt,{add:()=>fg,ceil:()=>yg,clone:()=>lg,copy:()=>cg,create:()=>Wc,cross:()=>Ag,dist:()=>Bg,distance:()=>Yc,div:()=>Vg,divide:()=>Kc,dot:()=>wg,equals:()=>Fg,exactEquals:()=>Eg,floor:()=>mg,forEach:()=>Ng,fromValues:()=>ug,inverse:()=>Pg,len:()=>Rg,length:()=>ep,lerp:()=>_g,max:()=>dg,min:()=>hg,mul:()=>Dg,multiply:()=>Xc,negate:()=>vg,normalize:()=>Sg,random:()=>Ig,round:()=>gg,scale:()=>xg,scaleAndAdd:()=>bg,set:()=>pg,sqrDist:()=>zg,sqrLen:()=>Og,squaredDistance:()=>Qc,squaredLength:()=>tp,str:()=>Mg,sub:()=>Lg,subtract:()=>Hc,transformMat4:()=>Tg,transformQuat:()=>Cg,zero:()=>kg});function Wc(){var e=new Ge(4);return Ge!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function lg(e){var t=new Ge(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function ug(e,t,r,n){var i=new Ge(4);return i[0]=e,i[1]=t,i[2]=r,i[3]=n,i}function cg(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function pg(e,t,r,n,i){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e}function fg(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function Hc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function Xc(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function Kc(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e[3]=t[3]/r[3],e}function yg(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e}function mg(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e}function hg(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e[3]=Math.min(t[3],r[3]),e}function dg(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e[3]=Math.max(t[3],r[3]),e}function gg(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e}function xg(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function bg(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e}function Yc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return Math.hypot(r,n,i,o)}function Qc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return r*r+n*n+i*i+o*o}function ep(e){var t=e[0],r=e[1],n=e[2],i=e[3];return Math.hypot(t,r,n,i)}function tp(e){var t=e[0],r=e[1],n=e[2],i=e[3];return t*t+r*r+n*n+i*i}function vg(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function Pg(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e}function Sg(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=r*a,e[1]=n*a,e[2]=i*a,e[3]=o*a,e}function wg(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function Ag(e,t,r,n){var i=r[0]*n[1]-r[1]*n[0],o=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],s=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=t[0],p=t[1],f=t[2],y=t[3];return e[0]=p*u-f*l+y*s,e[1]=-(c*u)+f*a-y*o,e[2]=c*l-p*a+y*i,e[3]=-(c*s)+p*o-f*i,e}function _g(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3];return e[0]=i+n*(r[0]-i),e[1]=o+n*(r[1]-o),e[2]=a+n*(r[2]-a),e[3]=s+n*(r[3]-s),e}function Ig(e,t){t=t||1;var r,n,i,o,a,s;do r=qn()*2-1,n=qn()*2-1,a=r*r+n*n;while(a>=1);do i=qn()*2-1,o=qn()*2-1,s=i*i+o*o;while(s>=1);var l=Math.sqrt((1-a)/s);return e[0]=t*r,e[1]=t*n,e[2]=t*i*l,e[3]=t*o*l,e}function Tg(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3];return e[0]=r[0]*n+r[4]*i+r[8]*o+r[12]*a,e[1]=r[1]*n+r[5]*i+r[9]*o+r[13]*a,e[2]=r[2]*n+r[6]*i+r[10]*o+r[14]*a,e[3]=r[3]*n+r[7]*i+r[11]*o+r[15]*a,e}function Cg(e,t,r){var n=t[0],i=t[1],o=t[2],a=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*o-l*i,p=u*i+l*n-a*o,f=u*o+a*i-s*n,y=-a*n-s*i-l*o;return e[0]=c*u+y*-a+p*-l-f*-s,e[1]=p*u+y*-s+f*-a-c*-l,e[2]=f*u+y*-l+c*-s-p*-a,e[3]=t[3],e}function kg(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function Mg(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function Eg(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function Fg(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=t[0],s=t[1],l=t[2],u=t[3];return Math.abs(r-a)<=Q*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=Q*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-l)<=Q*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-u)<=Q*Math.max(1,Math.abs(o),Math.abs(u))}var Lg=Hc,Dg=Xc,Vg=Kc,Bg=Yc,zg=Qc,Rg=ep,Og=tp,Ng=function(){var e=Wc();return function(t,r,n,i,o,a){var s,l;for(r||(r=4),n||(n=0),i?l=Math.min(i*r+n,t.length):l=t.length,s=n;s<l;s+=r)e[0]=t[s],e[1]=t[s+1],e[2]=t[s+2],e[3]=t[s+3],o(e,e,a),t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3];return t}}();var rp=Z(he(),1),Ro=class extends se{constructor(t){super(t,Oc)}createBucket(t){return new Ht(t)}queryRadius(t){let r=t;return Xt("circle-radius",this,r)+Xt("circle-stroke-width",this,r)+_t(this.paint.get("circle-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s,l){let u=It(t,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,s),c=this.paint.get("circle-radius").evaluate(r,n),p=this.paint.get("circle-stroke-width").evaluate(r,n),f=c+p,y=this.paint.get("circle-pitch-alignment")==="map",m=y?u:Ug(u,l),h=y?f*s:f;for(let d of i)for(let g of d){let b=y?g:np(g,l),x=h,v=Kt.transformMat4([],[g.x,g.y,0,1],l);if(this.paint.get("circle-pitch-scale")==="viewport"&&this.paint.get("circle-pitch-alignment")==="map"?x*=v[3]/a.cameraToCenterDistance:this.paint.get("circle-pitch-scale")==="map"&&this.paint.get("circle-pitch-alignment")==="viewport"&&(x*=a.cameraToCenterDistance/v[3]),Lc(m,b,x))return!0}return!1}};function np(e,t){let r=Kt.transformMat4([],[e.x,e.y,0,1],t);return new rp.default(r[0]/r[3],r[1]/r[3])}function Ug(e,t){return e.map(r=>np(r,t))}var Jn=class extends Ht{};C("HeatmapBucket",Jn,{omit:["layers"]});var ip,$g=()=>ip=ip||new re({"heatmap-radius":new R(S.paint_heatmap["heatmap-radius"]),"heatmap-weight":new R(S.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new B(S.paint_heatmap["heatmap-intensity"]),"heatmap-color":new jt(S.paint_heatmap["heatmap-color"]),"heatmap-opacity":new B(S.paint_heatmap["heatmap-opacity"])}),op={get paint(){return $g()}};function Ls(e,{width:t,height:r},n,i){if(!i)i=new Uint8Array(t*r*n);else if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==t*r*n)throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${t*r*n}`);return e.width=t,e.height=r,e.data=i,e}function ap(e,{width:t,height:r},n){if(t===e.width&&r===e.height)return;let i=Ls({},{width:t,height:r},n);Ds(e,i,{x:0,y:0},{x:0,y:0},{width:Math.min(e.width,t),height:Math.min(e.height,r)},n),e.width=t,e.height=r,e.data=i.data}function Ds(e,t,r,n,i,o){if(i.width===0||i.height===0)return t;if(i.width>e.width||i.height>e.height||r.x>e.width-i.width||r.y>e.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>t.width||i.height>t.height||n.x>t.width-i.width||n.y>t.height-i.height)throw new RangeError("out of range destination coordinates for image copy");let a=e.data,s=t.data;if(a===s)throw new Error("srcData equals dstData, so image is already copied");for(let l=0;l<i.height;l++){let u=((r.y+l)*e.width+r.x)*o,c=((n.y+l)*t.width+n.x)*o;for(let p=0;p<i.width*o;p++)s[c+p]=a[u+p]}return t}var Yt=class e{constructor(t,r){Ls(this,t,1,r)}resize(t){ap(this,t,1)}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){Ds(t,r,n,i,o,1)}},de=class e{constructor(t,r){Ls(this,t,4,r)}resize(t){ap(this,t,4)}replace(t,r){r?this.data.set(t):t instanceof Uint8ClampedArray?this.data=new Uint8Array(t.buffer):this.data=t}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){Ds(t,r,n,i,o,4)}};C("AlphaImage",Yt);C("RGBAImage",de);function sp(e){let t={},r=e.resolution||256,n=e.clips?e.clips.length:1,i=e.image||new de({width:r,height:n});if(!ql(r))throw new Error(`width is not a power of 2 - ${r}`);let o=(a,s,l)=>{t[e.evaluationKey]=l;let u=e.expression.evaluate(t);i.data[a+s+0]=Math.floor(u.r*255/u.a),i.data[a+s+1]=Math.floor(u.g*255/u.a),i.data[a+s+2]=Math.floor(u.b*255/u.a),i.data[a+s+3]=Math.floor(u.a*255)};if(e.clips)for(let a=0,s=0;a<n;++a,s+=r*4)for(let l=0,u=0;l<r;l++,u+=4){let c=l/(r-1),{start:p,end:f}=e.clips[a],y=p*(1-c)+f*c;o(s,u,y)}else for(let a=0,s=0;a<r;a++,s+=4){let l=a/(r-1);o(0,s,l)}return i}var Oo=class extends se{createBucket(t){return new Jn(t)}constructor(t){super(t,op),this._updateColorRamp()}_handleSpecialPaintPropertyUpdate(t){t==="heatmap-color"&&this._updateColorRamp()}_updateColorRamp(){let t=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=sp({expression:t,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null)}queryRadius(){return 0}queryIntersectsFeature(){return!1}hasOffscreenPass(){return this.paint.get("heatmap-opacity")!==0&&this.visibility!=="none"}};var lp,Gg=()=>lp=lp||new re({"hillshade-illumination-direction":new B(S.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new B(S.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new B(S.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new B(S.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new B(S.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new B(S.paint_hillshade["hillshade-accent-color"])}),up={get paint(){return Gg()}};var No=class extends se{constructor(t){super(t,up)}hasOffscreenPass(){return this.paint.get("hillshade-exaggeration")!==0&&this.visibility!=="none"}};var qg=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:cp,size:LP,alignment:DP}=qg;var dp=Z(Os(),1);function Ns(e,t,r,n,i){hp(e,t,r||0,n||e.length-1,i||ax)}function hp(e,t,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=t-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(t-a*l/o+u)),p=Math.min(n,Math.floor(t+(o-a)*l/o+u));hp(e,t,c,p,i)}var f=e[t],y=r,m=n;for(Xn(e,r,t),i(e[n],f)>0&&Xn(e,r,n);y<m;){for(Xn(e,y,m),y++,m--;i(e[y],f)<0;)y++;for(;i(e[m],f)>0;)m--}i(e[r],f)===0?Xn(e,r,m):(m++,Xn(e,m,n)),m<=t&&(r=m+1),t<=m&&(n=m-1)}}function Xn(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function ax(e,t){return e<t?-1:e>t?1:0}function _r(e,t){let r=e.length;if(r<=1)return[e];let n=[],i,o;for(let a=0;a<r;a++){let s=Zl(e[a]);s!==0&&(e[a].area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[e[a]]):i.push(e[a]))}if(i&&n.push(i),t>1)for(let a=0;a<n.length;a++)n[a].length<=t||(Ns(n[a],t,1,n[a].length-1,sx),n[a]=n[a].slice(0,t));return n}function sx(e,t){return t.area-e.area}function Ir(e,t,r){let n=r.patternDependencies,i=!1;for(let o of t){let a=o.paint.get(`${e}-pattern`);a.isConstant()||(i=!0);let s=a.constantOr(null);s&&(i=!0,n[s.to]=!0,n[s.from]=!0)}return i}function Tr(e,t,r,n,i){let o=i.patternDependencies;for(let a of t){let l=a.paint.get(`${e}-pattern`).value;if(l.kind!=="constant"){let u=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),p=l.evaluate({zoom:n+1},r,{},i.availableImages);u=u&&u.name?u.name:u,c=c&&c.name?c.name:c,p=p&&p.name?p.name:p,o[u]=!0,o[c]=!0,o[p]=!0,r.patterns[a.id]={min:u,mid:c,max:p}}}return r}var lx=500,er=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new So,this.indexArray=new Le,this.indexArray2=new wt,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.segments2=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=Ir("fill",this.layers,r);let i=this.layers[0].layout.get("fill-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n,r.availableImages):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Tr("fill",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,cp),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy())}addFeature(t,r,n,i,o){for(let a of _r(r,lx)){let s=0;for(let y of a)s+=y.length;let l=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray),u=l.vertexLength,c=[],p=[];for(let y of a){if(y.length===0)continue;y!==a[0]&&p.push(c.length/2);let m=this.segments2.prepareSegment(y.length,this.layoutVertexArray,this.indexArray2),h=m.vertexLength;this.layoutVertexArray.emplaceBack(y[0].x,y[0].y),this.indexArray2.emplaceBack(h+y.length-1,h),c.push(y[0].x),c.push(y[0].y);for(let d=1;d<y.length;d++)this.layoutVertexArray.emplaceBack(y[d].x,y[d].y),this.indexArray2.emplaceBack(h+d-1,h+d),c.push(y[d].x),c.push(y[d].y);m.vertexLength+=y.length,m.primitiveLength+=y.length}let f=(0,dp.default)(c,p);for(let y=0;y<f.length;y+=3)this.indexArray.emplaceBack(u+f[y],u+f[y+1],u+f[y+2]);l.vertexLength+=s,l.primitiveLength+=f.length/3}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};C("FillBucket",er,{omit:["layers","patternFeatures"]});var gp,ux=()=>gp=gp||new re({"fill-sort-key":new R(S.layout_fill["fill-sort-key"])}),xp,cx=()=>xp=xp||new re({"fill-antialias":new B(S.paint_fill["fill-antialias"]),"fill-opacity":new R(S.paint_fill["fill-opacity"]),"fill-color":new R(S.paint_fill["fill-color"]),"fill-outline-color":new R(S.paint_fill["fill-outline-color"]),"fill-translate":new B(S.paint_fill["fill-translate"]),"fill-translate-anchor":new B(S.paint_fill["fill-translate-anchor"]),"fill-pattern":new lt(S.paint_fill["fill-pattern"])}),bp={get paint(){return cx()},get layout(){return ux()}};var jo=class extends se{constructor(t){super(t,bp)}recalculate(t,r){super.recalculate(t,r);let n=this.paint._values["fill-outline-color"];n.value.kind==="constant"&&n.value.value===void 0&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"])}createBucket(t){return new er(t)}queryRadius(){return _t(this.paint.get("fill-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s){let l=It(t,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,s);return Bo(l,i)}isTileClipped(){return!0}};var px=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4),vp=Y([{name:"a_centroid",components:2,type:"Int16"}],4);var{members:Pp,size:dS,alignment:gS}=px;var Tp=Z(Os(),1),Cp=Z(Tt(),1);var wx=Cp.default.VectorTileFeature.types,Ax=500,Gs=Math.pow(2,13);function Kn(e,t,r,n,i,o,a,s){e.emplaceBack(t,r,Math.floor(n*Gs)*2+a,i*Gs*2,o*Gs*2,Math.round(s))}var tr=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new wo,this.centroidVertexArray=new vo,this.indexArray=new Le,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.features=[],this.hasPattern=Ir("fill-extrusion",this.layers,r);for(let{feature:i,id:o,index:a,sourceLayerIndex:s}of t){let l=this.layers[0]._featureFilter.needGeometry,u=$e(i,l);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),u,n))continue;let c={id:o,sourceLayerIndex:s,index:a,geometry:l?u.geometry:ke(i),properties:i.properties,type:i.type,patterns:{}};this.hasPattern?this.features.push(Tr("fill-extrusion",this.layers,c,this.zoom,r)):this.addFeature(c,c.geometry,a,n,{}),r.featureIndex.insert(i,c.geometry,a,s,this.index,!0)}}addFeatures(t,r,n){for(let i of this.features){let{geometry:o}=i;this.addFeature(i,o,i.index,r,n)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0&&this.centroidVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Pp),this.centroidVertexBuffer=t.createVertexBuffer(this.centroidVertexArray,vp.members,!0),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.centroidVertexBuffer.destroy())}addFeature(t,r,n,i,o){let a={x:0,y:0,vertexCount:0};for(let s of _r(r,Ax)){let l=0;for(let m of s)l+=m.length;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray);for(let m of s){if(m.length===0||Ix(m))continue;let h=0;for(let d=0;d<m.length;d++){let g=m[d];if(d>=1){let b=m[d-1];if(!_x(g,b)){u.vertexLength+4>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));let x=g.sub(b)._perp()._unit(),v=b.dist(g);h+v>32768&&(h=0),Kn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,0,h),Kn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,1,h),a.x+=2*g.x,a.y+=2*g.y,a.vertexCount+=2,h+=v,Kn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,0,h),Kn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,1,h),a.x+=2*b.x,a.y+=2*b.y,a.vertexCount+=2;let P=u.vertexLength;this.indexArray.emplaceBack(P,P+2,P+1),this.indexArray.emplaceBack(P+1,P+2,P+3),u.vertexLength+=4,u.primitiveLength+=2}}}}if(u.vertexLength+l>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(l,this.layoutVertexArray,this.indexArray)),wx[t.type]!=="Polygon")continue;let c=[],p=[],f=u.vertexLength;for(let m of s)if(m.length!==0){m!==s[0]&&p.push(c.length/2);for(let h=0;h<m.length;h++){let d=m[h];Kn(this.layoutVertexArray,d.x,d.y,0,0,1,1,0),a.x+=d.x,a.y+=d.y,a.vertexCount+=1,c.push(d.x),c.push(d.y)}}let y=(0,Tp.default)(c,p);for(let m=0;m<y.length;m+=3)this.indexArray.emplaceBack(f+y[m],f+y[m+2],f+y[m+1]);u.primitiveLength+=y.length/3,u.vertexLength+=l}for(let s=0;s<a.vertexCount;s++)this.centroidVertexArray.emplaceBack(Math.floor(a.x/a.vertexCount),Math.floor(a.y/a.vertexCount));this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};C("FillExtrusionBucket",tr,{omit:["layers","features"]});function _x(e,t){return e.x===t.x&&(e.x<0||e.x>8192)||e.y===t.y&&(e.y<0||e.y>8192)}function Ix(e){return e.every(t=>t.x<0)||e.every(t=>t.x>8192)||e.every(t=>t.y<0)||e.every(t=>t.y>8192)}var kp,Tx=()=>kp=kp||new re({"fill-extrusion-opacity":new B(S["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new R(S["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new B(S["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new B(S["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new lt(S["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new R(S["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new R(S["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new B(S["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])}),Mp={get paint(){return Tx()}};var Zo=Z(he(),1);var Wo=class extends se{constructor(t){super(t,Mp)}createBucket(t){return new tr(t)}queryRadius(){return _t(this.paint.get("fill-extrusion-translate"))}is3D(){return!0}queryIntersectsFeature(t,r,n,i,o,a,s,l){let u=It(t,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),a.angle,s),c=this.paint.get("fill-extrusion-height").evaluate(r,n),p=this.paint.get("fill-extrusion-base").evaluate(r,n),f=Mx(u,l,a,0),y=kx(i,p,c,l),m=y[0],h=y[1];return Cx(m,h,f)}};function Yn(e,t){return e.x*t.x+e.y*t.y}function Ep(e,t){if(e.length===1){let r=0,n=t[r++],i;for(;!i||n.equals(i);)if(i=t[r++],!i)return 1/0;for(;r<t.length;r++){let o=t[r],a=e[0],s=i.sub(n),l=o.sub(n),u=a.sub(n),c=Yn(s,s),p=Yn(s,l),f=Yn(l,l),y=Yn(u,s),m=Yn(u,l),h=c*f-p*p,d=(f*y-p*m)/h,g=(c*m-p*y)/h,b=1-d-g,x=n.z*b+i.z*d+o.z*g;if(isFinite(x))return x}return 1/0}else{let r=1/0;for(let n of t)r=Math.min(r,n.z);return r}}function Cx(e,t,r){let n=1/0;Bo(r,t)&&(n=Ep(r,t[0]));for(let i=0;i<t.length;i++){let o=t[i],a=e[i];for(let s=0;s<o.length-1;s++){let l=o[s],u=o[s+1],c=a[s],p=a[s+1],f=[l,u,p,c,l];Fc(r,f)&&(n=Math.min(n,Ep(r,f)))}}return n===1/0?!1:n}function kx(e,t,r,n){let i=[],o=[],a=n[8]*t,s=n[9]*t,l=n[10]*t,u=n[11]*t,c=n[8]*r,p=n[9]*r,f=n[10]*r,y=n[11]*r;for(let m of e){let h=[],d=[];for(let g of m){let b=g.x,x=g.y,v=n[0]*b+n[4]*x+n[12],P=n[1]*b+n[5]*x+n[13],w=n[2]*b+n[6]*x+n[14],T=n[3]*b+n[7]*x+n[15],F=v+a,E=P+s,_=w+l,I=T+u,k=v+c,V=P+p,A=w+f,z=T+y,O=new Zo.default(F/I,E/I);O.z=_/I,h.push(O);let N=new Zo.default(k/z,V/z);N.z=A/z,d.push(N)}i.push(h),o.push(d)}return[i,o]}function Mx(e,t,r,n){let i=[];for(let o of e){let a=[o.x,o.y,n,1];Kt.transformMat4(a,a,t),i.push(new Zo.default(a[0]/a[3],a[1]/a[3]))}return i}var Ex=Y([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4),{members:Fp,size:QS,alignment:ew}=Ex;var Fx=Y([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]),{members:Lp,size:nw,alignment:iw}=Fx;var Bp=Z(Tt(),1);var Lx=Bp.default.VectorTileFeature.types,Dp=63,Dx=Math.cos(75/2*(Math.PI/180)),Vx=15,Bx=20,zx=15,zp=1/2,Vp=Math.pow(2,zx-1)/zp,rr=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach(r=>{this.gradients[r.id]={}}),this.layoutVertexArray=new Ao,this.layoutVertexArray2=new _o,this.indexArray=new Le,this.programConfigurations=new Ce(t.layers,t.zoom),this.segments=new me,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=Ir("line",this.layers,r);let i=this.layers[0].layout.get("line-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Tr("line",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexArray2.length!==0&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Lp)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Fp),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}lineFeatureClips(t){if(t.properties&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_start")&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_end")){let r=+t.properties.mapbox_clip_start,n=+t.properties.mapbox_clip_end;return{start:r,end:n}}}addFeature(t,r,n,i,o){let a=this.layers[0].layout,s=a.get("line-join").evaluate(t,{}),l=a.get("line-cap"),u=a.get("line-miter-limit"),c=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(let p of r)this.addLine(p,t,s,l,u,c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}addLine(t,r,n,i,o,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let g=0;g<t.length-1;g++)this.totalDistance+=t[g].dist(t[g+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance)}let s=Lx[r.type]==="Polygon",l=t.length;for(;l>=2&&t[l-1].equals(t[l-2]);)l--;let u=0;for(;u<l-1&&t[u].equals(t[u+1]);)u++;if(l<(s?3:2))return;n==="bevel"&&(o=1.05);let c=this.overscaling<=16?Vx*8192/(512*this.overscaling):0,p=this.segments.prepareSegment(l*10,this.layoutVertexArray,this.indexArray),f,y,m,h,d;this.e1=this.e2=-1,s&&(f=t[l-2],d=t[u].sub(f)._unit()._perp());for(let g=u;g<l;g++){if(m=g===l-1?s?t[u+1]:void 0:t[g+1],m&&t[g].equals(m))continue;d&&(h=d),f&&(y=f),f=t[g],d=m?m.sub(f)._unit()._perp():h,h=h||d;let b=h.add(d);(b.x!==0||b.y!==0)&&b._unit();let x=h.x*d.x+h.y*d.y,v=b.x*d.x+b.y*d.y,P=v!==0?1/v:1/0,w=2*Math.sqrt(2-2*v),T=v<Dx&&y&&m,F=h.x*d.y-h.y*d.x>0;if(T&&g>u){let I=f.dist(y);if(I>2*c){let k=f.sub(f.sub(y)._mult(c/I)._round());this.updateDistance(y,k),this.addCurrentVertex(k,h,0,0,p),y=k}}let E=y&&m,_=E?n:s?"butt":i;if(E&&_==="round"&&(P<a?_="miter":P<=2&&(_="fakeround")),_==="miter"&&P>o&&(_="bevel"),_==="bevel"&&(P>2&&(_="flipbevel"),P<o&&(_="miter")),y&&this.updateDistance(y,f),_==="miter")b._mult(P),this.addCurrentVertex(f,b,0,0,p);else if(_==="flipbevel"){if(P>100)b=d.mult(-1);else{let I=P*h.add(d).mag()/h.sub(d).mag();b._perp()._mult(I*(F?-1:1))}this.addCurrentVertex(f,b,0,0,p),this.addCurrentVertex(f,b.mult(-1),0,0,p)}else if(_==="bevel"||_==="fakeround"){let I=-Math.sqrt(P*P-1),k=F?I:0,V=F?0:I;if(y&&this.addCurrentVertex(f,h,k,V,p),_==="fakeround"){let A=Math.round(w*180/Math.PI/Bx);for(let z=1;z<A;z++){let O=z/A;if(O!==.5){let K=O-.5,xe=1.0904+x*(-3.2452+x*(3.55645-x*1.43519)),X=.848013+x*(-1.06021+x*.215638);O=O+O*K*(O-1)*(xe*K*K+X)}let N=d.sub(h)._mult(O)._add(h)._unit()._mult(F?-1:1);this.addHalfVertex(f,N.x,N.y,!1,F,0,p)}}m&&this.addCurrentVertex(f,d,-k,-V,p)}else if(_==="butt")this.addCurrentVertex(f,b,0,0,p);else if(_==="square"){let I=y?1:-1;this.addCurrentVertex(f,b,I,I,p)}else _==="round"&&(y&&(this.addCurrentVertex(f,h,0,0,p),this.addCurrentVertex(f,h,1,1,p,!0)),m&&(this.addCurrentVertex(f,d,-1,-1,p,!0),this.addCurrentVertex(f,d,0,0,p)));if(T&&g<l-1){let I=f.dist(m);if(I>2*c){let k=f.add(m.sub(f)._mult(c/I)._round());this.updateDistance(f,k),this.addCurrentVertex(k,d,0,0,p),f=k}}}}addCurrentVertex(t,r,n,i,o,a=!1){let s=r.x+r.y*n,l=r.y-r.x*n,u=-r.x+r.y*i,c=-r.y-r.x*i;this.addHalfVertex(t,s,l,a,!1,n,o),this.addHalfVertex(t,u,c,a,!0,-i,o),this.distance>Vp/2&&this.totalDistance===0&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(t,r,n,i,o,a))}addHalfVertex({x:t,y:r},n,i,o,a,s,l){let c=(this.lineClips?this.scaledDistance*(Vp-1):this.scaledDistance)*zp;if(this.layoutVertexArray.emplaceBack((t<<1)+(o?1:0),(r<<1)+(a?1:0),Math.round(Dp*n)+128,Math.round(Dp*i)+128,(s===0?0:s<0?-1:1)+1|(c&63)<<2,c>>6),this.lineClips){let f=this.scaledDistance-this.lineClips.start,y=this.lineClips.end-this.lineClips.start,m=f/y;this.layoutVertexArray2.emplaceBack(m,this.lineClipsArray.length)}let p=l.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,p),l.primitiveLength++),a?this.e2=p:this.e1=p}updateScaledDistance(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance}updateDistance(t,r){this.distance+=t.dist(r),this.updateScaledDistance()}};C("LineBucket",rr,{omit:["layers","patternFeatures"]});var Rp,Rx=()=>Rp=Rp||new re({"line-cap":new B(S.layout_line["line-cap"]),"line-join":new R(S.layout_line["line-join"]),"line-miter-limit":new B(S.layout_line["line-miter-limit"]),"line-round-limit":new B(S.layout_line["line-round-limit"]),"line-sort-key":new R(S.layout_line["line-sort-key"])}),Op,Ox=()=>Op=Op||new re({"line-opacity":new R(S.paint_line["line-opacity"]),"line-color":new R(S.paint_line["line-color"]),"line-translate":new B(S.paint_line["line-translate"]),"line-translate-anchor":new B(S.paint_line["line-translate-anchor"]),"line-width":new R(S.paint_line["line-width"]),"line-gap-width":new R(S.paint_line["line-gap-width"]),"line-offset":new R(S.paint_line["line-offset"]),"line-blur":new R(S.paint_line["line-blur"]),"line-dasharray":new qt(S.paint_line["line-dasharray"]),"line-pattern":new lt(S.paint_line["line-pattern"]),"line-gradient":new jt(S.paint_line["line-gradient"])}),qs={get paint(){return Ox()},get layout(){return Rx()}};var js=class extends R{possiblyEvaluate(t,r){return r=new q(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),super.possiblyEvaluate(t,r)}evaluate(t,r,n,i){return r=Pe({},r,{zoom:Math.floor(r.zoom)}),super.evaluate(t,r,n,i)}},Ho,Xo=class extends se{constructor(t){super(t,qs),this.gradientVersion=0,Ho||(Ho=new js(qs.paint.properties["line-width"].specification),Ho.useIntegerZoom=!0)}_handleSpecialPaintPropertyUpdate(t){if(t==="line-gradient"){let r=this.gradientExpression();$t(r)?this.stepInterpolant=r._styleExpression.expression instanceof pr:this.stepInterpolant=!1,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}recalculate(t,r){super.recalculate(t,r),this.paint._values["line-floorwidth"]=Ho.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,t)}createBucket(t){return new rr(t)}queryRadius(t){let r=t,n=Np(Xt("line-width",this,r),Xt("line-gap-width",this,r)),i=Xt("line-offset",this,r);return n/2+Math.abs(i)+_t(this.paint.get("line-translate"))}queryIntersectsFeature(t,r,n,i,o,a,s){let l=It(t,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),a.angle,s),u=s/2*Np(this.paint.get("line-width").evaluate(r,n),this.paint.get("line-gap-width").evaluate(r,n)),c=this.paint.get("line-offset").evaluate(r,n);return c&&(i=Bc(i,c*s)),Dc(l,i,u)}isTileClipped(){return!0}};function Np(e,t){return t>0?t+2*e:e}var Up=Y([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),$p=Y([{name:"a_projected_pos",components:3,type:"Float32"}],4),Uw=Y([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Gp=Y([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),$w=Y([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Js=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),Gw=Y([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4),qw=Y([{name:"triangle",components:3,type:"Uint16"}]),jw=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),Jw=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",name:"collisionCircleDiameter"},{type:"Uint16",name:"textAnchorOffsetStartIndex"},{type:"Uint16",name:"textAnchorOffsetEndIndex"}]),Zw=Y([{type:"Float32",name:"offsetX"}]),Ww=Y([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]),Hw=Y([{type:"Uint16",name:"textAnchor"},{type:"Float32",components:2,name:"textOffset"}]);var ii=Z(he(),1);function Nx(e,t,r){let n=t.layout.get("text-transform").evaluate(r,{});return n==="uppercase"?e=e.toLocaleUpperCase():n==="lowercase"&&(e=e.toLocaleLowerCase()),ye.applyArabicShaping&&(e=ye.applyArabicShaping(e)),e}function qp(e,t,r){return e.sections.forEach(n=>{n.text=Nx(n.text,t,r)}),e}function jp(e){let t={},r={},n=[],i=0;function o(u){n.push(e[u]),i++}function a(u,c,p){let f=r[u];return delete r[u],r[c]=f,n[f].geometry[0].pop(),n[f].geometry[0]=n[f].geometry[0].concat(p[0]),f}function s(u,c,p){let f=t[c];return delete t[c],t[u]=f,n[f].geometry[0].shift(),n[f].geometry[0]=p[0].concat(n[f].geometry[0]),f}function l(u,c,p){let f=p?c[0][c[0].length-1]:c[0][0];return`${u}:${f.x}:${f.y}`}for(let u=0;u<e.length;u++){let c=e[u],p=c.geometry,f=c.text?c.text.toString():null;if(!f){o(u);continue}let y=l(f,p),m=l(f,p,!0);if(y in r&&m in t&&r[y]!==t[m]){let h=s(y,m,p),d=a(y,m,n[h].geometry);delete t[y],delete r[m],r[l(f,n[d].geometry,!0)]=d,n[h].geometry=null}else y in r?a(y,m,p):m in t?s(y,m,p):(o(u),t[y]=i-1,r[m]=i-1)}return n.filter(u=>u.geometry)}var kr={"!":"\\uFE15","#":"\\uFF03",$:"\\uFF04","%":"\\uFF05","&":"\\uFF06","(":"\\uFE35",")":"\\uFE36","*":"\\uFF0A","+":"\\uFF0B",",":"\\uFE10","-":"\\uFE32",".":"\\u30FB","/":"\\uFF0F",":":"\\uFE13",";":"\\uFE14","<":"\\uFE3F","=":"\\uFF1D",">":"\\uFE40","?":"\\uFE16","@":"\\uFF20","[":"\\uFE47","\\\\":"\\uFF3C","]":"\\uFE48","^":"\\uFF3E",_:"\\uFE33","`":"\\uFF40","{":"\\uFE37","|":"\\u2015","}":"\\uFE38","~":"\\uFF5E","\\xA2":"\\uFFE0","\\xA3":"\\uFFE1","\\xA5":"\\uFFE5","\\xA6":"\\uFFE4","\\xAC":"\\uFFE2","\\xAF":"\\uFFE3","\\u2013":"\\uFE32","\\u2014":"\\uFE31","\\u2018":"\\uFE43","\\u2019":"\\uFE44","\\u201C":"\\uFE41","\\u201D":"\\uFE42","\\u2026":"\\uFE19","\\u2027":"\\u30FB","\\u20A9":"\\uFFE6","\\u3001":"\\uFE11","\\u3002":"\\uFE12","\\u3008":"\\uFE3F","\\u3009":"\\uFE40","\\u300A":"\\uFE3D","\\u300B":"\\uFE3E","\\u300C":"\\uFE41","\\u300D":"\\uFE42","\\u300E":"\\uFE43","\\u300F":"\\uFE44","\\u3010":"\\uFE3B","\\u3011":"\\uFE3C","\\u3014":"\\uFE39","\\u3015":"\\uFE3A","\\u3016":"\\uFE17","\\u3017":"\\uFE18","\\uFF01":"\\uFE15","\\uFF08":"\\uFE35","\\uFF09":"\\uFE36","\\uFF0C":"\\uFE10","\\uFF0D":"\\uFE32","\\uFF0E":"\\u30FB","\\uFF1A":"\\uFE13","\\uFF1B":"\\uFE14","\\uFF1C":"\\uFE3F","\\uFF1E":"\\uFE40","\\uFF1F":"\\uFE16","\\uFF3B":"\\uFE47","\\uFF3D":"\\uFE48","\\uFF3F":"\\uFE33","\\uFF5B":"\\uFE37","\\uFF5C":"\\u2015","\\uFF5D":"\\uFE38","\\uFF5F":"\\uFE35","\\uFF60":"\\uFE36","\\uFF61":"\\uFE12","\\uFF62":"\\uFE41","\\uFF63":"\\uFE42"};function Jp(e){let t="";for(let r=0;r<e.length;r++){let n=e.charCodeAt(r+1)||null,i=e.charCodeAt(r-1)||null;(!n||!Ps(n)||kr[e[r+1]])&&(!i||!Ps(i)||kr[e[r-1]])&&kr[e[r]]?t+=kr[e[r]]:t+=e[r]}return t}var ne=24;var ib=Z(Qn(),1),ob=3;var Qo=ob;function ei(e){let t=0,r=0;for(let s of e)t+=s.w*s.h,r=Math.max(r,s.w);e.sort((s,l)=>l.h-s.h);let i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),r),h:1/0}],o=0,a=0;for(let s of e)for(let l=i.length-1;l>=0;l--){let u=i[l];if(!(s.w>u.w||s.h>u.h)){if(s.x=u.x,s.y=u.y,a=Math.max(a,s.y+s.h),o=Math.max(o,s.x+s.w),s.w===u.w&&s.h===u.h){let c=i.pop();l<i.length&&(i[l]=c)}else s.h===u.h?(u.x+=s.w,u.w-=s.w):s.w===u.w?(u.y+=s.h,u.h-=s.h):(i.push({x:u.x+s.w,y:u.y,w:u.w-s.w,h:s.h}),u.y+=s.h,u.h-=s.h);break}}return{w:o,h:a,fill:t/(o*a)||0}}var ge=1;var ea=class{constructor(t,{pixelRatio:r,version:n,stretchX:i,stretchY:o,content:a}){this.paddedRect=t,this.pixelRatio=r,this.stretchX=i,this.stretchY=o,this.content=a,this.version=n}get tl(){return[this.paddedRect.x+ge,this.paddedRect.y+ge]}get br(){return[this.paddedRect.x+this.paddedRect.w-ge,this.paddedRect.y+this.paddedRect.h-ge]}get tlbr(){return this.tl.concat(this.br)}get displaySize(){return[(this.paddedRect.w-ge*2)/this.pixelRatio,(this.paddedRect.h-ge*2)/this.pixelRatio]}},ti=class{constructor(t,r){let n={},i={};this.haveRenderCallbacks=[];let o=[];this.addImages(t,n,o),this.addImages(r,i,o);let{w:a,h:s}=ei(o),l=new de({width:a||1,height:s||1});for(let u in t){let c=t[u],p=n[u].paddedRect;de.copy(c.data,l,{x:0,y:0},{x:p.x+ge,y:p.y+ge},c.data)}for(let u in r){let c=r[u],p=i[u].paddedRect,f=p.x+ge,y=p.y+ge,m=c.data.width,h=c.data.height;de.copy(c.data,l,{x:0,y:0},{x:f,y},c.data),de.copy(c.data,l,{x:0,y:h-1},{x:f,y:y-1},{width:m,height:1}),de.copy(c.data,l,{x:0,y:0},{x:f,y:y+h},{width:m,height:1}),de.copy(c.data,l,{x:m-1,y:0},{x:f-1,y},{width:1,height:h}),de.copy(c.data,l,{x:0,y:0},{x:f+m,y},{width:1,height:h})}this.image=l,this.iconPositions=n,this.patternPositions=i}addImages(t,r,n){for(let i in t){let o=t[i],a={x:0,y:0,w:o.data.width+2*ge,h:o.data.height+2*ge};n.push(a),r[i]=new ea(a,o),o.hasRenderCallback&&this.haveRenderCallbacks.push(i)}}patchUpdatedImages(t,r){t.dispatchRenderCallbacks(this.haveRenderCallbacks);for(let n in t.updatedImages)this.patchUpdatedImage(this.iconPositions[n],t.getImage(n),r),this.patchUpdatedImage(this.patternPositions[n],t.getImage(n),r)}patchUpdatedImage(t,r,n){if(!t||!r||t.version===r.version)return;t.version=r.version;let[i,o]=t.tl;n.update(r.data,void 0,{x:i,y:o})}};C("ImagePosition",ea);C("ImageAtlas",ti);var na=(i=>(i[i.none=0]="none",i[i.horizontal=1]="horizontal",i[i.vertical=2]="vertical",i[i.horizontalOnly=3]="horizontalOnly",i))(na||{}),Fr=-17;function ab(e){for(let t of e)if(t.positionedGlyphs.length!==0)return!1;return!0}var Qp=57344,ef=63743,ta=class e{constructor(){this.scale=1,this.fontStack="",this.imageName=null}static forText(t,r){let n=new e;return n.scale=t||1,n.fontStack=r,n}static forImage(t){let r=new e;return r.imageName=t,r}},ri=class e{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null}static fromFeature(t,r){let n=new e;for(let i=0;i<t.sections.length;i++){let o=t.sections[i];o.image?n.addImageSection(o):n.addTextSection(o,r)}return n}length(){return this.text.length}getSection(t){return this.sections[this.sectionIndex[t]]}getSectionIndex(t){return this.sectionIndex[t]}getCharCode(t){return this.text.charCodeAt(t)}verticalizePunctuation(){this.text=Jp(this.text)}trim(){let t=0;for(let n=0;n<this.text.length&&ra[this.text.charCodeAt(n)];n++)t++;let r=this.text.length;for(let n=this.text.length-1;n>=0&&n>=t&&ra[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r)}substring(t,r){let n=new e;return n.text=this.text.substring(t,r),n.sectionIndex=this.sectionIndex.slice(t,r),n.sections=this.sections,n}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce((t,r)=>Math.max(t,this.sections[r].scale),0)}addTextSection(t,r){this.text+=t.text,this.sections.push(ta.forText(t.scale,t.fontStack||r));let n=this.sections.length-1;for(let i=0;i<t.text.length;++i)this.sectionIndex.push(n)}addImageSection(t){let r=t.image?t.image.name:"";if(r.length===0){fe("Can\'t add FormattedSection with an empty image.");return}let n=this.getNextImageSectionCharCode();if(!n){fe(`Reached maximum number of images ${ef-Qp+2}`);return}this.text+=String.fromCharCode(n),this.sections.push(ta.forImage(r)),this.sectionIndex.push(this.sections.length-1)}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=ef?null:++this.imageSectionID:(this.imageSectionID=Qp,this.imageSectionID)}};function sb(e,t){let r=[],n=e.text,i=0;for(let o of t)r.push(e.substring(i,o)),i=o;return i<n.length&&r.push(e.substring(i,n.length)),r}function ni(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){let d=ri.fromFeature(e,i);p===2&&d.verticalizePunctuation();let g,{processBidirectionalText:b,processStyledBidirectionalText:x}=ye;if(b&&d.sections.length===1){g=[];let w=b(d.toString(),Hs(d,u,o,t,n,y,m));for(let T of w){let F=new ri;F.text=T,F.sections=d.sections;for(let E=0;E<T.length;E++)F.sectionIndex.push(0);g.push(F)}}else if(x){g=[];let w=x(d.text,d.sectionIndex,Hs(d,u,o,t,n,y,m));for(let T of w){let F=new ri;F.text=T[0],F.sectionIndex=T[1],F.sections=d.sections,g.push(F)}}else g=sb(d,Hs(d,u,o,t,n,y,m));let v=[],P={positionedLines:v,text:d.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:p,iconsInText:!1,verticalizable:!1};return pb(P,t,r,n,g,a,s,l,p,u,f,h),ab(v)?!1:P}var ra={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},lb={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function nf(e,t,r,n,i,o){if(t.imageName){let a=n[t.imageName];return a?a.displaySize[0]*t.scale*ne/o+i:0}else{let a=r[t.fontStack],s=a&&a[e];return s?s.metrics.advance*t.scale+i:0}}function ub(e,t,r,n,i,o){let a=0;for(let l=0;l<e.length();l++){let u=e.getSection(l);a+=nf(e.getCharCode(l),u,n,i,t,o)}let s=Math.max(1,Math.ceil(a/r));return a/s}function tf(e,t,r,n){let i=Math.pow(e-t,2);return n?e<t?i/2:i*2:i+Math.abs(r)*r}function cb(e,t,r){let n=0;return e===10&&(n-=1e4),r&&(n+=150),(e===40||e===65288)&&(n+=50),(t===41||t===65289)&&(n+=50),n}function rf(e,t,r,n,i,o){let a=null,s=tf(t,r,i,o);for(let l of n){let u=t-l.x,c=tf(u,r,i,o)+l.badness;c<=s&&(a=l,s=c)}return{index:e,x:t,priorBreak:a,badness:s}}function of(e){return e?of(e.priorBreak).concat(e.index):[]}function Hs(e,t,r,n,i,o,a){if(o!=="point")return[];if(!e)return[];let s=[],l=ub(e,t,r,n,i,a),u=e.text.indexOf("\\u200B")>=0,c=0;for(let p=0;p<e.length();p++){let f=e.getSection(p),y=e.getCharCode(p);if(ra[y]||(c+=nf(y,f,n,i,t,a)),p<e.length()-1){let m=dc(y);(lb[y]||m||f.imageName)&&s.push(rf(p+1,c,l,s,cb(y,e.getCharCode(p+1),m&&u),!1))}}return of(rf(e.length(),c,l,s,0,!0))}function af(e){let t=.5,r=.5;switch(e){case"right":case"top-right":case"bottom-right":t=1;break;case"left":case"top-left":case"bottom-left":t=0;break}switch(e){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;break}return{horizontalAlign:t,verticalAlign:r}}function pb(e,t,r,n,i,o,a,s,l,u,c,p){let f=0,y=Fr,m=0,h=0,d=s==="right"?1:s==="left"?0:.5,g=0;for(let P of i){P.trim();let w=P.getMaxScale(),T=(w-1)*ne,F={positionedGlyphs:[],lineOffset:0};e.positionedLines[g]=F;let E=F.positionedGlyphs,_=0;if(!P.length()){y+=o,++g;continue}for(let k=0;k<P.length();k++){let V=P.getSection(k),A=P.getSectionIndex(k),z=P.getCharCode(k),O=0,N=null,K=null,xe=null,X=ne,le=!(l===1||!c&&!oo(z)||c&&(ra[z]||gc(z)));if(V.imageName){let ce=n[V.imageName];if(!ce)continue;xe=V.imageName,e.iconsInText=e.iconsInText||!0,K=ce.paddedRect;let pe=ce.displaySize;V.scale=V.scale*ne/p,N={width:pe[0],height:pe[1],left:ge,top:-Qo,advance:le?pe[1]:pe[0]};let _e=ne-pe[1]*V.scale;O=T+_e,X=N.advance;let be=le?pe[0]*V.scale-ne*w:pe[1]*V.scale-ne*w;be>0&&be>_&&(_=be)}else{let ce=r[V.fontStack],pe=ce&&ce[z];if(pe&&pe.rect)K=pe.rect,N=pe.metrics;else{let _e=t[V.fontStack],be=_e&&_e[z];if(!be)continue;N=be.metrics}O=(w-V.scale)*ne}le?(e.verticalizable=!0,E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=X*V.scale+u):(E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=N.advance*V.scale+u)}if(E.length!==0){let k=f-u;m=Math.max(k,m),fb(E,0,E.length-1,d,_)}f=0;let I=o*w+_;F.lineOffset=Math.max(_,T),y+=I,h=Math.max(I,h),++g}let b=y-Fr,{horizontalAlign:x,verticalAlign:v}=af(a);yb(e.positionedLines,d,x,v,m,h,o,b,i.length),e.top+=-v*b,e.bottom=e.top+b,e.left+=-x*m,e.right=e.left+m}function fb(e,t,r,n,i){if(!n&&!i)return;let o=e[r],a=o.metrics.advance*o.scale,s=(e[r].x+a)*n;for(let l=t;l<=r;l++)e[l].x-=s,e[l].y+=i}function yb(e,t,r,n,i,o,a,s,l){let u=(t-r)*i,c=0;o!==a?c=-s*n-Fr:c=(-n*l+.5)*a;for(let p of e)for(let f of p.positionedGlyphs)f.x+=u,f.y+=c}function sf(e,t,r){let{horizontalAlign:n,verticalAlign:i}=af(r),o=t[0],a=t[1],s=o-e.displaySize[0]*n,l=s+e.displaySize[0],u=a-e.displaySize[1]*i,c=u+e.displaySize[1];return{image:e,top:u,bottom:c,left:s,right:l}}function Xs(e,t,r,n,i,o){let a=e.image,s;if(a.content){let d=a.content,g=a.pixelRatio||1;s=[d[0]/g,d[1]/g,a.displaySize[0]-d[2]/g,a.displaySize[1]-d[3]/g]}let l=t.left*o,u=t.right*o,c,p,f,y;r==="width"||r==="both"?(y=i[0]+l-n[3],p=i[0]+u+n[1]):(y=i[0]+(l+u-a.displaySize[0])/2,p=y+a.displaySize[0]);let m=t.top*o,h=t.bottom*o;return r==="height"||r==="both"?(c=i[1]+m-n[0],f=i[1]+h+n[2]):(c=i[1]+(m+h-a.displaySize[1])/2,f=c+a.displaySize[1]),{image:a,top:c,right:p,bottom:f,left:y,collisionPadding:s}}var lf=Z(Tt(),1);var Lr=255,Ct=128,tt=Lr*Ct;function Ks(e,t){let{expression:r}=t;if(r.kind==="constant")return{kind:"constant",layoutSize:r.evaluate(new q(e+1))};if(r.kind==="source")return{kind:"source"};{let{zoomStops:n,interpolationType:i}=r,o=0;for(;o<n.length&&n[o]<=e;)o++;o=Math.max(0,o-1);let a=o;for(;a<n.length&&n[a]<e+1;)a++;a=Math.min(n.length-1,a);let s=n[o],l=n[a];if(r.kind==="composite")return{kind:"composite",minZoom:s,maxZoom:l,interpolationType:i};let u=r.evaluate(new q(s)),c=r.evaluate(new q(l));return{kind:"camera",minZoom:s,maxZoom:l,minSize:u,maxSize:c,interpolationType:i}}}function Ys(e,t,r){let n="never",i=e.get(t);return i?n=i:e.get(r)&&(n="always"),n}var mb=lf.default.VectorTileFeature.types,hb=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function ia(e,t,r,n,i,o,a,s,l,u,c,p,f){let y=s?Math.min(tt,Math.round(s[0])):0,m=s?Math.min(tt,Math.round(s[1])):0;e.emplaceBack(t,r,Math.round(n*32),Math.round(i*32),o,a,(y<<1)+(l?1:0),m,u*16,c*16,p*256,f*256)}function uf(e,t,r){e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r)}function db(e){for(let t of e.sections)if(bc(t.text))return!0;return!1}var oi=class{constructor(t){this.layoutVertexArray=new Io,this.indexArray=new Le,this.programConfigurations=t,this.segments=new me,this.dynamicLayoutVertexArray=new To,this.opacityVertexArray=new Co,this.hasVisibleVertices=!1,this.placedSymbolArray=new Ln}isEmpty(){return this.layoutVertexArray.length===0&&this.indexArray.length===0&&this.dynamicLayoutVertexArray.length===0&&this.opacityVertexArray.length===0}upload(t,r,n,i){this.isEmpty()||(n&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Up.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,r),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,$p.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,hb,!0),this.opacityVertexBuffer.itemSize=1),(n||i)&&this.programConfigurations.upload(t))}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy())}};C("SymbolBuffers",oi);var ai=class{constructor(t,r,n){this.layoutVertexArray=new t,this.layoutAttributes=r,this.indexArray=new n,this.segments=new me,this.collisionVertexArray=new ko}upload(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Gp.members,!0)}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy())}};C("CollisionBuffers",ai);var He=class{constructor(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(l=>l.id),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=jn.identity([]),this.placementViewportMatrix=jn.identity([]);let n=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Ks(this.zoom,n["text-size"]),this.iconSizeData=Ks(this.zoom,n["icon-size"]);let i=this.layers[0].layout,o=i.get("symbol-sort-key"),a=i.get("symbol-z-order");this.canOverlap=Ys(i,"text-overlap","text-allow-overlap")!=="never"||Ys(i,"icon-overlap","icon-allow-overlap")!=="never"||i.get("text-ignore-placement")||i.get("icon-ignore-placement"),this.sortFeaturesByKey=a!=="viewport-y"&&!o.isConstant();let s=a==="viewport-y"||a==="auto"&&!this.sortFeaturesByKey;this.sortFeaturesByY=s&&this.canOverlap,i.get("symbol-placement")==="point"&&(this.writingModes=i.get("text-writing-mode").map(l=>na[l])),this.stateDependentLayerIds=this.layers.filter(l=>l.isStateDependent()).map(l=>l.id),this.sourceID=t.sourceID}createArrays(){this.text=new oi(new Ce(this.layers,this.zoom,t=>/^text/.test(t))),this.icon=new oi(new Ce(this.layers,this.zoom,t=>/^icon/.test(t))),this.glyphOffsetArray=new Vn,this.lineVertexArray=new Bn,this.symbolInstances=new Dn,this.textAnchorOffsets=new zn}calculateGlyphDependencies(t,r,n,i,o){for(let a=0;a<t.length;a++)if(r[t.charCodeAt(a)]=!0,(n||i)&&o){let s=kr[t.charAt(a)];s&&(r[s.charCodeAt(0)]=!0)}}populate(t,r,n){let i=this.layers[0],o=i.layout,a=o.get("text-font"),s=o.get("text-field"),l=o.get("icon-image"),u=(s.value.kind!=="constant"||s.value.value instanceof Fe&&!s.value.value.isEmpty()||s.value.value.toString().length>0)&&(a.value.kind!=="constant"||a.value.value.length>0),c=l.value.kind!=="constant"||!!l.value.value||Object.keys(l.parameters).length>0,p=o.get("symbol-sort-key");if(this.features=[],!u&&!c)return;let f=r.iconDependencies,y=r.glyphDependencies,m=r.availableImages,h=new q(this.zoom);for(let{feature:d,id:g,index:b,sourceLayerIndex:x}of t){let v=i._featureFilter.needGeometry,P=$e(d,v);if(!i._featureFilter.filter(h,P,n))continue;v||(P.geometry=ke(d));let w;if(u){let _=i.getValueAndResolveTokens("text-field",P,n,m),I=Fe.factory(_),k=this.hasRTLText=this.hasRTLText||db(I);(!k||ye.getRTLTextPluginStatus()==="unavailable"||k&&ye.isParsed())&&(w=qp(I,i,P))}let T;if(c){let _=i.getValueAndResolveTokens("icon-image",P,n,m);_ instanceof Te?T=_:T=Te.fromString(_)}if(!w&&!T)continue;let F=this.sortFeaturesByKey?p.evaluate(P,{},n):void 0,E={id:g,text:w,icon:T,index:b,sourceLayerIndex:x,geometry:P.geometry,properties:d.properties,type:mb[d.type],sortKey:F};if(this.features.push(E),T&&(f[T.name]=!0),w){let _=a.evaluate(P,{},n).join(","),I=o.get("text-rotation-alignment")!=="viewport"&&o.get("symbol-placement")!=="point";this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(2)>=0;for(let k of w.sections)if(k.image)f[k.image.name]=!0;else{let V=mn(w.toString()),A=k.fontStack||_,z=y[A]=y[A]||{};this.calculateGlyphDependencies(k.text,z,I,this.allowVerticalPlacement,V)}}}o.get("symbol-placement")==="line"&&(this.features=jp(this.features)),this.sortFeaturesByKey&&this.features.sort((d,g)=>d.sortKey-g.sortKey)}update(t,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,r,this.layers,n),this.icon.programConfigurations.updatePaintArrays(t,r,this.layers,n))}isEmpty(){return this.symbolInstances.length===0&&!this.hasRTLText}uploadPending(){return!this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy()}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData()}addToLineVertexArray(t,r){let n=this.lineVertexArray.length;if(t.segment!==void 0){let i=t.dist(r[t.segment+1]),o=t.dist(r[t.segment]),a={};for(let s=t.segment+1;s<r.length;s++)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:i},s<r.length-1&&(i+=r[s+1].dist(r[s]));for(let s=t.segment||0;s>=0;s--)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:o},s>0&&(o+=r[s-1].dist(r[s]));for(let s=0;s<r.length;s++){let l=a[s];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor)}}return{lineStartIndex:n,lineLength:this.lineVertexArray.length-n}}addSymbols(t,r,n,i,o,a,s,l,u,c,p,f){let y=t.indexArray,m=t.layoutVertexArray,h=t.segments.prepareSegment(4*r.length,m,y,this.canOverlap?a.sortKey:void 0),d=this.glyphOffsetArray.length,g=h.vertexLength,b=this.allowVerticalPlacement&&s===2?Math.PI/2:0,x=a.text&&a.text.sections;for(let v=0;v<r.length;v++){let{tl:P,tr:w,bl:T,br:F,tex:E,pixelOffsetTL:_,pixelOffsetBR:I,minFontScaleX:k,minFontScaleY:V,glyphOffset:A,isSDF:z,sectionIndex:O}=r[v],N=h.vertexLength,K=A[1];ia(m,l.x,l.y,P.x,K+P.y,E.x,E.y,n,z,_.x,_.y,k,V),ia(m,l.x,l.y,w.x,K+w.y,E.x+E.w,E.y,n,z,I.x,_.y,k,V),ia(m,l.x,l.y,T.x,K+T.y,E.x,E.y+E.h,n,z,_.x,I.y,k,V),ia(m,l.x,l.y,F.x,K+F.y,E.x+E.w,E.y+E.h,n,z,I.x,I.y,k,V),uf(t.dynamicLayoutVertexArray,l,b),y.emplaceBack(N,N+1,N+2),y.emplaceBack(N+1,N+2,N+3),h.vertexLength+=4,h.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(A[0]),(v===r.length-1||O!==r[v+1].sectionIndex)&&t.programConfigurations.populatePaintArrays(m.length,a,a.index,{},f,x&&x[O])}t.placedSymbolArray.emplaceBack(l.x,l.y,d,this.glyphOffsetArray.length-d,g,u,c,l.segment,n?n[0]:0,n?n[1]:0,i[0],i[1],s,0,!1,0,p)}_addCollisionDebugVertex(t,r,n,i,o,a){return r.emplaceBack(0,0),t.emplaceBack(n.x,n.y,i,o,Math.round(a.x),Math.round(a.y))}addCollisionDebugVertices(t,r,n,i,o,a,s){let l=o.segments.prepareSegment(4,o.layoutVertexArray,o.indexArray),u=l.vertexLength,c=o.layoutVertexArray,p=o.collisionVertexArray,f=s.anchorX,y=s.anchorY;this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(t,r)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(n,r)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(n,i)),this._addCollisionDebugVertex(c,p,a,f,y,new ii.default(t,i)),l.vertexLength+=4;let m=o.indexArray;m.emplaceBack(u,u+1),m.emplaceBack(u+1,u+2),m.emplaceBack(u+2,u+3),m.emplaceBack(u+3,u),l.primitiveLength+=4}addDebugCollisionBoxes(t,r,n,i){for(let o=t;o<r;o++){let a=this.collisionBoxArray.get(o),s=a.x1,l=a.y1,u=a.x2,c=a.y2;this.addCollisionDebugVertices(s,l,u,c,i?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,n)}}generateCollisionDebugBuffers(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new ai(On,Js.members,wt),this.iconCollisionBox=new ai(On,Js.members,wt);for(let t=0;t<this.symbolInstances.length;t++){let r=this.symbolInstances.get(t);this.addDebugCollisionBoxes(r.textBoxStartIndex,r.textBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.iconBoxStartIndex,r.iconBoxEndIndex,r,!1),this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex,r,!1)}}_deserializeCollisionBoxesForSymbol(t,r,n,i,o,a,s,l,u){let c={};for(let p=r;p<n;p++){let f=t.get(p);c.textBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.textFeatureIndex=f.featureIndex;break}for(let p=i;p<o;p++){let f=t.get(p);c.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalTextFeatureIndex=f.featureIndex;break}for(let p=a;p<s;p++){let f=t.get(p);c.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.iconFeatureIndex=f.featureIndex;break}for(let p=l;p<u;p++){let f=t.get(p);c.verticalIconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalIconFeatureIndex=f.featureIndex;break}return c}deserializeCollisionBoxes(t){this.collisionArrays=[];for(let r=0;r<this.symbolInstances.length;r++){let n=this.symbolInstances.get(r);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,n.textBoxStartIndex,n.textBoxEndIndex,n.verticalTextBoxStartIndex,n.verticalTextBoxEndIndex,n.iconBoxStartIndex,n.iconBoxEndIndex,n.verticalIconBoxStartIndex,n.verticalIconBoxEndIndex))}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(t,r){let n=t.placedSymbolArray.get(r),i=n.vertexStartIndex+n.numGlyphs*4;for(let o=n.vertexStartIndex;o<i;o+=4)t.indexArray.emplaceBack(o,o+1,o+2),t.indexArray.emplaceBack(o+1,o+2,o+3)}getSortedSymbolIndexes(t){if(this.sortedAngle===t&&this.symbolInstanceIndexes!==void 0)return this.symbolInstanceIndexes;let r=Math.sin(t),n=Math.cos(t),i=[],o=[],a=[];for(let s=0;s<this.symbolInstances.length;++s){a.push(s);let l=this.symbolInstances.get(s);i.push(Math.round(r*l.anchorX+n*l.anchorY)|0),o.push(l.featureIndex)}return a.sort((s,l)=>i[s]-i[l]||o[l]-o[s]),a}addToSortKeyRanges(t,r){let n=this.sortKeyRanges[this.sortKeyRanges.length-1];n&&n.sortKey===r?n.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:r,symbolInstanceStart:t,symbolInstanceEnd:t+1})}sortFeatures(t){if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(let r of this.symbolInstanceIndexes){let n=this.symbolInstances.get(r);this.featureSortOrder.push(n.featureIndex),[n.rightJustifiedTextSymbolIndex,n.centerJustifiedTextSymbolIndex,n.leftJustifiedTextSymbolIndex].forEach((i,o,a)=>{i>=0&&a.indexOf(i)===o&&this.addIndicesForPlacedSymbol(this.text,i)}),n.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,n.verticalPlacedTextSymbolIndex),n.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.placedIconSymbolIndex),n.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.verticalPlacedIconSymbolIndex)}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray)}}};C("SymbolBucket",He,{omit:["layers","collisionBoxArray","features","compareText"]});He.MAX_GLYPHS=65535;He.addDynamicAttributes=uf;function cf(e,t){return t.replace(/{([^{}]+)}/g,(r,n)=>e&&n in e?String(e[n]):"")}var pf,gb=()=>pf=pf||new re({"symbol-placement":new B(S.layout_symbol["symbol-placement"]),"symbol-spacing":new B(S.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new B(S.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new R(S.layout_symbol["symbol-sort-key"]),"symbol-z-order":new B(S.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new B(S.layout_symbol["icon-allow-overlap"]),"icon-overlap":new B(S.layout_symbol["icon-overlap"]),"icon-ignore-placement":new B(S.layout_symbol["icon-ignore-placement"]),"icon-optional":new B(S.layout_symbol["icon-optional"]),"icon-rotation-alignment":new B(S.layout_symbol["icon-rotation-alignment"]),"icon-size":new R(S.layout_symbol["icon-size"]),"icon-text-fit":new B(S.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new B(S.layout_symbol["icon-text-fit-padding"]),"icon-image":new R(S.layout_symbol["icon-image"]),"icon-rotate":new R(S.layout_symbol["icon-rotate"]),"icon-padding":new R(S.layout_symbol["icon-padding"]),"icon-keep-upright":new B(S.layout_symbol["icon-keep-upright"]),"icon-offset":new R(S.layout_symbol["icon-offset"]),"icon-anchor":new R(S.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new B(S.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new B(S.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new B(S.layout_symbol["text-rotation-alignment"]),"text-field":new R(S.layout_symbol["text-field"]),"text-font":new R(S.layout_symbol["text-font"]),"text-size":new R(S.layout_symbol["text-size"]),"text-max-width":new R(S.layout_symbol["text-max-width"]),"text-line-height":new B(S.layout_symbol["text-line-height"]),"text-letter-spacing":new R(S.layout_symbol["text-letter-spacing"]),"text-justify":new R(S.layout_symbol["text-justify"]),"text-radial-offset":new R(S.layout_symbol["text-radial-offset"]),"text-variable-anchor":new B(S.layout_symbol["text-variable-anchor"]),"text-variable-anchor-offset":new R(S.layout_symbol["text-variable-anchor-offset"]),"text-anchor":new R(S.layout_symbol["text-anchor"]),"text-max-angle":new B(S.layout_symbol["text-max-angle"]),"text-writing-mode":new B(S.layout_symbol["text-writing-mode"]),"text-rotate":new R(S.layout_symbol["text-rotate"]),"text-padding":new B(S.layout_symbol["text-padding"]),"text-keep-upright":new B(S.layout_symbol["text-keep-upright"]),"text-transform":new R(S.layout_symbol["text-transform"]),"text-offset":new R(S.layout_symbol["text-offset"]),"text-allow-overlap":new B(S.layout_symbol["text-allow-overlap"]),"text-overlap":new B(S.layout_symbol["text-overlap"]),"text-ignore-placement":new B(S.layout_symbol["text-ignore-placement"]),"text-optional":new B(S.layout_symbol["text-optional"])}),ff,xb=()=>ff=ff||new re({"icon-opacity":new R(S.paint_symbol["icon-opacity"]),"icon-color":new R(S.paint_symbol["icon-color"]),"icon-halo-color":new R(S.paint_symbol["icon-halo-color"]),"icon-halo-width":new R(S.paint_symbol["icon-halo-width"]),"icon-halo-blur":new R(S.paint_symbol["icon-halo-blur"]),"icon-translate":new B(S.paint_symbol["icon-translate"]),"icon-translate-anchor":new B(S.paint_symbol["icon-translate-anchor"]),"text-opacity":new R(S.paint_symbol["text-opacity"]),"text-color":new R(S.paint_symbol["text-color"],{runtimeType:Re,getOverride:e=>e.textColor,hasOverride:e=>!!e.textColor}),"text-halo-color":new R(S.paint_symbol["text-halo-color"]),"text-halo-width":new R(S.paint_symbol["text-halo-width"]),"text-halo-blur":new R(S.paint_symbol["text-halo-blur"]),"text-translate":new B(S.paint_symbol["text-translate"]),"text-translate-anchor":new B(S.paint_symbol["text-translate-anchor"])}),oa={get paint(){return xb()},get layout(){return gb()}};var si=class{constructor(t){if(t.property.overrides===void 0)throw new Error("overrides must be provided to instantiate FormatSectionOverride class");this.type=t.property.overrides?t.property.overrides.runtimeType:yr,this.defaultValue=t}evaluate(t){if(t.formattedSection){let r=this.defaultValue.property.overrides;if(r&&r.hasOverride(t.formattedSection))return r.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default}eachChild(t){if(!this.defaultValue.isConstant()){let r=this.defaultValue.value;t(r._styleExpression.expression)}}outputDefined(){return!1}serialize(){return null}};C("FormatSectionOverride",si,{omit:["defaultValue"]});var aa=class e extends se{constructor(t){super(t,oa)}recalculate(t,r){if(super.recalculate(t,r),this.layout.get("icon-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),this.layout.get("text-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),this.layout.get("text-pitch-alignment")==="auto"&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")==="map"?"map":"viewport"),this.layout.get("icon-pitch-alignment")==="auto"&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),this.layout.get("symbol-placement")==="point"){let n=this.layout.get("text-writing-mode");if(n){let i=[];for(let o of n)i.indexOf(o)<0&&i.push(o);this.layout._values["text-writing-mode"]=i}else this.layout._values["text-writing-mode"]=["horizontal"]}this._setPaintOverrides()}getValueAndResolveTokens(t,r,n,i){let o=this.layout.get(t).evaluate(r,{},n,i),a=this._unevaluatedLayout._values[t];return!a.isDataDriven()&&!$t(a.value)&&o?cf(r.properties,o):o}createBucket(t){return new He(t)}queryRadius(){return 0}queryIntersectsFeature(){throw new Error("Should take a different path in FeatureIndex")}_setPaintOverrides(){for(let t of oa.paint.overridableProperties){if(!e.hasPaintOverride(this.layout,t))continue;let r=this.paint.get(t),n=new si(r),i=new Rt(n,r.property.specification),o=null;r.value.kind==="constant"||r.value.kind==="source"?o=new dt("source",i):o=new gt("composite",i,r.value.zoomStops),this.paint._values[t]=new Se(r.property,o,r.parameters)}}_handleOverridablePaintPropertyUpdate(t,r,n){return!this.layout||r.isDataDriven()||n.isDataDriven()?!1:e.hasPaintOverride(this.layout,t)}static hasPaintOverride(t,r){let n=t.get("text-field"),i=oa.paint.properties[r],o=!1,a=s=>{for(let l of s)if(i.overrides&&i.overrides.hasOverride(l)){o=!0;return}};if(n.value.kind==="constant"&&n.value.value instanceof Fe)a(n.value.value.sections);else if(n.value.kind==="source"){let s=u=>{if(!o)if(u instanceof mt&&ue(u.value)===mr){let c=u.value;a(c.sections)}else u instanceof en?a(u.sections):u.eachChild(s)},l=n.value;l._styleExpression&&s(l._styleExpression.expression)}return o}};function yf(e,t,r,n=1){let i=e.get("icon-padding").evaluate(t,{},r),o=i&&i.values;return[o[0]*n,o[1]*n,o[2]*n,o[3]*n]}var mf,bb=()=>mf=mf||new re({"background-color":new B(S.paint_background["background-color"]),"background-pattern":new qt(S.paint_background["background-pattern"]),"background-opacity":new B(S.paint_background["background-opacity"])}),hf={get paint(){return bb()}};var sa=class extends se{constructor(t){super(t,hf)}};var df,vb=()=>df=df||new re({"raster-opacity":new B(S.paint_raster["raster-opacity"]),"raster-hue-rotate":new B(S.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new B(S.paint_raster["raster-brightness-min"]),"raster-brightness-max":new B(S.paint_raster["raster-brightness-max"]),"raster-saturation":new B(S.paint_raster["raster-saturation"]),"raster-contrast":new B(S.paint_raster["raster-contrast"]),"raster-resampling":new B(S.paint_raster["raster-resampling"]),"raster-fade-duration":new B(S.paint_raster["raster-fade-duration"])}),gf={get paint(){return vb()}};var la=class extends se{constructor(t){super(t,gf)}};var ua=class extends se{constructor(r){super(r,{});this.onAdd=r=>{this.implementation.onAdd&&this.implementation.onAdd(r,r.painter.context.gl)};this.onRemove=r=>{this.implementation.onRemove&&this.implementation.onRemove(r,r.painter.context.gl)};this.implementation=r}is3D(){return this.implementation.renderingMode==="3d"}hasOffscreenPass(){return this.implementation.prerender!==void 0}recalculate(){}updateTransitions(){}hasTransition(){return!1}serialize(){throw new Error("Custom layers cannot be serialized")}};function xf(e){if(e.type==="custom")return new ua(e);switch(e.type){case"background":return new sa(e);case"circle":return new Ro(e);case"fill":return new jo(e);case"fill-extrusion":return new Wo(e);case"heatmap":return new Oo(e);case"hillshade":return new No(e);case"line":return new Xo(e);case"raster":return new la(e);case"symbol":return new aa(e)}}var ca=class{constructor(t){this.keyCache={},t&&this.replace(t)}replace(t){this._layerConfigs={},this._layers={},this.update(t,[])}update(t,r){for(let i of t){this._layerConfigs[i.id]=i;let o=this._layers[i.id]=xf(i);o._featureFilter=fn(o.filter),this.keyCache[i.id]&&delete this.keyCache[i.id]}for(let i of r)delete this.keyCache[i],delete this._layerConfigs[i],delete this._layers[i];this.familiesBySource={};let n=Ru(Object.values(this._layerConfigs),this.keyCache);for(let i of n){let o=i.map(p=>this._layers[p.id]),a=o[0];if(a.visibility==="none")continue;let s=a.source||"",l=this.familiesBySource[s];l||(l=this.familiesBySource[s]={});let u=a.sourceLayer||"_geojsonTileLayer",c=l[u];c||(c=l[u]=[]),c.push(o)}}};var Gf=Z(Tt(),1),qf=Z(Qn(),1);var Dr=class{constructor(t){this._stringToNumber={},this._numberToString=[];for(let r=0;r<t.length;r++){let n=t[r];this._stringToNumber[n]=r,this._numberToString[r]=n}}encode(t){return this._stringToNumber[t]}decode(t){if(t>=this._numberToString.length)throw new Error(`Out of bounds. Index requested n=${t} can\'t be >= this._numberToString.length ${this._numberToString.length}`);return this._numberToString[t]}};var Pf=Z(Tt(),1),Sf=Z(Qn(),1);var pa=class{constructor(t,r,n,i,o){this.type="Feature",this._vectorTileFeature=t,t._z=r,t._x=n,t._y=i,this.properties=t.properties,this.id=o}get geometry(){return this._geometry===void 0&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry}set geometry(t){this._geometry=t}toJSON(){let t={geometry:this.geometry};for(let r in this)r==="_geometry"||r==="_vectorTileFeature"||(t[r]=this[r]);return t}};var li=class{constructor(t,r){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Dt(8192,16,0),this.grid3D=new Dt(8192,16,0),this.featureIndexArray=new Rn,this.promoteId=r}insert(t,r,n,i,o,a){let s=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(n,i,o);let l=a?this.grid3D:this.grid;for(let u=0;u<r.length;u++){let c=r[u],p=[1/0,1/0,-1/0,-1/0];for(let f=0;f<c.length;f++){let y=c[f];p[0]=Math.min(p[0],y.x),p[1]=Math.min(p[1],y.y),p[2]=Math.max(p[2],y.x),p[3]=Math.max(p[3],y.y)}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&l.insert(s,p[0],p[1],p[2],p[3])}}loadVTLayers(){return this.vtLayers||(this.vtLayers=new Pf.default.VectorTile(new Sf.default(this.rawTileData)).layers,this.sourceLayerCoder=new Dr(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers}query(t,r,n,i){this.loadVTLayers();let o=t.params||{},a=8192/t.tileSize/t.scale,s=fn(o.filter),l=t.queryGeometry,u=t.queryPadding*a,c=vf(l),p=this.grid.query(c.minX-u,c.minY-u,c.maxX+u,c.maxY+u),f=vf(t.cameraQueryGeometry),y=this.grid3D.query(f.minX-u,f.minY-u,f.maxX+u,f.maxY+u,(d,g,b,x)=>Vc(t.cameraQueryGeometry,d-u,g-u,b+u,x+u));for(let d of y)p.push(d);p.sort(Pb);let m={},h;for(let d=0;d<p.length;d++){let g=p[d];if(g===h)continue;h=g;let b=this.featureIndexArray.get(g),x=null;this.loadMatchingFeature(m,b.bucketIndex,b.sourceLayerIndex,b.featureIndex,s,o.layers,o.availableImages,r,n,i,(v,P,w)=>(x||(x=ke(v)),P.queryIntersectsFeature(l,v,w,x,this.z,t.transform,a,t.pixelPosMatrix)))}return m}loadMatchingFeature(t,r,n,i,o,a,s,l,u,c,p){let f=this.bucketLayerIDs[r];if(a&&!Jl(a,f))return;let y=this.sourceLayerCoder.decode(n),h=this.vtLayers[y].feature(i);if(o.needGeometry){let g=$e(h,!0);if(!o.filter(new q(this.tileID.overscaledZ),g,this.tileID.canonical))return}else if(!o.filter(new q(this.tileID.overscaledZ),h))return;let d=this.getId(h,y);for(let g=0;g<f.length;g++){let b=f[g];if(a&&a.indexOf(b)<0)continue;let x=l[b];if(!x)continue;let v={};d&&c&&(v=c.getState(x.sourceLayer||"_geojsonTileLayer",d));let P=Pe({},u[b]);P.paint=bf(P.paint,x.paint,h,v,s),P.layout=bf(P.layout,x.layout,h,v,s);let w=!p||p(h,x,v);if(!w)continue;let T=new pa(h,this.z,this.x,this.y,d);T.layer=P;let F=t[b];F===void 0&&(F=t[b]=[]),F.push({featureIndex:i,feature:T,intersectionZ:w})}}lookupSymbolFeatures(t,r,n,i,o,a,s,l){let u={};this.loadVTLayers();let c=fn(o);for(let p of t)this.loadMatchingFeature(u,n,i,p,c,a,s,l,r);return u}hasLayer(t){for(let r of this.bucketLayerIDs)for(let n of r)if(t===n)return!0;return!1}getId(t,r){let n=t.id;if(this.promoteId){let i=typeof this.promoteId=="string"?this.promoteId:this.promoteId[r];n=t.properties[i],typeof n=="boolean"&&(n=Number(n))}return n}};C("FeatureIndex",li,{omit:["rawTileData","sourceLayerCoder"]});function bf(e,t,r,n,i){return Gr(e,(o,a)=>{let s=t instanceof vt?t.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s})}function vf(e){let t=1/0,r=1/0,n=-1/0,i=-1/0;for(let o of e)t=Math.min(t,o.x),r=Math.min(r,o.y),n=Math.max(n,o.x),i=Math.max(i,o.y);return{minX:t,minY:r,maxX:n,maxY:i}}function Pb(e,t){return t-e}var wf=Z(he(),1);var rt=class e extends wf.default{constructor(t,r,n,i){super(t,r),this.angle=n,i!==void 0&&(this.segment=i)}clone(){return new e(this.x,this.y,this.angle,this.segment)}};C("Anchor",rt);function Qs(e,t,r,n,i){if(t.segment===void 0||r===0)return!0;let o=t,a=t.segment+1,s=0;for(;s>-r/2;){if(a--,a<0)return!1;s-=e[a].dist(o),o=e[a]}s+=e[a].dist(e[a+1]),a++;let l=[],u=0;for(;s<r/2;){let c=e[a-1],p=e[a],f=e[a+1];if(!f)return!1;let y=c.angleTo(p)-p.angleTo(f);for(y=Math.abs((y+3*Math.PI)%(Math.PI*2)-Math.PI),l.push({distance:s,angleDelta:y}),u+=y;s-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return!1;a++,s+=p.dist(f)}return!0}function Af(e){let t=0;for(let r=0;r<e.length-1;r++)t+=e[r].dist(e[r+1]);return t}function _f(e,t,r){return e?3/5*t*r:0}function If(e,t){return Math.max(e?e.right-e.left:0,t?t.right-t.left:0)}function Tf(e,t,r,n,i,o){let a=_f(r,i,o),s=If(r,n)*o,l=0,u=Af(e)/2;for(let c=0;c<e.length-1;c++){let p=e[c],f=e[c+1],y=p.dist(f);if(l+y>u){let m=(u-l)/y,h=Oe.number(p.x,f.x,m),d=Oe.number(p.y,f.y,m),g=new rt(h,d,f.angleTo(p),c);return g._round(),!a||Qs(e,g,s,a,t)?g:void 0}l+=y}}function Cf(e,t,r,n,i,o,a,s,l){let u=_f(n,o,a),c=If(n,i),p=c*a,f=e[0].x===0||e[0].x===l||e[0].y===0||e[0].y===l;t-p<t/4&&(t=p+t/4);let y=o*2,m=f?t/2*s%t:(c/2+y)*a*s%t;return kf(e,m,t,u,r,p,f,!1,l)}function kf(e,t,r,n,i,o,a,s,l){let u=o/2,c=Af(e),p=0,f=t-r,y=[];for(let m=0;m<e.length-1;m++){let h=e[m],d=e[m+1],g=h.dist(d),b=d.angleTo(h);for(;f+r<p+g;){f+=r;let x=(f-p)/g,v=Oe.number(h.x,d.x,x),P=Oe.number(h.y,d.y,x);if(v>=0&&v<l&&P>=0&&P<l&&f-u>=0&&f+u<=c){let w=new rt(v,P,b,m);w._round(),(!n||Qs(e,w,o,n,i))&&y.push(w)}}p+=g}return!s&&!y.length&&!a&&(y=kf(e,p/2,r,n,i,o,a,!0,l)),y}var pt=Z(he(),1);function Mf(e,t,r,n,i){let o=[];for(let a=0;a<e.length;a++){let s=e[a],l;for(let u=0;u<s.length-1;u++){let c=s[u],p=s[u+1];c.x<t&&p.x<t||(c.x<t?c=new pt.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round():p.x<t&&(p=new pt.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round()),!(c.y<r&&p.y<r)&&(c.y<r?c=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round():p.y<r&&(p=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round()),!(c.x>=n&&p.x>=n)&&(c.x>=n?c=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round():p.x>=n&&(p=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round()),!(c.y>=i&&p.y>=i)&&(c.y>=i?c=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round():p.y>=i&&(p=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round()),(!l||!c.equals(l[l.length-1]))&&(l=[c],o.push(l)),l.push(p)))))}}return o}var we=Z(he(),1);var Vr=ge;function el(e,t,r,n){let i=[],o=e.image,a=o.pixelRatio,s=o.paddedRect.w-2*Vr,l=o.paddedRect.h-2*Vr,u=e.right-e.left,c=e.bottom-e.top,p=o.stretchX||[[0,s]],f=o.stretchY||[[0,l]],y=(I,k)=>I+k[1]-k[0],m=p.reduce(y,0),h=f.reduce(y,0),d=s-m,g=l-h,b=0,x=m,v=0,P=h,w=0,T=d,F=0,E=g;if(o.content&&n){let I=o.content;b=fa(p,0,I[0]),v=fa(f,0,I[1]),x=fa(p,I[0],I[2]),P=fa(f,I[1],I[3]),w=I[0]-b,F=I[1]-v,T=I[2]-I[0]-x,E=I[3]-I[1]-P}let _=(I,k,V,A)=>{let z=ya(I.stretch-b,x,u,e.left),O=ma(I.fixed-w,T,I.stretch,m),N=ya(k.stretch-v,P,c,e.top),K=ma(k.fixed-F,E,k.stretch,h),xe=ya(V.stretch-b,x,u,e.left),X=ma(V.fixed-w,T,V.stretch,m),le=ya(A.stretch-v,P,c,e.top),ce=ma(A.fixed-F,E,A.stretch,h),pe=new we.default(z,N),_e=new we.default(xe,N),be=new we.default(xe,le),wi=new we.default(z,le),Ea=new we.default(O/a,K/a),Fa=new we.default(X/a,ce/a),Or=t*Math.PI/180;if(Or){let Ie=Math.sin(Or),ve=Math.cos(Or),Ve=[ve,-Ie,Ie,ve];pe._matMult(Ve),_e._matMult(Ve),wi._matMult(Ve),be._matMult(Ve)}let Ai=I.stretch+I.fixed,Me=V.stretch+V.fixed,Ft=k.stretch+k.fixed,_i=A.stretch+A.fixed,La={x:o.paddedRect.x+Vr+Ai,y:o.paddedRect.y+Vr+Ft,w:Me-Ai,h:_i-Ft},Da=T/a/u,Va=E/a/c;return{tl:pe,tr:_e,bl:wi,br:be,tex:La,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:Ea,pixelOffsetBR:Fa,minFontScaleX:Da,minFontScaleY:Va,isSDF:r}};if(!n||!o.stretchX&&!o.stretchY)i.push(_({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:s+1},{fixed:0,stretch:l+1}));else{let I=Ef(p,d,m),k=Ef(f,g,h);for(let V=0;V<I.length-1;V++){let A=I[V],z=I[V+1];for(let O=0;O<k.length-1;O++){let N=k[O],K=k[O+1];i.push(_(A,N,z,K))}}}return i}function fa(e,t,r){let n=0;for(let i of e)n+=Math.max(t,Math.min(r,i[1]))-Math.max(t,Math.min(r,i[0]));return n}function Ef(e,t,r){let n=[{fixed:-Vr,stretch:0}];for(let[i,o]of e){let a=n[n.length-1];n.push({fixed:i-a.stretch,stretch:a.stretch}),n.push({fixed:i-a.stretch,stretch:a.stretch+(o-i)})}return n.push({fixed:t+Vr,stretch:r}),n}function ya(e,t,r,n){return e/t*r+n}function ma(e,t,r,n){return e-t*r/n}function Ff(e,t,r,n,i,o,a,s){let l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,u=[];for(let c of t.positionedLines)for(let p of c.positionedGlyphs){if(!p.rect)continue;let f=p.rect||{},m=Qo+1,h=!0,d=1,g=0,b=(i||s)&&p.vertical,x=p.metrics.advance*p.scale/2;if(s&&t.verticalizable){let X=(p.scale-1)*ne,le=(ne-p.metrics.width*p.scale)/2;g=c.lineOffset/2-(p.imageName?-le:X)}if(p.imageName){let X=a[p.imageName];h=X.sdf,d=X.pixelRatio,m=ge/d}let v=i?[p.x+x,p.y]:[0,0],P=i?[0,0]:[p.x+x+r[0],p.y+r[1]-g],w=[0,0];b&&(w=P,P=[0,0]);let T=p.metrics.isDoubleResolution?2:1,F=(p.metrics.left-m)*p.scale-x+P[0],E=(-p.metrics.top-m)*p.scale+P[1],_=F+f.w/T*p.scale/d,I=E+f.h/T*p.scale/d,k=new we.default(F,E),V=new we.default(_,E),A=new we.default(F,I),z=new we.default(_,I);if(b){let X=new we.default(-x,x-Fr),le=-Math.PI/2,ce=ne/2-x,pe=p.imageName?ce:0,_e=new we.default(5-Fr-ce,-pe),be=new we.default(...w);k._rotateAround(le,X)._add(_e)._add(be),V._rotateAround(le,X)._add(_e)._add(be),A._rotateAround(le,X)._add(_e)._add(be),z._rotateAround(le,X)._add(_e)._add(be)}if(l){let X=Math.sin(l),le=Math.cos(l),ce=[le,-X,X,le];k._matMult(ce),V._matMult(ce),A._matMult(ce),z._matMult(ce)}let O=new we.default(0,0),N=new we.default(0,0);u.push({tl:k,tr:V,bl:A,br:z,tex:f,writingMode:t.writingMode,glyphOffset:v,sectionIndex:p.sectionIndex,isSDF:h,pixelOffsetTL:O,pixelOffsetBR:N,minFontScaleX:0,minFontScaleY:0})}return u}var ui=Z(he(),1),nr=class{constructor(t,r,n,i,o,a,s,l,u,c){if(this.boxStartIndex=t.length,u){let p=a.top,f=a.bottom,y=a.collisionPadding;y&&(p-=y[1],f+=y[3]);let m=f-p;m>0&&(m=Math.max(10,m),this.circleDiameter=m)}else{let p=a.top*s-l[0],f=a.bottom*s+l[2],y=a.left*s-l[3],m=a.right*s+l[1],h=a.collisionPadding;if(h&&(y-=h[0]*s,p-=h[1]*s,m+=h[2]*s,f+=h[3]*s),c){let d=new ui.default(y,p),g=new ui.default(m,p),b=new ui.default(y,f),x=new ui.default(m,f),v=c*Math.PI/180;d._rotate(v),g._rotate(v),b._rotate(v),x._rotate(v),y=Math.min(d.x,g.x,b.x,x.x),m=Math.max(d.x,g.x,b.x,x.x),p=Math.min(d.y,g.y,b.y,x.y),f=Math.max(d.y,g.y,b.y,x.y)}t.emplaceBack(r.x,r.y,y,p,m,f,n,i,o)}this.boxEndIndex=t.length}};var ci=class{constructor(t=[],r=Sb){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let t=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),t}peek(){return this.data[0]}_up(t){let{data:r,compare:n}=this,i=r[t];for(;t>0;){let o=t-1>>1,a=r[o];if(n(i,a)>=0)break;r[t]=a,t=o}r[t]=i}_down(t){let{data:r,compare:n}=this,i=this.length>>1,o=r[t];for(;t<i;){let a=(t<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[t]=s,t=a}r[t]=o}};function Sb(e,t){return e<t?-1:e>t?1:0}var tl=Z(he(),1);function Lf(e,t=1,r=!1){let n=1/0,i=1/0,o=-1/0,a=-1/0,s=e[0];for(let h=0;h<s.length;h++){let d=s[h];(!h||d.x<n)&&(n=d.x),(!h||d.y<i)&&(i=d.y),(!h||d.x>o)&&(o=d.x),(!h||d.y>a)&&(a=d.y)}let l=o-n,u=a-i,c=Math.min(l,u),p=c/2,f=new ci([],wb);if(c===0)return new tl.default(n,i);for(let h=n;h<o;h+=c)for(let d=i;d<a;d+=c)f.push(new Br(h+p,d+p,p,e));let y=_b(e),m=f.length;for(;f.length;){let h=f.pop();(h.d>y.d||!y.d)&&(y=h,r&&console.log("found best %d after %d probes",Math.round(1e4*h.d)/1e4,m)),!(h.max-y.d<=t)&&(p=h.h/2,f.push(new Br(h.p.x-p,h.p.y-p,p,e)),f.push(new Br(h.p.x+p,h.p.y-p,p,e)),f.push(new Br(h.p.x-p,h.p.y+p,p,e)),f.push(new Br(h.p.x+p,h.p.y+p,p,e)),m+=4)}return r&&(console.log(`num probes: ${m}`),console.log(`best distance: ${y.d}`)),y.p}function wb(e,t){return t.max-e.max}function Br(e,t,r,n){this.p=new tl.default(e,t),this.h=r,this.d=Ab(this.p,n),this.max=this.d+this.h*Math.SQRT2}function Ab(e,t){let r=!1,n=1/0;for(let i=0;i<t.length;i++){let o=t[i];for(let a=0,s=o.length,l=s-1;a<s;l=a++){let u=o[a],c=o[l];u.y>e.y!=c.y>e.y&&e.x<(c.x-u.x)*(e.y-u.y)/(c.y-u.y)+u.x&&(r=!r),n=Math.min(n,Fs(e,u,c))}}return(r?1:-1)*Math.sqrt(n)}function _b(e){let t=0,r=0,n=0,i=e[0];for(let o=0,a=i.length,s=a-1;o<a;s=o++){let l=i[o],u=i[s],c=l.x*u.y-u.x*l.y;r+=(l.x+u.x)*c,n+=(l.y+u.y)*c,t+=c*3}return new Br(r/t,n/t,0,e)}var ol=Z(Is(),1);var rl=(o=>(o[o.center=1]="center",o[o.left=2]="left",o[o.right=3]="right",o[o.top=4]="top",o[o.bottom=5]="bottom",o[o["top-left"]=6]="top-left",o[o["top-right"]=7]="top-right",o[o["bottom-left"]=8]="bottom-left",o[o["bottom-right"]=9]="bottom-right",o))(rl||{}),kt=7,ha=Number.POSITIVE_INFINITY;function nl(e,t){function r(i,o){let a=0,s=0;o<0&&(o=0);let l=o/Math.SQRT2;switch(i){case"top-right":case"top-left":s=l-kt;break;case"bottom-right":case"bottom-left":s=-l+kt;break;case"bottom":s=-o+kt;break;case"top":s=o-kt;break}switch(i){case"top-right":case"bottom-right":a=-l;break;case"top-left":case"bottom-left":a=l;break;case"left":a=o;break;case"right":a=-o;break}return[a,s]}function n(i,o,a){let s=0,l=0;switch(o=Math.abs(o),a=Math.abs(a),i){case"top-right":case"top-left":case"top":l=a-kt;break;case"bottom-right":case"bottom-left":case"bottom":l=-a+kt;break}switch(i){case"top-right":case"bottom-right":case"right":s=-o;break;case"top-left":case"bottom-left":case"left":s=o;break}return[s,l]}return t[1]!==ha?n(e,t[0],t[1]):r(e,t[0])}function il(e,t,r){var a;let n=e.layout,i=(a=n.get("text-variable-anchor-offset"))==null?void 0:a.evaluate(t,{},r);if(i){let s=i.values,l=[];for(let u=0;u<s.length;u+=2){let c=l[u]=s[u],p=s[u+1].map(f=>f*ne);c.startsWith("top")?p[1]-=kt:c.startsWith("bottom")&&(p[1]+=kt),l[u+1]=p}return new Ne(l)}let o=n.get("text-variable-anchor");if(o){let s;e._unevaluatedLayout.getValue("text-radial-offset")!==void 0?s=[n.get("text-radial-offset").evaluate(t,{},r)*ne,ha]:s=n.get("text-offset").evaluate(t,{},r).map(c=>c*ne);let u=[];for(let c of o)u.push(c,nl(c,s));return new Ne(u)}return null}function Bf(e){e.bucket.createArrays();let t=512*e.bucket.overscaling;e.bucket.tilePixelRatio=8192/t,e.bucket.compareText={},e.bucket.iconsNeedLinear=!1;let r=e.bucket.layers[0],n=r.layout,i=r._unevaluatedLayout._values,o={layoutIconSize:i["icon-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),layoutTextSize:i["text-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),textMaxSize:i["text-size"].possiblyEvaluate(new q(18))};if(e.bucket.textSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=e.bucket.textSizeData;o.compositeTextSizes=[i["text-size"].possiblyEvaluate(new q(c),e.canonical),i["text-size"].possiblyEvaluate(new q(p),e.canonical)]}if(e.bucket.iconSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=e.bucket.iconSizeData;o.compositeIconSizes=[i["icon-size"].possiblyEvaluate(new q(c),e.canonical),i["icon-size"].possiblyEvaluate(new q(p),e.canonical)]}let a=n.get("text-line-height")*ne,s=n.get("text-rotation-alignment")!=="viewport"&&n.get("symbol-placement")!=="point",l=n.get("text-keep-upright"),u=n.get("text-size");for(let c of e.bucket.features){let p=n.get("text-font").evaluate(c,{},e.canonical).join(","),f=u.evaluate(c,{},e.canonical),y=o.layoutTextSize.evaluate(c,{},e.canonical),m=o.layoutIconSize.evaluate(c,{},e.canonical),h={horizontal:{},vertical:void 0},d=c.text,g=[0,0];if(d){let P=d.toString(),w=n.get("text-letter-spacing").evaluate(c,{},e.canonical)*ne,T=hc(P)?w:0,F=n.get("text-anchor").evaluate(c,{},e.canonical),E=il(r,c,e.canonical);if(!E){let A=n.get("text-radial-offset").evaluate(c,{},e.canonical);A?g=nl(F,[A*ne,ha]):g=n.get("text-offset").evaluate(c,{},e.canonical).map(z=>z*ne)}let _=s?"center":n.get("text-justify").evaluate(c,{},e.canonical),I=n.get("symbol-placement"),k=I==="point"?n.get("text-max-width").evaluate(c,{},e.canonical)*ne:0,V=()=>{e.bucket.allowVerticalPlacement&&mn(P)&&(h.vertical=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,"left",T,g,2,!0,I,y,f))};if(!s&&E){let A=new Set;if(_==="auto")for(let O=0;O<E.values.length;O+=2)A.add(Df(E.values[O]));else A.add(_);let z=!1;for(let O of A)if(!h.horizontal[O])if(z)h.horizontal[O]=h.horizontal[0];else{let N=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,"center",O,T,g,1,!1,I,y,f);N&&(h.horizontal[O]=N,z=N.positionedLines.length===1)}V()}else{_==="auto"&&(_=Df(F));let A=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,_,T,g,1,!1,I,y,f);A&&(h.horizontal[_]=A),V(),mn(P)&&s&&l&&(h.vertical=ni(d,e.glyphMap,e.glyphPositions,e.imagePositions,p,k,a,F,_,T,g,2,!1,I,y,f))}}let b,x=!1;if(c.icon&&c.icon.name){let P=e.imageMap[c.icon.name];P&&(b=sf(e.imagePositions[c.icon.name],n.get("icon-offset").evaluate(c,{},e.canonical),n.get("icon-anchor").evaluate(c,{},e.canonical)),x=!!P.sdf,e.bucket.sdfIcons===void 0?e.bucket.sdfIcons=x:e.bucket.sdfIcons!==x&&fe("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(P.pixelRatio!==e.bucket.pixelRatio||n.get("icon-rotate").constantOr(1)!==0)&&(e.bucket.iconsNeedLinear=!0))}let v=zf(h.horizontal)||h.vertical;e.bucket.iconsInText=v?v.iconsInText:!1,(v||b)&&Ib(e.bucket,c,h,b,e.imageMap,o,y,m,g,x,e.canonical)}e.showCollisionBoxes&&e.bucket.generateCollisionDebugBuffers()}function Df(e){switch(e){case"right":case"top-right":case"bottom-right":return"right";case"left":case"top-left":case"bottom-left":return"left"}return"center"}function Ib(e,t,r,n,i,o,a,s,l,u,c){let p=o.textMaxSize.evaluate(t,{});p===void 0&&(p=a);let f=e.layers[0].layout,y=f.get("icon-offset").evaluate(t,{},c),m=zf(r.horizontal),h=24,d=a/h,g=e.tilePixelRatio*d,b=e.tilePixelRatio*p/h,x=e.tilePixelRatio*s,v=e.tilePixelRatio*f.get("symbol-spacing"),P=f.get("text-padding")*e.tilePixelRatio,w=yf(f,t,c,e.tilePixelRatio),T=f.get("text-max-angle")/180*Math.PI,F=f.get("text-rotation-alignment")!=="viewport"&&f.get("symbol-placement")!=="point",E=f.get("icon-rotation-alignment")==="map"&&f.get("symbol-placement")!=="point",_=f.get("symbol-placement"),I=v/2,k=f.get("icon-text-fit"),V;n&&k!=="none"&&(e.allowVerticalPlacement&&r.vertical&&(V=Xs(n,r.vertical,k,f.get("icon-text-fit-padding"),y,d)),m&&(n=Xs(n,m,k,f.get("icon-text-fit-padding"),y,d)));let A=(z,O)=>{O.x<0||O.x>=8192||O.y<0||O.y>=8192||Cb(e,O,z,r,n,i,V,e.layers[0],e.collisionBoxArray,t.index,t.sourceLayerIndex,e.index,g,[P,P,P,P],F,l,x,w,E,y,t,o,u,c,a)};if(_==="line")for(let z of Mf(t.geometry,0,0,8192,8192)){let O=Cf(z,v,T,r.vertical||m,n,h,b,e.overscaling,8192);for(let N of O){let K=m;(!K||!kb(e,K.text,I,N))&&A(z,N)}}else if(_==="line-center"){for(let z of t.geometry)if(z.length>1){let O=Tf(z,T,r.vertical||m,n,h,b);O&&A(z,O)}}else if(t.type==="Polygon")for(let z of _r(t.geometry,0)){let O=Lf(z,16);A(z[0],new rt(O.x,O.y,0))}else if(t.type==="LineString")for(let z of t.geometry)A(z,new rt(z[0].x,z[0].y,0));else if(t.type==="Point")for(let z of t.geometry)for(let O of z)A([O],new rt(O.x,O.y,0))}function Tb(e,t){let r=e.length,n=t==null?void 0:t.values;if((n==null?void 0:n.length)>0)for(let i=0;i<n.length;i+=2){let o=rl[n[i]],a=n[i+1];e.emplaceBack(o,a[0],a[1])}return[r,e.length]}function Vf(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=Ff(t,r,s,i,o,a,n,e.allowVerticalPlacement),d=e.textSizeData,g=null;d.kind==="source"?(g=[Ct*i.layout.get("text-size").evaluate(a,{})],g[0]>tt&&fe(`${e.layerIds[0]}: Value for "text-size" is >= ${Lr}. Reduce your "text-size".`)):d.kind==="composite"&&(g=[Ct*y.compositeTextSizes[0].evaluate(a,{},m),Ct*y.compositeTextSizes[1].evaluate(a,{},m)],(g[0]>tt||g[1]>tt)&&fe(`${e.layerIds[0]}: Value for "text-size" is >= ${Lr}. Reduce your "text-size".`)),e.addSymbols(e.text,h,g,s,o,a,u,t,l.lineStartIndex,l.lineLength,f,m);for(let b of c)p[b]=e.text.placedSymbolArray.length-1;return h.length*4}function zf(e){for(let t in e)return e[t];return null}function Cb(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F){let E=e.addToLineVertexArray(t,r),_,I,k,V,A=0,z=0,O=0,N=0,K=-1,xe=-1,X={},le=(0,ol.default)("");if(e.allowVerticalPlacement&&n.vertical){let ve=s.layout.get("text-rotate").evaluate(v,{},T)+90,Ve=n.vertical;k=new nr(l,t,u,c,p,Ve,f,y,m,ve),a&&(V=new nr(l,t,u,c,p,a,d,g,m,ve))}if(i){let Ie=s.layout.get("icon-rotate").evaluate(v,{}),ve=s.layout.get("icon-text-fit")!=="none",Ve=el(i,Ie,w,ve),Nr=a?el(a,Ie,w,ve):void 0;I=new nr(l,t,u,c,p,i,d,g,!1,Ie),A=Ve.length*4;let Fl=e.iconSizeData,Lt=null;Fl.kind==="source"?(Lt=[Ct*s.layout.get("icon-size").evaluate(v,{})],Lt[0]>tt&&fe(`${e.layerIds[0]}: Value for "icon-size" is >= ${Lr}. Reduce your "icon-size".`)):Fl.kind==="composite"&&(Lt=[Ct*P.compositeIconSizes[0].evaluate(v,{},T),Ct*P.compositeIconSizes[1].evaluate(v,{},T)],(Lt[0]>tt||Lt[1]>tt)&&fe(`${e.layerIds[0]}: Value for "icon-size" is >= ${Lr}. Reduce your "icon-size".`)),e.addSymbols(e.icon,Ve,Lt,x,b,v,0,t,E.lineStartIndex,E.lineLength,-1,T),K=e.icon.placedSymbolArray.length-1,Nr&&(z=Nr.length*4,e.addSymbols(e.icon,Nr,Lt,x,b,v,2,t,E.lineStartIndex,E.lineLength,-1,T),xe=e.icon.placedSymbolArray.length-1)}let ce=Object.keys(n.horizontal);for(let Ie of ce){let ve=n.horizontal[Ie];if(!_){le=(0,ol.default)(ve.text);let Nr=s.layout.get("text-rotate").evaluate(v,{},T);_=new nr(l,t,u,c,p,ve,f,y,m,Nr)}let Ve=ve.positionedLines.length===1;if(O+=Vf(e,t,ve,o,s,m,v,h,E,n.vertical?1:3,Ve?ce:[Ie],X,K,P,T),Ve)break}n.vertical&&(N+=Vf(e,t,n.vertical,o,s,m,v,h,E,2,["vertical"],X,xe,P,T));let pe=_?_.boxStartIndex:e.collisionBoxArray.length,_e=_?_.boxEndIndex:e.collisionBoxArray.length,be=k?k.boxStartIndex:e.collisionBoxArray.length,wi=k?k.boxEndIndex:e.collisionBoxArray.length,Ea=I?I.boxStartIndex:e.collisionBoxArray.length,Fa=I?I.boxEndIndex:e.collisionBoxArray.length,Or=V?V.boxStartIndex:e.collisionBoxArray.length,Ai=V?V.boxEndIndex:e.collisionBoxArray.length,Me=-1,Ft=(Ie,ve)=>Ie&&Ie.circleDiameter?Math.max(Ie.circleDiameter,ve):ve;Me=Ft(_,Me),Me=Ft(k,Me),Me=Ft(I,Me),Me=Ft(V,Me);let _i=Me>-1?1:0;_i&&(Me*=F/ne),e.glyphOffsetArray.length>=He.MAX_GLYPHS&&fe("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),v.sortKey!==void 0&&e.addToSortKeyRanges(e.symbolInstances.length,v.sortKey);let La=il(s,v,T),[Da,Va]=Tb(e.textAnchorOffsets,La);e.symbolInstances.emplaceBack(t.x,t.y,X.right>=0?X.right:-1,X.center>=0?X.center:-1,X.left>=0?X.left:-1,X.vertical||-1,K,xe,le,pe,_e,be,wi,Ea,Fa,Or,Ai,u,O,N,A,z,_i,0,f,Me,Da,Va)}function kb(e,t,r,n){let i=e.compareText;if(!(t in i))i[t]=[];else{let o=i[t];for(let a=o.length-1;a>=0;a--)if(n.dist(o[a])<r)return!0}return i[t].push(n),!1}var da=1,pi=class{constructor(t){let r={},n=[];for(let s in t){let l=t[s],u=r[s]={};for(let c in l){let p=l[+c];if(!p||p.bitmap.width===0||p.bitmap.height===0)continue;let f={x:0,y:0,w:p.bitmap.width+2*da,h:p.bitmap.height+2*da};n.push(f),u[c]={rect:f,metrics:p.metrics}}}let{w:i,h:o}=ei(n),a=new Yt({width:i||1,height:o||1});for(let s in t){let l=t[s];for(let u in l){let c=l[+u];if(!c||c.bitmap.width===0||c.bitmap.height===0)continue;let p=r[s][u].rect;Yt.copy(c.bitmap,a,{x:0,y:0},{x:p.x+da,y:p.y+da},c.bitmap)}}this.image=a,this.positions=r}};C("GlyphAtlas",pi);function Of(e,t,r){t=Math.pow(2,r)-t-1;var n=Rf(e*256,t*256,r),i=Rf((e+1)*256,(t+1)*256,r);return n[0]+","+n[1]+","+i[0]+","+i[1]}function Rf(e,t,r){var n=2*Math.PI*6378137/256/Math.pow(2,r),i=e*n-2*Math.PI*6378137/2,o=t*n-2*Math.PI*6378137/2;return[i,o]}var $f=Z(he(),1);var al=63710088e-1,fi=class e{constructor(t,r){if(isNaN(t)||isNaN(r))throw new Error(`Invalid LngLat object: (${t}, ${r})`);if(this.lng=+t,this.lat=+r,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new e(Gl(this.lng,-180,180),this.lat)}toArray(){return[this.lng,this.lat]}toString(){return`LngLat(${this.lng}, ${this.lat})`}distanceTo(t){let r=Math.PI/180,n=this.lat*r,i=t.lat*r,o=Math.sin(n)*Math.sin(i)+Math.cos(n)*Math.cos(i)*Math.cos((t.lng-this.lng)*r);return al*Math.acos(Math.min(o,1))}static convert(t){if(t instanceof e)return t;if(Array.isArray(t)&&(t.length===2||t.length===3))return new e(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&typeof t=="object"&&t!==null)return new e(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}};var Nf=2*Math.PI*al;function Uf(e){return Nf*Math.cos(e*Math.PI/180)}function Mb(e){return(180+e)/360}function Eb(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function Fb(e,t){return e/Uf(t)}function Lb(e){return e*360-180}function sl(e){let t=180-e*360;return 360/Math.PI*Math.atan(Math.exp(t*Math.PI/180))-90}function Db(e,t){return e*Uf(sl(t))}function Vb(e){return 1/Math.cos(e*Math.PI/180)}var ga=class e{constructor(t,r,n=0){this.x=+t,this.y=+r,this.z=+n}static fromLngLat(t,r=0){let n=fi.convert(t);return new e(Mb(n.lng),Eb(n.lat),Fb(r,n.lat))}toLngLat(){return new fi(Lb(this.x),sl(this.y))}toAltitude(){return Db(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/Nf*Vb(sl(this.y))}};var xa=class{constructor(t,r,n){if(t<0||t>25||n<0||n>=Math.pow(2,t)||r<0||r>=Math.pow(2,t))throw new Error(`x=${r}, y=${n}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);this.z=t,this.x=r,this.y=n,this.key=yi(0,t,t,r,n)}equals(t){return this.z===t.z&&this.x===t.x&&this.y===t.y}url(t,r,n){let i=Of(this.x,this.y,this.z),o=Bb(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace(/{prefix}/g,(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String(n==="tms"?Math.pow(2,this.z)-this.y-1:this.y)).replace(/{ratio}/g,r>1?"@2x":"").replace(/{quadkey}/g,o).replace(/{bbox-epsg-3857}/g,i)}isChildOf(t){let r=this.z-t.z;return r>0&&t.x===this.x>>r&&t.y===this.y>>r}getTilePoint(t){let r=Math.pow(2,this.z);return new $f.default((t.x*r-this.x)*8192,(t.y*r-this.y)*8192)}toString(){return`${this.z}/${this.x}/${this.y}`}},ll=class{constructor(t,r){this.wrap=t,this.canonical=r,this.key=yi(t,r.z,r.z,r.x,r.y)}},mi=class e{constructor(t,r,n,i,o){if(t<n)throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${n}`);this.overscaledZ=t,this.wrap=r,this.canonical=new xa(n,+i,+o),this.key=yi(r,t,n,i,o)}clone(){return new e(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)}equals(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)}scaledTo(t){if(t>this.overscaledZ)throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);let r=this.canonical.z-t;return t>this.canonical.z?new e(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new e(t,this.wrap,t,this.canonical.x>>r,this.canonical.y>>r)}calculateScaledKey(t,r){if(t>this.overscaledZ)throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);let n=this.canonical.z-t;return t>this.canonical.z?yi(this.wrap*+r,t,this.canonical.z,this.canonical.x,this.canonical.y):yi(this.wrap*+r,t,t,this.canonical.x>>n,this.canonical.y>>n)}isChildOf(t){if(t.wrap!==this.wrap)return!1;let r=this.canonical.z-t.canonical.z;return t.overscaledZ===0||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>r&&t.canonical.y===this.canonical.y>>r}children(t){if(this.overscaledZ>=t)return[new e(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];let r=this.canonical.z+1,n=this.canonical.x*2,i=this.canonical.y*2;return[new e(r,this.wrap,r,n,i),new e(r,this.wrap,r,n+1,i),new e(r,this.wrap,r,n,i+1),new e(r,this.wrap,r,n+1,i+1)]}isLessThan(t){return this.wrap<t.wrap?!0:this.wrap>t.wrap?!1:this.overscaledZ<t.overscaledZ?!0:this.overscaledZ>t.overscaledZ?!1:this.canonical.x<t.canonical.x?!0:this.canonical.x>t.canonical.x?!1:this.canonical.y<t.canonical.y}wrapped(){return new e(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(t){return new e(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new ll(this.wrap,this.canonical)}toString(){return`${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`}getTilePoint(t){return this.canonical.getTilePoint(new ga(t.x-this.wrap,t.y))}};function yi(e,t,r,n,i){e*=2,e<0&&(e=e*-1-1);let o=1<<r;return(o*o*e+o*i+n).toString(36)+r.toString(36)+t.toString(36)}function Bb(e,t,r){let n="",i;for(let o=e;o>0;o--)i=1<<o-1,n+=(t&i?1:0)+(r&i?2:0);return n}C("CanonicalTileID",xa);C("OverscaledTileID",mi,{omit:["posMatrix"]});var ba=class{constructor(t){this.tileID=new mi(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId,this.inFlightDependencies=[]}async parse(t,r,n,i){this.status="parsing",this.data=t,this.collisionBoxArray=new Fn;let o=new Dr(Object.keys(t.layers).sort()),a=new li(this.tileID,this.promoteId);a.bucketLayerIDs=[];let s={},l={featureIndex:a,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:n},u=r.familiesBySource[this.source];for(let P in u){let w=t.layers[P];if(!w)continue;w.version===1&&fe(`Vector tile source "${this.source}" layer "${P}" does not use vector tile spec v2 and therefore may have some rendering errors.`);let T=o.encode(P),F=[];for(let E=0;E<w.length;E++){let _=w.feature(E),I=a.getId(_,P);F.push({feature:_,id:I,index:E,sourceLayerIndex:T})}for(let E of u[P]){let _=E[0];if(_.source!==this.source&&fe(`layer.source = ${_.source} does not equal this.source = ${this.source}`),_.minzoom&&this.zoom<Math.floor(_.minzoom)||_.maxzoom&&this.zoom>=_.maxzoom||_.visibility==="none")continue;ul(E,this.zoom,n),(s[_.id]=_.createBucket({index:a.bucketLayerIDs.length,layers:E,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:T,sourceID:this.source})).populate(F,l,this.tileID.canonical),a.bucketLayerIDs.push(E.map(k=>k.id))}}let c=Gr(l.glyphDependencies,P=>Object.keys(P).map(Number));this.inFlightDependencies.forEach(P=>P==null?void 0:P.abort()),this.inFlightDependencies=[];let p=Promise.resolve({});if(Object.keys(c).length){let P=new AbortController;this.inFlightDependencies.push(P),p=i.sendAsync({type:"GG",data:{stacks:c,source:this.source,tileID:this.tileID,type:"glyphs"}},P)}let f=Object.keys(l.iconDependencies),y=Promise.resolve({});if(f.length){let P=new AbortController;this.inFlightDependencies.push(P),y=i.sendAsync({type:"GI",data:{icons:f,source:this.source,tileID:this.tileID,type:"icons"}},P)}let m=Object.keys(l.patternDependencies),h=Promise.resolve({});if(m.length){let P=new AbortController;this.inFlightDependencies.push(P),h=i.sendAsync({type:"GI",data:{icons:m,source:this.source,tileID:this.tileID,type:"patterns"}},P)}let[d,g,b]=await Promise.all([p,y,h]),x=new pi(d),v=new ti(g,b);for(let P in s){let w=s[P];w instanceof He?(ul(w.layers,this.zoom,n),Bf({bucket:w,glyphMap:d,glyphPositions:x.positions,imageMap:g,imagePositions:v.iconPositions,showCollisionBoxes:this.showCollisionBoxes,canonical:this.tileID.canonical})):w.hasPattern&&(w instanceof rr||w instanceof er||w instanceof tr)&&(ul(w.layers,this.zoom,n),w.addFeatures(l,this.tileID.canonical,v.patternPositions))}return this.status="done",{buckets:Object.values(s).filter(P=>!P.isEmpty()),featureIndex:a,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:x.image,imageAtlas:v,glyphMap:this.returnDependencies?d:null,iconMap:this.returnDependencies?g:null,glyphPositions:this.returnDependencies?x.positions:null}}};function ul(e,t,r){let n=new q(t);for(let i of e)i.recalculate(n,r)}var zb=60,OI=1e3/zb;var zr=class{constructor(t){this._marks={start:[t.url,"start"].join("#"),end:[t.url,"end"].join("#"),measure:t.url.toString()},performance.mark(this._marks.start)}finish(){performance.mark(this._marks.end);let t=performance.getEntriesByName(this._marks.measure);return t.length===0&&(performance.measure(this._marks.measure,this._marks.start,this._marks.end),t=performance.getEntriesByName(this._marks.measure),performance.clearMarks(this._marks.start),performance.clearMarks(this._marks.end),performance.clearMeasures(this._marks.measure)),t}};var Rr=class{constructor(t,r,n){this.actor=t,this.layerIndex=r,this.availableImages=n,this.fetching={},this.loading={},this.loaded={}}async loadVectorTile(t,r){let n=await uc(t.request,r);try{return{vectorTile:new Gf.default.VectorTile(new qf.default(n.data)),rawData:n.data,cacheControl:n.cacheControl,expires:n.expires}}catch(i){let o=new Uint8Array(n.data),a=o[0]===31&&o[1]===139,s=`Unable to parse the tile at ${t.request.url}, `;throw a?s+="please make sure the data is not gzipped and that you have configured the relevant header in the server":s+=`got error: ${i.messge}`,new Error(s)}}async loadTile(t){let r=t.uid,n=t&&t.request&&t.request.collectResourceTiming?new zr(t.request):!1,i=new ba(t);this.loading[r]=i;let o=new AbortController;i.abort=o;try{let a=await this.loadVectorTile(t,o);if(delete this.loading[r],!a)return null;let s=a.rawData,l={};a.expires&&(l.expires=a.expires),a.cacheControl&&(l.cacheControl=a.cacheControl);let u={};if(n){let p=n.finish();p&&(u.resourceTiming=JSON.parse(JSON.stringify(p)))}i.vectorTile=a.vectorTile;let c=i.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor);this.loaded[r]=i,this.fetching[r]={rawTileData:s,cacheControl:l,resourceTiming:u};try{let p=await c;return Pe({rawTileData:s.slice(0)},p,l,u)}finally{delete this.fetching[r]}}catch(a){throw delete this.loading[r],i.status="done",this.loaded[r]=i,a}}async reloadTile(t){let r=t.uid;if(!this.loaded||!this.loaded[r])throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");let n=this.loaded[r];if(n.showCollisionBoxes=t.showCollisionBoxes,n.status==="parsing"){let i=await n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor),o;if(this.fetching[r]){let{rawTileData:a,cacheControl:s,resourceTiming:l}=this.fetching[r];delete this.fetching[r],o=Pe({rawTileData:a.slice(0)},i,s,l)}else o=i;return o}if(n.status==="done"&&n.vectorTile)return n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor)}async abortTile(t){let r=this.loading,n=t.uid;r&&r[n]&&r[n].abort&&(r[n].abort.abort(),delete r[n])}async removeTile(t){this.loaded&&this.loaded[t.uid]&&delete this.loaded[t.uid]}};var hi=class{constructor(t,r,n,i=1,o=1,a=1,s=0){if(this.uid=t,r.height!==r.width)throw new RangeError("DEM tiles must be square");if(n&&!["mapbox","terrarium","custom"].includes(n)){fe(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);return}this.stride=r.height;let l=this.dim=r.height-2;switch(this.data=new Uint32Array(r.data.buffer),n){case"terrarium":this.redFactor=256,this.greenFactor=1,this.blueFactor=1/256,this.baseShift=32768;break;case"custom":this.redFactor=i,this.greenFactor=o,this.blueFactor=a,this.baseShift=s;break;case"mapbox":default:this.redFactor=6553.6,this.greenFactor=25.6,this.blueFactor=.1,this.baseShift=1e4;break}for(let u=0;u<l;u++)this.data[this._idx(-1,u)]=this.data[this._idx(0,u)],this.data[this._idx(l,u)]=this.data[this._idx(l-1,u)],this.data[this._idx(u,-1)]=this.data[this._idx(u,0)],this.data[this._idx(u,l)]=this.data[this._idx(u,l-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(l,-1)]=this.data[this._idx(l-1,0)],this.data[this._idx(-1,l)]=this.data[this._idx(0,l-1)],this.data[this._idx(l,l)]=this.data[this._idx(l-1,l-1)],this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER;for(let u=0;u<l;u++)for(let c=0;c<l;c++){let p=this.get(u,c);p>this.max&&(this.max=p),p<this.min&&(this.min=p)}}get(t,r){let n=new Uint8Array(this.data.buffer),i=this._idx(t,r)*4;return this.unpack(n[i],n[i+1],n[i+2])}getUnpackVector(){return[this.redFactor,this.greenFactor,this.blueFactor,this.baseShift]}_idx(t,r){if(t<-1||t>=this.dim+1||r<-1||r>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return(r+1)*this.stride+(t+1)}unpack(t,r,n){return t*this.redFactor+r*this.greenFactor+n*this.blueFactor-this.baseShift}getPixels(){return new de({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))}backfillBorder(t,r,n){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");let i=r*this.dim,o=r*this.dim+this.dim,a=n*this.dim,s=n*this.dim+this.dim;switch(r){case-1:i=o-1;break;case 1:o=i+1;break}switch(n){case-1:a=s-1;break;case 1:s=a+1;break}let l=-r*this.dim,u=-n*this.dim;for(let c=a;c<s;c++)for(let p=i;p<o;p++)this.data[this._idx(p,c)]=t.data[this._idx(p+l,c+u)]}};C("DEMData",hi);var va=class{constructor(){this.loaded={}}async loadTile(t){let{uid:r,encoding:n,rawImageData:i,redFactor:o,greenFactor:a,blueFactor:s,baseShift:l}=t,u=i.width+2,c=i.height+2,p=qr(i)?new de({width:u,height:c},await Wl(i,-1,-1,u,c)):i,f=new hi(r,p,n,o,a,s,l);return this.loaded=this.loaded||{},this.loaded[r]=f,f}removeTile(t){let r=this.loaded,n=t.uid;r&&r[n]&&delete r[n]}};var gy=Z(Wf(),1);var cl=Z(he(),1),Hf=Z(Tt(),1);var Rb=Hf.default.VectorTileFeature.prototype.toGeoJSON,pl=class{constructor(t){this._feature=t,this.extent=8192,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10))}loadGeometry(){if(this._feature.type===1){let t=[];for(let r of this._feature.geometry)t.push([new cl.default(r[0],r[1])]);return t}else{let t=[];for(let r of this._feature.geometry){let n=[];for(let i of r)n.push(new cl.default(i[0],i[1]));t.push(n)}return t}}toGeoJSON(t,r,n){return Rb.call(this,t,r,n)}},Sa=class{constructor(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=8192,this.length=t.length,this._features=t}feature(t){return new pl(this._features[t])}};var xy=Z(ty(),1);var ry=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ml=1,gi=8,bi=class e{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");let[r,n]=new Uint8Array(t,0,2);if(r!==219)throw new Error("Data does not appear to be in a KDBush format.");let i=n>>4;if(i!==ml)throw new Error(`Got v${i} data when expected v${ml}.`);let o=ry[n&15];if(!o)throw new Error("Unrecognized array type.");let[a]=new Uint16Array(t,2,1),[s]=new Uint32Array(t,4,1);return new e(s,a,o,t)}constructor(t,r=64,n=Float64Array,i){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+r,2),65535),this.ArrayType=n,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;let o=ry.indexOf(this.ArrayType),a=t*2*this.ArrayType.BYTES_PER_ELEMENT,s=t*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${n}.`);i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,gi,t),this.coords=new this.ArrayType(this.data,gi+s+l,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(gi+a+s+l),this.ids=new this.IndexArrayType(this.data,gi,t),this.coords=new this.ArrayType(this.data,gi+s+l,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(ml<<4)+o]),new Uint16Array(this.data,2,1)[0]=r,new Uint32Array(this.data,4,1)[0]=t)}add(t,r){let n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=t,this.coords[this._pos++]=r,n}finish(){let t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return dl(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,r,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],u=[];for(;l.length;){let c=l.pop()||0,p=l.pop()||0,f=l.pop()||0;if(p-f<=s){for(let d=f;d<=p;d++){let g=a[2*d],b=a[2*d+1];g>=t&&g<=n&&b>=r&&b<=i&&u.push(o[d])}continue}let y=f+p>>1,m=a[2*y],h=a[2*y+1];m>=t&&m<=n&&h>=r&&h<=i&&u.push(o[y]),(c===0?t<=m:r<=h)&&(l.push(f),l.push(y-1),l.push(1-c)),(c===0?n>=m:i>=h)&&(l.push(y+1),l.push(p),l.push(1-c))}return u}within(t,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:i,coords:o,nodeSize:a}=this,s=[0,i.length-1,0],l=[],u=n*n;for(;s.length;){let c=s.pop()||0,p=s.pop()||0,f=s.pop()||0;if(p-f<=a){for(let d=f;d<=p;d++)ny(o[2*d],o[2*d+1],t,r)<=u&&l.push(i[d]);continue}let y=f+p>>1,m=o[2*y],h=o[2*y+1];ny(m,h,t,r)<=u&&l.push(i[y]),(c===0?t-n<=m:r-n<=h)&&(s.push(f),s.push(y-1),s.push(1-c)),(c===0?t+n>=m:r+n>=h)&&(s.push(y+1),s.push(p),s.push(1-c))}return l}};function dl(e,t,r,n,i,o){if(i-n<=r)return;let a=n+i>>1;iy(e,t,a,n,i,o),dl(e,t,r,n,a-1,1-o),dl(e,t,r,a+1,i,1-o)}function iy(e,t,r,n,i,o){for(;i>n;){if(i-n>600){let u=i-n+1,c=r-n+1,p=Math.log(u),f=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*f*(u-f)/u)*(c-u/2<0?-1:1),m=Math.max(n,Math.floor(r-c*f/u+y)),h=Math.min(i,Math.floor(r+(u-c)*f/u+y));iy(e,t,r,m,h,o)}let a=t[2*r+o],s=n,l=i;for(xi(e,t,n,r),t[2*i+o]>a&&xi(e,t,n,i);s<l;){for(xi(e,t,s,l),s++,l--;t[2*s+o]<a;)s++;for(;t[2*l+o]>a;)l--}t[2*n+o]===a?xi(e,t,n,l):(l++,xi(e,t,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1)}}function xi(e,t,r,n){hl(e,r,n),hl(t,2*r,2*n),hl(t,2*r+1,2*n+1)}function hl(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function ny(e,t,r,n){let i=e-r,o=t-n;return i*i+o*o}var Hb={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},oy=Math.fround||(e=>t=>(e[0]=+t,e[0]))(new Float32Array(1)),ir=2,Et=3,gl=4,Mt=5,sy=6,vi=class{constructor(t){this.options=Object.assign(Object.create(Hb),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){let{log:r,minZoom:n,maxZoom:i}=this.options;r&&console.time("total time");let o=`prepare ${t.length} points`;r&&console.time(o),this.points=t;let a=[];for(let l=0;l<t.length;l++){let u=t[l];if(!u.geometry)continue;let[c,p]=u.geometry.coordinates,f=oy(Aa(c)),y=oy(_a(p));a.push(f,y,1/0,l,-1,1),this.options.reduce&&a.push(0)}let s=this.trees[i+1]=this._createTree(a);r&&console.timeEnd(o);for(let l=i;l>=n;l--){let u=+Date.now();s=this.trees[l]=this._createTree(this._cluster(s,l)),r&&console.log("z%d: %d clusters in %dms",l,s.numItems,+Date.now()-u)}return r&&console.timeEnd("total time"),this}getClusters(t,r){let n=((t[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,t[1])),o=t[2]===180?180:((t[2]+180)%360+360)%360-180,a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)n=-180,o=180;else if(n>o){let p=this.getClusters([n,i,180,a],r),f=this.getClusters([-180,i,o,a],r);return p.concat(f)}let s=this.trees[this._limitZoom(r)],l=s.range(Aa(n),_a(a),Aa(o),_a(i)),u=s.data,c=[];for(let p of l){let f=this.stride*p;c.push(u[f+Mt]>1?ay(u,f,this.clusterProps):this.points[u[f+Et]])}return c}getChildren(t){let r=this._getOriginId(t),n=this._getOriginZoom(t),i="No cluster with the specified id.",o=this.trees[n];if(!o)throw new Error(i);let a=o.data;if(r*this.stride>=a.length)throw new Error(i);let s=this.options.radius/(this.options.extent*Math.pow(2,n-1)),l=a[r*this.stride],u=a[r*this.stride+1],c=o.within(l,u,s),p=[];for(let f of c){let y=f*this.stride;a[y+gl]===t&&p.push(a[y+Mt]>1?ay(a,y,this.clusterProps):this.points[a[y+Et]])}if(p.length===0)throw new Error(i);return p}getLeaves(t,r,n){r=r||10,n=n||0;let i=[];return this._appendLeaves(i,t,r,n,0),i}getTile(t,r,n){let i=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:a,radius:s}=this.options,l=s/a,u=(n-l)/o,c=(n+1+l)/o,p={features:[]};return this._addTileFeatures(i.range((r-l)/o,u,(r+1+l)/o,c),i.data,r,n,o,p),r===0&&this._addTileFeatures(i.range(1-l/o,u,1,c),i.data,o,n,o,p),r===o-1&&this._addTileFeatures(i.range(0,u,l/o,c),i.data,-1,n,o,p),p.features.length?p:null}getClusterExpansionZoom(t){let r=this._getOriginZoom(t)-1;for(;r<=this.options.maxZoom;){let n=this.getChildren(t);if(r++,n.length!==1)break;t=n[0].properties.cluster_id}return r}_appendLeaves(t,r,n,i,o){let a=this.getChildren(r);for(let s of a){let l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(t,l.cluster_id,n,i,o):o<i?o++:t.push(s),t.length===n)break}return o}_createTree(t){let r=new bi(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<t.length;n+=this.stride)r.add(t[n],t[n+1]);return r.finish(),r.data=t,r}_addTileFeatures(t,r,n,i,o,a){for(let s of t){let l=s*this.stride,u=r[l+Mt]>1,c,p,f;if(u)c=ly(r,l,this.clusterProps),p=r[l],f=r[l+1];else{let h=this.points[r[l+Et]];c=h.properties;let[d,g]=h.geometry.coordinates;p=Aa(d),f=_a(g)}let y={type:1,geometry:[[Math.round(this.options.extent*(p*o-n)),Math.round(this.options.extent*(f*o-i))]],tags:c},m;u||this.options.generateId?m=r[l+Et]:m=this.points[r[l+Et]].id,m!==void 0&&(y.id=m),a.features.push(y)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,r){let{radius:n,extent:i,reduce:o,minPoints:a}=this.options,s=n/(i*Math.pow(2,r)),l=t.data,u=[],c=this.stride;for(let p=0;p<l.length;p+=c){if(l[p+ir]<=r)continue;l[p+ir]=r;let f=l[p],y=l[p+1],m=t.within(l[p],l[p+1],s),h=l[p+Mt],d=h;for(let g of m){let b=g*c;l[b+ir]>r&&(d+=l[b+Mt])}if(d>h&&d>=a){let g=f*h,b=y*h,x,v=-1,P=((p/c|0)<<5)+(r+1)+this.points.length;for(let w of m){let T=w*c;if(l[T+ir]<=r)continue;l[T+ir]=r;let F=l[T+Mt];g+=l[T]*F,b+=l[T+1]*F,l[T+gl]=P,o&&(x||(x=this._map(l,p,!0),v=this.clusterProps.length,this.clusterProps.push(x)),o(x,this._map(l,T)))}l[p+gl]=P,u.push(g/d,b/d,1/0,P,-1,d),o&&u.push(v)}else{for(let g=0;g<c;g++)u.push(l[p+g]);if(d>1)for(let g of m){let b=g*c;if(!(l[b+ir]<=r)){l[b+ir]=r;for(let x=0;x<c;x++)u.push(l[b+x])}}}}return u}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,r,n){if(t[r+Mt]>1){let a=this.clusterProps[t[r+sy]];return n?Object.assign({},a):a}let i=this.points[t[r+Et]].properties,o=this.options.map(i);return n&&o===i?Object.assign({},o):o}};function ay(e,t,r){return{type:"Feature",id:e[t+Et],properties:ly(e,t,r),geometry:{type:"Point",coordinates:[Xb(e[t]),Kb(e[t+1])]}}}function ly(e,t,r){let n=e[t+Mt],i=n>=1e4?`${Math.round(n/1e3)}k`:n>=1e3?`${Math.round(n/100)/10}k`:n,o=e[t+sy],a=o===-1?{}:Object.assign({},r[o]);return Object.assign(a,{cluster:!0,cluster_id:e[t+Et],point_count:n,point_count_abbreviated:i})}function Aa(e){return e/360+.5}function _a(e){let t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function Xb(e){return(e-.5)*360}function Kb(e){let t=(180-e*360)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function Pi(e,t,r,n){for(var i=n,o=r-t>>1,a=r-t,s,l=e[t],u=e[t+1],c=e[r],p=e[r+1],f=t+3;f<r;f+=3){var y=Yb(e[f],e[f+1],l,u,c,p);if(y>i)s=f,i=y;else if(y===i){var m=Math.abs(f-o);m<a&&(s=f,a=m)}}i>n&&(s-t>3&&Pi(e,t,s,n),e[s+2]=i,r-s>3&&Pi(e,s,r,n))}function Yb(e,t,r,n,i,o){var a=i-r,s=o-n;if(a!==0||s!==0){var l=((e-r)*a+(t-n)*s)/(a*a+s*s);l>1?(r=i,n=o):l>0&&(r+=a*l,n+=s*l)}return a=e-r,s=t-n,a*a+s*s}function ft(e,t,r,n){var i={id:typeof e>"u"?null:e,type:t,geometry:r,tags:n,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return Qb(i),i}function Qb(e){var t=e.geometry,r=e.type;if(r==="Point"||r==="MultiPoint"||r==="LineString")xl(e,t);else if(r==="Polygon"||r==="MultiLineString")for(var n=0;n<t.length;n++)xl(e,t[n]);else if(r==="MultiPolygon")for(n=0;n<t.length;n++)for(var i=0;i<t[n].length;i++)xl(e,t[n][i])}function xl(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1])}function Pl(e,t){var r=[];if(e.type==="FeatureCollection")for(var n=0;n<e.features.length;n++)Ia(r,e.features[n],t,n);else e.type==="Feature"?Ia(r,e,t):Ia(r,{geometry:e},t);return r}function Ia(e,t,r,n){if(t.geometry){var i=t.geometry.coordinates,o=t.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=n||0),o==="Point")uy(i,s);else if(o==="MultiPoint")for(var u=0;u<i.length;u++)uy(i[u],s);else if(o==="LineString")vl(i,s,a,!1);else if(o==="MultiLineString")if(r.lineMetrics){for(u=0;u<i.length;u++)s=[],vl(i[u],s,a,!1),e.push(ft(l,"LineString",s,t.properties));return}else bl(i,s,a,!1);else if(o==="Polygon")bl(i,s,a,!0);else if(o==="MultiPolygon")for(u=0;u<i.length;u++){var c=[];bl(i[u],c,a,!0),s.push(c)}else if(o==="GeometryCollection"){for(u=0;u<t.geometry.geometries.length;u++)Ia(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,n);return}else throw new Error("Input data is not a valid GeoJSON object.");e.push(ft(l,o,s,t.properties))}}function uy(e,t){t.push(cy(e[0])),t.push(py(e[1])),t.push(0)}function vl(e,t,r,n){for(var i,o,a=0,s=0;s<e.length;s++){var l=cy(e[s][0]),u=py(e[s][1]);t.push(l),t.push(u),t.push(0),s>0&&(n?a+=(i*u-l*o)/2:a+=Math.sqrt(Math.pow(l-i,2)+Math.pow(u-o,2))),i=l,o=u}var c=t.length-3;t[2]=1,Pi(t,0,c,r),t[c+2]=1,t.size=Math.abs(a),t.start=0,t.end=t.size}function bl(e,t,r,n){for(var i=0;i<e.length;i++){var o=[];vl(e[i],o,r,n),t.push(o)}}function cy(e){return e/360+.5}function py(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function qe(e,t,r,n,i,o,a,s){if(r/=t,n/=t,o>=r&&a<n)return e;if(a<r||o>=n)return null;for(var l=[],u=0;u<e.length;u++){var c=e[u],p=c.geometry,f=c.type,y=i===0?c.minX:c.minY,m=i===0?c.maxX:c.maxY;if(y>=r&&m<n){l.push(c);continue}else if(m<r||y>=n)continue;var h=[];if(f==="Point"||f==="MultiPoint")e0(p,h,r,n,i);else if(f==="LineString")yy(p,h,r,n,i,!1,s.lineMetrics);else if(f==="MultiLineString")Sl(p,h,r,n,i,!1);else if(f==="Polygon")Sl(p,h,r,n,i,!0);else if(f==="MultiPolygon")for(var d=0;d<p.length;d++){var g=[];Sl(p[d],g,r,n,i,!0),g.length&&h.push(g)}if(h.length){if(s.lineMetrics&&f==="LineString"){for(d=0;d<h.length;d++)l.push(ft(c.id,f,h[d],c.tags));continue}(f==="LineString"||f==="MultiLineString")&&(h.length===1?(f="LineString",h=h[0]):f="MultiLineString"),(f==="Point"||f==="MultiPoint")&&(f=h.length===3?"Point":"MultiPoint"),l.push(ft(c.id,f,h,c.tags))}}return l.length?l:null}function e0(e,t,r,n,i){for(var o=0;o<e.length;o+=3){var a=e[o+i];a>=r&&a<=n&&(t.push(e[o]),t.push(e[o+1]),t.push(e[o+2]))}}function yy(e,t,r,n,i,o,a){for(var s=fy(e),l=i===0?t0:r0,u=e.start,c,p,f=0;f<e.length-3;f+=3){var y=e[f],m=e[f+1],h=e[f+2],d=e[f+3],g=e[f+4],b=i===0?y:m,x=i===0?d:g,v=!1;a&&(c=Math.sqrt(Math.pow(y-d,2)+Math.pow(m-g,2))),b<r?x>r&&(p=l(s,y,m,d,g,r),a&&(s.start=u+c*p)):b>n?x<n&&(p=l(s,y,m,d,g,n),a&&(s.start=u+c*p)):wl(s,y,m,h),x<r&&b>=r&&(p=l(s,y,m,d,g,r),v=!0),x>n&&b<=n&&(p=l(s,y,m,d,g,n),v=!0),!o&&v&&(a&&(s.end=u+c*p),t.push(s),s=fy(e)),a&&(u+=c)}var P=e.length-3;y=e[P],m=e[P+1],h=e[P+2],b=i===0?y:m,b>=r&&b<=n&&wl(s,y,m,h),P=s.length-3,o&&P>=3&&(s[P]!==s[0]||s[P+1]!==s[1])&&wl(s,s[0],s[1],s[2]),s.length&&t.push(s)}function fy(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function Sl(e,t,r,n,i,o){for(var a=0;a<e.length;a++)yy(e[a],t,r,n,i,o,!1)}function wl(e,t,r,n){e.push(t),e.push(r),e.push(n)}function t0(e,t,r,n,i,o){var a=(o-t)/(n-t);return e.push(o),e.push(r+(i-r)*a),e.push(1),a}function r0(e,t,r,n,i,o){var a=(o-r)/(i-r);return e.push(t+(n-t)*a),e.push(o),e.push(1),a}function _l(e,t){var r=t.buffer/t.extent,n=e,i=qe(e,1,-1-r,r,0,-1,2,t),o=qe(e,1,1-r,2+r,0,-1,2,t);return(i||o)&&(n=qe(e,1,-r,1+r,0,-1,2,t)||[],i&&(n=my(i,1).concat(n)),o&&(n=n.concat(my(o,-1)))),n}function my(e,t){for(var r=[],n=0;n<e.length;n++){var i=e[n],o=i.type,a;if(o==="Point"||o==="MultiPoint"||o==="LineString")a=Al(i.geometry,t);else if(o==="MultiLineString"||o==="Polygon"){a=[];for(var s=0;s<i.geometry.length;s++)a.push(Al(i.geometry[s],t))}else if(o==="MultiPolygon")for(a=[],s=0;s<i.geometry.length;s++){for(var l=[],u=0;u<i.geometry[s].length;u++)l.push(Al(i.geometry[s][u],t));a.push(l)}r.push(ft(i.id,o,a,i.tags))}return r}function Al(e,t){var r=[];r.size=e.size,e.start!==void 0&&(r.start=e.start,r.end=e.end);for(var n=0;n<e.length;n+=3)r.push(e[n]+t,e[n+1],e[n+2]);return r}function Ta(e,t){if(e.transformed)return e;var r=1<<e.z,n=e.x,i=e.y,o,a,s;for(o=0;o<e.features.length;o++){var l=e.features[o],u=l.geometry,c=l.type;if(l.geometry=[],c===1)for(a=0;a<u.length;a+=2)l.geometry.push(hy(u[a],u[a+1],t,r,n,i));else for(a=0;a<u.length;a++){var p=[];for(s=0;s<u[a].length;s+=2)p.push(hy(u[a][s],u[a][s+1],t,r,n,i));l.geometry.push(p)}}return e.transformed=!0,e}function hy(e,t,r,n,i,o){return[Math.round(r*(e*n-i)),Math.round(r*(t*n-o))]}function Tl(e,t,r,n,i){for(var o=t===i.maxZoom?0:i.tolerance/((1<<t)*i.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:n,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<e.length;s++){a.numFeatures++,n0(a,e[s],o,i);var l=e[s].minX,u=e[s].minY,c=e[s].maxX,p=e[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),c>a.maxX&&(a.maxX=c),p>a.maxY&&(a.maxY=p)}return a}function n0(e,t,r,n){var i=t.geometry,o=t.type,a=[];if(o==="Point"||o==="MultiPoint")for(var s=0;s<i.length;s+=3)a.push(i[s]),a.push(i[s+1]),e.numPoints++,e.numSimplified++;else if(o==="LineString")Il(a,i,e,r,!1,!1);else if(o==="MultiLineString"||o==="Polygon")for(s=0;s<i.length;s++)Il(a,i[s],e,r,o==="Polygon",s===0);else if(o==="MultiPolygon")for(var l=0;l<i.length;l++){var u=i[l];for(s=0;s<u.length;s++)Il(a,u[s],e,r,!0,s===0)}if(a.length){var c=t.tags||null;if(o==="LineString"&&n.lineMetrics){c={};for(var p in t.tags)c[p]=t.tags[p];c.mapbox_clip_start=i.start/i.size,c.mapbox_clip_end=i.end/i.size}var f={geometry:a,type:o==="Polygon"||o==="MultiPolygon"?3:o==="LineString"||o==="MultiLineString"?2:1,tags:c};t.id!==null&&(f.id=t.id),e.features.push(f)}}function Il(e,t,r,n,i,o){var a=n*n;if(n>0&&t.size<(i?a:n)){r.numPoints+=t.length/3;return}for(var s=[],l=0;l<t.length;l+=3)(n===0||t[l+2]>a)&&(r.numSimplified++,s.push(t[l]),s.push(t[l+1])),r.numPoints++;i&&i0(s,o),e.push(s)}function i0(e,t){for(var r=0,n=0,i=e.length,o=i-2;n<i;o=n,n+=2)r+=(e[n]-e[o])*(e[n+1]+e[o+1]);if(r>0===t)for(n=0,i=e.length;n<i/2;n+=2){var a=e[n],s=e[n+1];e[n]=e[i-2-n],e[n+1]=e[i-1-n],e[i-2-n]=a,e[i-1-n]=s}}function kl(e,t){return new Ca(e,t)}function Ca(e,t){t=this.options=o0(Object.create(this.options),t);var r=t.debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var n=Pl(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=_l(n,t),n.length&&this.splitTile(n,0,0,0),r&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}Ca.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};Ca.prototype.splitTile=function(e,t,r,n,i,o,a){for(var s=[e,t,r,n],l=this.options,u=l.debug;s.length;){n=s.pop(),r=s.pop(),t=s.pop(),e=s.pop();var c=1<<t,p=Cl(t,r,n),f=this.tiles[p];if(!f&&(u>1&&console.time("creation"),f=this.tiles[p]=Tl(e,t,r,n,l),this.tileCoords.push({z:t,x:r,y:n}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,n,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));var y="z"+t;this.stats[y]=(this.stats[y]||0)+1,this.total++}if(f.source=e,i){if(t===l.maxZoom||t===i)continue;var m=1<<i-t;if(r!==Math.floor(o/m)||n!==Math.floor(a/m))continue}else if(t===l.indexMaxZoom||f.numPoints<=l.indexMaxPoints)continue;if(f.source=null,e.length!==0){u>1&&console.time("clipping");var h=.5*l.buffer/l.extent,d=.5-h,g=.5+h,b=1+h,x,v,P,w,T,F;x=v=P=w=null,T=qe(e,c,r-h,r+g,0,f.minX,f.maxX,l),F=qe(e,c,r+d,r+b,0,f.minX,f.maxX,l),e=null,T&&(x=qe(T,c,n-h,n+g,1,f.minY,f.maxY,l),v=qe(T,c,n+d,n+b,1,f.minY,f.maxY,l),T=null),F&&(P=qe(F,c,n-h,n+g,1,f.minY,f.maxY,l),w=qe(F,c,n+d,n+b,1,f.minY,f.maxY,l),F=null),u>1&&console.timeEnd("clipping"),s.push(x||[],t+1,r*2,n*2),s.push(v||[],t+1,r*2,n*2+1),s.push(P||[],t+1,r*2+1,n*2),s.push(w||[],t+1,r*2+1,n*2+1)}}};Ca.prototype.getTile=function(e,t,r){var n=this.options,i=n.extent,o=n.debug;if(e<0||e>24)return null;var a=1<<e;t=(t%a+a)%a;var s=Cl(e,t,r);if(this.tiles[s])return Ta(this.tiles[s],i);o>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l=e,u=t,c=r,p;!p&&l>0;)l--,u=Math.floor(u/2),c=Math.floor(c/2),p=this.tiles[Cl(l,u,c)];return!p||!p.source?null:(o>1&&console.log("found parent tile z%d-%d-%d",l,u,c),o>1&&console.time("drilling down"),this.splitTile(p.source,l,u,c,e,t,r),o>1&&console.timeEnd("drilling down"),this.tiles[s]?Ta(this.tiles[s],i):null)};function Cl(e,t,r){return((1<<e)*r+t)*32+e}function o0(e,t){for(var r in t)e[r]=t[r];return e}function Si(e,t){return t?e.properties[t]:e.id}function Ml(e,t){if(e==null)return!0;if(e.type==="Feature")return Si(e,t)!=null;if(e.type==="FeatureCollection"){let r=new Set;for(let n of e.features){let i=Si(n,t);if(i==null||r.has(i))return!1;r.add(i)}return!0}return!1}function El(e,t){let r=new Map;if(e!=null)if(e.type==="Feature")r.set(Si(e,t),e);else for(let n of e.features)r.set(Si(n,t),n);return r}function dy(e,t,r){var n,i,o,a;if(t.removeAll&&e.clear(),t.remove)for(let s of t.remove)e.delete(s);if(t.add)for(let s of t.add){let l=Si(s,r);l!=null&&e.set(l,s)}if(t.update)for(let s of t.update){let l=e.get(s.id);if(l==null)continue;let u=s.newGeometry||s.removeAllProperties,c=!s.removeAllProperties&&(((n=s.removeProperties)==null?void 0:n.length)>0||((i=s.addOrUpdateProperties)==null?void 0:i.length)>0);if((u||c)&&(l={...l},e.set(s.id,l),c&&(l.properties={...l.properties})),s.newGeometry&&(l.geometry=s.newGeometry),s.removeAllProperties)l.properties={};else if(((o=s.removeProperties)==null?void 0:o.length)>0)for(let p of s.removeProperties)Object.prototype.hasOwnProperty.call(l.properties,p)&&delete l.properties[p];if(((a=s.addOrUpdateProperties)==null?void 0:a.length)>0)for(let{key:p,value:f}of s.addOrUpdateProperties)l.properties[p]=f}}var ka=class extends Rr{constructor(){super(...arguments);this._dataUpdateable=new Map}async loadVectorTile(r,n){let i=r.tileID.canonical;if(!this._geoJSONIndex)throw new Error("Unable to parse the data into a cluster or geojson");let o=this._geoJSONIndex.getTile(i.z,i.x,i.y);if(!o)return null;let a=new Sa(o.features),s=(0,xy.default)(a);return(s.byteOffset!==0||s.byteLength!==s.buffer.byteLength)&&(s=new Uint8Array(s)),{vectorTile:a,rawData:s.buffer}}async loadData(r){var i;(i=this._pendingRequest)==null||i.abort();let n=r&&r.request&&r.request.collectResourceTiming?new zr(r.request):!1;this._pendingRequest=new AbortController;try{let o=await this.loadGeoJSON(r,this._pendingRequest);if(delete this._pendingRequest,typeof o!="object")throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`);if((0,gy.default)(o,!0),r.filter){let s=Gt(r.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if(s.result==="error")throw new Error(s.value.map(u=>`${u.key}: ${u.message}`).join(", "));o={type:"FeatureCollection",features:o.features.filter(u=>s.value.evaluate({zoom:0},u))}}this._geoJSONIndex=r.cluster?new vi(a0(r)).load(o.features):kl(o,r.geojsonVtOptions),this.loaded={};let a={};if(n){let s=n.finish();s&&(a.resourceTiming={},a.resourceTiming[r.source]=JSON.parse(JSON.stringify(s)))}return a}catch(o){if(delete this._pendingRequest,ec(o))return{abandoned:!0};throw o}}reloadTile(r){let n=this.loaded,i=r.uid;return n&&n[i]?super.reloadTile(r):this.loadTile(r)}async loadGeoJSON(r,n){let{promoteId:i}=r;if(r.request){let o=await lc(r.request,n);return this._dataUpdateable=Ml(o.data,i)?El(o.data,i):void 0,o.data}if(typeof r.data=="string")try{let o=JSON.parse(r.data);return this._dataUpdateable=Ml(o,i)?El(o,i):void 0,o}catch{throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`)}if(!r.dataDiff)throw new Error(`Input data given to \'${r.source}\' is not a valid GeoJSON object.`);if(!this._dataUpdateable)throw new Error(`Cannot update existing geojson data in ${r.source}`);return dy(this._dataUpdateable,r.dataDiff,i),{type:"FeatureCollection",features:Array.from(this._dataUpdateable.values())}}async removeSource(r){this._pendingRequest&&this._pendingRequest.abort()}getClusterExpansionZoom(r){return this._geoJSONIndex.getClusterExpansionZoom(r.clusterId)}getClusterChildren(r){return this._geoJSONIndex.getChildren(r.clusterId)}getClusterLeaves(r){return this._geoJSONIndex.getLeaves(r.clusterId,r.limit,r.offset)}};function a0({superclusterOptions:e,clusterProperties:t}){if(!t||!e)return e;let r={},n={},i={accumulated:null,zoom:0},o={properties:null},a=Object.keys(t);for(let s of a){let[l,u]=t[s],c=Gt(u),p=Gt(typeof l=="string"?[l,["accumulated"],["get",s]]:l);r[s]=c.value,n[s]=p.value}return e.map=s=>{o.properties=s;let l={};for(let u of a)l[u]=r[u].evaluate(i,o);return l},e.reduce=(s,l)=>{o.properties=l;for(let u of a)i.accumulated=s[u],s[u]=n[u].evaluate(i,o)},e}var Ma=class{constructor(t){this.self=t,this.actor=new to(t),this.layerIndexes={},this.availableImages={},this.workerSources={},this.demWorkerSources={},this.externalWorkerSourceTypes={},this.self.registerWorkerSource=(r,n)=>{if(this.externalWorkerSourceTypes[r])throw new Error(`Worker source with name "${r}" already registered.`);this.externalWorkerSourceTypes[r]=n},this.self.addProtocol=rc,this.self.removeProtocol=nc,this.self.registerRTLTextPlugin=r=>{if(ye.isParsed())throw new Error("RTL text plugin already registered.");ye.setMethods(r)},this.actor.registerMessageHandler("LDT",(r,n)=>this._getDEMWorkerSource(r,n.source).loadTile(n)),this.actor.registerMessageHandler("RDT",async(r,n)=>{this._getDEMWorkerSource(r,n.source).removeTile(n)}),this.actor.registerMessageHandler("GCEZ",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterExpansionZoom(n)),this.actor.registerMessageHandler("GCC",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterChildren(n)),this.actor.registerMessageHandler("GCL",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterLeaves(n)),this.actor.registerMessageHandler("LD",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadData(n)),this.actor.registerMessageHandler("LT",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadTile(n)),this.actor.registerMessageHandler("RT",(r,n)=>this._getWorkerSource(r,n.type,n.source).reloadTile(n)),this.actor.registerMessageHandler("AT",(r,n)=>this._getWorkerSource(r,n.type,n.source).abortTile(n)),this.actor.registerMessageHandler("RMT",(r,n)=>this._getWorkerSource(r,n.type,n.source).removeTile(n)),this.actor.registerMessageHandler("RS",async(r,n)=>{if(!this.workerSources[r]||!this.workerSources[r][n.type]||!this.workerSources[r][n.type][n.source])return;let i=this.workerSources[r][n.type][n.source];delete this.workerSources[r][n.type][n.source],i.removeSource!==void 0&&i.removeSource(n)}),this.actor.registerMessageHandler("RM",async r=>{delete this.layerIndexes[r],delete this.availableImages[r],delete this.workerSources[r],delete this.demWorkerSources[r]}),this.actor.registerMessageHandler("SR",async(r,n)=>{this.referrer=n}),this.actor.registerMessageHandler("SRPS",(r,n)=>this._syncRTLPluginState(r,n)),this.actor.registerMessageHandler("IS",async(r,n)=>{this.self.importScripts(n)}),this.actor.registerMessageHandler("SI",(r,n)=>this._setImages(r,n)),this.actor.registerMessageHandler("UL",async(r,n)=>{this._getLayerIndex(r).update(n.layers,n.removedIds)}),this.actor.registerMessageHandler("SL",async(r,n)=>{this._getLayerIndex(r).replace(n)})}async _setImages(t,r){this.availableImages[t]=r;for(let n in this.workerSources[t]){let i=this.workerSources[t][n];for(let o in i)i[o].availableImages=r}}async _syncRTLPluginState(t,r){if(ye.isParsed())return ye.getState();if(r.pluginStatus!=="loading")return ye.setState(r),r;let n=r.pluginURL;if(this.self.importScripts(n),ye.isParsed()){let o={pluginStatus:"loaded",pluginURL:n};return ye.setState(o),o}throw ye.setState({pluginStatus:"error",pluginURL:""}),new Error(`RTL Text Plugin failed to import scripts from ${n}`)}_getAvailableImages(t){let r=this.availableImages[t];return r||(r=[]),r}_getLayerIndex(t){let r=this.layerIndexes[t];return r||(r=this.layerIndexes[t]=new ca),r}_getWorkerSource(t,r,n){if(this.workerSources[t]||(this.workerSources[t]={}),this.workerSources[t][r]||(this.workerSources[t][r]={}),!this.workerSources[t][r][n]){let i={sendAsync:(o,a)=>(o.targetMapId=t,this.actor.sendAsync(o,a))};switch(r){case"vector":this.workerSources[t][r][n]=new Rr(i,this._getLayerIndex(t),this._getAvailableImages(t));break;case"geojson":this.workerSources[t][r][n]=new ka(i,this._getLayerIndex(t),this._getAvailableImages(t));break;default:this.workerSources[t][r][n]=new this.externalWorkerSourceTypes[r](i,this._getLayerIndex(t),this._getAvailableImages(t));break}}return this.workerSources[t][r][n]}_getDEMWorkerSource(t,r){return this.demWorkerSources[t]||(this.demWorkerSources[t]={}),this.demWorkerSources[t][r]||(this.demWorkerSources[t][r]=new va),this.demWorkerSources[t][r]}};at(self)&&(self.worker=new Ma(self));})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n';
var Uk = r(() => URL.createObjectURL(new Blob([Z0], { type: "text/javascript" })), "getWorkerURL");
function H0() {
  return new Worker(Uk());
}
r(H0, "workerFactory");
var hu = "maplibre_preloaded_worker_pool";
var pu = class pu2 {
  constructor() {
    this.active = {};
  }
  acquire(e) {
    if (!this.workers) for (this.workers = []; this.workers.length < pu2.workerCount; ) this.workers.push(H0());
    return this.active[e] = true, this.workers.slice();
  }
  release(e) {
    delete this.active[e], this.numActive() === 0 && (this.workers.forEach((t3) => {
      t3.terminate();
    }), this.workers = null);
  }
  isPreloaded() {
    return !!this.active[hu];
  }
  numActive() {
    return Object.keys(this.active).length;
  }
};
r(pu, "WorkerPool");
var Dr = pu;
var Nk = Math.floor(Y.hardwareConcurrency / 2);
Dr.workerCount = rb(globalThis) ? Math.max(Math.min(Nk, 3), 1) : 1;
var oa;
function aa() {
  return oa || (oa = new Dr()), oa;
}
r(aa, "getGlobalWorkerPool");
function Gk() {
  aa().acquire(hu);
}
r(Gk, "prewarm");
function $k() {
  let r3 = oa;
  r3 && (r3.isPreloaded() && r3.numActive() === 1 ? (r3.release(hu), oa = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
}
r($k, "clearPrewarmedResources");
var hd = class hd2 {
  constructor(e, t3) {
    this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = t3;
    let i = this.workerPool.acquire(t3);
    for (let n = 0; n < i.length; n++) {
      let o = i[n], a = new cu(o, t3);
      a.name = `Worker ${n}`, this.actors.push(a);
    }
    if (!this.actors.length) throw new Error("No actors found");
  }
  broadcast(e, t3) {
    let i = [];
    for (let n of this.actors) i.push(n.sendAsync({ type: e, data: t3 }));
    return Promise.all(i);
  }
  getActor() {
    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
  }
  remove(e = true) {
    this.actors.forEach((t3) => {
      t3.remove();
    }), this.actors = [], e && this.workerPool.release(this.id);
  }
  registerMessageHandler(e, t3) {
    for (let i of this.actors) i.registerMessageHandler(e, t3);
  }
};
r(hd, "Dispatcher");
var sa = hd;
var fu;
function mu() {
  return fu || (fu = new sa(aa(), as), fu.registerMessageHandler("GR", (r3, e, t3) => Ii(e, t3))), fu;
}
r(mu, "getGlobalDispatcher");
q();
function qk(r3, e) {
  let t3 = $.create();
  return $.translate(t3, t3, [1, 1, 0]), $.scale(t3, t3, [r3.width * 0.5, r3.height * 0.5, 1]), $.multiply(t3, t3, r3.calculatePosMatrix(e.toUnwrapped()));
}
r(qk, "getPixelPosMatrix");
function jk(r3, e, t3) {
  if (r3) for (let i of r3) {
    let n = e[i];
    if (n && n.source === t3 && n.type === "fill-extrusion") return true;
  }
  else for (let i in e) {
    let n = e[i];
    if (n.source === t3 && n.type === "fill-extrusion") return true;
  }
  return false;
}
r(jk, "queryIncludes3DLayer");
function W0(r3, e, t3, i, n, o) {
  let a = jk(n && n.layers, e, r3.id), s3 = o.maxPitchScaleFactor(), l = r3.tilesIn(i, s3, a);
  l.sort(J0);
  let c = [];
  for (let h of l) c.push({ wrappedTileID: h.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(e, t3, r3._state, h.queryGeometry, h.cameraQueryGeometry, h.scale, n, o, s3, qk(r3.transform, h.tileID)) });
  let p = Zk(c);
  for (let h in p) p[h].forEach((f) => {
    let m = f.feature, y = r3.getFeatureState(m.layer["source-layer"], m.id);
    m.source = m.layer.source, m.layer["source-layer"] && (m.sourceLayer = m.layer["source-layer"]), m.state = y;
  });
  return p;
}
r(W0, "queryRenderedFeatures");
function X0(r3, e, t3, i, n, o, a) {
  let s3 = {}, l = o.queryRenderedSymbols(i), c = [];
  for (let p of Object.keys(l).map(Number)) c.push(a[p]);
  c.sort(J0);
  for (let p of c) {
    let h = p.featureIndex.lookupSymbolFeatures(l[p.bucketInstanceId], e, p.bucketIndex, p.sourceLayerIndex, n.filter, n.layers, n.availableImages, r3);
    for (let f in h) {
      let m = s3[f] = s3[f] || [], y = h[f];
      y.sort((g, x) => {
        let b = p.featureSortOrder;
        if (b) {
          let w = b.indexOf(g.featureIndex);
          return b.indexOf(x.featureIndex) - w;
        } else return x.featureIndex - g.featureIndex;
      });
      for (let g of y) m.push(g);
    }
  }
  for (let p in s3) s3[p].forEach((h) => {
    let f = h.feature, m = r3[p], g = t3[m.source].getFeatureState(f.layer["source-layer"], f.id);
    f.source = f.layer.source, f.layer["source-layer"] && (f.sourceLayer = f.layer["source-layer"]), f.state = g;
  });
  return s3;
}
r(X0, "queryRenderedSymbols");
function K0(r3, e) {
  let t3 = r3.getRenderableIds().map((o) => r3.getTileByID(o)), i = [], n = {};
  for (let o = 0; o < t3.length; o++) {
    let a = t3[o], s3 = a.tileID.canonical.key;
    n[s3] || (n[s3] = true, a.querySourceFeatures(i, e));
  }
  return i;
}
r(K0, "querySourceFeatures");
function J0(r3, e) {
  let t3 = r3.tileID, i = e.tileID;
  return t3.overscaledZ - i.overscaledZ || t3.canonical.y - i.canonical.y || t3.wrap - i.wrap || t3.canonical.x - i.canonical.x;
}
r(J0, "sortTilesIn");
function Zk(r3) {
  let e = {}, t3 = {};
  for (let i of r3) {
    let n = i.queryResults, o = i.wrappedTileID, a = t3[o] = t3[o] || {};
    for (let s3 in n) {
      let l = n[s3], c = a[s3] = a[s3] || {}, p = e[s3] = e[s3] || [];
      for (let h of l) c[h.featureIndex] || (c[h.featureIndex] = true, p.push(h));
    }
  }
  return e;
}
r(Zk, "mergeRenderedFeatureLayers");
q();
q();
q();
q();
async function du(r3, e, t3) {
  let i = r3;
  if (r3.url ? i = (await yr(e.transformRequest(r3.url, "Source"), t3)).data : await Y.frameAsync(t3), !i) return null;
  let n = dr(V(i, r3), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
  return "vector_layers" in i && i.vector_layers && (n.vectorLayerIds = i.vector_layers.map((o) => o.id)), n;
}
r(du, "loadTileJson");
q();
q();
q();
var la = 63710088e-1;
var gi = class gi2 {
  constructor(e, t3) {
    if (isNaN(e) || isNaN(t3)) throw new Error(`Invalid LngLat object: (${e}, ${t3})`);
    if (this.lng = +e, this.lat = +t3, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
  }
  wrap() {
    return new gi2(Qt(this.lng, -180, 180), this.lat);
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return `LngLat(${this.lng}, ${this.lat})`;
  }
  distanceTo(e) {
    let t3 = Math.PI / 180, i = this.lat * t3, n = e.lat * t3, o = Math.sin(i) * Math.sin(n) + Math.cos(i) * Math.cos(n) * Math.cos((e.lng - this.lng) * t3);
    return la * Math.acos(Math.min(o, 1));
  }
  static convert(e) {
    if (e instanceof gi2) return e;
    if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new gi2(Number(e[0]), Number(e[1]));
    if (!Array.isArray(e) && typeof e == "object" && e !== null) return new gi2(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};
r(gi, "LngLat");
var ie = gi;
var zr = class zr2 {
  constructor(e, t3) {
    e && (t3 ? this.setSouthWest(e).setNorthEast(t3) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
  }
  setNorthEast(e) {
    return this._ne = e instanceof ie ? new ie(e.lng, e.lat) : ie.convert(e), this;
  }
  setSouthWest(e) {
    return this._sw = e instanceof ie ? new ie(e.lng, e.lat) : ie.convert(e), this;
  }
  extend(e) {
    let t3 = this._sw, i = this._ne, n, o;
    if (e instanceof ie) n = e, o = e;
    else if (e instanceof zr2) {
      if (n = e._sw, o = e._ne, !n || !o) return this;
    } else {
      if (Array.isArray(e)) if (e.length === 4 || e.every(Array.isArray)) {
        let a = e;
        return this.extend(zr2.convert(a));
      } else {
        let a = e;
        return this.extend(ie.convert(a));
      }
      else if (e && ("lng" in e || "lon" in e) && "lat" in e) return this.extend(ie.convert(e));
      return this;
    }
    return !t3 && !i ? (this._sw = new ie(n.lng, n.lat), this._ne = new ie(o.lng, o.lat)) : (t3.lng = Math.min(n.lng, t3.lng), t3.lat = Math.min(n.lat, t3.lat), i.lng = Math.max(o.lng, i.lng), i.lat = Math.max(o.lat, i.lat)), this;
  }
  getCenter() {
    return new ie((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new ie(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new ie(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toString() {
    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
  }
  isEmpty() {
    return !(this._sw && this._ne);
  }
  contains(e) {
    let { lng: t3, lat: i } = ie.convert(e), n = this._sw.lat <= i && i <= this._ne.lat, o = this._sw.lng <= t3 && t3 <= this._ne.lng;
    return this._sw.lng > this._ne.lng && (o = this._sw.lng >= t3 && t3 >= this._ne.lng), n && o;
  }
  static convert(e) {
    return e instanceof zr2 || !e ? e : new zr2(e);
  }
  static fromLngLat(e, t3 = 0) {
    let n = 360 * t3 / 40075017, o = n / Math.cos(Math.PI / 180 * e.lat);
    return new zr2(new ie(e.lng - o, e.lat - n), new ie(e.lng + o, e.lat + n));
  }
};
r(zr, "LngLatBounds");
var ut = zr;
q();
var Y0 = 2 * Math.PI * la;
function Q0(r3) {
  return Y0 * Math.cos(r3 * Math.PI / 180);
}
r(Q0, "circumferenceAtLatitude");
function Fr(r3) {
  return (180 + r3) / 360;
}
r(Fr, "mercatorXfromLng");
function Rr(r3) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r3 * Math.PI / 360))) / 360;
}
r(Rr, "mercatorYfromLat");
function gu(r3, e) {
  return r3 / Q0(e);
}
r(gu, "mercatorZfromAltitude");
function Hk(r3) {
  return r3 * 360 - 180;
}
r(Hk, "lngFromMercatorX");
function fd(r3) {
  let e = 180 - r3 * 360;
  return 360 / Math.PI * Math.atan(Math.exp(e * Math.PI / 180)) - 90;
}
r(fd, "latFromMercatorY");
function Wk(r3, e) {
  return r3 * Q0(fd(e));
}
r(Wk, "altitudeFromMercatorZ");
function Xk(r3) {
  return 1 / Math.cos(r3 * Math.PI / 180);
}
r(Xk, "mercatorScale");
var yu = class yu2 {
  constructor(e, t3, i = 0) {
    this.x = +e, this.y = +t3, this.z = +i;
  }
  static fromLngLat(e, t3 = 0) {
    let i = ie.convert(e);
    return new yu2(Fr(i.lng), Rr(i.lat), gu(t3, i.lat));
  }
  toLngLat() {
    return new ie(Hk(this.x), fd(this.y));
  }
  toAltitude() {
    return Wk(this.z, this.y);
  }
  meterInMercatorCoordinateUnits() {
    return 1 / Y0 * Xk(fd(this.y));
  }
};
r(yu, "MercatorCoordinate");
var Fe = yu;
var md = class md2 {
  constructor(e, t3, i) {
    this.bounds = ut.convert(this.validateBounds(e)), this.minzoom = t3 || 0, this.maxzoom = i || 24;
  }
  validateBounds(e) {
    return !Array.isArray(e) || e.length !== 4 ? [-180, -90, 180, 90] : [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])];
  }
  contains(e) {
    let t3 = Math.pow(2, e.z), i = { minX: Math.floor(Fr(this.bounds.getWest()) * t3), minY: Math.floor(Rr(this.bounds.getNorth()) * t3), maxX: Math.ceil(Fr(this.bounds.getEast()) * t3), maxY: Math.ceil(Rr(this.bounds.getSouth()) * t3) };
    return e.x >= i.minX && e.x < i.maxX && e.y >= i.minY && e.y < i.maxY;
  }
};
r(md, "TileBounds");
var dn = md;
var dd = class dd2 extends de {
  constructor(e, t3, i, n) {
    if (super(), this.id = e, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, V(this, dr(t3, ["url", "scheme", "tileSize", "promoteId"])), this._options = V({ type: "vector" }, t3), this._collectResourceTiming = t3.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
    this.setEventedParent(n);
  }
  async load() {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await du(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (V(this, e), e.bounds && (this.tileBounds = new dn(e.bounds, this.minzoom, this.maxzoom)), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new Z(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setSourceProperty(e) {
    this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  serialize() {
    return V({}, this._options);
  }
  async loadTile(e) {
    let t3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = { request: this.map._requestManager.transformRequest(t3, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    i.request.collectResourceTiming = this._collectResourceTiming;
    let n = "RT";
    if (!e.actor || e.state === "expired") e.actor = this.dispatcher.getActor(), n = "LT";
    else if (e.state === "loading") return new Promise((o, a) => {
      e.reloadPromise = { resolve: o, reject: a };
    });
    e.abortController = new AbortController();
    try {
      let o = await e.actor.sendAsync({ type: n, data: i }, e.abortController);
      if (delete e.abortController, e.aborted) return;
      this._afterTileLoadWorkerResponse(e, o);
    } catch (o) {
      if (delete e.abortController, e.aborted) return;
      if (o && o.status !== 404) throw o;
      this._afterTileLoadWorkerResponse(e, null);
    }
  }
  _afterTileLoadWorkerResponse(e, t3) {
    if (t3 && t3.resourceTiming && (e.resourceTiming = t3.resourceTiming), t3 && this.map._refreshExpiredTiles && e.setExpiryData(t3), e.loadVectorData(t3, this.map.painter), e.reloadPromise) {
      let i = e.reloadPromise;
      e.reloadPromise = null, this.loadTile(e).then(i.resolve).catch(i.reject);
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && await e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  async unloadTile(e) {
    e.unloadVectorData(), e.actor && await e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  hasTransition() {
    return false;
  }
};
r(dd, "VectorTileSource");
var ua = dd;
q();
var yd = class yd2 extends de {
  constructor(e, t3, i, n) {
    super(), this.id = e, this.dispatcher = i, this.setEventedParent(n), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = V({ type: "raster" }, t3), V(this, dr(t3, ["url", "scheme", "tileSize"]));
  }
  async load() {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await du(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, e && (V(this, e), e.bounds && (this.tileBounds = new dn(e.bounds, this.minzoom, this.maxzoom)), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new Z(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  setSourceProperty(e) {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  serialize() {
    return V({}, this._options);
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  async loadTile(e) {
    let t3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    e.abortController = new AbortController();
    try {
      let i = await st.getImage(this.map._requestManager.transformRequest(t3, "Tile"), e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (i && i.data) {
        this.map._refreshExpiredTiles && i.cacheControl && i.expires && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires });
        let n = this.map.painter.context, o = n.gl, a = i.data;
        e.texture = this.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, { useMipmap: true }) : (e.texture = new ve(n, a, o.RGBA, { useMipmap: true }), e.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && o.texParameterf(o.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), e.state = "loaded";
      }
    } catch (i) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (i) throw e.state = "errored", i;
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController);
  }
  async unloadTile(e) {
    e.texture && this.map.painter.saveTileTexture(e.texture);
  }
  hasTransition() {
    return false;
  }
};
r(yd, "RasterTileSource");
var xi = yd;
q();
q();
q();
function t1(r3, e, t3) {
  e = Math.pow(2, t3) - e - 1;
  var i = e1(r3 * 256, e * 256, t3), n = e1((r3 + 1) * 256, (e + 1) * 256, t3);
  return i[0] + "," + i[1] + "," + n[0] + "," + n[1];
}
r(t1, "getTileBBox");
function e1(r3, e, t3) {
  var i = 2 * Math.PI * 6378137 / 256 / Math.pow(2, t3), n = r3 * i - 2 * Math.PI * 6378137 / 2, o = e * i - 2 * Math.PI * 6378137 / 2;
  return [n, o];
}
r(e1, "getMercCoords");
var r1 = u(ge(), 1);
var gd = class gd2 {
  constructor(e, t3, i) {
    if (e < 0 || e > 25 || i < 0 || i >= Math.pow(2, e) || t3 < 0 || t3 >= Math.pow(2, e)) throw new Error(`x=${t3}, y=${i}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
    this.z = e, this.x = t3, this.y = i, this.key = ca(0, e, e, t3, i);
  }
  equals(e) {
    return this.z === e.z && this.x === e.x && this.y === e.y;
  }
  url(e, t3, i) {
    let n = t1(this.x, this.y, this.z), o = Kk(this.z, this.x, this.y);
    return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, t3 > 1 ? "@2x" : "").replace(/{quadkey}/g, o).replace(/{bbox-epsg-3857}/g, n);
  }
  isChildOf(e) {
    let t3 = this.z - e.z;
    return t3 > 0 && e.x === this.x >> t3 && e.y === this.y >> t3;
  }
  getTilePoint(e) {
    let t3 = Math.pow(2, this.z);
    return new r1.default((e.x * t3 - this.x) * 8192, (e.y * t3 - this.y) * 8192);
  }
  toString() {
    return `${this.z}/${this.x}/${this.y}`;
  }
};
r(gd, "CanonicalTileID");
var yn = gd;
var xd = class xd2 {
  constructor(e, t3) {
    this.wrap = e, this.canonical = t3, this.key = ca(e, t3.z, t3.z, t3.x, t3.y);
  }
};
r(xd, "UnwrappedTileID");
var gn = xd;
var Pt = class Pt2 {
  constructor(e, t3, i, n, o) {
    if (e < i) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${i}`);
    this.overscaledZ = e, this.wrap = t3, this.canonical = new yn(i, +n, +o), this.key = ca(t3, e, i, n, o);
  }
  clone() {
    return new Pt2(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  equals(e) {
    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
  }
  scaledTo(e) {
    if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
    let t3 = this.canonical.z - e;
    return e > this.canonical.z ? new Pt2(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Pt2(e, this.wrap, e, this.canonical.x >> t3, this.canonical.y >> t3);
  }
  calculateScaledKey(e, t3) {
    if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
    let i = this.canonical.z - e;
    return e > this.canonical.z ? ca(this.wrap * +t3, e, this.canonical.z, this.canonical.x, this.canonical.y) : ca(this.wrap * +t3, e, e, this.canonical.x >> i, this.canonical.y >> i);
  }
  isChildOf(e) {
    if (e.wrap !== this.wrap) return false;
    let t3 = this.canonical.z - e.canonical.z;
    return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t3 && e.canonical.y === this.canonical.y >> t3;
  }
  children(e) {
    if (this.overscaledZ >= e) return [new Pt2(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
    let t3 = this.canonical.z + 1, i = this.canonical.x * 2, n = this.canonical.y * 2;
    return [new Pt2(t3, this.wrap, t3, i, n), new Pt2(t3, this.wrap, t3, i + 1, n), new Pt2(t3, this.wrap, t3, i, n + 1), new Pt2(t3, this.wrap, t3, i + 1, n + 1)];
  }
  isLessThan(e) {
    return this.wrap < e.wrap ? true : this.wrap > e.wrap ? false : this.overscaledZ < e.overscaledZ ? true : this.overscaledZ > e.overscaledZ ? false : this.canonical.x < e.canonical.x ? true : this.canonical.x > e.canonical.x ? false : this.canonical.y < e.canonical.y;
  }
  wrapped() {
    return new Pt2(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  unwrapTo(e) {
    return new Pt2(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.canonical.z);
  }
  toUnwrapped() {
    return new gn(this.wrap, this.canonical);
  }
  toString() {
    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
  }
  getTilePoint(e) {
    return this.canonical.getTilePoint(new Fe(e.x - this.wrap, e.y));
  }
};
r(Pt, "OverscaledTileID");
var Ke = Pt;
function ca(r3, e, t3, i, n) {
  r3 *= 2, r3 < 0 && (r3 = r3 * -1 - 1);
  let o = 1 << t3;
  return (o * o * r3 + o * n + i).toString(36) + t3.toString(36) + e.toString(36);
}
r(ca, "calculateKey");
function Kk(r3, e, t3) {
  let i = "", n;
  for (let o = r3; o > 0; o--) n = 1 << o - 1, i += (e & n ? 1 : 0) + (t3 & n ? 2 : 0);
  return i;
}
r(Kk, "getQuadkey");
N("CanonicalTileID", yn);
N("OverscaledTileID", Ke, { omit: ["posMatrix"] });
q();
var _d = class _d2 {
  constructor(e, t3, i, n = 1, o = 1, a = 1, s3 = 0) {
    if (this.uid = e, t3.height !== t3.width) throw new RangeError("DEM tiles must be square");
    if (i && !["mapbox", "terrarium", "custom"].includes(i)) {
      ke(`"${i}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
      return;
    }
    this.stride = t3.height;
    let l = this.dim = t3.height - 2;
    switch (this.data = new Uint32Array(t3.data.buffer), i) {
      case "terrarium":
        this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
        break;
      case "custom":
        this.redFactor = n, this.greenFactor = o, this.blueFactor = a, this.baseShift = s3;
        break;
      case "mapbox":
      default:
        this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
        break;
    }
    for (let c = 0; c < l; c++) this.data[this._idx(-1, c)] = this.data[this._idx(0, c)], this.data[this._idx(l, c)] = this.data[this._idx(l - 1, c)], this.data[this._idx(c, -1)] = this.data[this._idx(c, 0)], this.data[this._idx(c, l)] = this.data[this._idx(c, l - 1)];
    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(l, -1)] = this.data[this._idx(l - 1, 0)], this.data[this._idx(-1, l)] = this.data[this._idx(0, l - 1)], this.data[this._idx(l, l)] = this.data[this._idx(l - 1, l - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
    for (let c = 0; c < l; c++) for (let p = 0; p < l; p++) {
      let h = this.get(c, p);
      h > this.max && (this.max = h), h < this.min && (this.min = h);
    }
  }
  get(e, t3) {
    let i = new Uint8Array(this.data.buffer), n = this._idx(e, t3) * 4;
    return this.unpack(i[n], i[n + 1], i[n + 2]);
  }
  getUnpackVector() {
    return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
  }
  _idx(e, t3) {
    if (e < -1 || e >= this.dim + 1 || t3 < -1 || t3 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
    return (t3 + 1) * this.stride + (e + 1);
  }
  unpack(e, t3, i) {
    return e * this.redFactor + t3 * this.greenFactor + i * this.blueFactor - this.baseShift;
  }
  getPixels() {
    return new Se({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
  }
  backfillBorder(e, t3, i) {
    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
    let n = t3 * this.dim, o = t3 * this.dim + this.dim, a = i * this.dim, s3 = i * this.dim + this.dim;
    switch (t3) {
      case -1:
        n = o - 1;
        break;
      case 1:
        o = n + 1;
        break;
    }
    switch (i) {
      case -1:
        a = s3 - 1;
        break;
      case 1:
        s3 = a + 1;
        break;
    }
    let l = -t3 * this.dim, c = -i * this.dim;
    for (let p = a; p < s3; p++) for (let h = n; h < o; h++) this.data[this._idx(h, p)] = e.data[this._idx(h + l, p + c)];
  }
};
r(_d, "DEMData");
var bd = _d;
N("DEMData", bd);
var vd = class vd2 extends xi {
  constructor(e, t3, i, n) {
    super(e, t3, i, n), this.type = "raster-dem", this.maxzoom = 22, this._options = V({ type: "raster-dem" }, t3), this.encoding = t3.encoding || "mapbox", this.redFactor = t3.redFactor, this.greenFactor = t3.greenFactor, this.blueFactor = t3.blueFactor, this.baseShift = t3.baseShift;
  }
  async loadTile(e) {
    let t3 = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = this.map._requestManager.transformRequest(t3, "Tile");
    e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
    try {
      let n = await st.getImage(i, e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (n && n.data) {
        let o = n.data;
        this.map._refreshExpiredTiles && n.cacheControl && n.expires && e.setExpiryData({ cacheControl: n.cacheControl, expires: n.expires });
        let s3 = ht(o) && es() ? o : await this.readImageNow(o), l = { type: this.type, uid: e.uid, source: this.id, rawImageData: s3, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
        if (!e.actor || e.state === "expired") {
          e.actor = this.dispatcher.getActor();
          let c = await e.actor.sendAsync({ type: "LDT", data: l });
          e.dem = c, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
        }
      }
    } catch (n) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (n) throw e.state = "errored", n;
    }
  }
  async readImageNow(e) {
    if (typeof VideoFrame < "u" && xp()) {
      let t3 = e.width + 2, i = e.height + 2;
      try {
        return new Se({ width: t3, height: i }, await ob(e, -1, -1, t3, i));
      } catch {
      }
    }
    return Y.getImageData(e, 1);
  }
  _getNeighboringTiles(e) {
    let t3 = e.canonical, i = Math.pow(2, t3.z), n = (t3.x - 1 + i) % i, o = t3.x === 0 ? e.wrap - 1 : e.wrap, a = (t3.x + 1 + i) % i, s3 = t3.x + 1 === i ? e.wrap + 1 : e.wrap, l = {};
    return l[new Ke(e.overscaledZ, o, t3.z, n, t3.y).key] = { backfilled: false }, l[new Ke(e.overscaledZ, s3, t3.z, a, t3.y).key] = { backfilled: false }, t3.y > 0 && (l[new Ke(e.overscaledZ, o, t3.z, n, t3.y - 1).key] = { backfilled: false }, l[new Ke(e.overscaledZ, e.wrap, t3.z, t3.x, t3.y - 1).key] = { backfilled: false }, l[new Ke(e.overscaledZ, s3, t3.z, a, t3.y - 1).key] = { backfilled: false }), t3.y + 1 < i && (l[new Ke(e.overscaledZ, o, t3.z, n, t3.y + 1).key] = { backfilled: false }, l[new Ke(e.overscaledZ, e.wrap, t3.z, t3.x, t3.y + 1).key] = { backfilled: false }, l[new Ke(e.overscaledZ, s3, t3.z, a, t3.y + 1).key] = { backfilled: false }), l;
  }
  async unloadTile(e) {
    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && await e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } });
  }
};
r(vd, "RasterDEMTileSource");
var pa = vd;
q();
var wd = class wd2 extends de {
  constructor(e, t3, i, n) {
    super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = i.getActor(), this.setEventedParent(n), this._data = t3.data, this._options = V({}, t3), this._collectResourceTiming = t3.collectResourceTiming, t3.maxzoom !== void 0 && (this.maxzoom = t3.maxzoom), t3.type && (this.type = t3.type), t3.attribution && (this.attribution = t3.attribution), this.promoteId = t3.promoteId;
    let o = 8192 / this.tileSize;
    this.workerOptions = V({ source: this.id, cluster: t3.cluster || false, geojsonVtOptions: { buffer: (t3.buffer !== void 0 ? t3.buffer : 128) * o, tolerance: (t3.tolerance !== void 0 ? t3.tolerance : 0.375) * o, extent: 8192, maxZoom: this.maxzoom, lineMetrics: t3.lineMetrics || false, generateId: t3.generateId || false }, superclusterOptions: { maxZoom: t3.clusterMaxZoom !== void 0 ? t3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t3.clusterMinPoints || 2), extent: 8192, radius: (t3.clusterRadius || 50) * o, log: false, generateId: t3.generateId || false }, clusterProperties: t3.clusterProperties, filter: t3.filter }, t3.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
  }
  async load() {
    await this._updateWorkerData();
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setData(e) {
    return this._data = e, this._updateWorkerData(), this;
  }
  updateData(e) {
    return this._updateWorkerData(e), this;
  }
  setClusterOptions(e) {
    return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
  }
  getClusterExpansionZoom(e) {
    return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterChildren(e) {
    return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterLeaves(e, t3, i) {
    return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: t3, offset: i } });
  }
  async _updateWorkerData(e) {
    let t3 = V({ type: this.type }, this.workerOptions);
    e ? t3.dataDiff = e : typeof this._data == "string" ? (t3.request = this.map._requestManager.transformRequest(Y.resolveURL(this._data), "Source"), t3.request.collectResourceTiming = this._collectResourceTiming) : t3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new F("dataloading", { dataType: "source" }));
    try {
      let i = await this.actor.sendAsync({ type: "LD", data: t3 });
      if (this._pendingLoads--, this._removed || i.abandoned) {
        this.fire(new F("dataabort", { dataType: "source" }));
        return;
      }
      let n = null;
      i.resourceTiming && i.resourceTiming[this.id] && (n = i.resourceTiming[this.id].slice(0));
      let o = { dataType: "source" };
      this._collectResourceTiming && n && n.length > 0 && V(o, { resourceTiming: n }), this.fire(new F("data", { ...o, sourceDataType: "metadata" })), this.fire(new F("data", { ...o, sourceDataType: "content" }));
    } catch (i) {
      if (this._pendingLoads--, this._removed) {
        this.fire(new F("dataabort", { dataType: "source" }));
        return;
      }
      this.fire(new Z(i));
    }
  }
  loaded() {
    return this._pendingLoads === 0;
  }
  async loadTile(e) {
    let t3 = e.actor ? "RT" : "LT";
    e.actor = this.actor;
    let i = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    e.abortController = new AbortController();
    let n = await this.actor.sendAsync({ type: t3, data: i }, e.abortController);
    delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(n, this.map.painter, t3 === "RT");
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
  }
  async unloadTile(e) {
    e.unloadVectorData(), await this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  onRemove() {
    this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
  }
  serialize() {
    return V({}, this._options, { type: this.type, data: this._data });
  }
  hasTransition() {
    return false;
  }
};
r(wd, "GeoJSONSource");
var ha = wd;
q();
q();
q();
var Br = _e([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
var Sd = class Sd2 extends de {
  constructor(e, t3, i, n) {
    super(), this.id = e, this.dispatcher = i, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(n), this.options = t3;
  }
  async load(e) {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
    try {
      let t3 = await st.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
      this._request = null, this._loaded = true, t3 && t3.data && (this.image = t3.data, e && (this.coordinates = e), this._finishLoading());
    } catch (t3) {
      this._request = null, this._loaded = true, this.fire(new Z(t3));
    }
  }
  loaded() {
    return this._loaded;
  }
  updateImage(e) {
    return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
      this.texture = null;
    }), this) : this;
  }
  _finishLoading() {
    this.map && (this.setCoordinates(this.coordinates), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })));
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._request && (this._request.abort(), this._request = null);
  }
  setCoordinates(e) {
    this.coordinates = e;
    let t3 = e.map(Fe.fromLngLat);
    this.tileID = Jk(t3), this.minzoom = this.maxzoom = this.tileID.z;
    let i = t3.map((n) => this.tileID.getTilePoint(n)._round());
    return this._boundsArray = new en(), this._boundsArray.emplaceBack(i[0].x, i[0].y, 0, 0), this._boundsArray.emplaceBack(i[1].x, i[1].y, 8192, 0), this._boundsArray.emplaceBack(i[3].x, i[3].y, 0, 8192), this._boundsArray.emplaceBack(i[2].x, i[2].y, 8192, 8192), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })), this;
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || !this.image) return;
    let e = this.map.painter.context, t3 = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Br.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new ve(e, this.image, t3.RGBA), this.texture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE));
    let i = false;
    for (let n in this.tiles) {
      let o = this.tiles[n];
      o.state !== "loaded" && (o.state = "loaded", o.texture = this.texture, i = true);
    }
    i && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  async loadTile(e) {
    this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
  }
  serialize() {
    return { type: "image", url: this.options.url, coordinates: this.coordinates };
  }
  hasTransition() {
    return false;
  }
};
r(Sd, "ImageSource");
var Lt = Sd;
function Jk(r3) {
  let e = 1 / 0, t3 = 1 / 0, i = -1 / 0, n = -1 / 0;
  for (let p of r3) e = Math.min(e, p.x), t3 = Math.min(t3, p.y), i = Math.max(i, p.x), n = Math.max(n, p.y);
  let o = i - e, a = n - t3, s3 = Math.max(o, a), l = Math.max(0, Math.floor(-Math.log(s3) / Math.LN2)), c = Math.pow(2, l);
  return new yn(l, Math.floor((e + i) / 2 * c), Math.floor((t3 + n) / 2 * c));
}
r(Jk, "getCoordinatesCenterTileID");
var Pd = class Pd2 extends Lt {
  constructor(e, t3, i, n) {
    super(e, t3, i, n), this.roundZoom = true, this.type = "video", this.options = t3;
  }
  async load() {
    this._loaded = false;
    let e = this.options;
    this.urls = [];
    for (let t3 of e.urls) this.urls.push(this.map._requestManager.transformRequest(t3, "Source").url);
    try {
      let t3 = await ub(this.urls);
      if (this._loaded = true, !t3) return;
      this.video = t3, this.video.loop = true, this.video.addEventListener("playing", () => {
        this.map.triggerRepaint();
      }), this.map && this.video.play(), this._finishLoading();
    } catch (t3) {
      this.fire(new Z(t3));
    }
  }
  pause() {
    this.video && this.video.pause();
  }
  play() {
    this.video && this.video.play();
  }
  seek(e) {
    if (this.video) {
      let t3 = this.video.seekable;
      e < t3.start(0) || e > t3.end(0) ? this.fire(new Z(new B(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t3.start(0)} and ${t3.end(0)}-second mark.`))) : this.video.currentTime = e;
    }
  }
  getVideo() {
    return this.video;
  }
  onAdd(e) {
    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
    let e = this.map.painter.context, t3 = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Br.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE), t3.texSubImage2D(t3.TEXTURE_2D, 0, 0, 0, t3.RGBA, t3.UNSIGNED_BYTE, this.video)) : (this.texture = new ve(e, this.video, t3.RGBA), this.texture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE));
    let i = false;
    for (let n in this.tiles) {
      let o = this.tiles[n];
      o.state !== "loaded" && (o.state = "loaded", o.texture = this.texture, i = true);
    }
    i && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "video", urls: this.urls, coordinates: this.coordinates };
  }
  hasTransition() {
    return this.video && !this.video.paused;
  }
};
r(Pd, "VideoSource");
var fa = Pd;
q();
var Td = class Td2 extends Lt {
  constructor(e, t3, i, n) {
    super(e, t3, i, n), t3.coordinates ? (!Array.isArray(t3.coordinates) || t3.coordinates.length !== 4 || t3.coordinates.some((o) => !Array.isArray(o) || o.length !== 2 || o.some((a) => typeof a != "number"))) && this.fire(new Z(new B(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new Z(new B(`sources.${e}`, null, 'missing required property "coordinates"'))), t3.animate && typeof t3.animate != "boolean" && this.fire(new Z(new B(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), t3.canvas ? typeof t3.canvas != "string" && !(t3.canvas instanceof HTMLCanvasElement) && this.fire(new Z(new B(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new Z(new B(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = t3, this.animate = t3.animate !== void 0 ? t3.animate : true;
  }
  async load() {
    if (this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions()) {
      this.fire(new Z(new Error("Canvas dimensions cannot be less than or equal to zero.")));
      return;
    }
    this.play = function() {
      this._playing = true, this.map.triggerRepaint();
    }, this.pause = function() {
      this._playing && (this.prepare(), this._playing = false);
    }, this._finishLoading();
  }
  getCanvas() {
    return this.canvas;
  }
  onAdd(e) {
    this.map = e, this.load(), this.canvas && this.animate && this.play();
  }
  onRemove() {
    this.pause();
  }
  prepare() {
    let e = false;
    if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
    let t3 = this.map.painter.context, i = t3.gl;
    this.boundsBuffer || (this.boundsBuffer = t3.createVertexBuffer(this._boundsArray, Br.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new ve(t3, this.canvas, i.RGBA, { premultiply: true });
    let n = false;
    for (let o in this.tiles) {
      let a = this.tiles[o];
      a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, n = true);
    }
    n && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "canvas", coordinates: this.coordinates };
  }
  hasTransition() {
    return this._playing;
  }
  _hasInvalidDimensions() {
    for (let e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
    return false;
  }
};
r(Td, "CanvasSource");
var ma = Td;
var i1 = {};
var n1 = r((r3, e, t3, i) => {
  let n = o1(e.type), o = new n(r3, e, t3, i);
  if (o.id !== r3) throw new Error(`Expected Source id to be ${r3} instead of ${o.id}`);
  return o;
}, "create");
var o1 = r((r3) => {
  switch (r3) {
    case "geojson":
      return ha;
    case "image":
      return Lt;
    case "raster":
      return xi;
    case "raster-dem":
      return pa;
    case "vector":
      return ua;
    case "video":
      return fa;
    case "canvas":
      return ma;
  }
  return i1[r3];
}, "getSourceType");
var Yk = r((r3, e) => {
  i1[r3] = e;
}, "setSourceType");
var Qk = r(async (r3, e) => {
  if (o1(r3)) throw new Error(`A source type called "${r3}" already exists.`);
  Yk(r3, e);
}, "addSourceType");
q();
q();
function a1(r3, e) {
  let t3 = {};
  if (!e) return t3;
  for (let i of r3) {
    let n = i.layerIds.map((o) => e.getLayer(o)).filter(Boolean);
    if (n.length !== 0) {
      i.layers = n, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map((o) => n.filter((a) => a.id === o)[0]));
      for (let o of n) t3[o.id] = i;
    }
  }
  return t3;
}
r(a1, "deserialize");
q();
q();
var Md = class Md2 {
  constructor(e) {
    this._stringToNumber = {}, this._numberToString = [];
    for (let t3 = 0; t3 < e.length; t3++) {
      let i = e[t3];
      this._stringToNumber[i] = t3, this._numberToString[t3] = i;
    }
  }
  encode(e) {
    return this._stringToNumber[e];
  }
  decode(e) {
    if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
    return this._numberToString[e];
  }
};
r(Md, "DictionaryCoder");
var xu = Md;
var u1 = u(Zo(), 1);
var c1 = u(qm(), 1);
q();
var Ad = class Ad2 {
  constructor(e, t3, i, n, o) {
    this.type = "Feature", this._vectorTileFeature = e, e._z = t3, e._x = i, e._y = n, this.properties = e.properties, this.id = o;
  }
  get geometry() {
    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
  }
  set geometry(e) {
    this._geometry = e;
  }
  toJSON() {
    let e = { geometry: this.geometry };
    for (let t3 in this) t3 === "_geometry" || t3 === "_vectorTileFeature" || (e[t3] = this[t3]);
    return e;
  }
};
r(Ad, "GeoJSONFeature");
var xn = Ad;
var Cd = class Cd2 {
  constructor(e, t3) {
    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new ri(8192, 16, 0), this.grid3D = new ri(8192, 16, 0), this.featureIndexArray = new ko(), this.promoteId = t3;
  }
  insert(e, t3, i, n, o, a) {
    let s3 = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(i, n, o);
    let l = a ? this.grid3D : this.grid;
    for (let c = 0; c < t3.length; c++) {
      let p = t3[c], h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let f = 0; f < p.length; f++) {
        let m = p[f];
        h[0] = Math.min(h[0], m.x), h[1] = Math.min(h[1], m.y), h[2] = Math.max(h[2], m.x), h[3] = Math.max(h[3], m.y);
      }
      h[0] < 8192 && h[1] < 8192 && h[2] >= 0 && h[3] >= 0 && l.insert(s3, h[0], h[1], h[2], h[3]);
    }
  }
  loadVTLayers() {
    return this.vtLayers || (this.vtLayers = new u1.default.VectorTile(new c1.default(this.rawTileData)).layers, this.sourceLayerCoder = new xu(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
  }
  query(e, t3, i, n) {
    this.loadVTLayers();
    let o = e.params || {}, a = 8192 / e.tileSize / e.scale, s3 = oo(o.filter), l = e.queryGeometry, c = e.queryPadding * a, p = l1(l), h = this.grid.query(p.minX - c, p.minY - c, p.maxX + c, p.maxY + c), f = l1(e.cameraQueryGeometry), m = this.grid3D.query(f.minX - c, f.minY - c, f.maxX + c, f.maxY + c, (x, b, w, _) => G_(e.cameraQueryGeometry, x - c, b - c, w + c, _ + c));
    for (let x of m) h.push(x);
    h.sort(eL);
    let y = {}, g;
    for (let x = 0; x < h.length; x++) {
      let b = h[x];
      if (b === g) continue;
      g = b;
      let w = this.featureIndexArray.get(b), _ = null;
      this.loadMatchingFeature(y, w.bucketIndex, w.sourceLayerIndex, w.featureIndex, s3, o.layers, o.availableImages, t3, i, n, (S, P, T) => (_ || (_ = dt(S)), P.queryIntersectsFeature(l, S, T, _, this.z, e.transform, a, e.pixelPosMatrix)));
    }
    return y;
  }
  loadMatchingFeature(e, t3, i, n, o, a, s3, l, c, p, h) {
    let f = this.bucketLayerIDs[t3];
    if (a && !Jx(a, f)) return;
    let m = this.sourceLayerCoder.decode(i), g = this.vtLayers[m].feature(n);
    if (o.needGeometry) {
      let b = yt(g, true);
      if (!o.filter(new ye(this.tileID.overscaledZ), b, this.tileID.canonical)) return;
    } else if (!o.filter(new ye(this.tileID.overscaledZ), g)) return;
    let x = this.getId(g, m);
    for (let b = 0; b < f.length; b++) {
      let w = f[b];
      if (a && a.indexOf(w) < 0) continue;
      let _ = l[w];
      if (!_) continue;
      let S = {};
      x && p && (S = p.getState(_.sourceLayer || "_geojsonTileLayer", x));
      let P = V({}, c[w]);
      P.paint = s1(P.paint, _.paint, g, S, s3), P.layout = s1(P.layout, _.layout, g, S, s3);
      let T = !h || h(g, _, S);
      if (!T) continue;
      let L = new xn(g, this.z, this.x, this.y, x);
      L.layer = P;
      let C = e[w];
      C === void 0 && (C = e[w] = []), C.push({ featureIndex: n, feature: L, intersectionZ: T });
    }
  }
  lookupSymbolFeatures(e, t3, i, n, o, a, s3, l) {
    let c = {};
    this.loadVTLayers();
    let p = oo(o);
    for (let h of e) this.loadMatchingFeature(c, i, n, h, p, a, s3, l, t3);
    return c;
  }
  hasLayer(e) {
    for (let t3 of this.bucketLayerIDs) for (let i of t3) if (e === i) return true;
    return false;
  }
  getId(e, t3) {
    let i = e.id;
    if (this.promoteId) {
      let n = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[t3];
      i = e.properties[n], typeof i == "boolean" && (i = Number(i));
    }
    return i;
  }
};
r(Cd, "FeatureIndex");
var Id = Cd;
N("FeatureIndex", Id, { omit: ["rawTileData", "sourceLayerCoder"] });
function s1(r3, e, t3, i, n) {
  return En(r3, (o, a) => {
    let s3 = e instanceof Sr ? e.get(a) : null;
    return s3 && s3.evaluate ? s3.evaluate(t3, i, n) : s3;
  });
}
r(s1, "evaluateProperties");
function l1(r3) {
  let e = 1 / 0, t3 = 1 / 0, i = -1 / 0, n = -1 / 0;
  for (let o of r3) e = Math.min(e, o.x), t3 = Math.min(t3, o.y), i = Math.max(i, o.x), n = Math.max(n, o.y);
  return { minX: e, minY: t3, maxX: i, maxY: n };
}
r(l1, "getBounds");
function eL(r3, e) {
  return e - r3;
}
r(eL, "topDownFeatureComparator");
q();
q();
var da = "RTLPluginLoaded";
var Ld = class Ld2 extends de {
  constructor() {
    super(...arguments);
    this.status = "unavailable";
    this.url = null;
    this.dispatcher = mu();
  }
  _syncState(t3) {
    return this.status = t3, this.dispatcher.broadcast("SRPS", { pluginStatus: t3, pluginURL: this.url }).catch((i) => {
      throw this.status = "error", i;
    });
  }
  getRTLTextPluginStatus() {
    return this.status;
  }
  clearRTLTextPlugin() {
    this.status = "unavailable", this.url = null;
  }
  async setRTLTextPlugin(t3, i = false) {
    if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
    if (this.url = Y.resolveURL(t3), !this.url) throw new Error(`requested url ${t3} is invalid`);
    if (this.status === "unavailable") if (i) this.status = "deferred", this._syncState(this.status);
    else return this._requestImport();
    else if (this.status === "requested") return this._requestImport();
  }
  async _requestImport() {
    await this._syncState("loading"), this.status = "loaded", this.fire(new F(da));
  }
  lazyLoad() {
    this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
  }
};
r(Ld, "RTLMainThreadPlugin");
var kd = Ld;
var Ed = null;
function Or() {
  return Ed || (Ed = new kd()), Ed;
}
r(Or, "rtlMainThreadPluginFactory");
var tL = 3e4;
var Dd = class Dd2 {
  constructor(e, t3) {
    this.timeAdded = 0;
    this.fadeEndTime = 0;
    this.tileID = e, this.uid = rs(), this.uses = 0, this.tileSize = t3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
  }
  registerFadeDuration(e) {
    let t3 = e + this.timeAdded;
    t3 < this.fadeEndTime || (this.fadeEndTime = t3);
  }
  wasRequested() {
    return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
  }
  clearTextures(e) {
    this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
  }
  loadVectorData(e, t3, i) {
    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", !e) {
      this.collisionBoxArray = new To();
      return;
    }
    e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = a1(e.buckets, t3.style), this.hasSymbolBuckets = false;
    for (let n in this.buckets) {
      let o = this.buckets[n];
      if (o instanceof Ot) if (this.hasSymbolBuckets = true, i) o.justReloaded = true;
      else break;
    }
    if (this.hasRTLText = false, this.hasSymbolBuckets) for (let n in this.buckets) {
      let o = this.buckets[n];
      if (o instanceof Ot && o.hasRTLText) {
        this.hasRTLText = true, Or().lazyLoad();
        break;
      }
    }
    this.queryPadding = 0;
    for (let n in this.buckets) {
      let o = this.buckets[n];
      this.queryPadding = Math.max(this.queryPadding, t3.style.getLayer(n).queryRadius(o));
    }
    e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
  }
  unloadVectorData() {
    for (let e in this.buckets) this.buckets[e].destroy();
    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
  }
  getBucket(e) {
    return this.buckets[e.id];
  }
  upload(e) {
    for (let i in this.buckets) {
      let n = this.buckets[i];
      n.uploadPending() && n.upload(e);
    }
    let t3 = e.gl;
    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new ve(e, this.imageAtlas.image, t3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new ve(e, this.glyphAtlasImage, t3.ALPHA), this.glyphAtlasImage = null);
  }
  prepare(e) {
    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
  }
  queryRenderedFeatures(e, t3, i, n, o, a, s3, l, c, p) {
    return !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData ? {} : this.latestFeatureIndex.query({ queryGeometry: n, cameraQueryGeometry: o, scale: a, tileSize: this.tileSize, pixelPosMatrix: p, transform: l, params: s3, queryPadding: this.queryPadding * c }, e, t3, i);
  }
  querySourceFeatures(e, t3) {
    let i = this.latestFeatureIndex;
    if (!i || !i.rawTileData) return;
    let n = i.loadVTLayers(), o = t3 && t3.sourceLayer ? t3.sourceLayer : "", a = n._geojsonTileLayer || n[o];
    if (!a) return;
    let s3 = oo(t3 && t3.filter), { z: l, x: c, y: p } = this.tileID.canonical, h = { z: l, x: c, y: p };
    for (let f = 0; f < a.length; f++) {
      let m = a.feature(f);
      if (s3.needGeometry) {
        let x = yt(m, true);
        if (!s3.filter(new ye(this.tileID.overscaledZ), x, this.tileID.canonical)) continue;
      } else if (!s3.filter(new ye(this.tileID.overscaledZ), m)) continue;
      let y = i.getId(m, o), g = new xn(m, l, c, p, y);
      g.tile = h, e.push(g);
    }
  }
  hasData() {
    return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
  }
  patternsLoaded() {
    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
  }
  setExpiryData(e) {
    let t3 = this.expirationTime;
    if (e.cacheControl) {
      let i = tb(e.cacheControl);
      i["max-age"] && (this.expirationTime = Date.now() + i["max-age"] * 1e3);
    } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
    if (this.expirationTime) {
      let i = Date.now(), n = false;
      if (this.expirationTime > i) n = false;
      else if (!t3) n = true;
      else if (this.expirationTime < t3) n = true;
      else {
        let o = this.expirationTime - t3;
        o ? this.expirationTime = i + Math.max(o, tL) : n = true;
      }
      n ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
    }
  }
  getExpiryTimeout() {
    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
  }
  setFeatureState(e, t3) {
    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
    let i = this.latestFeatureIndex.loadVTLayers();
    for (let n in this.buckets) {
      if (!t3.style.hasLayer(n)) continue;
      let o = this.buckets[n], a = o.layers[0].sourceLayer || "_geojsonTileLayer", s3 = i[a], l = e[a];
      if (!s3 || !l || Object.keys(l).length === 0) continue;
      o.update(l, s3, this.imageAtlas && this.imageAtlas.patternPositions || {});
      let c = t3 && t3.style && t3.style.getLayer(n);
      c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(o)));
    }
  }
  holdingForFade() {
    return this.symbolFadeHoldUntil !== void 0;
  }
  symbolFadeFinished() {
    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Y.now();
  }
  clearFadeHold() {
    this.symbolFadeHoldUntil = void 0;
  }
  setHoldDuration(e) {
    this.symbolFadeHoldUntil = Y.now() + e;
  }
  setDependencies(e, t3) {
    let i = {};
    for (let n of t3) i[n] = true;
    this.dependencies[e] = i;
  }
  hasDependency(e, t3) {
    for (let i of e) {
      let n = this.dependencies[i];
      if (n) {
        for (let o of t3) if (n[o]) return true;
      }
    }
    return false;
  }
};
r(Dd, "Tile");
var bn = Dd;
q();
var zd = class zd2 {
  constructor(e, t3) {
    this.max = e, this.onRemove = t3, this.reset();
  }
  reset() {
    for (let e in this.data) for (let t3 of this.data[e]) t3.timeout && clearTimeout(t3.timeout), this.onRemove(t3.value);
    return this.data = {}, this.order = [], this;
  }
  add(e, t3, i) {
    let n = e.wrapped().key;
    this.data[n] === void 0 && (this.data[n] = []);
    let o = { value: t3, timeout: void 0 };
    if (i !== void 0 && (o.timeout = setTimeout(() => {
      this.remove(e, o);
    }, i)), this.data[n].push(o), this.order.push(n), this.order.length > this.max) {
      let a = this._getAndRemoveByKey(this.order[0]);
      a && this.onRemove(a);
    }
    return this;
  }
  has(e) {
    return e.wrapped().key in this.data;
  }
  getAndRemove(e) {
    return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
  }
  _getAndRemoveByKey(e) {
    let t3 = this.data[e].shift();
    return t3.timeout && clearTimeout(t3.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t3.value;
  }
  getByKey(e) {
    let t3 = this.data[e];
    return t3 ? t3[0].value : null;
  }
  get(e) {
    return this.has(e) ? this.data[e.wrapped().key][0].value : null;
  }
  remove(e, t3) {
    if (!this.has(e)) return this;
    let i = e.wrapped().key, n = t3 === void 0 ? 0 : this.data[i].indexOf(t3), o = this.data[i][n];
    return this.data[i].splice(n, 1), o.timeout && clearTimeout(o.timeout), this.data[i].length === 0 && delete this.data[i], this.onRemove(o.value), this.order.splice(this.order.indexOf(i), 1), this;
  }
  setMaxSize(e) {
    for (this.max = e; this.order.length > this.max; ) {
      let t3 = this._getAndRemoveByKey(this.order[0]);
      t3 && this.onRemove(t3);
    }
    return this;
  }
  filter(e) {
    let t3 = [];
    for (let i in this.data) for (let n of this.data[i]) e(n.value) || t3.push(n);
    for (let i of t3) this.remove(i.value.tileID, i);
  }
};
r(zd, "TileCache");
var bu = zd;
var Rd = u(ge(), 1);
q();
var Fd = class Fd2 {
  constructor() {
    this.state = {}, this.stateChanges = {}, this.deletedStates = {};
  }
  updateState(e, t3, i) {
    let n = String(t3);
    if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][n] = this.stateChanges[e][n] || {}, V(this.stateChanges[e][n], i), this.deletedStates[e] === null) {
      this.deletedStates[e] = {};
      for (let o in this.state[e]) o !== n && (this.deletedStates[e][o] = null);
    } else if (this.deletedStates[e] && this.deletedStates[e][n] === null) {
      this.deletedStates[e][n] = {};
      for (let a in this.state[e][n]) i[a] || (this.deletedStates[e][n][a] = null);
    } else for (let a in i) this.deletedStates[e] && this.deletedStates[e][n] && this.deletedStates[e][n][a] === null && delete this.deletedStates[e][n][a];
  }
  removeFeatureState(e, t3, i) {
    if (this.deletedStates[e] === null) return;
    let o = String(t3);
    if (this.deletedStates[e] = this.deletedStates[e] || {}, i && t3 !== void 0) this.deletedStates[e][o] !== null && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);
    else if (t3 !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o]) {
      this.deletedStates[e][o] = {};
      for (i in this.stateChanges[e][o]) this.deletedStates[e][o][i] = null;
    } else this.deletedStates[e][o] = null;
    else this.deletedStates[e] = null;
  }
  getState(e, t3) {
    let i = String(t3), n = this.state[e] || {}, o = this.stateChanges[e] || {}, a = V({}, n[i], o[i]);
    if (this.deletedStates[e] === null) return {};
    if (this.deletedStates[e]) {
      let s3 = this.deletedStates[e][t3];
      if (s3 === null) return {};
      for (let l in s3) delete a[l];
    }
    return a;
  }
  initializeTileState(e, t3) {
    e.setFeatureState(this.state, t3);
  }
  coalesceChanges(e, t3) {
    let i = {};
    for (let n in this.stateChanges) {
      this.state[n] = this.state[n] || {};
      let o = {};
      for (let a in this.stateChanges[n]) this.state[n][a] || (this.state[n][a] = {}), V(this.state[n][a], this.stateChanges[n][a]), o[a] = this.state[n][a];
      i[n] = o;
    }
    for (let n in this.deletedStates) {
      this.state[n] = this.state[n] || {};
      let o = {};
      if (this.deletedStates[n] === null) for (let a in this.state[n]) o[a] = {}, this.state[n][a] = {};
      else for (let a in this.deletedStates[n]) {
        if (this.deletedStates[n][a] === null) this.state[n][a] = {};
        else for (let l of Object.keys(this.deletedStates[n][a])) delete this.state[n][a][l];
        o[a] = this.state[n][a];
      }
      i[n] = i[n] || {}, V(i[n], o);
    }
    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(i).length !== 0) for (let n in e) e[n].setFeatureState(i, t3);
  }
};
r(Fd, "SourceFeatureState");
var _u = Fd;
var bi = class bi2 extends de {
  constructor(e, t3, i) {
    super(), this.id = e, this.dispatcher = i, this.on("data", (n) => this._dataHandler(n)), this.on("dataloading", () => {
      this._sourceErrored = false;
    }), this.on("error", () => {
      this._sourceErrored = this._source.loaded();
    }), this._source = n1(e, t3, i, this), this._tiles = {}, this._cache = new bu(0, (n) => this._unloadTile(n)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new _u(), this._didEmitContent = false, this._updated = false;
  }
  onAdd(e) {
    this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
  }
  onRemove(e) {
    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
  }
  loaded() {
    if (this._sourceErrored) return true;
    if (!this._sourceLoaded || !this._source.loaded()) return false;
    if ((this.used !== void 0 || this.usedForTerrain !== void 0) && !this.used && !this.usedForTerrain) return true;
    if (!this._updated) return false;
    for (let e in this._tiles) {
      let t3 = this._tiles[e];
      if (t3.state !== "loaded" && t3.state !== "errored") return false;
    }
    return true;
  }
  getSource() {
    return this._source;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    if (!this._paused) return;
    let e = this._shouldReloadOnResume;
    this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
  }
  async _loadTile(e, t3, i) {
    try {
      await this._source.loadTile(e), this._tileLoaded(e, t3, i);
    } catch (n) {
      e.state = "errored", n.status !== 404 ? this._source.fire(new Z(n, { tile: e })) : this.update(this.transform, this.terrain);
    }
  }
  _unloadTile(e) {
    this._source.unloadTile && this._source.unloadTile(e);
  }
  _abortTile(e) {
    this._source.abortTile && this._source.abortTile(e), this._source.fire(new F("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
  }
  serialize() {
    return this._source.serialize();
  }
  prepare(e) {
    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
    for (let t3 in this._tiles) {
      let i = this._tiles[t3];
      i.upload(e), i.prepare(this.map.style.imageManager);
    }
  }
  getIds() {
    return Object.values(this._tiles).map((e) => e.tileID).sort(p1).map((e) => e.key);
  }
  getRenderableIds(e) {
    let t3 = [];
    for (let i in this._tiles) this._isIdRenderable(i, e) && t3.push(this._tiles[i]);
    return e ? t3.sort((i, n) => {
      let o = i.tileID, a = n.tileID, s3 = new Rd.default(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), l = new Rd.default(a.canonical.x, a.canonical.y)._rotate(this.transform.angle);
      return o.overscaledZ - a.overscaledZ || l.y - s3.y || l.x - s3.x;
    }).map((i) => i.tileID.key) : t3.map((i) => i.tileID).sort(p1).map((i) => i.key);
  }
  hasRenderableParent(e) {
    let t3 = this.findLoadedParent(e, 0);
    return t3 ? this._isIdRenderable(t3.tileID.key) : false;
  }
  _isIdRenderable(e, t3) {
    return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t3 || !this._tiles[e].holdingForFade());
  }
  reload() {
    if (this._paused) {
      this._shouldReloadOnResume = true;
      return;
    }
    this._cache.reset();
    for (let e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
  }
  async _reloadTile(e, t3) {
    let i = this._tiles[e];
    i && (i.state !== "loading" && (i.state = t3), await this._loadTile(i, e, t3));
  }
  _tileLoaded(e, t3, i) {
    e.timeAdded = Y.now(), i === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(t3, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new F("data", { dataType: "source", tile: e, coord: e.tileID }));
  }
  _backfillDEM(e) {
    let t3 = this.getRenderableIds();
    for (let n = 0; n < t3.length; n++) {
      let o = t3[n];
      if (e.neighboringTiles && e.neighboringTiles[o]) {
        let a = this.getTileByID(o);
        i(e, a), i(a, e);
      }
    }
    function i(n, o) {
      n.needsHillshadePrepare = true, n.needsTerrainPrepare = true;
      let a = o.tileID.canonical.x - n.tileID.canonical.x, s3 = o.tileID.canonical.y - n.tileID.canonical.y, l = Math.pow(2, n.tileID.canonical.z), c = o.tileID.key;
      a === 0 && s3 === 0 || Math.abs(s3) > 1 || (Math.abs(a) > 1 && (Math.abs(a + l) === 1 ? a += l : Math.abs(a - l) === 1 && (a -= l)), !(!o.dem || !n.dem) && (n.dem.backfillBorder(o.dem, a, s3), n.neighboringTiles && n.neighboringTiles[c] && (n.neighboringTiles[c].backfilled = true)));
    }
    r(i, "fillBorder");
  }
  getTile(e) {
    return this.getTileByID(e.key);
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  _retainLoadedChildren(e, t3, i, n) {
    for (let o in this._tiles) {
      let a = this._tiles[o];
      if (n[o] || !a.hasData() || a.tileID.overscaledZ <= t3 || a.tileID.overscaledZ > i) continue;
      let s3 = a.tileID;
      for (; a && a.tileID.overscaledZ > t3 + 1; ) {
        let c = a.tileID.scaledTo(a.tileID.overscaledZ - 1);
        a = this._tiles[c.key], a && a.hasData() && (s3 = c);
      }
      let l = s3;
      for (; l.overscaledZ > t3; ) if (l = l.scaledTo(l.overscaledZ - 1), e[l.key]) {
        n[s3.key] = s3;
        break;
      }
    }
  }
  findLoadedParent(e, t3) {
    if (e.key in this._loadedParentTiles) {
      let i = this._loadedParentTiles[e.key];
      return i && i.tileID.overscaledZ >= t3 ? i : null;
    }
    for (let i = e.overscaledZ - 1; i >= t3; i--) {
      let n = e.scaledTo(i), o = this._getLoadedTile(n);
      if (o) return o;
    }
  }
  _getLoadedTile(e) {
    let t3 = this._tiles[e.key];
    return t3 && t3.hasData() ? t3 : this._cache.getByKey(e.wrapped().key);
  }
  updateCacheSize(e) {
    let t3 = Math.ceil(e.width / this._source.tileSize) + 1, i = Math.ceil(e.height / this._source.tileSize) + 1, n = t3 * i, o = this._maxTileCacheZoomLevels === null ? ot.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels, a = Math.floor(n * o), s3 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a;
    this._cache.setMaxSize(s3);
  }
  handleWrapJump(e) {
    let t3 = this._prevLng === void 0 ? e : this._prevLng, n = (e - t3) / 360, o = Math.round(n);
    if (this._prevLng = e, o) {
      let a = {};
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        l.tileID = l.tileID.unwrapTo(l.tileID.wrap + o), a[l.tileID.key] = l;
      }
      this._tiles = a;
      for (let s3 in this._timers) clearTimeout(this._timers[s3]), delete this._timers[s3];
      for (let s3 in this._tiles) {
        let l = this._tiles[s3];
        this._setTileReloadTimer(s3, l);
      }
    }
  }
  update(e, t3) {
    if (!this._sourceLoaded || this._paused) return;
    this.transform = e, this.terrain = t3, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {};
    let i;
    !this.used && !this.usedForTerrain ? i = [] : this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((p) => new Ke(p.canonical.z, p.wrap, p.canonical.z, p.canonical.x, p.canonical.y)) : (i = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this.usedForTerrain ? false : this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: t3 }), this._source.hasTile && (i = i.filter((p) => this._source.hasTile(p))));
    let n = e.coveringZoomLevel(this._source), o = Math.max(n - bi2.maxOverzooming, this._source.minzoom), a = Math.max(n + bi2.maxUnderzooming, this._source.minzoom);
    if (this.usedForTerrain) {
      let p = {};
      for (let h of i) if (h.canonical.z > this._source.minzoom) {
        let f = h.scaledTo(h.canonical.z - 1);
        p[f.key] = f;
        let m = h.scaledTo(Math.max(this._source.minzoom, Math.min(h.canonical.z, 5)));
        p[m.key] = m;
      }
      i = i.concat(Object.values(p));
    }
    let s3 = i.length === 0 && !this._updated && this._didEmitContent;
    this._updated = true, s3 && this.fire(new F("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
    let l = this._updateRetainedTiles(i, n);
    if (h1(this._source.type)) {
      let p = {}, h = {}, f = Object.keys(l), m = Y.now();
      for (let y of f) {
        let g = l[y], x = this._tiles[y];
        if (!x || x.fadeEndTime !== 0 && x.fadeEndTime <= m) continue;
        let b = this.findLoadedParent(g, o);
        b && (this._addTile(b.tileID), p[b.tileID.key] = b.tileID), h[y] = g;
      }
      this._retainLoadedChildren(h, n, a, l);
      for (let y in p) l[y] || (this._coveredTiles[y] = true, l[y] = p[y]);
      if (t3) {
        let y = {}, g = {};
        for (let x of i) this._tiles[x.key].hasData() ? y[x.key] = x : g[x.key] = x;
        for (let x in g) {
          let b = g[x].children(this._source.maxzoom);
          this._tiles[b[0].key] && this._tiles[b[1].key] && this._tiles[b[2].key] && this._tiles[b[3].key] && (y[b[0].key] = l[b[0].key] = b[0], y[b[1].key] = l[b[1].key] = b[1], y[b[2].key] = l[b[2].key] = b[2], y[b[3].key] = l[b[3].key] = b[3], delete g[x]);
        }
        for (let x in g) {
          let b = this.findLoadedParent(g[x], this._source.minzoom);
          if (b) {
            y[b.tileID.key] = l[b.tileID.key] = b.tileID;
            for (let w in y) y[w].isChildOf(b.tileID) && delete y[w];
          }
        }
        for (let x in this._tiles) y[x] || (this._coveredTiles[x] = true);
      }
    }
    for (let p in l) this._tiles[p].clearFadeHold();
    let c = Wx(this._tiles, l);
    for (let p of c) {
      let h = this._tiles[p];
      h.hasSymbolBuckets && !h.holdingForFade() ? h.setHoldDuration(this.map._fadeDuration) : (!h.hasSymbolBuckets || h.symbolFadeFinished()) && this._removeTile(p);
    }
    this._updateLoadedParentTileCache();
  }
  releaseSymbolFadeTiles() {
    for (let e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
  }
  _updateRetainedTiles(e, t3) {
    let i = {}, n = {}, o = Math.max(t3 - bi2.maxOverzooming, this._source.minzoom), a = Math.max(t3 + bi2.maxUnderzooming, this._source.minzoom), s3 = {};
    for (let l of e) {
      let c = this._addTile(l);
      i[l.key] = l, !c.hasData() && t3 < this._source.maxzoom && (s3[l.key] = l);
    }
    this._retainLoadedChildren(s3, t3, a, i);
    for (let l of e) {
      let c = this._tiles[l.key];
      if (c.hasData()) continue;
      if (t3 + 1 > this._source.maxzoom) {
        let h = l.children(this._source.maxzoom)[0], f = this.getTile(h);
        if (f && f.hasData()) {
          i[h.key] = h;
          continue;
        }
      } else {
        let h = l.children(this._source.maxzoom);
        if (i[h[0].key] && i[h[1].key] && i[h[2].key] && i[h[3].key]) continue;
      }
      let p = c.wasRequested();
      for (let h = l.overscaledZ - 1; h >= o; --h) {
        let f = l.scaledTo(h);
        if (n[f.key]) break;
        if (n[f.key] = true, c = this.getTile(f), !c && p && (c = this._addTile(f)), c) {
          let m = c.hasData();
          if ((p || m) && (i[f.key] = f), p = c.wasRequested(), m) break;
        }
      }
    }
    return i;
  }
  _updateLoadedParentTileCache() {
    this._loadedParentTiles = {};
    for (let e in this._tiles) {
      let t3 = [], i, n = this._tiles[e].tileID;
      for (; n.overscaledZ > 0; ) {
        if (n.key in this._loadedParentTiles) {
          i = this._loadedParentTiles[n.key];
          break;
        }
        t3.push(n.key);
        let o = n.scaledTo(n.overscaledZ - 1);
        if (i = this._getLoadedTile(o), i) break;
        n = o;
      }
      for (let o of t3) this._loadedParentTiles[o] = i;
    }
  }
  _addTile(e) {
    let t3 = this._tiles[e.key];
    if (t3) return t3;
    t3 = this._cache.getAndRemove(e), t3 && (this._setTileReloadTimer(e.key, t3), t3.tileID = e, this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t3)));
    let i = t3;
    return t3 || (t3 = new bn(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(t3, e.key, t3.state)), t3.uses++, this._tiles[e.key] = t3, i || this._source.fire(new F("dataloading", { tile: t3, coord: t3.tileID, dataType: "source" })), t3;
  }
  _setTileReloadTimer(e, t3) {
    e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
    let i = t3.getExpiryTimeout();
    i && (this._timers[e] = setTimeout(() => {
      this._reloadTile(e, "expired"), delete this._timers[e];
    }, i));
  }
  _removeTile(e) {
    let t3 = this._tiles[e];
    t3 && (t3.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), !(t3.uses > 0) && (t3.hasData() && t3.state !== "reloading" ? this._cache.add(t3.tileID, t3, t3.getExpiryTimeout()) : (t3.aborted = true, this._abortTile(t3), this._unloadTile(t3))));
  }
  _dataHandler(e) {
    let t3 = e.sourceDataType;
    e.dataType === "source" && t3 === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && t3 === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
  }
  clearTiles() {
    this._shouldReloadOnResume = false, this._paused = false;
    for (let e in this._tiles) this._removeTile(e);
    this._cache.reset();
  }
  tilesIn(e, t3, i) {
    let n = [], o = this.transform;
    if (!o) return n;
    let a = i ? o.getCameraQueryGeometry(e) : e, s3 = e.map((y) => o.pointCoordinate(y, this.terrain)), l = a.map((y) => o.pointCoordinate(y, this.terrain)), c = this.getIds(), p = 1 / 0, h = 1 / 0, f = -1 / 0, m = -1 / 0;
    for (let y of l) p = Math.min(p, y.x), h = Math.min(h, y.y), f = Math.max(f, y.x), m = Math.max(m, y.y);
    for (let y = 0; y < c.length; y++) {
      let g = this._tiles[c[y]];
      if (g.holdingForFade()) continue;
      let x = g.tileID, b = Math.pow(2, o.zoom - g.tileID.overscaledZ), w = t3 * g.queryPadding * 8192 / g.tileSize / b, _ = [x.getTilePoint(new Fe(p, h)), x.getTilePoint(new Fe(f, m))];
      if (_[0].x - w < 8192 && _[0].y - w < 8192 && _[1].x + w >= 0 && _[1].y + w >= 0) {
        let S = s3.map((T) => x.getTilePoint(T)), P = l.map((T) => x.getTilePoint(T));
        n.push({ tile: g, tileID: x, queryGeometry: S, cameraQueryGeometry: P, scale: b });
      }
    }
    return n;
  }
  getVisibleCoordinates(e) {
    let t3 = this.getRenderableIds(e).map((i) => this._tiles[i].tileID);
    for (let i of t3) i.posMatrix = this.transform.calculatePosMatrix(i.toUnwrapped());
    return t3;
  }
  hasTransition() {
    if (this._source.hasTransition()) return true;
    if (h1(this._source.type)) {
      let e = Y.now();
      for (let t3 in this._tiles) if (this._tiles[t3].fadeEndTime >= e) return true;
    }
    return false;
  }
  setFeatureState(e, t3, i) {
    e = e || "_geojsonTileLayer", this._state.updateState(e, t3, i);
  }
  removeFeatureState(e, t3, i) {
    e = e || "_geojsonTileLayer", this._state.removeFeatureState(e, t3, i);
  }
  getFeatureState(e, t3) {
    return e = e || "_geojsonTileLayer", this._state.getState(e, t3);
  }
  setDependencies(e, t3, i) {
    let n = this._tiles[e];
    n && n.setDependencies(t3, i);
  }
  reloadTilesForDependencies(e, t3) {
    for (let i in this._tiles) this._tiles[i].hasDependency(e, t3) && this._reloadTile(i, "reloading");
    this._cache.filter((i) => !i.hasDependency(e, t3));
  }
};
r(bi, "SourceCache");
var ur = bi;
ur.maxOverzooming = 10;
ur.maxUnderzooming = 3;
function p1(r3, e) {
  let t3 = Math.abs(r3.wrap * 2) - +(r3.wrap < 0), i = Math.abs(e.wrap * 2) - +(e.wrap < 0);
  return r3.overscaledZ - e.overscaledZ || i - t3 || e.canonical.y - r3.canonical.y || e.canonical.x - r3.canonical.x;
}
r(p1, "compareTileId");
function h1(r3) {
  return r3 === "raster" || r3 === "image" || r3 === "video";
}
r(h1, "isRasterType");
q();
q();
q();
var Zt = u(ge(), 1);
q();
var cr = u(ge(), 1);
function Bd(r3, e, t3, i, n) {
  let o = [];
  for (let a = 0; a < r3.length; a++) {
    let s3 = r3[a], l;
    for (let c = 0; c < s3.length - 1; c++) {
      let p = s3[c], h = s3[c + 1];
      p.x < e && h.x < e || (p.x < e ? p = new cr.default(e, p.y + (h.y - p.y) * ((e - p.x) / (h.x - p.x)))._round() : h.x < e && (h = new cr.default(e, p.y + (h.y - p.y) * ((e - p.x) / (h.x - p.x)))._round()), !(p.y < t3 && h.y < t3) && (p.y < t3 ? p = new cr.default(p.x + (h.x - p.x) * ((t3 - p.y) / (h.y - p.y)), t3)._round() : h.y < t3 && (h = new cr.default(p.x + (h.x - p.x) * ((t3 - p.y) / (h.y - p.y)), t3)._round()), !(p.x >= i && h.x >= i) && (p.x >= i ? p = new cr.default(i, p.y + (h.y - p.y) * ((i - p.x) / (h.x - p.x)))._round() : h.x >= i && (h = new cr.default(i, p.y + (h.y - p.y) * ((i - p.x) / (h.x - p.x)))._round()), !(p.y >= n && h.y >= n) && (p.y >= n ? p = new cr.default(p.x + (h.x - p.x) * ((n - p.y) / (h.y - p.y)), n)._round() : h.y >= n && (h = new cr.default(p.x + (h.x - p.x) * ((n - p.y) / (h.y - p.y)), n)._round()), (!l || !p.equals(l[l.length - 1])) && (l = [p], o.push(l)), l.push(h)))));
    }
  }
  return o;
}
r(Bd, "clipLine");
q();
var Od = class Od2 {
  constructor(e, t3) {
    this.reset(e, t3);
  }
  reset(e, t3) {
    this.points = e || [], this._distances = [0];
    for (let i = 1; i < this.points.length; i++) this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);
    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, this.length * 0.5), this.paddedLength = this.length - this.padding * 2;
  }
  lerp(e) {
    if (this.points.length === 1) return this.points[0];
    e = Ae(e, 0, 1);
    let t3 = 1, i = this._distances[t3], n = e * this.paddedLength + this.padding;
    for (; i < n && t3 < this._distances.length; ) i = this._distances[++t3];
    let o = t3 - 1, a = this._distances[o], s3 = i - a, l = s3 > 0 ? (n - a) / s3 : 0;
    return this.points[o].mult(1 - l).add(this.points[t3].mult(l));
  }
};
r(Od, "PathInterpolator");
var vu = Od;
q();
function wu(r3, e) {
  let t3 = true;
  return r3 === "always" || (r3 === "never" || e === "never") && (t3 = false), t3;
}
r(wu, "overlapAllowed");
var Vd = class Vd2 {
  constructor(e, t3, i) {
    let n = this.boxCells = [], o = this.circleCells = [];
    this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t3 / i);
    for (let a = 0; a < this.xCellCount * this.yCellCount; a++) n.push([]), o.push([]);
    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t3, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
  }
  keysLength() {
    return this.boxKeys.length + this.circleKeys.length;
  }
  insert(e, t3, i, n, o) {
    this._forEachCell(t3, i, n, o, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t3), this.bboxes.push(i), this.bboxes.push(n), this.bboxes.push(o);
  }
  insertCircle(e, t3, i, n) {
    this._forEachCell(t3 - n, i - n, t3 + n, i + n, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t3), this.circles.push(i), this.circles.push(n);
  }
  _insertBoxCell(e, t3, i, n, o, a) {
    this.boxCells[o].push(a);
  }
  _insertCircleCell(e, t3, i, n, o, a) {
    this.circleCells[o].push(a);
  }
  _query(e, t3, i, n, o, a, s3) {
    if (i < 0 || e > this.width || n < 0 || t3 > this.height) return [];
    let l = [];
    if (e <= 0 && t3 <= 0 && this.width <= i && this.height <= n) {
      if (o) return [{ key: null, x1: e, y1: t3, x2: i, y2: n }];
      for (let c = 0; c < this.boxKeys.length; c++) l.push({ key: this.boxKeys[c], x1: this.bboxes[c * 4], y1: this.bboxes[c * 4 + 1], x2: this.bboxes[c * 4 + 2], y2: this.bboxes[c * 4 + 3] });
      for (let c = 0; c < this.circleKeys.length; c++) {
        let p = this.circles[c * 3], h = this.circles[c * 3 + 1], f = this.circles[c * 3 + 2];
        l.push({ key: this.circleKeys[c], x1: p - f, y1: h - f, x2: p + f, y2: h + f });
      }
    } else {
      let c = { hitTest: o, overlapMode: a, seenUids: { box: {}, circle: {} } };
      this._forEachCell(e, t3, i, n, this._queryCell, l, c, s3);
    }
    return l;
  }
  query(e, t3, i, n) {
    return this._query(e, t3, i, n, false, null);
  }
  hitTest(e, t3, i, n, o, a) {
    return this._query(e, t3, i, n, true, o, a).length > 0;
  }
  hitTestCircle(e, t3, i, n, o) {
    let a = e - i, s3 = e + i, l = t3 - i, c = t3 + i;
    if (s3 < 0 || a > this.width || c < 0 || l > this.height) return false;
    let p = [], h = { hitTest: true, overlapMode: n, circle: { x: e, y: t3, radius: i }, seenUids: { box: {}, circle: {} } };
    return this._forEachCell(a, l, s3, c, this._queryCellCircle, p, h, o), p.length > 0;
  }
  _queryCell(e, t3, i, n, o, a, s3, l) {
    let { seenUids: c, hitTest: p, overlapMode: h } = s3, f = this.boxCells[o];
    if (f !== null) {
      let y = this.bboxes;
      for (let g of f) if (!c.box[g]) {
        c.box[g] = true;
        let x = g * 4, b = this.boxKeys[g];
        if (e <= y[x + 2] && t3 <= y[x + 3] && i >= y[x + 0] && n >= y[x + 1] && (!l || l(b)) && (!p || !wu(h, b.overlapMode)) && (a.push({ key: b, x1: y[x], y1: y[x + 1], x2: y[x + 2], y2: y[x + 3] }), p)) return true;
      }
    }
    let m = this.circleCells[o];
    if (m !== null) {
      let y = this.circles;
      for (let g of m) if (!c.circle[g]) {
        c.circle[g] = true;
        let x = g * 3, b = this.circleKeys[g];
        if (this._circleAndRectCollide(y[x], y[x + 1], y[x + 2], e, t3, i, n) && (!l || l(b)) && (!p || !wu(h, b.overlapMode))) {
          let w = y[x], _ = y[x + 1], S = y[x + 2];
          if (a.push({ key: b, x1: w - S, y1: _ - S, x2: w + S, y2: _ + S }), p) return true;
        }
      }
    }
    return false;
  }
  _queryCellCircle(e, t3, i, n, o, a, s3, l) {
    let { circle: c, seenUids: p, overlapMode: h } = s3, f = this.boxCells[o];
    if (f !== null) {
      let y = this.bboxes;
      for (let g of f) if (!p.box[g]) {
        p.box[g] = true;
        let x = g * 4, b = this.boxKeys[g];
        if (this._circleAndRectCollide(c.x, c.y, c.radius, y[x + 0], y[x + 1], y[x + 2], y[x + 3]) && (!l || l(b)) && !wu(h, b.overlapMode)) return a.push(true), true;
      }
    }
    let m = this.circleCells[o];
    if (m !== null) {
      let y = this.circles;
      for (let g of m) if (!p.circle[g]) {
        p.circle[g] = true;
        let x = g * 3, b = this.circleKeys[g];
        if (this._circlesCollide(y[x], y[x + 1], y[x + 2], c.x, c.y, c.radius) && (!l || l(b)) && !wu(h, b.overlapMode)) return a.push(true), true;
      }
    }
  }
  _forEachCell(e, t3, i, n, o, a, s3, l) {
    let c = this._convertToXCellCoord(e), p = this._convertToYCellCoord(t3), h = this._convertToXCellCoord(i), f = this._convertToYCellCoord(n);
    for (let m = c; m <= h; m++) for (let y = p; y <= f; y++) {
      let g = this.xCellCount * y + m;
      if (o.call(this, e, t3, i, n, g, a, s3, l)) return;
    }
  }
  _convertToXCellCoord(e) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
  }
  _convertToYCellCoord(e) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
  }
  _circlesCollide(e, t3, i, n, o, a) {
    let s3 = n - e, l = o - t3, c = i + a;
    return c * c > s3 * s3 + l * l;
  }
  _circleAndRectCollide(e, t3, i, n, o, a, s3) {
    let l = (a - n) / 2, c = Math.abs(e - (n + l));
    if (c > l + i) return false;
    let p = (s3 - o) / 2, h = Math.abs(t3 - (o + p));
    if (h > p + i) return false;
    if (c <= l || h <= p) return true;
    let f = c - l, m = h - p;
    return f * f + m * m <= i * i;
  }
};
r(Vd, "GridIndex");
var ya = Vd;
q();
var _n = u(ge(), 1);
function ga(r3, e, t3, i, n) {
  let o = $.create();
  return e ? ($.scale(o, o, [1 / n, 1 / n, 1]), t3 || $.rotateZ(o, o, i.angle)) : $.multiply(o, i.labelPlaneMatrix, r3), o;
}
r(ga, "getLabelPlaneMatrix");
function Pu(r3, e, t3, i, n) {
  if (e) {
    let o = $.clone(r3);
    return $.scale(o, o, [n, n, 1]), t3 || $.rotateZ(o, o, -i.angle), o;
  } else return i.glCoordMatrix;
}
r(Pu, "getGlCoordMatrix");
function bt(r3, e, t3) {
  let i;
  t3 ? (i = [r3.x, r3.y, t3(r3.x, r3.y), 1], $e.transformMat4(i, i, e)) : (i = [r3.x, r3.y, 0, 1], Tu(i, i, e));
  let n = i[3];
  return { point: new _n.default(i[0] / n, i[1] / n), signedDistanceFromCamera: n };
}
r(bt, "project");
function xa(r3, e) {
  return 0.5 + 0.5 * (r3 / e);
}
r(xa, "getPerspectiveRatio");
function rL(r3, e) {
  let t3 = r3[0] / r3[3], i = r3[1] / r3[3];
  return t3 >= -e[0] && t3 <= e[0] && i >= -e[1] && i <= e[1];
}
r(rL, "isVisible");
function d1(r3, e, t3, i, n, o, a, s3, l, c) {
  let p = i ? r3.textSizeData : r3.iconSizeData, h = mi(p, t3.transform.zoom), f = [256 / t3.width * 2 + 1, 256 / t3.height * 2 + 1], m = i ? r3.text.dynamicLayoutVertexArray : r3.icon.dynamicLayoutVertexArray;
  m.clear();
  let y = r3.lineVertexArray, g = i ? r3.text.placedSymbolArray : r3.icon.placedSymbolArray, x = t3.transform.width / t3.transform.height, b = false;
  for (let w = 0; w < g.length; w++) {
    let _ = g.get(w);
    if (_.hidden || _.writingMode === 2 && !b) {
      _i(_.numGlyphs, m);
      continue;
    }
    b = false;
    let S;
    if (c ? (S = [_.anchorX, _.anchorY, c(_.anchorX, _.anchorY), 1], $e.transformMat4(S, S, e)) : (S = [_.anchorX, _.anchorY, 0, 1], Tu(S, S, e)), !rL(S, f)) {
      _i(_.numGlyphs, m);
      continue;
    }
    let P = S[3], T = xa(t3.transform.cameraToCenterDistance, P), L = hn(p, h, _), C = a ? L / T : L * T, E = new _n.default(_.anchorX, _.anchorY), I = bt(E, n, c).point, R = { projections: {}, offsets: {} }, z = m1(_, C, false, s3, e, n, o, r3.glyphOffsetArray, y, m, I, E, R, x, l, c);
    b = z.useVertical, (z.notEnoughRoom || b || z.needsFlipping && m1(_, C, true, s3, e, n, o, r3.glyphOffsetArray, y, m, I, E, R, x, l, c).notEnoughRoom) && _i(_.numGlyphs, m);
  }
  i ? r3.text.dynamicLayoutVertexBuffer.updateData(m) : r3.icon.dynamicLayoutVertexBuffer.updateData(m);
}
r(d1, "updateLineLabels");
function Gd(r3, e, t3, i, n, o, a, s3, l, c, p, h, f) {
  let m = s3.glyphStartIndex + s3.numGlyphs, y = s3.lineStartIndex, g = s3.lineStartIndex + s3.lineLength, x = e.getoffsetX(s3.glyphStartIndex), b = e.getoffsetX(m - 1), w = Su(r3 * x, t3, i, n, o, a, s3.segment, y, g, l, c, p, h, f);
  if (!w) return null;
  let _ = Su(r3 * b, t3, i, n, o, a, s3.segment, y, g, l, c, p, h, f);
  return _ ? { first: w, last: _ } : null;
}
r(Gd, "placeFirstAndLastGlyph");
function f1(r3, e, t3, i) {
  if (r3 === 1) {
    let n = Math.abs(t3.y - e.y), o = Math.abs(t3.x - e.x) * i;
    if (n > o) return { useVertical: true };
  }
  return (r3 === 2 ? e.y < t3.y : e.x > t3.x) ? { needsFlipping: true } : null;
}
r(f1, "requiresOrientationChange");
function m1(r3, e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g) {
  let x = e / 24, b = r3.lineOffsetX * x, w = r3.lineOffsetY * x, _;
  if (r3.numGlyphs > 1) {
    let S = r3.glyphStartIndex + r3.numGlyphs, P = r3.lineStartIndex, T = r3.lineStartIndex + r3.lineLength, L = Gd(x, s3, b, w, t3, p, h, r3, l, o, f, y, g);
    if (!L) return { notEnoughRoom: true };
    let C = bt(L.first.point, a, g).point, E = bt(L.last.point, a, g).point;
    if (i && !t3) {
      let I = f1(r3.writingMode, C, E, m);
      if (I) return I;
    }
    _ = [L.first];
    for (let I = r3.glyphStartIndex + 1; I < S - 1; I++) _.push(Su(x * s3.getoffsetX(I), b, w, t3, p, h, r3.segment, P, T, l, o, f, y, g));
    _.push(L.last);
  } else {
    if (i && !t3) {
      let P = bt(h, n, g).point, T = r3.lineStartIndex + r3.segment + 1, L = new _n.default(l.getx(T), l.gety(T)), C = bt(L, n, g), E = C.signedDistanceFromCamera > 0 ? C.point : y1(h, L, P, 1, n, g), I = f1(r3.writingMode, P, E, m);
      if (I) return I;
    }
    let S = Su(x * s3.getoffsetX(r3.glyphStartIndex), b, w, t3, p, h, r3.segment, r3.lineStartIndex, r3.lineStartIndex + r3.lineLength, l, o, f, y, g);
    if (!S) return { notEnoughRoom: true };
    _ = [S];
  }
  for (let S of _) di(c, S.point, S.angle);
  return {};
}
r(m1, "placeGlyphsAlongLine");
function y1(r3, e, t3, i, n, o) {
  let a = bt(r3.add(r3.sub(e)._unit()), n, o).point, s3 = t3.sub(a);
  return t3.add(s3._mult(i / s3.mag()));
}
r(y1, "projectTruncatedLineSegment");
function Ud(r3, e) {
  let { projectionCache: t3, lineVertexArray: i, labelPlaneMatrix: n, tileAnchorPoint: o, distanceFromAnchor: a, getElevation: s3, previousVertex: l, direction: c, absOffsetX: p } = e;
  if (t3.projections[r3]) return t3.projections[r3];
  let h = new _n.default(i.getx(r3), i.gety(r3)), f = bt(h, n, s3);
  if (f.signedDistanceFromCamera > 0) return t3.projections[r3] = f.point, f.point;
  let m = r3 - c, y = a === 0 ? o : new _n.default(i.getx(m), i.gety(m));
  return y1(y, h, l, p - a + 1, n, s3);
}
r(Ud, "projectVertexToViewport");
function Nd(r3, e, t3) {
  return r3._unit()._perp()._mult(e * t3);
}
r(Nd, "transformToOffsetNormal");
function iL(r3, e, t3, i, n, o, a, s3) {
  let { projectionCache: l, direction: c } = s3;
  if (l.offsets[r3]) return l.offsets[r3];
  let p = t3.add(e);
  if (r3 + c < i || r3 + c >= n) return l.offsets[r3] = p, p;
  let h = Ud(r3 + c, s3), f = Nd(h.sub(t3), a, c), m = t3.add(f), y = h.add(f);
  return l.offsets[r3] = Yx(o, p, m, y) || p, l.offsets[r3];
}
r(iL, "findOffsetIntersectionPoint");
function Su(r3, e, t3, i, n, o, a, s3, l, c, p, h, f, m) {
  let y = i ? r3 - e : r3 + e, g = y > 0 ? 1 : -1, x = 0;
  i && (g *= -1, x = Math.PI), g < 0 && (x += Math.PI);
  let b = g > 0 ? s3 + a : s3 + a + 1, w = n, _ = n, S, P, T = 0, L = 0, C = Math.abs(y), E = [], I;
  for (; T + L <= C; ) {
    if (b += g, b < s3 || b >= l) return null;
    T += L, _ = w, P = S;
    let M = { projectionCache: h, lineVertexArray: c, labelPlaneMatrix: p, tileAnchorPoint: o, distanceFromAnchor: T, getElevation: m, previousVertex: _, direction: g, absOffsetX: C };
    if (w = Ud(b, M), t3 === 0) E.push(_), I = w.sub(_);
    else {
      let G, K = w.sub(_);
      if (K.mag() === 0) {
        let ne = Ud(b + g, M);
        G = Nd(ne.sub(w), t3, g);
      } else G = Nd(K, t3, g);
      P || (P = _.add(G)), S = iL(b, G, w, s3, l, P, t3, M), E.push(P), I = S.sub(P);
    }
    L = I.mag();
  }
  let R = (C - T) / L, z = I._mult(R)._add(P || _), k = x + Math.atan2(w.y - _.y, w.x - _.x);
  return E.push(z), { point: z, angle: f ? k : 0, path: E };
}
r(Su, "placeGlyphAlongLine");
var nL = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
function _i(r3, e) {
  for (let t3 = 0; t3 < r3; t3++) {
    let i = e.length;
    e.resize(i + 4), e.float32.set(nL, i * 3);
  }
}
r(_i, "hideGlyphs");
function Tu(r3, e, t3) {
  let i = e[0], n = e[1];
  return r3[0] = t3[0] * i + t3[4] * n + t3[12], r3[1] = t3[1] * i + t3[5] * n + t3[13], r3[3] = t3[3] * i + t3[7] * n + t3[15], r3;
}
r(Tu, "xyTransformMat4");
var Xe = 100;
var qd = class qd2 {
  constructor(e, t3 = new ya(e.width + 2 * Xe, e.height + 2 * Xe, 25), i = new ya(e.width + 2 * Xe, e.height + 2 * Xe, 25)) {
    this.transform = e, this.grid = t3, this.ignoredGrid = i, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Xe, this.screenBottomBoundary = e.height + Xe, this.gridRightBoundary = e.width + 2 * Xe, this.gridBottomBoundary = e.height + 2 * Xe, this.perspectiveRatioCutoff = 0.6;
  }
  placeCollisionBox(e, t3, i, n, o, a) {
    let s3 = this.projectAndGetPerspectiveRatio(n, e.anchorPointX, e.anchorPointY, a), l = i * s3.perspectiveRatio, c = e.x1 * l + s3.point.x, p = e.y1 * l + s3.point.y, h = e.x2 * l + s3.point.x, f = e.y2 * l + s3.point.y;
    return !this.isInsideGrid(c, p, h, f) || t3 !== "always" && this.grid.hitTest(c, p, h, f, t3, o) || s3.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [c, p, h, f], offscreen: this.isOffscreen(c, p, h, f) };
  }
  placeCollisionCircles(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y) {
    let g = [], x = new Zt.default(t3.anchorX, t3.anchorY), b = bt(x, a, y), w = xa(this.transform.cameraToCenterDistance, b.signedDistanceFromCamera), S = (p ? o / w : o * w) / Lr, P = bt(x, s3, y).point, T = { projections: {}, offsets: {} }, L = t3.lineOffsetX * S, C = t3.lineOffsetY * S, E = Gd(S, n, L, C, false, P, x, t3, i, s3, T, false, y), I = false, R = false, z = true;
    if (E) {
      let k = f * 0.5 * w + m, M = new Zt.default(-Xe, -Xe), G = new Zt.default(this.screenRightBoundary, this.screenBottomBoundary), K = new vu(), ne = E.first, J = E.last, W = [];
      for (let ce = ne.path.length - 1; ce >= 1; ce--) W.push(ne.path[ce]);
      for (let ce = 1; ce < J.path.length; ce++) W.push(J.path[ce]);
      let Je = k * 2.5;
      if (l) {
        let ce = W.map((Me) => bt(Me, l, y));
        ce.some((Me) => Me.signedDistanceFromCamera <= 0) ? W = [] : W = ce.map((Me) => Me.point);
      }
      let Ve = [];
      if (W.length > 0) {
        let ce = W[0].clone(), Me = W[0].clone();
        for (let Ye = 1; Ye < W.length; Ye++) ce.x = Math.min(ce.x, W[Ye].x), ce.y = Math.min(ce.y, W[Ye].y), Me.x = Math.max(Me.x, W[Ye].x), Me.y = Math.max(Me.y, W[Ye].y);
        ce.x >= M.x && Me.x <= G.x && ce.y >= M.y && Me.y <= G.y ? Ve = [W] : Me.x < M.x || ce.x > G.x || Me.y < M.y || ce.y > G.y ? Ve = [] : Ve = Bd([W], M.x, M.y, G.x, G.y);
      }
      for (let ce of Ve) {
        K.reset(ce, k * 0.25);
        let Me = 0;
        K.length <= 0.5 * k ? Me = 1 : Me = Math.ceil(K.paddedLength / Je) + 1;
        for (let Ye = 0; Ye < Me; Ye++) {
          let fr = Ye / Math.max(Me - 1, 1), mr = K.lerp(fr), zt = mr.x + Xe, Wt = mr.y + Xe;
          g.push(zt, Wt, k, 0);
          let Nr = zt - k, Xt = Wt - k, Kt = zt + k, Qe = Wt + k;
          if (z = z && this.isOffscreen(Nr, Xt, Kt, Qe), R = R || this.isInsideGrid(Nr, Xt, Kt, Qe), e !== "always" && this.grid.hitTestCircle(zt, Wt, k, e, h) && (I = true, !c)) return { circles: [], offscreen: false, collisionDetected: I };
        }
      }
    }
    return { circles: !c && I || !R || w < this.perspectiveRatioCutoff ? [] : g, offscreen: z, collisionDetected: I };
  }
  queryRenderedSymbols(e) {
    if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
    let t3 = [], i = 1 / 0, n = 1 / 0, o = -1 / 0, a = -1 / 0;
    for (let p of e) {
      let h = new Zt.default(p.x + Xe, p.y + Xe);
      i = Math.min(i, h.x), n = Math.min(n, h.y), o = Math.max(o, h.x), a = Math.max(a, h.y), t3.push(h);
    }
    let s3 = this.grid.query(i, n, o, a).concat(this.ignoredGrid.query(i, n, o, a)), l = {}, c = {};
    for (let p of s3) {
      let h = p.key;
      if (l[h.bucketInstanceId] === void 0 && (l[h.bucketInstanceId] = {}), l[h.bucketInstanceId][h.featureIndex]) continue;
      let f = [new Zt.default(p.x1, p.y1), new Zt.default(p.x2, p.y1), new Zt.default(p.x2, p.y2), new Zt.default(p.x1, p.y2)];
      Il(t3, f) && (l[h.bucketInstanceId][h.featureIndex] = true, c[h.bucketInstanceId] === void 0 && (c[h.bucketInstanceId] = []), c[h.bucketInstanceId].push(h.featureIndex));
    }
    return c;
  }
  insertCollisionBox(e, t3, i, n, o, a) {
    let s3 = i ? this.ignoredGrid : this.grid, l = { bucketInstanceId: n, featureIndex: o, collisionGroupID: a, overlapMode: t3 };
    s3.insert(l, e[0], e[1], e[2], e[3]);
  }
  insertCollisionCircles(e, t3, i, n, o, a) {
    let s3 = i ? this.ignoredGrid : this.grid, l = { bucketInstanceId: n, featureIndex: o, collisionGroupID: a, overlapMode: t3 };
    for (let c = 0; c < e.length; c += 4) s3.insertCircle(l, e[c], e[c + 1], e[c + 2]);
  }
  projectAndGetPerspectiveRatio(e, t3, i, n) {
    let o;
    return n ? (o = [t3, i, n(t3, i), 1], $e.transformMat4(o, o, e)) : (o = [t3, i, 0, 1], Tu(o, o, e)), { point: new Zt.default((o[0] / o[3] + 1) / 2 * this.transform.width + Xe, (-o[1] / o[3] + 1) / 2 * this.transform.height + Xe), perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / o[3]) };
  }
  isOffscreen(e, t3, i, n) {
    return i < Xe || e >= this.screenRightBoundary || n < Xe || t3 > this.screenBottomBoundary;
  }
  isInsideGrid(e, t3, i, n) {
    return i >= 0 && e < this.gridRightBoundary && n >= 0 && t3 < this.gridBottomBoundary;
  }
  getViewportMatrix() {
    let e = $.identity([]);
    return $.translate(e, e, [-Xe, -Xe, 0]), e;
  }
};
r(qd, "CollisionIndex");
var Mu = qd;
q();
q();
var g1 = u(ge(), 1);
var Au = class Au2 extends g1.default {
  constructor(e, t3, i, n) {
    super(e, t3), this.angle = i, n !== void 0 && (this.segment = n);
  }
  clone() {
    return new Au2(this.x, this.y, this.angle, this.segment);
  }
};
r(Au, "Anchor");
var ba = Au;
N("Anchor", ba);
q();
q();
q();
var oL = u(ge(), 1);
q();
var aL = u(ge(), 1);
q();
q();
var sL = u(ge(), 1);
var uL = u(Xf(), 1);
q();
var _a = ((o) => (o[o.center = 1] = "center", o[o.left = 2] = "left", o[o.right = 3] = "right", o[o.top = 4] = "top", o[o.bottom = 5] = "bottom", o[o["top-left"] = 6] = "top-left", o[o["top-right"] = 7] = "top-right", o[o["bottom-left"] = 8] = "bottom-left", o[o["bottom-right"] = 9] = "bottom-right", o))(_a || {});
var lL = Number.POSITIVE_INFINITY;
function x1(r3) {
  switch (r3) {
    case "right":
    case "top-right":
    case "bottom-right":
      return "right";
    case "left":
    case "top-left":
    case "bottom-left":
      return "left";
  }
  return "center";
}
r(x1, "getAnchorJustification");
q();
function He(r3, e, t3) {
  return e * (8192 / (r3.tileSize * Math.pow(2, t3 - r3.tileID.overscaledZ)));
}
r(He, "pixelsToTileUnits");
var Lu = u(ge(), 1);
var Xd = class Xd2 {
  constructor(e, t3, i, n) {
    e ? this.opacity = Math.max(0, Math.min(1, e.opacity + (e.placed ? t3 : -t3))) : this.opacity = n && i ? 1 : 0, this.placed = i;
  }
  isHidden() {
    return this.opacity === 0 && !this.placed;
  }
};
r(Xd, "OpacityState");
var Cu = Xd;
var Kd = class Kd2 {
  constructor(e, t3, i, n, o) {
    this.text = new Cu(e ? e.text : null, t3, i, o), this.icon = new Cu(e ? e.icon : null, t3, n, o);
  }
  isHidden() {
    return this.text.isHidden() && this.icon.isHidden();
  }
};
r(Kd, "JointOpacityState");
var vi = Kd;
var Jd = class Jd2 {
  constructor(e, t3, i) {
    this.text = e, this.icon = t3, this.skipFade = i;
  }
};
r(Jd, "JointPlacement");
var Eu = Jd;
var Yd = class Yd2 {
  constructor() {
    this.invProjMatrix = $.create(), this.viewportMatrix = $.create(), this.circles = [];
  }
};
r(Yd, "CollisionCircleArray");
var Zd = Yd;
var Qd = class Qd2 {
  constructor(e, t3, i, n, o) {
    this.bucketInstanceId = e, this.featureIndex = t3, this.sourceLayerIndex = i, this.bucketIndex = n, this.tileID = o;
  }
};
r(Qd, "RetainedQueryData");
var Hd = Qd;
var ey = class ey2 {
  constructor(e) {
    this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
  }
  get(e) {
    if (this.crossSourceCollisions) return { ID: 0, predicate: null };
    if (!this.collisionGroups[e]) {
      let t3 = ++this.maxGroupID;
      this.collisionGroups[e] = { ID: t3, predicate: (i) => i.collisionGroupID === t3 };
    }
    return this.collisionGroups[e];
  }
};
r(ey, "CollisionGroups");
var Wd = ey;
function b1(r3, e, t3, i, n) {
  let { horizontalAlign: o, verticalAlign: a } = Xl(r3), s3 = -(o - 0.5) * e, l = -(a - 0.5) * t3;
  return new Lu.default(s3 + i[0] * n, l + i[1] * n);
}
r(b1, "calculateVariableLayoutShift");
function jd(r3, e, t3, i, n, o) {
  let { x1: a, x2: s3, y1: l, y2: c, anchorPointX: p, anchorPointY: h } = r3, f = new Lu.default(e, t3);
  return i && f._rotate(n ? o : -o), { x1: a + f.x, y1: l + f.y, x2: s3 + f.x, y2: c + f.y, anchorPointX: p, anchorPointY: h };
}
r(jd, "shiftVariableCollisionBox");
var ty = class ty2 {
  constructor(e, t3, i, n, o) {
    this.transform = e.clone(), this.terrain = t3, this.collisionIndex = new Mu(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i, this.retainedQueryData = {}, this.collisionGroups = new Wd(n), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
  }
  getBucketParts(e, t3, i, n) {
    let o = i.getBucket(t3), a = i.latestFeatureIndex;
    if (!o || !a || t3.id !== o.layerIds[0]) return;
    let s3 = i.collisionBoxArray, l = o.layers[0].layout, c = Math.pow(2, this.transform.zoom - i.tileID.overscaledZ), p = i.tileSize / 8192, h = this.transform.calculatePosMatrix(i.tileID.toUnwrapped()), f = l.get("text-pitch-alignment") === "map", m = l.get("text-rotation-alignment") === "map", y = He(i, 1, this.transform.zoom), g = ga(h, f, m, this.transform, y), x = null;
    if (f) {
      let w = Pu(h, f, m, this.transform, y);
      x = $.multiply([], this.transform.labelPlaneMatrix, w);
    }
    this.retainedQueryData[o.bucketInstanceId] = new Hd(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, i.tileID);
    let b = { bucket: o, layout: l, posMatrix: h, textLabelPlaneMatrix: g, labelToScreenMatrix: x, scale: c, textPixelRatio: p, holdingForFade: i.holdingForFade(), collisionBoxArray: s3, partiallyEvaluatedTextSize: mi(o.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) };
    if (n) for (let w of o.sortKeyRanges) {
      let { sortKey: _, symbolInstanceStart: S, symbolInstanceEnd: P } = w;
      e.push({ sortKey: _, symbolInstanceStart: S, symbolInstanceEnd: P, parameters: b });
    }
    else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: b });
  }
  attemptAnchorPlacement(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x) {
    let b = _a[e.textAnchor], w = [e.textOffset0, e.textOffset1], _ = b1(b, i, n, w, o), S = this.collisionIndex.placeCollisionBox(jd(t3, _.x, _.y, a, s3, this.transform.angle), h, l, c, p.predicate, x);
    if (!(g && this.collisionIndex.placeCollisionBox(jd(g, _.x, _.y, a, s3, this.transform.angle), h, l, c, p.predicate, x).box.length === 0) && S.box.length > 0) {
      let P;
      if (this.prevPlacement && this.prevPlacement.variableOffsets[f.crossTileID] && this.prevPlacement.placements[f.crossTileID] && this.prevPlacement.placements[f.crossTileID].text && (P = this.prevPlacement.variableOffsets[f.crossTileID].anchor), f.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      return this.variableOffsets[f.crossTileID] = { textOffset: w, width: i, height: n, anchor: b, textBoxScale: o, prevAnchor: P }, this.markUsedJustification(m, b, f, y), m.allowVerticalPlacement && (this.markUsedOrientation(m, y, f), this.placedOrientations[f.crossTileID] = y), { shift: _, placedGlyphBoxes: S };
    }
  }
  placeLayerBucketPart(e, t3, i) {
    let { bucket: n, layout: o, posMatrix: a, textLabelPlaneMatrix: s3, labelToScreenMatrix: l, textPixelRatio: c, holdingForFade: p, collisionBoxArray: h, partiallyEvaluatedTextSize: f, collisionGroup: m } = e.parameters, y = o.get("text-optional"), g = o.get("icon-optional"), x = fn(o, "text-overlap", "text-allow-overlap"), b = x === "always", w = fn(o, "icon-overlap", "icon-allow-overlap"), _ = w === "always", S = o.get("text-rotation-alignment") === "map", P = o.get("text-pitch-alignment") === "map", T = o.get("icon-text-fit") !== "none", L = o.get("symbol-z-order") === "viewport-y", C = b && (_ || !n.hasIconData() || g), E = _ && (b || !n.hasTextData() || y);
    !n.collisionArrays && h && n.deserializeCollisionBoxes(h);
    let I = this.retainedQueryData[n.bucketInstanceId].tileID, R = this.terrain ? (k, M) => this.terrain.getElevation(I, k, M) : null, z = r((k, M) => {
      var Xt, Kt;
      if (t3[k.crossTileID]) return;
      if (p) {
        this.placements[k.crossTileID] = new Eu(false, false, false);
        return;
      }
      let G = false, K = false, ne = true, J = null, W = { box: null, offscreen: null }, Je = { box: null, offscreen: null }, Ve = null, ce = null, Me = null, Ye = 0, fr = 0, mr = 0;
      M.textFeatureIndex ? Ye = M.textFeatureIndex : k.useRuntimeCollisionCircles && (Ye = k.featureIndex), M.verticalTextFeatureIndex && (fr = M.verticalTextFeatureIndex);
      let zt = M.textBox;
      if (zt) {
        let Qe = r((je) => {
          let ct = 1;
          if (n.allowVerticalPlacement && !je && this.prevPlacement) {
            let Jt = this.prevPlacement.placedOrientations[k.crossTileID];
            Jt && (this.placedOrientations[k.crossTileID] = Jt, ct = Jt, this.markUsedOrientation(n, ct, k));
          }
          return ct;
        }, "updatePreviousOrientationIfNotPlaced"), nt = r((je, ct) => {
          if (n.allowVerticalPlacement && k.numVerticalGlyphVertices > 0 && M.verticalTextBox) {
            for (let Jt of n.writingModes) if (Jt === 2 ? (W = ct(), Je = W) : W = je(), W && W.box && W.box.length) break;
          } else W = je();
        }, "placeTextForPlacementModes"), et = k.textAnchorOffsetStartIndex, Gr = k.textAnchorOffsetEndIndex;
        if (Gr === et) {
          let je = r(($r, Ya) => {
            let tt = this.collisionIndex.placeCollisionBox($r, x, c, a, m.predicate, R);
            return tt && tt.box && tt.box.length && (this.markUsedOrientation(n, Ya, k), this.placedOrientations[k.crossTileID] = Ya), tt;
          }, "placeBox");
          nt(r(() => je(zt, 1), "placeHorizontal"), r(() => {
            let $r = M.verticalTextBox;
            return n.allowVerticalPlacement && k.numVerticalGlyphVertices > 0 && $r ? je($r, 2) : { box: null, offscreen: null };
          }, "placeVertical")), Qe(W && W.box && W.box.length);
        } else {
          let je = _a[(Kt = (Xt = this.prevPlacement) == null ? void 0 : Xt.variableOffsets[k.crossTileID]) == null ? void 0 : Kt.anchor], ct = r((tt, mp, h2) => {
            let f2 = tt.x2 - tt.x1, m2 = tt.y2 - tt.y1, d2 = k.textBoxScale, y2 = T && w === "never" ? mp : null, Ti = { box: [], offscreen: false }, Fx = x === "never" ? 1 : 2, Rx = "never";
            je && Fx++;
            for (let Bx = 0; Bx < Fx; Bx++) {
              for (let dp = et; dp < Gr; dp++) {
                let Ox = n.textAnchorOffsets.get(dp);
                if (je && Ox.textAnchor !== je) continue;
                let yp = this.attemptAnchorPlacement(Ox, tt, f2, m2, d2, S, P, c, a, m, Rx, k, n, h2, y2, R);
                if (yp && (Ti = yp.placedGlyphBoxes, Ti && Ti.box && Ti.box.length)) return G = true, J = yp.shift, Ti;
              }
              je ? je = null : Rx = x;
            }
            return Ti;
          }, "placeBoxForVariableAnchors");
          nt(r(() => ct(zt, M.iconBox, 1), "placeHorizontal"), r(() => {
            let tt = M.verticalTextBox, mp = W && W.box && W.box.length;
            return n.allowVerticalPlacement && !mp && k.numVerticalGlyphVertices > 0 && tt ? ct(tt, M.verticalIconBox, 2) : { box: null, offscreen: null };
          }, "placeVertical")), W && (G = W.box, ne = W.offscreen);
          let Ya = Qe(W && W.box);
          if (!G && this.prevPlacement) {
            let tt = this.prevPlacement.variableOffsets[k.crossTileID];
            tt && (this.variableOffsets[k.crossTileID] = tt, this.markUsedJustification(n, tt.anchor, k, Ya));
          }
        }
      }
      if (Ve = W, G = Ve && Ve.box && Ve.box.length > 0, ne = Ve && Ve.offscreen, k.useRuntimeCollisionCircles) {
        let Qe = n.text.placedSymbolArray.get(k.centerJustifiedTextSymbolIndex), nt = hn(n.textSizeData, f, Qe), et = o.get("text-padding"), Gr = k.collisionCircleDiameter;
        ce = this.collisionIndex.placeCollisionCircles(x, Qe, n.lineVertexArray, n.glyphOffsetArray, nt, a, s3, l, i, P, m.predicate, Gr, et, R), ce.circles.length && ce.collisionDetected && !i && ke("Collisions detected, but collision boxes are not shown"), G = b || ce.circles.length > 0 && !ce.collisionDetected, ne = ne && ce.offscreen;
      }
      if (M.iconFeatureIndex && (mr = M.iconFeatureIndex), M.iconBox) {
        let Qe = r((nt) => {
          let et = T && J ? jd(nt, J.x, J.y, S, P, this.transform.angle) : nt;
          return this.collisionIndex.placeCollisionBox(et, w, c, a, m.predicate, R);
        }, "placeIconFeature");
        Je && Je.box && Je.box.length && M.verticalIconBox ? (Me = Qe(M.verticalIconBox), K = Me.box.length > 0) : (Me = Qe(M.iconBox), K = Me.box.length > 0), ne = ne && Me.offscreen;
      }
      let Wt = y || k.numHorizontalGlyphVertices === 0 && k.numVerticalGlyphVertices === 0, Nr = g || k.numIconVertices === 0;
      if (!Wt && !Nr ? K = G = K && G : Nr ? Wt || (K = K && G) : G = K && G, G && Ve && Ve.box && (Je && Je.box && fr ? this.collisionIndex.insertCollisionBox(Ve.box, x, o.get("text-ignore-placement"), n.bucketInstanceId, fr, m.ID) : this.collisionIndex.insertCollisionBox(Ve.box, x, o.get("text-ignore-placement"), n.bucketInstanceId, Ye, m.ID)), K && Me && this.collisionIndex.insertCollisionBox(Me.box, w, o.get("icon-ignore-placement"), n.bucketInstanceId, mr, m.ID), ce && (G && this.collisionIndex.insertCollisionCircles(ce.circles, x, o.get("text-ignore-placement"), n.bucketInstanceId, Ye, m.ID), i)) {
        let Qe = n.bucketInstanceId, nt = this.collisionCircleArrays[Qe];
        nt === void 0 && (nt = this.collisionCircleArrays[Qe] = new Zd());
        for (let et = 0; et < ce.circles.length; et += 4) nt.circles.push(ce.circles[et + 0]), nt.circles.push(ce.circles[et + 1]), nt.circles.push(ce.circles[et + 2]), nt.circles.push(ce.collisionDetected ? 1 : 0);
      }
      if (k.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      if (n.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
      this.placements[k.crossTileID] = new Eu(G || C, K || E, ne || n.justReloaded), t3[k.crossTileID] = true;
    }, "placeSymbol");
    if (L) {
      if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
      let k = n.getSortedSymbolIndexes(this.transform.angle);
      for (let M = k.length - 1; M >= 0; --M) {
        let G = k[M];
        z(n.symbolInstances.get(G), n.collisionArrays[G]);
      }
    } else for (let k = e.symbolInstanceStart; k < e.symbolInstanceEnd; k++) z(n.symbolInstances.get(k), n.collisionArrays[k]);
    if (i && n.bucketInstanceId in this.collisionCircleArrays) {
      let k = this.collisionCircleArrays[n.bucketInstanceId];
      $.invert(k.invProjMatrix, a), k.viewportMatrix = this.collisionIndex.getViewportMatrix();
    }
    n.justReloaded = false;
  }
  markUsedJustification(e, t3, i, n) {
    let o = { left: i.leftJustifiedTextSymbolIndex, center: i.centerJustifiedTextSymbolIndex, right: i.rightJustifiedTextSymbolIndex }, a;
    n === 2 ? a = i.verticalPlacedTextSymbolIndex : a = o[x1(t3)];
    let s3 = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex, i.verticalPlacedTextSymbolIndex];
    for (let l of s3) l >= 0 && (a >= 0 && l !== a ? e.text.placedSymbolArray.get(l).crossTileID = 0 : e.text.placedSymbolArray.get(l).crossTileID = i.crossTileID);
  }
  markUsedOrientation(e, t3, i) {
    let n = t3 === 1 || t3 === 3 ? t3 : 0, o = t3 === 2 ? t3 : 0, a = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex];
    for (let s3 of a) e.text.placedSymbolArray.get(s3).placedOrientation = n;
    i.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(i.verticalPlacedTextSymbolIndex).placedOrientation = o);
  }
  commit(e) {
    this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
    let t3 = this.prevPlacement, i = false;
    this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
    let n = t3 ? t3.symbolFadeChange(e) : 1, o = t3 ? t3.opacities : {}, a = t3 ? t3.variableOffsets : {}, s3 = t3 ? t3.placedOrientations : {};
    for (let l in this.placements) {
      let c = this.placements[l], p = o[l];
      p ? (this.opacities[l] = new vi(p, n, c.text, c.icon), i = i || c.text !== p.text.placed || c.icon !== p.icon.placed) : (this.opacities[l] = new vi(null, n, c.text, c.icon, c.skipFade), i = i || c.text || c.icon);
    }
    for (let l in o) {
      let c = o[l];
      if (!this.opacities[l]) {
        let p = new vi(c, n, false, false);
        p.isHidden() || (this.opacities[l] = p, i = i || c.text.placed || c.icon.placed);
      }
    }
    for (let l in a) !this.variableOffsets[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.variableOffsets[l] = a[l]);
    for (let l in s3) !this.placedOrientations[l] && this.opacities[l] && !this.opacities[l].isHidden() && (this.placedOrientations[l] = s3[l]);
    if (t3 && t3.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
    i ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e);
  }
  updateLayerOpacities(e, t3) {
    let i = {};
    for (let n of t3) {
      let o = n.getBucket(e);
      o && n.latestFeatureIndex && e.id === o.layerIds[0] && this.updateBucketOpacities(o, i, n.collisionBoxArray);
    }
  }
  updateBucketOpacities(e, t3, i) {
    e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
    let n = e.layers[0], o = n.layout, a = new vi(null, 0, false, false, true), s3 = o.get("text-allow-overlap"), l = o.get("icon-allow-overlap"), c = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset"), p = o.get("text-rotation-alignment") === "map", h = o.get("text-pitch-alignment") === "map", f = o.get("icon-text-fit") !== "none", m = new vi(null, 0, s3 && (l || !e.hasIconData() || o.get("icon-optional")), l && (s3 || !e.hasTextData() || o.get("text-optional")), true);
    !e.collisionArrays && i && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(i);
    let y = r((g, x, b) => {
      for (let w = 0; w < x / 4; w++) g.opacityVertexArray.emplaceBack(b);
      g.hasVisibleVertices = g.hasVisibleVertices || b !== va;
    }, "addOpacities");
    for (let g = 0; g < e.symbolInstances.length; g++) {
      let x = e.symbolInstances.get(g), { numHorizontalGlyphVertices: b, numVerticalGlyphVertices: w, crossTileID: _ } = x, S = t3[_], P = this.opacities[_];
      S ? P = a : P || (P = m, this.opacities[_] = P), t3[_] = true;
      let T = b > 0 || w > 0, L = x.numIconVertices > 0, C = this.placedOrientations[x.crossTileID], E = C === 2, I = C === 1 || C === 3;
      if (T) {
        let R = _1(P.text), z = E ? va : R;
        y(e.text, b, z);
        let k = I ? va : R;
        y(e.text, w, k);
        let M = P.text.isHidden();
        [x.rightJustifiedTextSymbolIndex, x.centerJustifiedTextSymbolIndex, x.leftJustifiedTextSymbolIndex].forEach((ne) => {
          ne >= 0 && (e.text.placedSymbolArray.get(ne).hidden = M || E ? 1 : 0);
        }), x.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(x.verticalPlacedTextSymbolIndex).hidden = M || I ? 1 : 0);
        let G = this.variableOffsets[x.crossTileID];
        G && this.markUsedJustification(e, G.anchor, x, C);
        let K = this.placedOrientations[x.crossTileID];
        K && (this.markUsedJustification(e, "left", x, K), this.markUsedOrientation(e, K, x));
      }
      if (L) {
        let R = _1(P.icon), z = !(f && x.verticalPlacedIconSymbolIndex && E);
        if (x.placedIconSymbolIndex >= 0) {
          let k = z ? R : va;
          y(e.icon, x.numIconVertices, k), e.icon.placedSymbolArray.get(x.placedIconSymbolIndex).hidden = P.icon.isHidden();
        }
        if (x.verticalPlacedIconSymbolIndex >= 0) {
          let k = z ? va : R;
          y(e.icon, x.numVerticalIconVertices, k), e.icon.placedSymbolArray.get(x.verticalPlacedIconSymbolIndex).hidden = P.icon.isHidden();
        }
      }
      if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
        let R = e.collisionArrays[g];
        if (R) {
          let z = new Lu.default(0, 0);
          if (R.textBox || R.verticalTextBox) {
            let M = true;
            if (c) {
              let G = this.variableOffsets[_];
              G ? (z = b1(G.anchor, G.width, G.height, G.textOffset, G.textBoxScale), p && z._rotate(h ? this.transform.angle : -this.transform.angle)) : M = false;
            }
            R.textBox && Iu(e.textCollisionBox.collisionVertexArray, P.text.placed, !M || E, z.x, z.y), R.verticalTextBox && Iu(e.textCollisionBox.collisionVertexArray, P.text.placed, !M || I, z.x, z.y);
          }
          let k = !!(!I && R.verticalIconBox);
          R.iconBox && Iu(e.iconCollisionBox.collisionVertexArray, P.icon.placed, k, f ? z.x : 0, f ? z.y : 0), R.verticalIconBox && Iu(e.iconCollisionBox.collisionVertexArray, P.icon.placed, !k, f ? z.x : 0, f ? z.y : 0);
        }
      }
    }
    if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
    if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
    if (e.bucketInstanceId in this.collisionCircleArrays) {
      let g = this.collisionCircleArrays[e.bucketInstanceId];
      e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
    }
  }
  symbolFadeChange(e) {
    return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
  }
  zoomAdjustment(e) {
    return Math.max(0, (this.transform.zoom - e) / 1.5);
  }
  hasTransitions(e) {
    return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
  }
  stillRecent(e, t3) {
    let i = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
    return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i > e;
  }
  setStale() {
    this.stale = true;
  }
};
r(ty, "Placement");
var ku = ty;
function Iu(r3, e, t3, i, n) {
  r3.emplaceBack(e ? 1 : 0, t3 ? 1 : 0, i || 0, n || 0), r3.emplaceBack(e ? 1 : 0, t3 ? 1 : 0, i || 0, n || 0), r3.emplaceBack(e ? 1 : 0, t3 ? 1 : 0, i || 0, n || 0), r3.emplaceBack(e ? 1 : 0, t3 ? 1 : 0, i || 0, n || 0);
}
r(Iu, "updateCollisionVertices");
var cL = Math.pow(2, 25);
var pL = Math.pow(2, 24);
var hL = Math.pow(2, 17);
var fL = Math.pow(2, 16);
var mL = Math.pow(2, 9);
var dL = Math.pow(2, 8);
var yL = Math.pow(2, 1);
function _1(r3) {
  if (r3.opacity === 0 && !r3.placed) return 0;
  if (r3.opacity === 1 && r3.placed) return 4294967295;
  let e = r3.placed ? 1 : 0, t3 = Math.floor(r3.opacity * 127);
  return t3 * cL + e * pL + t3 * hL + e * fL + t3 * mL + e * dL + t3 * yL + e;
}
r(_1, "packOpacity");
var va = 0;
var iy = class iy2 {
  constructor(e) {
    this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
  }
  continuePlacement(e, t3, i, n, o) {
    let a = this._bucketParts;
    for (; this._currentTileIndex < e.length; ) {
      let s3 = e[this._currentTileIndex];
      if (t3.getBucketParts(a, n, s3, this._sortAcrossTiles), this._currentTileIndex++, o()) return true;
    }
    for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a.sort((s3, l) => s3.sortKey - l.sortKey)); this._currentPartIndex < a.length; ) {
      let s3 = a[this._currentPartIndex];
      if (t3.placeLayerBucketPart(s3, this._seenCrossTileIDs, i), this._currentPartIndex++, o()) return true;
    }
    return false;
  }
};
r(iy, "LayerPlacement");
var ry = iy;
var ny = class ny2 {
  constructor(e, t3, i, n, o, a, s3, l) {
    this.placement = new ku(e, t3, a, s3, l), this._currentPlacementIndex = i.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = o, this._done = false;
  }
  isDone() {
    return this._done;
  }
  continuePlacement(e, t3, i) {
    let n = Y.now(), o = r(() => this._forceFullPlacement ? false : Y.now() - n > 2, "shouldPausePlacement");
    for (; this._currentPlacementIndex >= 0; ) {
      let a = e[this._currentPlacementIndex], s3 = t3[a], l = this.placement.collisionIndex.transform.zoom;
      if (s3.type === "symbol" && (!s3.minzoom || s3.minzoom <= l) && (!s3.maxzoom || s3.maxzoom > l)) {
        if (this._inProgressLayer || (this._inProgressLayer = new ry(s3)), this._inProgressLayer.continuePlacement(i[s3.source], this.placement, this._showCollisionBoxes, s3, o)) return;
        delete this._inProgressLayer;
      }
      this._currentPlacementIndex--;
    }
    this._done = true;
  }
  commit(e) {
    return this.placement.commit(e), this.placement;
  }
};
r(ny, "PauseablePlacement");
var Du = ny;
q();
q();
var v1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var oy = 1;
var wa = 8;
var zu = class zu2 {
  static from(e) {
    if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
    let [t3, i] = new Uint8Array(e, 0, 2);
    if (t3 !== 219) throw new Error("Data does not appear to be in a KDBush format.");
    let n = i >> 4;
    if (n !== oy) throw new Error(`Got v${n} data when expected v${oy}.`);
    let o = v1[i & 15];
    if (!o) throw new Error("Unrecognized array type.");
    let [a] = new Uint16Array(e, 2, 1), [s3] = new Uint32Array(e, 4, 1);
    return new zu2(s3, a, o, e);
  }
  constructor(e, t3 = 64, i = Float64Array, n) {
    if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+t3, 2), 65535), this.ArrayType = i, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    let o = v1.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s3 = e * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s3 % 8) % 8;
    if (o < 0) throw new Error(`Unexpected typed array class: ${i}.`);
    n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, wa, e), this.coords = new this.ArrayType(this.data, wa + s3 + l, e * 2), this._pos = e * 2, this._finished = true) : (this.data = new ArrayBuffer(wa + a + s3 + l), this.ids = new this.IndexArrayType(this.data, wa, e), this.coords = new this.ArrayType(this.data, wa + s3 + l, e * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (oy << 4) + o]), new Uint16Array(this.data, 2, 1)[0] = t3, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  add(e, t3) {
    let i = this._pos >> 1;
    return this.ids[i] = i, this.coords[this._pos++] = e, this.coords[this._pos++] = t3, i;
  }
  finish() {
    let e = this._pos >> 1;
    if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
    return sy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  range(e, t3, i, n) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: o, coords: a, nodeSize: s3 } = this, l = [0, o.length - 1, 0], c = [];
    for (; l.length; ) {
      let p = l.pop() || 0, h = l.pop() || 0, f = l.pop() || 0;
      if (h - f <= s3) {
        for (let x = f; x <= h; x++) {
          let b = a[2 * x], w = a[2 * x + 1];
          b >= e && b <= i && w >= t3 && w <= n && c.push(o[x]);
        }
        continue;
      }
      let m = f + h >> 1, y = a[2 * m], g = a[2 * m + 1];
      y >= e && y <= i && g >= t3 && g <= n && c.push(o[m]), (p === 0 ? e <= y : t3 <= g) && (l.push(f), l.push(m - 1), l.push(1 - p)), (p === 0 ? i >= y : n >= g) && (l.push(m + 1), l.push(h), l.push(1 - p));
    }
    return c;
  }
  within(e, t3, i) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: n, coords: o, nodeSize: a } = this, s3 = [0, n.length - 1, 0], l = [], c = i * i;
    for (; s3.length; ) {
      let p = s3.pop() || 0, h = s3.pop() || 0, f = s3.pop() || 0;
      if (h - f <= a) {
        for (let x = f; x <= h; x++) w1(o[2 * x], o[2 * x + 1], e, t3) <= c && l.push(n[x]);
        continue;
      }
      let m = f + h >> 1, y = o[2 * m], g = o[2 * m + 1];
      w1(y, g, e, t3) <= c && l.push(n[m]), (p === 0 ? e - i <= y : t3 - i <= g) && (s3.push(f), s3.push(m - 1), s3.push(1 - p)), (p === 0 ? e + i >= y : t3 + i >= g) && (s3.push(m + 1), s3.push(h), s3.push(1 - p));
    }
    return l;
  }
};
r(zu, "KDBush");
var Pa = zu;
function sy(r3, e, t3, i, n, o) {
  if (n - i <= t3) return;
  let a = i + n >> 1;
  S1(r3, e, a, i, n, o), sy(r3, e, t3, i, a - 1, 1 - o), sy(r3, e, t3, a + 1, n, 1 - o);
}
r(sy, "sort");
function S1(r3, e, t3, i, n, o) {
  for (; n > i; ) {
    if (n - i > 600) {
      let c = n - i + 1, p = t3 - i + 1, h = Math.log(c), f = 0.5 * Math.exp(2 * h / 3), m = 0.5 * Math.sqrt(h * f * (c - f) / c) * (p - c / 2 < 0 ? -1 : 1), y = Math.max(i, Math.floor(t3 - p * f / c + m)), g = Math.min(n, Math.floor(t3 + (c - p) * f / c + m));
      S1(r3, e, t3, y, g, o);
    }
    let a = e[2 * t3 + o], s3 = i, l = n;
    for (Sa(r3, e, i, t3), e[2 * n + o] > a && Sa(r3, e, i, n); s3 < l; ) {
      for (Sa(r3, e, s3, l), s3++, l--; e[2 * s3 + o] < a; ) s3++;
      for (; e[2 * l + o] > a; ) l--;
    }
    e[2 * i + o] === a ? Sa(r3, e, i, l) : (l++, Sa(r3, e, l, n)), l <= t3 && (i = l + 1), t3 <= l && (n = l - 1);
  }
}
r(S1, "select");
function Sa(r3, e, t3, i) {
  ay(r3, t3, i), ay(e, 2 * t3, 2 * i), ay(e, 2 * t3 + 1, 2 * i + 1);
}
r(Sa, "swapItem");
function ay(r3, e, t3) {
  let i = r3[e];
  r3[e] = r3[t3], r3[t3] = i;
}
r(ay, "swap");
function w1(r3, e, t3, i) {
  let n = r3 - t3, o = e - i;
  return n * n + o * o;
}
r(w1, "sqDist");
var Ta = 512 / 8192 / 2;
var gL = 128;
var py = class py2 {
  constructor(e, t3, i) {
    this.tileID = e;
    this.bucketInstanceId = i;
    this._symbolsByKey = {};
    let n = /* @__PURE__ */ new Map();
    for (let o = 0; o < t3.length; o++) {
      let a = t3.get(o), s3 = a.key, l = n.get(s3);
      l ? l.push(a) : n.set(s3, [a]);
    }
    for (let [o, a] of n) {
      let s3 = a.map((p) => ({ x: Math.floor(p.anchorX * Ta), y: Math.floor(p.anchorY * Ta) })), l = a.map((p) => p.crossTileID), c = { positions: s3, crossTileIDs: l };
      if (c.positions.length > gL) {
        let p = new Pa(c.positions.length, 16, Uint16Array);
        for (let { x: h, y: f } of c.positions) p.add(h, f);
        p.finish(), delete c.positions, c.index = p;
      }
      this._symbolsByKey[o] = c;
    }
  }
  getScaledCoordinates(e, t3) {
    let { x: i, y: n, z: o } = this.tileID.canonical, { x: a, y: s3, z: l } = t3.canonical, c = l - o, p = Ta / Math.pow(2, c), h = (a * 8192 + e.anchorX) * p, f = (s3 * 8192 + e.anchorY) * p, m = i * 8192 * Ta, y = n * 8192 * Ta;
    return { x: Math.floor(h - m), y: Math.floor(f - y) };
  }
  findMatches(e, t3, i) {
    let n = this.tileID.canonical.z < t3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t3.canonical.z);
    for (let o = 0; o < e.length; o++) {
      let a = e.get(o);
      if (a.crossTileID) continue;
      let s3 = this._symbolsByKey[a.key];
      if (!s3) continue;
      let l = this.getScaledCoordinates(a, t3);
      if (s3.index) {
        let c = s3.index.range(l.x - n, l.y - n, l.x + n, l.y + n).sort();
        for (let p of c) {
          let h = s3.crossTileIDs[p];
          if (!i[h]) {
            i[h] = true, a.crossTileID = h;
            break;
          }
        }
      } else if (s3.positions) for (let c = 0; c < s3.positions.length; c++) {
        let p = s3.positions[c], h = s3.crossTileIDs[c];
        if (Math.abs(p.x - l.x) <= n && Math.abs(p.y - l.y) <= n && !i[h]) {
          i[h] = true, a.crossTileID = h;
          break;
        }
      }
    }
  }
  getCrossTileIDsLists() {
    return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
  }
};
r(py, "TileLayerIndex");
var ly = py;
var hy = class hy2 {
  constructor() {
    this.maxCrossTileID = 0;
  }
  generate() {
    return ++this.maxCrossTileID;
  }
};
r(hy, "CrossTileIDs");
var uy = hy;
var fy = class fy2 {
  constructor() {
    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
  }
  handleWrapJump(e) {
    let t3 = Math.round((e - this.lng) / 360);
    if (t3 !== 0) for (let i in this.indexes) {
      let n = this.indexes[i], o = {};
      for (let a in n) {
        let s3 = n[a];
        s3.tileID = s3.tileID.unwrapTo(s3.tileID.wrap + t3), o[s3.tileID.key] = s3;
      }
      this.indexes[i] = o;
    }
    this.lng = e;
  }
  addBucket(e, t3, i) {
    if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
      if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t3.bucketInstanceId) return false;
      this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
    }
    for (let o = 0; o < t3.symbolInstances.length; o++) {
      let a = t3.symbolInstances.get(o);
      a.crossTileID = 0;
    }
    this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
    let n = this.usedCrossTileIDs[e.overscaledZ];
    for (let o in this.indexes) {
      let a = this.indexes[o];
      if (Number(o) > e.overscaledZ) for (let s3 in a) {
        let l = a[s3];
        l.tileID.isChildOf(e) && l.findMatches(t3.symbolInstances, e, n);
      }
      else {
        let s3 = e.scaledTo(Number(o)), l = a[s3.key];
        l && l.findMatches(t3.symbolInstances, e, n);
      }
    }
    for (let o = 0; o < t3.symbolInstances.length; o++) {
      let a = t3.symbolInstances.get(o);
      a.crossTileID || (a.crossTileID = i.generate(), n[a.crossTileID] = true);
    }
    return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new ly(e, t3.symbolInstances, t3.bucketInstanceId), true;
  }
  removeBucketCrossTileIDs(e, t3) {
    for (let i of t3.getCrossTileIDsLists()) for (let n of i) delete this.usedCrossTileIDs[e][n];
  }
  removeStaleBuckets(e) {
    let t3 = false;
    for (let i in this.indexes) {
      let n = this.indexes[i];
      for (let o in n) e[n[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, n[o]), delete n[o], t3 = true);
    }
    return t3;
  }
};
r(fy, "CrossTileSymbolLayerIndex");
var cy = fy;
var my = class my2 {
  constructor() {
    this.layerIndexes = {}, this.crossTileIDs = new uy(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
  }
  addLayer(e, t3, i) {
    let n = this.layerIndexes[e.id];
    n === void 0 && (n = this.layerIndexes[e.id] = new cy());
    let o = false, a = {};
    n.handleWrapJump(i);
    for (let s3 of t3) {
      let l = s3.getBucket(e);
      !l || e.id !== l.layerIds[0] || (l.bucketInstanceId || (l.bucketInstanceId = ++this.maxBucketInstanceId), n.addBucket(s3.tileID, l, this.crossTileIDs) && (o = true), a[l.bucketInstanceId] = true);
    }
    return n.removeStaleBuckets(a) && (o = true), o;
  }
  pruneUnusedLayers(e) {
    let t3 = {};
    e.forEach((i) => {
      t3[i] = true;
    });
    for (let i in this.layerIndexes) t3[i] || delete this.layerIndexes[i];
  }
};
r(my, "CrossTileSymbolIndex");
var vn = my;
var Fu = r((r3, e) => ji(r3, e && e.filter((t3) => t3.identifier !== "source.canvas")), "emitValidationErrors");
var xL = o_();
var dy = class dy2 extends de {
  constructor(t3, i = {}) {
    super();
    this._rtlPluginLoaded = () => {
      for (let t4 in this.sourceCaches) {
        let i3 = this.sourceCaches[t4].getSource().type;
        (i3 === "vector" || i3 === "geojson") && this.sourceCaches[t4].reload();
      }
    };
    this.map = t3, this.dispatcher = new sa(aa(), t3._getMapId()), this.dispatcher.registerMessageHandler("GG", (n, o) => this.getGlyphs(n, o)), this.dispatcher.registerMessageHandler("GI", (n, o) => this.getImages(n, o)), this.imageManager = new ou(), this.imageManager.setEventedParent(this), this.glyphManager = new au(t3._requestManager, i.localIdeographFontFamily), this.lineAtlas = new lu(256, 512), this.crossTileSymbolIndex = new vn(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new Wi(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", ss()), Or().on(da, this._rtlPluginLoaded), this.on("data", (n) => {
      if (n.dataType !== "source" || n.sourceDataType !== "metadata") return;
      let o = this.sourceCaches[n.sourceId];
      if (!o) return;
      let a = o.getSource();
      if (!(!a || !a.vectorLayerIds)) for (let s3 in this._layers) {
        let l = this._layers[s3];
        l.source === a.id && this._validateLayer(l);
      }
    });
  }
  loadURL(t3, i = {}, n) {
    this.fire(new F("dataloading", { dataType: "style" })), i.validate = typeof i.validate == "boolean" ? i.validate : true;
    let o = this.map._requestManager.transformRequest(t3, "Style");
    this._loadStyleRequest = new AbortController(), yr(o, this._loadStyleRequest).then((a) => {
      this._loadStyleRequest = null, this._load(a.data, i, n);
    }).catch((a) => {
      this._loadStyleRequest = null, a && this.fire(new Z(a));
    });
  }
  loadJSON(t3, i = {}, n) {
    this.fire(new F("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), Y.frameAsync(this._frameRequest).then(() => {
      this._frameRequest = null, i.validate = i.validate !== false, this._load(t3, i, n);
    }).catch(() => {
    });
  }
  loadEmpty() {
    this.fire(new F("dataloading", { dataType: "style" })), this._load(xL, { validate: false });
  }
  _load(t3, i, n) {
    var a;
    let o = i.transformStyle ? i.transformStyle(n, t3) : t3;
    if (!(i.validate && Fu(this, Ne(o)))) {
      this._loaded = true, this.stylesheet = o;
      for (let s3 in o.sources) this.addSource(s3, o.sources[s3], { validate: false });
      o.sprite ? this._loadSprite(o.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o.glyphs), this._createLayers(), this.light = new su(this.stylesheet.light), this.map.setTerrain((a = this.stylesheet.terrain) != null ? a : null), this.fire(new F("data", { dataType: "style" })), this.fire(new F("style.load"));
    }
  }
  _createLayers() {
    let t3 = eh(this.stylesheet.layers);
    this.dispatcher.broadcast("SL", t3), this._order = t3.map((i) => i.id), this._layers = {}, this._serializedLayers = null;
    for (let i of t3) {
      let n = iu(i);
      n.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = n;
    }
  }
  _loadSprite(t3, i = false, n = void 0) {
    this.imageManager.setLoaded(false), this._spriteRequest = new AbortController();
    let o;
    U0(t3, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((a) => {
      if (this._spriteRequest = null, a) for (let s3 in a) {
        this._spritesImagesIds[s3] = [];
        let l = this._spritesImagesIds[s3] ? this._spritesImagesIds[s3].filter((c) => !(c in a)) : [];
        for (let c of l) this.imageManager.removeImage(c), this._changedImages[c] = true;
        for (let c in a[s3]) {
          let p = s3 === "default" ? c : `${s3}:${c}`;
          this._spritesImagesIds[s3].push(p), p in this.imageManager.images ? this.imageManager.updateImage(p, a[s3][c], false) : this.imageManager.addImage(p, a[s3][c]), i && (this._changedImages[p] = true);
        }
      }
    }).catch((a) => {
      this._spriteRequest = null, o = a, this.fire(new Z(o));
    }).finally(() => {
      this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" })), n && n(o);
    });
  }
  _unloadSprite() {
    for (let t3 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t3), this._changedImages[t3] = true;
    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  _validateLayer(t3) {
    let i = this.sourceCaches[t3.source];
    if (!i) return;
    let n = t3.sourceLayer;
    if (!n) return;
    let o = i.getSource();
    (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(n) === -1) && this.fire(new Z(new Error(`Source layer "${n}" does not exist on source "${o.id}" as specified by style layer "${t3.id}".`)));
  }
  loaded() {
    if (!this._loaded || Object.keys(this._updatedSources).length) return false;
    for (let t3 in this.sourceCaches) if (!this.sourceCaches[t3].loaded()) return false;
    return !!this.imageManager.isLoaded();
  }
  _serializeByIds(t3) {
    let i = this._serializedAllLayers();
    if (!t3 || t3.length === 0) return Object.values(i);
    let n = [];
    for (let o of t3) i[o] && n.push(i[o]);
    return n;
  }
  _serializedAllLayers() {
    let t3 = this._serializedLayers;
    if (t3) return t3;
    t3 = this._serializedLayers = {};
    let i = Object.keys(this._layers);
    for (let n of i) {
      let o = this._layers[n];
      o.type !== "custom" && (t3[n] = o.serialize());
    }
    return t3;
  }
  hasTransitions() {
    if (this.light && this.light.hasTransition()) return true;
    for (let t3 in this.sourceCaches) if (this.sourceCaches[t3].hasTransition()) return true;
    for (let t3 in this._layers) if (this._layers[t3].hasTransition()) return true;
    return false;
  }
  _checkLoaded() {
    if (!this._loaded) throw new Error("Style is not done loading.");
  }
  update(t3) {
    if (!this._loaded) return;
    let i = this._changed;
    if (i) {
      let o = Object.keys(this._updatedLayers), a = Object.keys(this._removedLayers);
      (o.length || a.length) && this._updateWorkerLayers(o, a);
      for (let s3 in this._updatedSources) {
        let l = this._updatedSources[s3];
        if (l === "reload") this._reloadSource(s3);
        else if (l === "clear") this._clearSource(s3);
        else throw new Error(`Invalid action ${l}`);
      }
      this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
      for (let s3 in this._updatedPaintProps) this._layers[s3].updateTransitions(t3);
      this.light.updateTransitions(t3), this._resetUpdates();
    }
    let n = {};
    for (let o in this.sourceCaches) {
      let a = this.sourceCaches[o];
      n[o] = a.used, a.used = false;
    }
    for (let o of this._order) {
      let a = this._layers[o];
      a.recalculate(t3, this._availableImages), !a.isHidden(t3.zoom) && a.source && (this.sourceCaches[a.source].used = true);
    }
    for (let o in n) {
      let a = this.sourceCaches[o];
      !!n[o] != !!a.used && a.fire(new F("data", { sourceDataType: "visibility", dataType: "source", sourceId: o }));
    }
    this.light.recalculate(t3), this.z = t3.zoom, i && this.fire(new F("data", { dataType: "style" }));
  }
  _updateTilesForChangedImages() {
    let t3 = Object.keys(this._changedImages);
    if (t3.length) {
      for (let i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], t3);
      this._changedImages = {};
    }
  }
  _updateTilesForChangedGlyphs() {
    if (this._glyphsDidChange) {
      for (let t3 in this.sourceCaches) this.sourceCaches[t3].reloadTilesForDependencies(["glyphs"], [""]);
      this._glyphsDidChange = false;
    }
  }
  _updateWorkerLayers(t3, i) {
    this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t3), removedIds: i });
  }
  _resetUpdates() {
    this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
  }
  setState(t3, i = {}) {
    var l;
    this._checkLoaded();
    let n = this.serialize();
    if (t3 = i.transformStyle ? i.transformStyle(n, t3) : t3, ((l = i.validate) != null ? l : true) && Fu(this, Ne(t3))) return false;
    t3 = pt(t3), t3.layers = eh(t3.layers);
    let a = Bb(n, t3), s3 = this._getOperationsToPerform(a);
    if (s3.unimplemented.length > 0) throw new Error(`Unimplemented: ${s3.unimplemented.join(", ")}.`);
    if (s3.operations.length === 0) return false;
    for (let c of s3.operations) c();
    return this.stylesheet = t3, this._serializedLayers = null, true;
  }
  _getOperationsToPerform(t3) {
    let i = [], n = [];
    for (let o of t3) switch (o.command) {
      case "setCenter":
      case "setZoom":
      case "setBearing":
      case "setPitch":
        continue;
      case "addLayer":
        i.push(() => this.addLayer.apply(this, o.args));
        break;
      case "removeLayer":
        i.push(() => this.removeLayer.apply(this, o.args));
        break;
      case "setPaintProperty":
        i.push(() => this.setPaintProperty.apply(this, o.args));
        break;
      case "setLayoutProperty":
        i.push(() => this.setLayoutProperty.apply(this, o.args));
        break;
      case "setFilter":
        i.push(() => this.setFilter.apply(this, o.args));
        break;
      case "addSource":
        i.push(() => this.addSource.apply(this, o.args));
        break;
      case "removeSource":
        i.push(() => this.removeSource.apply(this, o.args));
        break;
      case "setLayerZoomRange":
        i.push(() => this.setLayerZoomRange.apply(this, o.args));
        break;
      case "setLight":
        i.push(() => this.setLight.apply(this, o.args));
        break;
      case "setGeoJSONSourceData":
        i.push(() => this.setGeoJSONSourceData.apply(this, o.args));
        break;
      case "setGlyphs":
        i.push(() => this.setGlyphs.apply(this, o.args));
        break;
      case "setSprite":
        i.push(() => this.setSprite.apply(this, o.args));
        break;
      case "setTerrain":
        i.push(() => this.map.setTerrain.apply(this, o.args));
        break;
      case "setTransition":
        i.push(() => {
        });
        break;
      default:
        n.push(o.command);
        break;
    }
    return { operations: i, unimplemented: n };
  }
  addImage(t3, i) {
    if (this.getImage(t3)) return this.fire(new Z(new Error(`An image named "${t3}" already exists.`)));
    this.imageManager.addImage(t3, i), this._afterImageUpdated(t3);
  }
  updateImage(t3, i) {
    this.imageManager.updateImage(t3, i);
  }
  getImage(t3) {
    return this.imageManager.getImage(t3);
  }
  removeImage(t3) {
    if (!this.getImage(t3)) return this.fire(new Z(new Error(`An image named "${t3}" does not exist.`)));
    this.imageManager.removeImage(t3), this._afterImageUpdated(t3);
  }
  _afterImageUpdated(t3) {
    this._availableImages = this.imageManager.listImages(), this._changedImages[t3] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  listImages() {
    return this._checkLoaded(), this.imageManager.listImages();
  }
  addSource(t3, i, n = {}) {
    if (this._checkLoaded(), this.sourceCaches[t3] !== void 0) throw new Error(`Source "${t3}" already exists.`);
    if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
    if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(Ne.source, `sources.${t3}`, i, null, n)) return;
    this.map && this.map._collectResourceTiming && (i.collectResourceTiming = true);
    let s3 = this.sourceCaches[t3] = new ur(t3, i, this.dispatcher);
    s3.style = this, s3.setEventedParent(this, () => ({ isSourceLoaded: s3.loaded(), source: s3.serialize(), sourceId: t3 })), s3.onAdd(this.map), this._changed = true;
  }
  removeSource(t3) {
    if (this._checkLoaded(), this.sourceCaches[t3] === void 0) throw new Error("There is no source with this ID");
    for (let n in this._layers) if (this._layers[n].source === t3) return this.fire(new Z(new Error(`Source "${t3}" cannot be removed while layer "${n}" is using it.`)));
    let i = this.sourceCaches[t3];
    delete this.sourceCaches[t3], delete this._updatedSources[t3], i.fire(new F("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3 })), i.setEventedParent(null), i.onRemove(this.map), this._changed = true;
  }
  setGeoJSONSourceData(t3, i) {
    if (this._checkLoaded(), this.sourceCaches[t3] === void 0) throw new Error(`There is no source with this ID=${t3}`);
    let n = this.sourceCaches[t3].getSource();
    if (n.type !== "geojson") throw new Error(`geojsonSource.type is ${n.type}, which is !== 'geojson`);
    n.setData(i), this._changed = true;
  }
  getSource(t3) {
    return this.sourceCaches[t3] && this.sourceCaches[t3].getSource();
  }
  addLayer(t3, i, n = {}) {
    this._checkLoaded();
    let o = t3.id;
    if (this.getLayer(o)) {
      this.fire(new Z(new Error(`Layer "${o}" already exists on this map.`)));
      return;
    }
    let a;
    if (t3.type === "custom") {
      if (Fu(this, V0(t3))) return;
      a = iu(t3);
    } else {
      if ("source" in t3 && typeof t3.source == "object" && (this.addSource(o, t3.source), t3 = pt(t3), t3 = V(t3, { source: o })), this._validate(Ne.layer, `layers.${o}`, t3, { arrayIndex: -1 }, n)) return;
      a = iu(t3), this._validateLayer(a), a.setEventedParent(this, { layer: { id: o } });
    }
    let s3 = i ? this._order.indexOf(i) : this._order.length;
    if (i && s3 === -1) {
      this.fire(new Z(new Error(`Cannot add layer "${o}" before non-existing layer "${i}".`)));
      return;
    }
    if (this._order.splice(s3, 0, o), this._layerOrderChanged = true, this._layers[o] = a, this._removedLayers[o] && a.source && a.type !== "custom") {
      let l = this._removedLayers[o];
      delete this._removedLayers[o], l.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());
    }
    this._updateLayer(a), a.onAdd && a.onAdd(this.map);
  }
  moveLayer(t3, i) {
    if (this._checkLoaded(), this._changed = true, !this._layers[t3]) {
      this.fire(new Z(new Error(`The layer '${t3}' does not exist in the map's style and cannot be moved.`)));
      return;
    }
    if (t3 === i) return;
    let o = this._order.indexOf(t3);
    this._order.splice(o, 1);
    let a = i ? this._order.indexOf(i) : this._order.length;
    if (i && a === -1) {
      this.fire(new Z(new Error(`Cannot move layer "${t3}" before non-existing layer "${i}".`)));
      return;
    }
    this._order.splice(a, 0, t3), this._layerOrderChanged = true;
  }
  removeLayer(t3) {
    this._checkLoaded();
    let i = this._layers[t3];
    if (!i) {
      this.fire(new Z(new Error(`Cannot remove non-existing layer "${t3}".`)));
      return;
    }
    i.setEventedParent(null);
    let n = this._order.indexOf(t3);
    this._order.splice(n, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t3] = i, delete this._layers[t3], this._serializedLayers && delete this._serializedLayers[t3], delete this._updatedLayers[t3], delete this._updatedPaintProps[t3], i.onRemove && i.onRemove(this.map);
  }
  getLayer(t3) {
    return this._layers[t3];
  }
  getLayersOrder() {
    return [...this._order];
  }
  hasLayer(t3) {
    return t3 in this._layers;
  }
  setLayerZoomRange(t3, i, n) {
    this._checkLoaded();
    let o = this.getLayer(t3);
    if (!o) {
      this.fire(new Z(new Error(`Cannot set the zoom range of non-existing layer "${t3}".`)));
      return;
    }
    o.minzoom === i && o.maxzoom === n || (i != null && (o.minzoom = i), n != null && (o.maxzoom = n), this._updateLayer(o));
  }
  setFilter(t3, i, n = {}) {
    this._checkLoaded();
    let o = this.getLayer(t3);
    if (!o) {
      this.fire(new Z(new Error(`Cannot filter non-existing layer "${t3}".`)));
      return;
    }
    if (!Yt(o.filter, i)) {
      if (i == null) {
        o.filter = void 0, this._updateLayer(o);
        return;
      }
      this._validate(Ne.filter, `layers.${o.id}.filter`, i, null, n) || (o.filter = pt(i), this._updateLayer(o));
    }
  }
  getFilter(t3) {
    return pt(this.getLayer(t3).filter);
  }
  setLayoutProperty(t3, i, n, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(t3);
    if (!a) {
      this.fire(new Z(new Error(`Cannot style non-existing layer "${t3}".`)));
      return;
    }
    Yt(a.getLayoutProperty(i), n) || (a.setLayoutProperty(i, n, o), this._updateLayer(a));
  }
  getLayoutProperty(t3, i) {
    let n = this.getLayer(t3);
    if (!n) {
      this.fire(new Z(new Error(`Cannot get style of non-existing layer "${t3}".`)));
      return;
    }
    return n.getLayoutProperty(i);
  }
  setPaintProperty(t3, i, n, o = {}) {
    this._checkLoaded();
    let a = this.getLayer(t3);
    if (!a) {
      this.fire(new Z(new Error(`Cannot style non-existing layer "${t3}".`)));
      return;
    }
    if (Yt(a.getPaintProperty(i), n)) return;
    a.setPaintProperty(i, n, o) && this._updateLayer(a), this._changed = true, this._updatedPaintProps[t3] = true, this._serializedLayers = null;
  }
  getPaintProperty(t3, i) {
    return this.getLayer(t3).getPaintProperty(i);
  }
  setFeatureState(t3, i) {
    this._checkLoaded();
    let n = t3.source, o = t3.sourceLayer, a = this.sourceCaches[n];
    if (a === void 0) {
      this.fire(new Z(new Error(`The source '${n}' does not exist in the map's style.`)));
      return;
    }
    let s3 = a.getSource().type;
    if (s3 === "geojson" && o) {
      this.fire(new Z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
      return;
    }
    if (s3 === "vector" && !o) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    t3.id === void 0 && this.fire(new Z(new Error("The feature id parameter must be provided."))), a.setFeatureState(o, t3.id, i);
  }
  removeFeatureState(t3, i) {
    this._checkLoaded();
    let n = t3.source, o = this.sourceCaches[n];
    if (o === void 0) {
      this.fire(new Z(new Error(`The source '${n}' does not exist in the map's style.`)));
      return;
    }
    let a = o.getSource().type, s3 = a === "vector" ? t3.sourceLayer : void 0;
    if (a === "vector" && !s3) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    if (i && typeof t3.id != "string" && typeof t3.id != "number") {
      this.fire(new Z(new Error("A feature id is required to remove its specific state property.")));
      return;
    }
    o.removeFeatureState(s3, t3.id, i);
  }
  getFeatureState(t3) {
    this._checkLoaded();
    let i = t3.source, n = t3.sourceLayer, o = this.sourceCaches[i];
    if (o === void 0) {
      this.fire(new Z(new Error(`The source '${i}' does not exist in the map's style.`)));
      return;
    }
    if (o.getSource().type === "vector" && !n) {
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    return t3.id === void 0 && this.fire(new Z(new Error("The feature id parameter must be provided."))), o.getFeatureState(n, t3.id);
  }
  getTransition() {
    return V({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
  }
  serialize() {
    if (!this._loaded) return;
    let t3 = En(this.sourceCaches, (a) => a.serialize()), i = this._serializeByIds(this._order), n = this.map.getTerrain() || void 0, o = this.stylesheet;
    return is({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, sources: t3, layers: i, terrain: n }, (a) => a !== void 0);
  }
  _updateLayer(t3) {
    this._updatedLayers[t3.id] = true, t3.source && !this._updatedSources[t3.source] && this.sourceCaches[t3.source].getSource().type !== "raster" && (this._updatedSources[t3.source] = "reload", this.sourceCaches[t3.source].pause()), this._serializedLayers = null, this._changed = true;
  }
  _flattenAndSortRenderedFeatures(t3) {
    let i = r((s3) => this._layers[s3].type === "fill-extrusion", "isLayer3D"), n = {}, o = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (i(l)) {
        n[l] = s3;
        for (let c of t3) {
          let p = c[l];
          if (p) for (let h of p) o.push(h);
        }
      }
    }
    o.sort((s3, l) => l.intersectionZ - s3.intersectionZ);
    let a = [];
    for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
      let l = this._order[s3];
      if (i(l)) for (let c = o.length - 1; c >= 0; c--) {
        let p = o[c].feature;
        if (n[p.layer.id] < s3) break;
        a.push(p), o.pop();
      }
      else for (let c of t3) {
        let p = c[l];
        if (p) for (let h of p) a.push(h.feature);
      }
    }
    return a;
  }
  queryRenderedFeatures(t3, i, n) {
    i && i.filter && this._validate(Ne.filter, "queryRenderedFeatures.filter", i.filter, null, i);
    let o = {};
    if (i && i.layers) {
      if (!Array.isArray(i.layers)) return this.fire(new Z(new Error("parameters.layers must be an Array."))), [];
      for (let l of i.layers) {
        let c = this._layers[l];
        if (!c) return this.fire(new Z(new Error(`The layer '${l}' does not exist in the map's style and cannot be queried for features.`))), [];
        o[c.source] = true;
      }
    }
    let a = [];
    i.availableImages = this._availableImages;
    let s3 = this._serializedAllLayers();
    for (let l in this.sourceCaches) i.layers && !o[l] || a.push(W0(this.sourceCaches[l], this._layers, s3, t3, i, n));
    return this.placement && a.push(X0(this._layers, s3, this.sourceCaches, t3, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
  }
  querySourceFeatures(t3, i) {
    i && i.filter && this._validate(Ne.filter, "querySourceFeatures.filter", i.filter, null, i);
    let n = this.sourceCaches[t3];
    return n ? K0(n, i) : [];
  }
  getLight() {
    return this.light.getLight();
  }
  setLight(t3, i = {}) {
    this._checkLoaded();
    let n = this.light.getLight(), o = false;
    for (let s3 in t3) if (!Yt(t3[s3], n[s3])) {
      o = true;
      break;
    }
    if (!o) return;
    let a = { now: Y.now(), transition: V({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.light.setLight(t3, i), this.light.updateTransitions(a);
  }
  _validate(t3, i, n, o, a = {}) {
    return a && a.validate === false ? false : Fu(this, t3.call(Ne, V({ key: i, style: this.serialize(), value: n, styleSpec: A }, o)));
  }
  _remove(t3 = true) {
    this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Or().off(da, this._rtlPluginLoaded);
    for (let i in this._layers) this._layers[i].setEventedParent(null);
    for (let i in this.sourceCaches) {
      let n = this.sourceCaches[i];
      n.setEventedParent(null), n.onRemove(this.map);
    }
    this.imageManager.setEventedParent(null), this.setEventedParent(null), t3 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t3);
  }
  _clearSource(t3) {
    this.sourceCaches[t3].clearTiles();
  }
  _reloadSource(t3) {
    this.sourceCaches[t3].resume(), this.sourceCaches[t3].reload();
  }
  _updateSources(t3) {
    for (let i in this.sourceCaches) this.sourceCaches[i].update(t3, this.map.terrain);
  }
  _generateCollisionBoxes() {
    for (let t3 in this.sourceCaches) this._reloadSource(t3);
  }
  _updatePlacement(t3, i, n, o, a = false) {
    let s3 = false, l = false, c = {};
    for (let h of this._order) {
      let f = this._layers[h];
      if (f.type !== "symbol") continue;
      if (!c[f.source]) {
        let y = this.sourceCaches[f.source];
        c[f.source] = y.getRenderableIds(true).map((g) => y.getTileByID(g)).sort((g, x) => x.tileID.overscaledZ - g.tileID.overscaledZ || (g.tileID.isLessThan(x.tileID) ? -1 : 1));
      }
      let m = this.crossTileSymbolIndex.addLayer(f, c[f.source], t3.center.lng);
      s3 = s3 || m;
    }
    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), a = a || this._layerOrderChanged || n === 0, (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Y.now(), t3.zoom)) && (this.pauseablePlacement = new Du(t3, this.map.terrain, this._order, a, i, n, o, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, c), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Y.now()), l = true), s3 && this.pauseablePlacement.placement.setStale()), l || s3) for (let h of this._order) {
      let f = this._layers[h];
      f.type === "symbol" && this.placement.updateLayerOpacities(f, c[f.source]);
    }
    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Y.now());
  }
  _releaseSymbolFadeTiles() {
    for (let t3 in this.sourceCaches) this.sourceCaches[t3].releaseSymbolFadeTiles();
  }
  async getImages(t3, i) {
    let n = await this.imageManager.getImages(i.icons);
    this._updateTilesForChangedImages();
    let o = this.sourceCaches[i.source];
    return o && o.setDependencies(i.tileID.key, i.type, i.icons), n;
  }
  async getGlyphs(t3, i) {
    let n = await this.glyphManager.getGlyphs(i.stacks), o = this.sourceCaches[i.source];
    return o && o.setDependencies(i.tileID.key, i.type, [""]), n;
  }
  getGlyphsUrl() {
    return this.stylesheet.glyphs || null;
  }
  setGlyphs(t3, i = {}) {
    this._checkLoaded(), !(t3 && this._validate(Ne.glyphs, "glyphs", t3, null, i)) && (this._glyphsDidChange = true, this.stylesheet.glyphs = t3, this.glyphManager.entries = {}, this.glyphManager.setURL(t3));
  }
  addSprite(t3, i, n = {}, o) {
    this._checkLoaded();
    let a = [{ id: t3, url: i }], s3 = [...mn(this.stylesheet.sprite), ...a];
    this._validate(Ne.sprite, "sprite", s3, null, n) || (this.stylesheet.sprite = s3, this._loadSprite(a, true, o));
  }
  removeSprite(t3) {
    this._checkLoaded();
    let i = mn(this.stylesheet.sprite);
    if (!i.find((n) => n.id === t3)) {
      this.fire(new Z(new Error(`Sprite "${t3}" doesn't exists on this map.`)));
      return;
    }
    if (this._spritesImagesIds[t3]) for (let n of this._spritesImagesIds[t3]) this.imageManager.removeImage(n), this._changedImages[n] = true;
    i.splice(i.findIndex((n) => n.id === t3), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[t3], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  getSprite() {
    return mn(this.stylesheet.sprite);
  }
  setSprite(t3, i = {}, n) {
    this._checkLoaded(), !(t3 && this._validate(Ne.sprite, "sprite", t3, null, i)) && (this.stylesheet.sprite = t3, t3 ? this._loadSprite(t3, true, n) : (this._unloadSprite(), n && n(null)));
  }
};
r(dy, "Style");
var wn = dy;
q();
q();
var Ru = _e([{ name: "a_pos", type: "Int16", components: 2 }]);
q();
q();
var P1 = `#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`;
q();
var T1 = `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`;
q();
var M1 = `uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var A1 = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
q();
var I1 = `uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var C1 = "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";
q();
var E1 = `varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var k1 = `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`;
q();
var L1 = "void main() {gl_FragColor=vec4(1.0);}";
q();
var D1 = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
q();
var z1 = `uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var F1 = `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`;
q();
var R1 = `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`;
q();
var B1 = "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";
q();
var O1 = "varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}";
q();
var V1 = "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}";
q();
var U1 = "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}";
q();
var N1 = "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";
q();
var G1 = "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}";
q();
var $1 = "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}";
q();
var q1 = `#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var j1 = `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`;
q();
var Z1 = `varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var H1 = `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`;
q();
var W1 = `uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var X1 = `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`;
q();
var K1 = `#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var J1 = `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`;
q();
var Y1 = `varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var Q1 = `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`;
q();
var ew = `uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var tw = `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`;
q();
var rw = `#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var iw = "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";
q();
var nw = `uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var ow = "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}";
q();
var aw = `uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var sw = `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`;
q();
var lw = `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var uw = `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`;
q();
var cw = `#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var pw = `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`;
q();
var hw = `uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var fw = `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`;
q();
var mw = `uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var dw = "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}";
q();
var yw = `uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var gw = `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`;
q();
var xw = `#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var bw = `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`;
q();
var _w = `#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`;
q();
var vw = `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`;
q();
var ww = "varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}";
q();
var Sw = "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}";
q();
var Pw = "uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}";
q();
var Bu = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
var wi = { prelude: Ce(P1, T1), background: Ce(M1, A1), backgroundPattern: Ce(I1, C1), circle: Ce(E1, k1), clippingMask: Ce(L1, D1), heatmap: Ce(z1, F1), heatmapTexture: Ce(R1, B1), collisionBox: Ce(O1, V1), collisionCircle: Ce(U1, N1), debug: Ce(G1, $1), fill: Ce(q1, j1), fillOutline: Ce(Z1, H1), fillOutlinePattern: Ce(W1, X1), fillPattern: Ce(K1, J1), fillExtrusion: Ce(Y1, Q1), fillExtrusionPattern: Ce(ew, tw), hillshadePrepare: Ce(rw, iw), hillshade: Ce(nw, ow), line: Ce(aw, sw), lineGradient: Ce(lw, uw), linePattern: Ce(cw, pw), lineSDF: Ce(hw, fw), raster: Ce(mw, dw), symbolIcon: Ce(yw, gw), symbolSDF: Ce(xw, bw), symbolTextAndIcon: Ce(_w, vw), terrain: Ce(Pw, Bu), terrainDepth: Ce(ww, Bu), terrainCoords: Ce(Sw, Bu) };
function Ce(r3, e) {
  let t3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, i = e.match(/attribute ([\w]+) ([\w]+)/g), n = r3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = o ? o.concat(n) : n, s3 = {};
  return r3 = r3.replace(t3, (l, c, p, h, f) => (s3[f] = true, c === "define" ? `
#ifndef HAS_UNIFORM_u_${f}
varying ${p} ${h} ${f};
#else
uniform ${p} ${h} u_${f};
#endif
` : `
#ifdef HAS_UNIFORM_u_${f}
    ${p} ${h} ${f} = u_${f};
#endif
`)), e = e.replace(t3, (l, c, p, h, f) => {
    let m = h === "float" ? "vec2" : "vec4", y = f.match(/color/) ? "color" : m;
    return s3[f] ? c === "define" ? `
#ifndef HAS_UNIFORM_u_${f}
uniform lowp float u_${f}_t;
attribute ${p} ${m} a_${f};
varying ${p} ${h} ${f};
#else
uniform ${p} ${h} u_${f};
#endif
` : y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${f}
    ${f} = a_${f};
#else
    ${p} ${h} ${f} = u_${f};
#endif
` : `
#ifndef HAS_UNIFORM_u_${f}
    ${f} = unpack_mix_${y}(a_${f}, u_${f}_t);
#else
    ${p} ${h} ${f} = u_${f};
#endif
` : c === "define" ? `
#ifndef HAS_UNIFORM_u_${f}
uniform lowp float u_${f}_t;
attribute ${p} ${m} a_${f};
#else
uniform ${p} ${h} u_${f};
#endif
` : y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${f}
    ${p} ${h} ${f} = a_${f};
#else
    ${p} ${h} ${f} = u_${f};
#endif
` : `
#ifndef HAS_UNIFORM_u_${f}
    ${p} ${h} ${f} = unpack_mix_${y}(a_${f}, u_${f}_t);
#else
    ${p} ${h} ${f} = u_${f};
#endif
`;
  }), { fragmentSource: r3, vertexSource: e, staticAttributes: i, staticUniforms: a };
}
r(Ce, "compile");
q();
q();
var yy = class yy2 {
  constructor() {
    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
  }
  bind(e, t3, i, n, o, a, s3, l, c) {
    this.context = e;
    let p = this.boundPaintVertexBuffers.length !== n.length;
    for (let f = 0; !p && f < n.length; f++) this.boundPaintVertexBuffers[f] !== n[f] && (p = true);
    !this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== i || p || this.boundIndexBuffer !== o || this.boundVertexOffset !== a || this.boundDynamicVertexBuffer !== s3 || this.boundDynamicVertexBuffer2 !== l || this.boundDynamicVertexBuffer3 !== c ? this.freshBind(t3, i, n, o, a, s3, l, c) : (e.bindVertexArray.set(this.vao), s3 && s3.bind(), o && o.dynamicDraw && o.bind(), l && l.bind(), c && c.bind());
  }
  freshBind(e, t3, i, n, o, a, s3, l) {
    let c = e.numAttributes, p = this.context, h = p.gl;
    this.vao && this.destroy(), this.vao = p.createVertexArray(), p.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = n, this.boundVertexOffset = o, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = s3, this.boundDynamicVertexBuffer3 = l, t3.enableAttributes(h, e);
    for (let f of i) f.enableAttributes(h, e);
    a && a.enableAttributes(h, e), s3 && s3.enableAttributes(h, e), l && l.enableAttributes(h, e), t3.bind(), t3.setVertexAttribPointers(h, e, o);
    for (let f of i) f.bind(), f.setVertexAttribPointers(h, e, o);
    a && (a.bind(), a.setVertexAttribPointers(h, e, o)), n && n.bind(), s3 && (s3.bind(), s3.setVertexAttribPointers(h, e, o)), l && (l.bind(), l.setVertexAttribPointers(h, e, o)), p.currentNumAttributes = c;
  }
  destroy() {
    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
  }
};
r(yy, "VertexArrayObject");
var Ou = yy;
q();
var Tw = r((r3, e) => ({ u_depth: new Q(r3, e.u_depth), u_terrain: new Q(r3, e.u_terrain), u_terrain_dim: new U(r3, e.u_terrain_dim), u_terrain_matrix: new re(r3, e.u_terrain_matrix), u_terrain_unpack: new Ir(r3, e.u_terrain_unpack), u_terrain_exaggeration: new U(r3, e.u_terrain_exaggeration) }), "terrainPreludeUniforms");
var Mw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_texture: new Q(r3, e.u_texture), u_ele_delta: new U(r3, e.u_ele_delta) }), "terrainUniforms");
var Aw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_ele_delta: new U(r3, e.u_ele_delta) }), "terrainDepthUniforms");
var Iw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_texture: new Q(r3, e.u_texture), u_terrain_coords_id: new U(r3, e.u_terrain_coords_id), u_ele_delta: new U(r3, e.u_ele_delta) }), "terrainCoordsUniforms");
var Cw = r((r3, e) => ({ u_matrix: r3, u_texture: 0, u_ele_delta: e }), "terrainUniformValues");
var Ew = r((r3, e) => ({ u_matrix: r3, u_ele_delta: e }), "terrainDepthUniformValues");
var kw = r((r3, e, t3) => ({ u_matrix: r3, u_terrain_coords_id: e / 255, u_texture: 0, u_ele_delta: t3 }), "terrainCoordsUniformValues");
function gy(r3) {
  let e = [];
  for (let t3 = 0; t3 < r3.length; t3++) {
    if (r3[t3] === null) continue;
    let i = r3[t3].split(" ");
    e.push(i.pop());
  }
  return e;
}
r(gy, "getTokenizedAttributesAndUniforms");
var xy = class xy2 {
  constructor(e, t3, i, n, o, a) {
    let s3 = e.gl;
    this.program = s3.createProgram();
    let l = gy(t3.staticAttributes), c = i ? i.getBinderAttributes() : [], p = l.concat(c), h = wi.prelude.staticUniforms ? gy(wi.prelude.staticUniforms) : [], f = t3.staticUniforms ? gy(t3.staticUniforms) : [], m = i ? i.getBinderUniforms() : [], y = h.concat(f).concat(m), g = [];
    for (let T of y) g.indexOf(T) < 0 && g.push(T);
    let x = i ? i.defines() : [];
    o && x.push("#define OVERDRAW_INSPECTOR;"), a && x.push("#define TERRAIN3D;");
    let b = x.concat(wi.prelude.fragmentSource, t3.fragmentSource).join(`
`), w = x.concat(wi.prelude.vertexSource, t3.vertexSource).join(`
`), _ = s3.createShader(s3.FRAGMENT_SHADER);
    if (s3.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s3.shaderSource(_, b), s3.compileShader(_), !s3.getShaderParameter(_, s3.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${s3.getShaderInfoLog(_)}`);
    s3.attachShader(this.program, _);
    let S = s3.createShader(s3.VERTEX_SHADER);
    if (s3.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s3.shaderSource(S, w), s3.compileShader(S), !s3.getShaderParameter(S, s3.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${s3.getShaderInfoLog(S)}`);
    s3.attachShader(this.program, S), this.attributes = {};
    let P = {};
    this.numAttributes = p.length;
    for (let T = 0; T < this.numAttributes; T++) p[T] && (s3.bindAttribLocation(this.program, T, p[T]), this.attributes[p[T]] = T);
    if (s3.linkProgram(this.program), !s3.getProgramParameter(this.program, s3.LINK_STATUS)) throw new Error(`Program failed to link: ${s3.getProgramInfoLog(this.program)}`);
    s3.deleteShader(S), s3.deleteShader(_);
    for (let T = 0; T < g.length; T++) {
      let L = g[T];
      if (L && !P[L]) {
        let C = s3.getUniformLocation(this.program, L);
        C && (P[L] = C);
      }
    }
    this.fixedUniforms = n(e, P), this.terrainUniforms = Tw(e, P), this.binderUniforms = i ? i.getUniforms(e, P) : [];
  }
  draw(e, t3, i, n, o, a, s3, l, c, p, h, f, m, y, g, x, b, w) {
    let _ = e.gl;
    if (this.failedToCreate) return;
    if (e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(n), e.setColorMode(o), e.setCullFace(a), l) {
      e.activeTexture.set(_.TEXTURE2), _.bindTexture(_.TEXTURE_2D, l.depthTexture), e.activeTexture.set(_.TEXTURE3), _.bindTexture(_.TEXTURE_2D, l.texture);
      for (let P in this.terrainUniforms) this.terrainUniforms[P].set(l[P]);
    }
    for (let P in this.fixedUniforms) this.fixedUniforms[P].set(s3[P]);
    g && g.setUniforms(e, this.binderUniforms, m, { zoom: y });
    let S = 0;
    switch (t3) {
      case _.LINES:
        S = 2;
        break;
      case _.TRIANGLES:
        S = 3;
        break;
      case _.LINE_STRIP:
        S = 1;
        break;
    }
    for (let P of f.get()) {
      let T = P.vaos || (P.vaos = {});
      (T[c] || (T[c] = new Ou())).bind(e, this, p, g ? g.getPaintVertexBuffers() : [], h, P.vertexOffset, x, b, w), _.drawElements(t3, P.primitiveLength * S, _.UNSIGNED_SHORT, P.primitiveOffset * S * 2);
    }
  }
};
r(xy, "Program");
var Vu = xy;
q();
q();
q();
function Uu(r3, e, t3) {
  let i = 1 / He(t3, 1, e.transform.tileZoom), n = Math.pow(2, t3.tileID.overscaledZ), o = t3.tileSize * Math.pow(2, e.transform.tileZoom) / n, a = o * (t3.tileID.canonical.x + t3.tileID.wrap * n), s3 = o * t3.tileID.canonical.y;
  return { u_image: 0, u_texsize: t3.imageAtlasTexture.size, u_scale: [i, r3.fromScale, r3.toScale], u_fade: r3.t, u_pixel_coord_upper: [a >> 16, s3 >> 16], u_pixel_coord_lower: [a & 65535, s3 & 65535] };
}
r(Uu, "patternUniformValues");
function Lw(r3, e, t3, i) {
  let n = t3.imageManager.getPattern(r3.from.toString()), o = t3.imageManager.getPattern(r3.to.toString()), { width: a, height: s3 } = t3.imageManager.getPixelSize(), l = Math.pow(2, i.tileID.overscaledZ), c = i.tileSize * Math.pow(2, t3.transform.tileZoom) / l, p = c * (i.tileID.canonical.x + i.tileID.wrap * l), h = c * i.tileID.canonical.y;
  return { u_image: 0, u_pattern_tl_a: n.tl, u_pattern_br_a: n.br, u_pattern_tl_b: o.tl, u_pattern_br_b: o.br, u_texsize: [a, s3], u_mix: e.t, u_pattern_size_a: n.displaySize, u_pattern_size_b: o.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / He(i, 1, t3.transform.tileZoom), u_pixel_coord_upper: [p >> 16, h >> 16], u_pixel_coord_lower: [p & 65535, h & 65535] };
}
r(Lw, "bgPatternUniformValues");
var Dw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_lightpos: new lt(r3, e.u_lightpos), u_lightintensity: new U(r3, e.u_lightintensity), u_lightcolor: new lt(r3, e.u_lightcolor), u_vertical_gradient: new U(r3, e.u_vertical_gradient), u_opacity: new U(r3, e.u_opacity) }), "fillExtrusionUniforms");
var zw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_lightpos: new lt(r3, e.u_lightpos), u_lightintensity: new U(r3, e.u_lightintensity), u_lightcolor: new lt(r3, e.u_lightcolor), u_vertical_gradient: new U(r3, e.u_vertical_gradient), u_height_factor: new U(r3, e.u_height_factor), u_image: new Q(r3, e.u_image), u_texsize: new te(r3, e.u_texsize), u_pixel_coord_upper: new te(r3, e.u_pixel_coord_upper), u_pixel_coord_lower: new te(r3, e.u_pixel_coord_lower), u_scale: new lt(r3, e.u_scale), u_fade: new U(r3, e.u_fade), u_opacity: new U(r3, e.u_opacity) }), "fillExtrusionPatternUniforms");
var by = r((r3, e, t3, i) => {
  let n = e.style.light, o = n.properties.get("position"), a = [o.x, o.y, o.z], s3 = Oo.create();
  n.properties.get("anchor") === "viewport" && Oo.fromRotation(s3, -e.transform.angle), gt.transformMat3(a, a, s3);
  let l = n.properties.get("color");
  return { u_matrix: r3, u_lightpos: a, u_lightintensity: n.properties.get("intensity"), u_lightcolor: [l.r, l.g, l.b], u_vertical_gradient: +t3, u_opacity: i };
}, "fillExtrusionUniformValues");
var Fw = r((r3, e, t3, i, n, o, a) => V(by(r3, e, t3, i), Uu(o, e, a), { u_height_factor: -Math.pow(2, n.overscaledZ) / a.tileSize / 8 }), "fillExtrusionPatternUniformValues");
q();
var Rw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix) }), "fillUniforms");
var Bw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_image: new Q(r3, e.u_image), u_texsize: new te(r3, e.u_texsize), u_pixel_coord_upper: new te(r3, e.u_pixel_coord_upper), u_pixel_coord_lower: new te(r3, e.u_pixel_coord_lower), u_scale: new lt(r3, e.u_scale), u_fade: new U(r3, e.u_fade) }), "fillPatternUniforms");
var Ow = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_world: new te(r3, e.u_world) }), "fillOutlineUniforms");
var Vw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_world: new te(r3, e.u_world), u_image: new Q(r3, e.u_image), u_texsize: new te(r3, e.u_texsize), u_pixel_coord_upper: new te(r3, e.u_pixel_coord_upper), u_pixel_coord_lower: new te(r3, e.u_pixel_coord_lower), u_scale: new lt(r3, e.u_scale), u_fade: new U(r3, e.u_fade) }), "fillOutlinePatternUniforms");
var _y = r((r3) => ({ u_matrix: r3 }), "fillUniformValues");
var vy = r((r3, e, t3, i) => V(_y(r3), Uu(t3, e, i)), "fillPatternUniformValues");
var Uw = r((r3, e) => ({ u_matrix: r3, u_world: e }), "fillOutlineUniformValues");
var Nw = r((r3, e, t3, i, n) => V(vy(r3, e, t3, i), { u_world: n }), "fillOutlinePatternUniformValues");
q();
var Gw = r((r3, e) => ({ u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_scale_with_map: new Q(r3, e.u_scale_with_map), u_pitch_with_map: new Q(r3, e.u_pitch_with_map), u_extrude_scale: new te(r3, e.u_extrude_scale), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_matrix: new re(r3, e.u_matrix) }), "circleUniforms");
var $w = r((r3, e, t3, i) => {
  let n = r3.transform, o, a;
  if (i.paint.get("circle-pitch-alignment") === "map") {
    let s3 = He(t3, 1, n.zoom);
    o = true, a = [s3, s3];
  } else o = false, a = n.pixelsToGLUnits;
  return { u_camera_to_center_distance: n.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_matrix: r3.translatePosMatrix(e.posMatrix, t3, i.paint.get("circle-translate"), i.paint.get("circle-translate-anchor")), u_pitch_with_map: +o, u_device_pixel_ratio: r3.pixelRatio, u_extrude_scale: a };
}, "circleUniformValues");
q();
var qw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_pixels_to_tile_units: new U(r3, e.u_pixels_to_tile_units), u_extrude_scale: new te(r3, e.u_extrude_scale), u_overscale_factor: new U(r3, e.u_overscale_factor) }), "collisionUniforms");
var jw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_inv_matrix: new re(r3, e.u_inv_matrix), u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_viewport_size: new te(r3, e.u_viewport_size) }), "collisionCircleUniforms");
var Zw = r((r3, e, t3) => {
  let i = He(t3, 1, e.zoom), n = Math.pow(2, e.zoom - t3.tileID.overscaledZ), o = t3.tileID.overscaleFactor();
  return { u_matrix: r3, u_camera_to_center_distance: e.cameraToCenterDistance, u_pixels_to_tile_units: i, u_extrude_scale: [e.pixelsToGLUnits[0] / (i * n), e.pixelsToGLUnits[1] / (i * n)], u_overscale_factor: o };
}, "collisionUniformValues");
var Hw = r((r3, e, t3) => ({ u_matrix: r3, u_inv_matrix: e, u_camera_to_center_distance: t3.cameraToCenterDistance, u_viewport_size: [t3.width, t3.height] }), "collisionCircleUniformValues");
q();
var Ww = r((r3, e) => ({ u_color: new kt(r3, e.u_color), u_matrix: new re(r3, e.u_matrix), u_overlay: new Q(r3, e.u_overlay), u_overlay_scale: new U(r3, e.u_overlay_scale) }), "debugUniforms");
var wy = r((r3, e, t3 = 1) => ({ u_matrix: r3, u_color: e, u_overlay: 0, u_overlay_scale: t3 }), "debugUniformValues");
q();
var Xw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix) }), "clippingMaskUniforms");
var Sy = r((r3) => ({ u_matrix: r3 }), "clippingMaskUniformValues");
q();
var Kw = r((r3, e) => ({ u_extrude_scale: new U(r3, e.u_extrude_scale), u_intensity: new U(r3, e.u_intensity), u_matrix: new re(r3, e.u_matrix) }), "heatmapUniforms");
var Jw = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_world: new te(r3, e.u_world), u_image: new Q(r3, e.u_image), u_color_ramp: new Q(r3, e.u_color_ramp), u_opacity: new U(r3, e.u_opacity) }), "heatmapTextureUniforms");
var Yw = r((r3, e, t3, i) => ({ u_matrix: r3, u_extrude_scale: He(e, 1, t3), u_intensity: i }), "heatmapUniformValues");
var Qw = r((r3, e, t3, i) => {
  let n = $.create();
  $.ortho(n, 0, r3.width, r3.height, 0, 0, 1);
  let o = r3.context.gl;
  return { u_matrix: n, u_world: [o.drawingBufferWidth, o.drawingBufferHeight], u_image: t3, u_color_ramp: i, u_opacity: e.paint.get("heatmap-opacity") };
}, "heatmapTextureUniformValues");
q();
var eS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_image: new Q(r3, e.u_image), u_latrange: new te(r3, e.u_latrange), u_light: new te(r3, e.u_light), u_shadow: new kt(r3, e.u_shadow), u_highlight: new kt(r3, e.u_highlight), u_accent: new kt(r3, e.u_accent) }), "hillshadeUniforms");
var tS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_image: new Q(r3, e.u_image), u_dimension: new te(r3, e.u_dimension), u_zoom: new U(r3, e.u_zoom), u_unpack: new Ir(r3, e.u_unpack) }), "hillshadePrepareUniforms");
var rS = r((r3, e, t3, i) => {
  let n = t3.paint.get("hillshade-shadow-color"), o = t3.paint.get("hillshade-highlight-color"), a = t3.paint.get("hillshade-accent-color"), s3 = t3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
  t3.paint.get("hillshade-illumination-anchor") === "viewport" && (s3 -= r3.transform.angle);
  let l = !r3.options.moving;
  return { u_matrix: i ? i.posMatrix : r3.transform.calculatePosMatrix(e.tileID.toUnwrapped(), l), u_image: 0, u_latrange: bL(r3, e.tileID), u_light: [t3.paint.get("hillshade-exaggeration"), s3], u_shadow: n, u_highlight: o, u_accent: a };
}, "hillshadeUniformValues");
var iS = r((r3, e) => {
  let t3 = e.stride, i = $.create();
  return $.ortho(i, 0, 8192, -8192, 0, 0, 1), $.translate(i, i, [0, -8192, 0]), { u_matrix: i, u_image: 1, u_dimension: [t3, t3], u_zoom: r3.overscaledZ, u_unpack: e.getUnpackVector() };
}, "hillshadeUniformPrepareValues");
function bL(r3, e) {
  let t3 = Math.pow(2, e.canonical.z), i = e.canonical.y;
  return [new Fe(0, i / t3).toLngLat().lat, new Fe(0, (i + 1) / t3).toLngLat().lat];
}
r(bL, "getTileLatRange");
q();
var nS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_ratio: new U(r3, e.u_ratio), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_units_to_pixels: new te(r3, e.u_units_to_pixels) }), "lineUniforms");
var oS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_ratio: new U(r3, e.u_ratio), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_units_to_pixels: new te(r3, e.u_units_to_pixels), u_image: new Q(r3, e.u_image), u_image_height: new U(r3, e.u_image_height) }), "lineGradientUniforms");
var aS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_texsize: new te(r3, e.u_texsize), u_ratio: new U(r3, e.u_ratio), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_image: new Q(r3, e.u_image), u_units_to_pixels: new te(r3, e.u_units_to_pixels), u_scale: new lt(r3, e.u_scale), u_fade: new U(r3, e.u_fade) }), "linePatternUniforms");
var sS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_ratio: new U(r3, e.u_ratio), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_units_to_pixels: new te(r3, e.u_units_to_pixels), u_patternscale_a: new te(r3, e.u_patternscale_a), u_patternscale_b: new te(r3, e.u_patternscale_b), u_sdfgamma: new U(r3, e.u_sdfgamma), u_image: new Q(r3, e.u_image), u_tex_y_a: new U(r3, e.u_tex_y_a), u_tex_y_b: new U(r3, e.u_tex_y_b), u_mix: new U(r3, e.u_mix) }), "lineSDFUniforms");
var Nu = r((r3, e, t3, i) => {
  let n = r3.transform;
  return { u_matrix: hS(r3, e, t3, i), u_ratio: 1 / He(e, 1, n.zoom), u_device_pixel_ratio: r3.pixelRatio, u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]] };
}, "lineUniformValues");
var lS = r((r3, e, t3, i, n) => V(Nu(r3, e, t3, n), { u_image: 0, u_image_height: i }), "lineGradientUniformValues");
var uS = r((r3, e, t3, i, n) => {
  let o = r3.transform, a = pS(e, o);
  return { u_matrix: hS(r3, e, t3, n), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / He(e, 1, o.zoom), u_device_pixel_ratio: r3.pixelRatio, u_image: 0, u_scale: [a, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] };
}, "linePatternUniformValues");
var cS = r((r3, e, t3, i, n, o) => {
  let a = r3.transform, s3 = r3.lineAtlas, l = pS(e, a), c = t3.layout.get("line-cap") === "round", p = s3.getDash(i.from, c), h = s3.getDash(i.to, c), f = p.width * n.fromScale, m = h.width * n.toScale;
  return V(Nu(r3, e, t3, o), { u_patternscale_a: [l / f, -p.height / 2], u_patternscale_b: [l / m, -h.height / 2], u_sdfgamma: s3.width / (Math.min(f, m) * 256 * r3.pixelRatio) / 2, u_image: 0, u_tex_y_a: p.y, u_tex_y_b: h.y, u_mix: n.t });
}, "lineSDFUniformValues");
function pS(r3, e) {
  return 1 / He(r3, 1, e.tileZoom);
}
r(pS, "calculateTileRatio");
function hS(r3, e, t3, i) {
  return r3.translatePosMatrix(i ? i.posMatrix : e.tileID.posMatrix, e, t3.paint.get("line-translate"), t3.paint.get("line-translate-anchor"));
}
r(hS, "calculateMatrix");
q();
var fS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_tl_parent: new te(r3, e.u_tl_parent), u_scale_parent: new U(r3, e.u_scale_parent), u_buffer_scale: new U(r3, e.u_buffer_scale), u_fade_t: new U(r3, e.u_fade_t), u_opacity: new U(r3, e.u_opacity), u_image0: new Q(r3, e.u_image0), u_image1: new Q(r3, e.u_image1), u_brightness_low: new U(r3, e.u_brightness_low), u_brightness_high: new U(r3, e.u_brightness_high), u_saturation_factor: new U(r3, e.u_saturation_factor), u_contrast_factor: new U(r3, e.u_contrast_factor), u_spin_weights: new lt(r3, e.u_spin_weights) }), "rasterUniforms");
var mS = r((r3, e, t3, i, n) => ({ u_matrix: r3, u_tl_parent: e, u_scale_parent: t3, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * n.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n.paint.get("raster-brightness-min"), u_brightness_high: n.paint.get("raster-brightness-max"), u_saturation_factor: wL(n.paint.get("raster-saturation")), u_contrast_factor: vL(n.paint.get("raster-contrast")), u_spin_weights: _L(n.paint.get("raster-hue-rotate")) }), "rasterUniformValues");
function _L(r3) {
  r3 *= Math.PI / 180;
  let e = Math.sin(r3), t3 = Math.cos(r3);
  return [(2 * t3 + 1) / 3, (-Math.sqrt(3) * e - t3 + 1) / 3, (Math.sqrt(3) * e - t3 + 1) / 3];
}
r(_L, "spinWeights");
function vL(r3) {
  return r3 > 0 ? 1 / (1 - r3) : 1 + r3;
}
r(vL, "contrastFactor");
function wL(r3) {
  return r3 > 0 ? 1 - 1 / (1.001 - r3) : -r3;
}
r(wL, "saturationFactor");
q();
var dS = r((r3, e) => ({ u_is_size_zoom_constant: new Q(r3, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q(r3, e.u_is_size_feature_constant), u_size_t: new U(r3, e.u_size_t), u_size: new U(r3, e.u_size), u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_pitch: new U(r3, e.u_pitch), u_rotate_symbol: new Q(r3, e.u_rotate_symbol), u_aspect_ratio: new U(r3, e.u_aspect_ratio), u_fade_change: new U(r3, e.u_fade_change), u_matrix: new re(r3, e.u_matrix), u_label_plane_matrix: new re(r3, e.u_label_plane_matrix), u_coord_matrix: new re(r3, e.u_coord_matrix), u_is_text: new Q(r3, e.u_is_text), u_pitch_with_map: new Q(r3, e.u_pitch_with_map), u_texsize: new te(r3, e.u_texsize), u_texture: new Q(r3, e.u_texture) }), "symbolIconUniforms");
var yS = r((r3, e) => ({ u_is_size_zoom_constant: new Q(r3, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q(r3, e.u_is_size_feature_constant), u_size_t: new U(r3, e.u_size_t), u_size: new U(r3, e.u_size), u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_pitch: new U(r3, e.u_pitch), u_rotate_symbol: new Q(r3, e.u_rotate_symbol), u_aspect_ratio: new U(r3, e.u_aspect_ratio), u_fade_change: new U(r3, e.u_fade_change), u_matrix: new re(r3, e.u_matrix), u_label_plane_matrix: new re(r3, e.u_label_plane_matrix), u_coord_matrix: new re(r3, e.u_coord_matrix), u_is_text: new Q(r3, e.u_is_text), u_pitch_with_map: new Q(r3, e.u_pitch_with_map), u_texsize: new te(r3, e.u_texsize), u_texture: new Q(r3, e.u_texture), u_gamma_scale: new U(r3, e.u_gamma_scale), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_is_halo: new Q(r3, e.u_is_halo) }), "symbolSDFUniforms");
var gS = r((r3, e) => ({ u_is_size_zoom_constant: new Q(r3, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q(r3, e.u_is_size_feature_constant), u_size_t: new U(r3, e.u_size_t), u_size: new U(r3, e.u_size), u_camera_to_center_distance: new U(r3, e.u_camera_to_center_distance), u_pitch: new U(r3, e.u_pitch), u_rotate_symbol: new Q(r3, e.u_rotate_symbol), u_aspect_ratio: new U(r3, e.u_aspect_ratio), u_fade_change: new U(r3, e.u_fade_change), u_matrix: new re(r3, e.u_matrix), u_label_plane_matrix: new re(r3, e.u_label_plane_matrix), u_coord_matrix: new re(r3, e.u_coord_matrix), u_is_text: new Q(r3, e.u_is_text), u_pitch_with_map: new Q(r3, e.u_pitch_with_map), u_texsize: new te(r3, e.u_texsize), u_texsize_icon: new te(r3, e.u_texsize_icon), u_texture: new Q(r3, e.u_texture), u_texture_icon: new Q(r3, e.u_texture_icon), u_gamma_scale: new U(r3, e.u_gamma_scale), u_device_pixel_ratio: new U(r3, e.u_device_pixel_ratio), u_is_halo: new Q(r3, e.u_is_halo) }), "symbolTextAndIconUniforms");
var Py = r((r3, e, t3, i, n, o, a, s3, l, c) => {
  let p = n.transform;
  return { u_is_size_zoom_constant: +(r3 === "constant" || r3 === "source"), u_is_size_feature_constant: +(r3 === "constant" || r3 === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: p.cameraToCenterDistance, u_pitch: p.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +t3, u_aspect_ratio: p.width / p.height, u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1, u_matrix: o, u_label_plane_matrix: a, u_coord_matrix: s3, u_is_text: +l, u_pitch_with_map: +i, u_texsize: c, u_texture: 0 };
}, "symbolIconUniformValues");
var Ty = r((r3, e, t3, i, n, o, a, s3, l, c, p) => {
  let h = n.transform;
  return V(Py(r3, e, t3, i, n, o, a, s3, l, c), { u_gamma_scale: i ? Math.cos(h._pitch) * h.cameraToCenterDistance : 1, u_device_pixel_ratio: n.pixelRatio, u_is_halo: +p });
}, "symbolSDFUniformValues");
var xS = r((r3, e, t3, i, n, o, a, s3, l, c) => V(Ty(r3, e, t3, i, n, o, a, s3, true, l, true), { u_texsize_icon: c, u_texture_icon: 1 }), "symbolTextAndIconUniformValues");
q();
var bS = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_opacity: new U(r3, e.u_opacity), u_color: new kt(r3, e.u_color) }), "backgroundUniforms");
var _S = r((r3, e) => ({ u_matrix: new re(r3, e.u_matrix), u_opacity: new U(r3, e.u_opacity), u_image: new Q(r3, e.u_image), u_pattern_tl_a: new te(r3, e.u_pattern_tl_a), u_pattern_br_a: new te(r3, e.u_pattern_br_a), u_pattern_tl_b: new te(r3, e.u_pattern_tl_b), u_pattern_br_b: new te(r3, e.u_pattern_br_b), u_texsize: new te(r3, e.u_texsize), u_mix: new U(r3, e.u_mix), u_pattern_size_a: new te(r3, e.u_pattern_size_a), u_pattern_size_b: new te(r3, e.u_pattern_size_b), u_scale_a: new U(r3, e.u_scale_a), u_scale_b: new U(r3, e.u_scale_b), u_pixel_coord_upper: new te(r3, e.u_pixel_coord_upper), u_pixel_coord_lower: new te(r3, e.u_pixel_coord_lower), u_tile_units_to_pixels: new U(r3, e.u_tile_units_to_pixels) }), "backgroundPatternUniforms");
var vS = r((r3, e, t3) => ({ u_matrix: r3, u_opacity: e, u_color: t3 }), "backgroundUniformValues");
var wS = r((r3, e, t3, i, n, o) => V(Lw(i, o, t3, n), { u_matrix: r3, u_opacity: e }), "backgroundPatternUniformValues");
var SS = { fillExtrusion: Dw, fillExtrusionPattern: zw, fill: Rw, fillPattern: Bw, fillOutline: Ow, fillOutlinePattern: Vw, circle: Gw, collisionBox: qw, collisionCircle: jw, debug: Ww, clippingMask: Xw, heatmap: Kw, heatmapTexture: Jw, hillshade: eS, hillshadePrepare: tS, line: nS, lineGradient: oS, linePattern: aS, lineSDF: sS, raster: fS, symbolIcon: dS, symbolSDF: yS, symbolTextAndIcon: gS, background: bS, backgroundPattern: _S, terrain: Mw, terrainDepth: Aw, terrainCoords: Iw };
q();
q();
var My = class My2 {
  constructor(e, t3, i) {
    this.context = e;
    let n = e.gl;
    this.buffer = n.createBuffer(), this.dynamicDraw = !!i, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
  }
  bind() {
    this.context.bindElementBuffer.set(this.buffer);
  }
  updateData(e) {
    let t3 = this.context.gl;
    if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
    this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
r(My, "IndexBuffer");
var Gu = My;
q();
var SL = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
var Ay = class Ay2 {
  constructor(e, t3, i, n) {
    this.length = t3.length, this.attributes = i, this.itemSize = t3.bytesPerElement, this.dynamicDraw = n, this.context = e;
    let o = e.gl;
    this.buffer = o.createBuffer(), e.bindVertexBuffer.set(this.buffer), o.bufferData(o.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
  }
  bind() {
    this.context.bindVertexBuffer.set(this.buffer);
  }
  updateData(e) {
    if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
    let t3 = this.context.gl;
    this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  enableAttributes(e, t3) {
    for (let i = 0; i < this.attributes.length; i++) {
      let n = this.attributes[i], o = t3.attributes[n.name];
      o !== void 0 && e.enableVertexAttribArray(o);
    }
  }
  setVertexAttribPointers(e, t3, i) {
    for (let n = 0; n < this.attributes.length; n++) {
      let o = this.attributes[n], a = t3.attributes[o.name];
      a !== void 0 && e.vertexAttribPointer(a, o.components, e[SL[o.type]], false, this.itemSize, o.offset + this.itemSize * (i || 0));
    }
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
r(Ay, "VertexBuffer");
var $u = Ay;
q();
q();
q();
var Iy = /* @__PURE__ */ new WeakMap();
function Sn(r3) {
  var e;
  if (Iy.has(r3)) return Iy.get(r3);
  {
    let t3 = (e = r3.getParameter(r3.VERSION)) == null ? void 0 : e.startsWith("WebGL 2.0");
    return Iy.set(r3, t3), t3;
  }
}
r(Sn, "isWebGL2");
var Cy = class Cy2 {
  constructor(e) {
    this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
  }
  get() {
    return this.current;
  }
  set(e) {
  }
  getDefault() {
    return this.default;
  }
  setDefault() {
    this.set(this.default);
  }
};
r(Cy, "BaseValue");
var be = Cy;
var Ey = class Ey2 extends be {
  getDefault() {
    return X.transparent;
  }
  set(e) {
    let t3 = this.current;
    e.r === t3.r && e.g === t3.g && e.b === t3.b && e.a === t3.a && !this.dirty || (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
r(Ey, "ClearColor");
var qu = Ey;
var ky = class ky2 extends be {
  getDefault() {
    return 1;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearDepth(e), this.current = e, this.dirty = false);
  }
};
r(ky, "ClearDepth");
var ju = ky;
var Ly = class Ly2 extends be {
  getDefault() {
    return 0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearStencil(e), this.current = e, this.dirty = false);
  }
};
r(Ly, "ClearStencil");
var Zu = Ly;
var Dy = class Dy2 extends be {
  getDefault() {
    return [true, true, true, true];
  }
  set(e) {
    let t3 = this.current;
    e[0] === t3[0] && e[1] === t3[1] && e[2] === t3[2] && e[3] === t3[3] && !this.dirty || (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
r(Dy, "ColorMask");
var Hu = Dy;
var zy = class zy2 extends be {
  getDefault() {
    return true;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthMask(e), this.current = e, this.dirty = false);
  }
};
r(zy, "DepthMask");
var Wu = zy;
var Fy = class Fy2 extends be {
  getDefault() {
    return 255;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.stencilMask(e), this.current = e, this.dirty = false);
  }
};
r(Fy, "StencilMask");
var Xu = Fy;
var Ry = class Ry2 extends be {
  getDefault() {
    return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
  }
  set(e) {
    let t3 = this.current;
    e.func === t3.func && e.ref === t3.ref && e.mask === t3.mask && !this.dirty || (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
  }
};
r(Ry, "StencilFunc");
var Ku = Ry;
var By = class By2 extends be {
  getDefault() {
    let e = this.gl;
    return [e.KEEP, e.KEEP, e.KEEP];
  }
  set(e) {
    let t3 = this.current;
    e[0] === t3[0] && e[1] === t3[1] && e[2] === t3[2] && !this.dirty || (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
  }
};
r(By, "StencilOp");
var Ju = By;
var Oy = class Oy2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    e ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e, this.dirty = false;
  }
};
r(Oy, "StencilTest");
var Yu = Oy;
var Vy = class Vy2 extends be {
  getDefault() {
    return [0, 1];
  }
  set(e) {
    let t3 = this.current;
    e[0] === t3[0] && e[1] === t3[1] && !this.dirty || (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
r(Vy, "DepthRange");
var Qu = Vy;
var Uy = class Uy2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    e ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e, this.dirty = false;
  }
};
r(Uy, "DepthTest");
var ec = Uy;
var Ny = class Ny2 extends be {
  getDefault() {
    return this.gl.LESS;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthFunc(e), this.current = e, this.dirty = false);
  }
};
r(Ny, "DepthFunc");
var tc = Ny;
var Gy = class Gy2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    e ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e, this.dirty = false;
  }
};
r(Gy, "Blend");
var rc = Gy;
var $y = class $y2 extends be {
  getDefault() {
    let e = this.gl;
    return [e.ONE, e.ZERO];
  }
  set(e) {
    let t3 = this.current;
    e[0] === t3[0] && e[1] === t3[1] && !this.dirty || (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
r($y, "BlendFunc");
var ic = $y;
var qy = class qy2 extends be {
  getDefault() {
    return X.transparent;
  }
  set(e) {
    let t3 = this.current;
    e.r === t3.r && e.g === t3.g && e.b === t3.b && e.a === t3.a && !this.dirty || (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
r(qy, "BlendColor");
var nc = qy;
var jy = class jy2 extends be {
  getDefault() {
    return this.gl.FUNC_ADD;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.blendEquation(e), this.current = e, this.dirty = false);
  }
};
r(jy, "BlendEquation");
var oc = jy;
var Zy = class Zy2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    e ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e, this.dirty = false;
  }
};
r(Zy, "CullFace");
var ac = Zy;
var Hy = class Hy2 extends be {
  getDefault() {
    return this.gl.BACK;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.cullFace(e), this.current = e, this.dirty = false);
  }
};
r(Hy, "CullFaceSide");
var sc = Hy;
var Wy = class Wy2 extends be {
  getDefault() {
    return this.gl.CCW;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.frontFace(e), this.current = e, this.dirty = false);
  }
};
r(Wy, "FrontFace");
var lc = Wy;
var Xy = class Xy2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.useProgram(e), this.current = e, this.dirty = false);
  }
};
r(Xy, "ProgramValue");
var uc = Xy;
var Ky = class Ky2 extends be {
  getDefault() {
    return this.gl.TEXTURE0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.activeTexture(e), this.current = e, this.dirty = false);
  }
};
r(Ky, "ActiveTextureUnit");
var cc = Ky;
var Jy = class Jy2 extends be {
  getDefault() {
    let e = this.gl;
    return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
  }
  set(e) {
    let t3 = this.current;
    e[0] === t3[0] && e[1] === t3[1] && e[2] === t3[2] && e[3] === t3[3] && !this.dirty || (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
r(Jy, "Viewport");
var pc = Jy;
var Yy = class Yy2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.bindFramebuffer(t3.FRAMEBUFFER, e), this.current = e, this.dirty = false;
  }
};
r(Yy, "BindFramebuffer");
var hc = Yy;
var Qy = class Qy2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.bindRenderbuffer(t3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
r(Qy, "BindRenderbuffer");
var fc = Qy;
var eg = class eg2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.bindTexture(t3.TEXTURE_2D, e), this.current = e, this.dirty = false;
  }
};
r(eg, "BindTexture");
var mc = eg;
var tg = class tg2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.bindBuffer(t3.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
r(tg, "BindVertexBuffer");
var dc = tg;
var rg = class rg2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    let t3 = this.gl;
    t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
r(rg, "BindElementBuffer");
var yc = rg;
var ig = class ig2 extends be {
  getDefault() {
    return null;
  }
  set(e) {
    var i;
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    Sn(t3) ? t3.bindVertexArray(e) : (i = t3.getExtension("OES_vertex_array_object")) == null || i.bindVertexArrayOES(e), this.current = e, this.dirty = false;
  }
};
r(ig, "BindVertexArray");
var gc = ig;
var ng = class ng2 extends be {
  getDefault() {
    return 4;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
  }
};
r(ng, "PixelStoreUnpack");
var xc = ng;
var og = class og2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
  }
};
r(og, "PixelStoreUnpackPremultiplyAlpha");
var bc = og;
var ag = class ag2 extends be {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
  }
};
r(ag, "PixelStoreUnpackFlipY");
var _c = ag;
var sg = class sg2 extends be {
  constructor(e, t3) {
    super(e), this.context = e, this.parent = t3;
  }
  getDefault() {
    return null;
  }
};
r(sg, "FramebufferAttachment");
var Ma = sg;
var lg = class lg2 extends Ma {
  setDirty() {
    this.dirty = true;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
  }
};
r(lg, "ColorAttachment");
var vc = lg;
var ug = class ug2 extends Ma {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
r(ug, "DepthAttachment");
var wc = ug;
var cg = class cg2 extends Ma {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_STENCIL_ATTACHMENT, t3.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
r(cg, "DepthStencilAttachment");
var Sc = cg;
var pg = class pg2 {
  constructor(e, t3, i, n, o) {
    this.context = e, this.width = t3, this.height = i;
    let a = e.gl, s3 = this.framebuffer = a.createFramebuffer();
    if (this.colorAttachment = new vc(e, s3), n) this.depthAttachment = o ? new Sc(e, s3) : new wc(e, s3);
    else if (o) throw new Error("Stencil cannot be set without depth");
    if (a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
  }
  destroy() {
    let e = this.context.gl, t3 = this.colorAttachment.get();
    if (t3 && e.deleteTexture(t3), this.depthAttachment) {
      let i = this.depthAttachment.get();
      i && e.deleteRenderbuffer(i);
    }
    e.deleteFramebuffer(this.framebuffer);
  }
};
r(pg, "Framebuffer");
var Pc = pg;
q();
var PL = 0;
var PS = 1;
var TL = 771;
var hg = class hg2 {
  constructor(e, t3, i) {
    this.blendFunction = e, this.blendColor = t3, this.mask = i;
  }
};
r(hg, "ColorMode");
var Ee = hg;
Ee.Replace = [PS, PL];
Ee.disabled = new Ee(Ee.Replace, X.transparent, [false, false, false, false]);
Ee.unblended = new Ee(Ee.Replace, X.transparent, [true, true, true, true]);
Ee.alphaBlended = new Ee([PS, TL], X.transparent, [true, true, true, true]);
var fg = class fg2 {
  constructor(e) {
    var t3, i;
    if (this.gl = e, this.clearColor = new qu(this), this.clearDepth = new ju(this), this.clearStencil = new Zu(this), this.colorMask = new Hu(this), this.depthMask = new Wu(this), this.stencilMask = new Xu(this), this.stencilFunc = new Ku(this), this.stencilOp = new Ju(this), this.stencilTest = new Yu(this), this.depthRange = new Qu(this), this.depthTest = new ec(this), this.depthFunc = new tc(this), this.blend = new rc(this), this.blendFunc = new ic(this), this.blendColor = new nc(this), this.blendEquation = new oc(this), this.cullFace = new ac(this), this.cullFaceSide = new sc(this), this.frontFace = new lc(this), this.program = new uc(this), this.activeTexture = new cc(this), this.viewport = new pc(this), this.bindFramebuffer = new hc(this), this.bindRenderbuffer = new fc(this), this.bindTexture = new mc(this), this.bindVertexBuffer = new dc(this), this.bindElementBuffer = new yc(this), this.bindVertexArray = new gc(this), this.pixelStoreUnpack = new xc(this), this.pixelStoreUnpackPremultiplyAlpha = new bc(this), this.pixelStoreUnpackFlipY = new _c(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Sn(e)) {
      this.HALF_FLOAT = e.HALF_FLOAT;
      let n = e.getExtension("EXT_color_buffer_half_float");
      this.RGBA16F = (t3 = e.RGBA16F) != null ? t3 : n == null ? void 0 : n.RGBA16F_EXT, this.RGB16F = (i = e.RGB16F) != null ? i : n == null ? void 0 : n.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
    } else {
      e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
      let n = e.getExtension("OES_texture_half_float");
      this.HALF_FLOAT = n == null ? void 0 : n.HALF_FLOAT_OES;
    }
  }
  setDefault() {
    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
  }
  setDirty() {
    this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
  }
  createIndexBuffer(e, t3) {
    return new Gu(this, e, t3);
  }
  createVertexBuffer(e, t3, i) {
    return new $u(this, e, t3, i);
  }
  createRenderbuffer(e, t3, i) {
    let n = this.gl, o = n.createRenderbuffer();
    return this.bindRenderbuffer.set(o), n.renderbufferStorage(n.RENDERBUFFER, e, t3, i), this.bindRenderbuffer.set(null), o;
  }
  createFramebuffer(e, t3, i, n) {
    return new Pc(this, e, t3, i, n);
  }
  clear({ color: e, depth: t3, stencil: i }) {
    let n = this.gl, o = 0;
    e && (o |= n.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), typeof t3 < "u" && (o |= n.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), typeof i < "u" && (o |= n.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), n.clear(o);
  }
  setCullFace(e) {
    e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
  }
  setDepthMode(e) {
    e.func === this.gl.ALWAYS && !e.mask ? this.depthTest.set(false) : (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range));
  }
  setStencilMode(e) {
    e.test.func === this.gl.ALWAYS && !e.mask ? this.stencilTest.set(false) : (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask }));
  }
  setColorMode(e) {
    Yt(e.blendFunction, Ee.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
  }
  createVertexArray() {
    var e;
    return Sn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : e.createVertexArrayOES();
  }
  deleteVertexArray(e) {
    var t3;
    return Sn(this.gl) ? this.gl.deleteVertexArray(e) : (t3 = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : t3.deleteVertexArrayOES(e);
  }
  unbindVAO() {
    this.bindVertexArray.set(null);
  }
};
r(fg, "Context");
var Tc = fg;
q();
var mg = class mg2 {
  constructor(e, t3, i) {
    this.func = e, this.mask = t3, this.range = i;
  }
};
r(mg, "DepthMode");
var ee = mg;
ee.ReadOnly = false;
ee.ReadWrite = true;
ee.disabled = new ee(519, ee.ReadOnly, [0, 1]);
q();
var dg = class dg2 {
  constructor(e, t3, i, n, o, a) {
    this.test = e, this.ref = t3, this.mask = i, this.fail = n, this.depthFail = o, this.pass = a;
  }
};
r(dg, "StencilMode");
var fe = dg;
fe.disabled = new fe({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
q();
var yg = class yg2 {
  constructor(e, t3, i) {
    this.enable = e, this.mode = t3, this.frontFace = i;
  }
};
r(yg, "CullFaceMode");
var ue = yg;
ue.disabled = new ue(false, 1029, 2305);
ue.backCCW = new ue(true, 1029, 2305);
q();
var xg = u(ge(), 1);
q();
var Mc;
function gg(r3, e, t3, i, n, o, a) {
  let s3 = r3.context, l = s3.gl, c = r3.useProgram("collisionBox"), p = [], h = 0, f = 0;
  for (let w = 0; w < i.length; w++) {
    let _ = i[w], S = e.getTile(_), P = S.getBucket(t3);
    if (!P) continue;
    let T = _.posMatrix;
    (n[0] !== 0 || n[1] !== 0) && (T = r3.translatePosMatrix(_.posMatrix, S, n, o));
    let L = a ? P.textCollisionBox : P.iconCollisionBox, C = P.collisionCircleArray;
    if (C.length > 0) {
      let E = $.create(), I = T;
      $.mul(E, P.placementInvProjMatrix, r3.transform.glCoordMatrix), $.mul(E, E, P.placementViewportMatrix), p.push({ circleArray: C, circleOffset: f, transform: I, invTransform: E, coord: _ }), h += C.length / 4, f = h;
    }
    L && c.draw(s3, l.LINES, ee.disabled, fe.disabled, r3.colorModeForRenderPass(), ue.disabled, Zw(T, r3.transform, S), r3.style.map.terrain && r3.style.map.terrain.getTerrainData(_), t3.id, L.layoutVertexBuffer, L.indexBuffer, L.segments, null, r3.transform.zoom, null, null, L.collisionVertexBuffer);
  }
  if (!a || !p.length) return;
  let m = r3.useProgram("collisionCircle"), y = new _l();
  y.resize(h * 4), y._trim();
  let g = 0;
  for (let w of p) for (let _ = 0; _ < w.circleArray.length / 4; _++) {
    let S = _ * 4, P = w.circleArray[S + 0], T = w.circleArray[S + 1], L = w.circleArray[S + 2], C = w.circleArray[S + 3];
    y.emplace(g++, P, T, L, C, 0), y.emplace(g++, P, T, L, C, 1), y.emplace(g++, P, T, L, C, 2), y.emplace(g++, P, T, L, C, 3);
  }
  (!Mc || Mc.length < h * 2) && (Mc = ML(h));
  let x = s3.createIndexBuffer(Mc, true), b = s3.createVertexBuffer(y, y0.members, true);
  for (let w of p) {
    let _ = Hw(w.transform, w.invTransform, r3.transform);
    m.draw(s3, l.TRIANGLES, ee.disabled, fe.disabled, r3.colorModeForRenderPass(), ue.disabled, _, r3.style.map.terrain && r3.style.map.terrain.getTerrainData(w.coord), t3.id, b, x, me.simpleSegment(0, w.circleOffset * 2, w.circleArray.length, w.circleArray.length / 2), null, r3.transform.zoom, null, null, null);
  }
  b.destroy(), x.destroy();
}
r(gg, "drawCollisionDebug");
function ML(r3) {
  let e = r3 * 2, t3 = new wl();
  t3.resize(e), t3._trim();
  for (let i = 0; i < e; i++) {
    let n = i * 6;
    t3.uint16[n + 0] = i * 4 + 0, t3.uint16[n + 1] = i * 4 + 1, t3.uint16[n + 2] = i * 4 + 2, t3.uint16[n + 3] = i * 4 + 2, t3.uint16[n + 4] = i * 4 + 3, t3.uint16[n + 5] = i * 4 + 0;
  }
  return t3;
}
r(ML, "createQuadTriangles");
var AL = $.identity(new Float32Array(16));
function AS(r3, e, t3, i, n) {
  if (r3.renderPass !== "translucent") return;
  let o = fe.disabled, a = r3.colorModeForRenderPass();
  (t3._unevaluatedLayout.hasValue("text-variable-anchor") || t3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && CL(i, r3, t3, e, t3.layout.get("text-rotation-alignment"), t3.layout.get("text-pitch-alignment"), n), t3.paint.get("icon-opacity").constantOr(1) !== 0 && TS(r3, e, t3, i, false, t3.paint.get("icon-translate"), t3.paint.get("icon-translate-anchor"), t3.layout.get("icon-rotation-alignment"), t3.layout.get("icon-pitch-alignment"), t3.layout.get("icon-keep-upright"), o, a), t3.paint.get("text-opacity").constantOr(1) !== 0 && TS(r3, e, t3, i, true, t3.paint.get("text-translate"), t3.paint.get("text-translate-anchor"), t3.layout.get("text-rotation-alignment"), t3.layout.get("text-pitch-alignment"), t3.layout.get("text-keep-upright"), o, a), e.map.showCollisionBoxes && (gg(r3, e, t3, i, t3.paint.get("text-translate"), t3.paint.get("text-translate-anchor"), true), gg(r3, e, t3, i, t3.paint.get("icon-translate"), t3.paint.get("icon-translate-anchor"), false));
}
r(AS, "drawSymbols");
function IL(r3, e, t3, i, n, o) {
  let { horizontalAlign: a, verticalAlign: s3 } = Xl(r3), l = -(a - 0.5) * e, c = -(s3 - 0.5) * t3;
  return new xg.default((l / n + i[0]) * o, (c / n + i[1]) * o);
}
r(IL, "calculateVariableRenderShift");
function CL(r3, e, t3, i, n, o, a) {
  let s3 = e.transform, l = n === "map", c = o === "map";
  for (let p of r3) {
    let h = i.getTile(p), f = h.getBucket(t3);
    if (!f || !f.text || !f.text.segments.get().length) continue;
    let m = f.textSizeData, y = mi(m, s3.zoom), g = He(h, 1, e.transform.zoom), x = ga(p.posMatrix, c, l, e.transform, g), b = t3.layout.get("icon-text-fit") !== "none" && f.hasIconData();
    if (y) {
      let w = Math.pow(2, s3.zoom - h.tileID.overscaledZ), _ = e.style.map.terrain ? (S, P) => e.style.map.terrain.getElevation(p, S, P) : null;
      EL(f, l, c, a, s3, x, p.posMatrix, w, y, b, _);
    }
  }
}
r(CL, "updateVariableAnchors");
function EL(r3, e, t3, i, n, o, a, s3, l, c, p) {
  let h = r3.text.placedSymbolArray, f = r3.text.dynamicLayoutVertexArray, m = r3.icon.dynamicLayoutVertexArray, y = {};
  f.clear();
  for (let g = 0; g < h.length; g++) {
    let x = h.get(g), b = r3.allowVerticalPlacement && !x.placedOrientation, w = !x.hidden && x.crossTileID && !b ? i[x.crossTileID] : null;
    if (!w) _i(x.numGlyphs, f);
    else {
      let _ = new xg.default(x.anchorX, x.anchorY), S = bt(_, t3 ? a : o, p), P = xa(n.cameraToCenterDistance, S.signedDistanceFromCamera), T = hn(r3.textSizeData, l, x) * P / Lr;
      t3 && (T *= r3.tilePixelRatio / s3);
      let { width: L, height: C, anchor: E, textOffset: I, textBoxScale: R } = w, z = IL(E, L, C, I, R, T), k = t3 ? bt(_.add(z), o, p).point : S.point.add(e ? z.rotate(-n.angle) : z), M = r3.allowVerticalPlacement && x.placedOrientation === 2 ? Math.PI / 2 : 0;
      for (let G = 0; G < x.numGlyphs; G++) di(f, k, M);
      c && x.associatedIconIndex >= 0 && (y[x.associatedIconIndex] = { shiftedAnchor: k, angle: M });
    }
  }
  if (c) {
    m.clear();
    let g = r3.icon.placedSymbolArray;
    for (let x = 0; x < g.length; x++) {
      let b = g.get(x);
      if (b.hidden) _i(b.numGlyphs, m);
      else {
        let w = y[x];
        if (!w) _i(b.numGlyphs, m);
        else for (let _ = 0; _ < b.numGlyphs; _++) di(m, w.shiftedAnchor, w.angle);
      }
    }
    r3.icon.dynamicLayoutVertexBuffer.updateData(m);
  }
  r3.text.dynamicLayoutVertexBuffer.updateData(f);
}
r(EL, "updateVariableAnchorsForBucket");
function kL(r3, e, t3) {
  return t3.iconsInText && e ? "symbolTextAndIcon" : r3 ? "symbolSDF" : "symbolIcon";
}
r(kL, "getSymbolProgramName");
function TS(r3, e, t3, i, n, o, a, s3, l, c, p, h) {
  let f = r3.context, m = f.gl, y = r3.transform, g = s3 === "map", x = l === "map", b = s3 !== "viewport" && t3.layout.get("symbol-placement") !== "point", w = g && !x && !b, _ = !t3.layout.get("symbol-sort-key").isConstant(), S = false, P = r3.depthModeForSublayer(0, ee.ReadOnly), T = t3._unevaluatedLayout.hasValue("text-variable-anchor") || t3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), L = [];
  for (let C of i) {
    let E = e.getTile(C), I = E.getBucket(t3);
    if (!I) continue;
    let R = n ? I.text : I.icon;
    if (!R || !R.segments.get().length || !R.hasVisibleVertices) continue;
    let z = R.programConfigurations.get(t3.id), k = n || I.sdfIcons, M = n ? I.textSizeData : I.iconSizeData, G = x || y.pitch !== 0, K = r3.useProgram(kL(k, n, I), z), ne = mi(M, y.zoom), J = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(C), W, Je = [0, 0], Ve, ce, Me = null, Ye;
    if (n) {
      if (Ve = E.glyphAtlasTexture, ce = m.LINEAR, W = E.glyphAtlasTexture.size, I.iconsInText) {
        Je = E.imageAtlasTexture.size, Me = E.imageAtlasTexture;
        let je = M.kind === "composite" || M.kind === "camera";
        Ye = G || r3.options.rotating || r3.options.zooming || je ? m.LINEAR : m.NEAREST;
      }
    } else {
      let je = t3.layout.get("icon-size").constantOr(0) !== 1 || I.iconsNeedLinear;
      Ve = E.imageAtlasTexture, ce = k || r3.options.rotating || r3.options.zooming || je || G ? m.LINEAR : m.NEAREST, W = E.imageAtlasTexture.size;
    }
    let fr = He(E, 1, r3.transform.zoom), mr = ga(C.posMatrix, x, g, r3.transform, fr), zt = Pu(C.posMatrix, x, g, r3.transform, fr), Wt = T && I.hasTextData(), Nr = t3.layout.get("icon-text-fit") !== "none" && Wt && I.hasIconData();
    if (b) {
      let je = r3.style.map.terrain ? (Jt, $r) => r3.style.map.terrain.getElevation(C, Jt, $r) : null, ct = t3.layout.get("text-rotation-alignment") === "map";
      d1(I, C.posMatrix, r3, n, mr, zt, x, c, ct, je);
    }
    let Xt = r3.translatePosMatrix(C.posMatrix, E, o, a), Kt = b || n && T || Nr ? AL : mr, Qe = r3.translatePosMatrix(zt, E, o, a, true), nt = k && t3.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, et;
    k ? I.iconsInText ? et = xS(M.kind, ne, w, x, r3, Xt, Kt, Qe, W, Je) : et = Ty(M.kind, ne, w, x, r3, Xt, Kt, Qe, n, W, true) : et = Py(M.kind, ne, w, x, r3, Xt, Kt, Qe, n, W);
    let Gr = { program: K, buffers: R, uniformValues: et, atlasTexture: Ve, atlasTextureIcon: Me, atlasInterpolation: ce, atlasInterpolationIcon: Ye, isSDF: k, hasHalo: nt };
    if (_ && I.canOverlap) {
      S = true;
      let je = R.segments.get();
      for (let ct of je) L.push({ segments: new me([ct]), sortKey: ct.sortKey, state: Gr, terrainData: J });
    } else L.push({ segments: R.segments, sortKey: 0, state: Gr, terrainData: J });
  }
  S && L.sort((C, E) => C.sortKey - E.sortKey);
  for (let C of L) {
    let E = C.state;
    if (f.activeTexture.set(m.TEXTURE0), E.atlasTexture.bind(E.atlasInterpolation, m.CLAMP_TO_EDGE), E.atlasTextureIcon && (f.activeTexture.set(m.TEXTURE1), E.atlasTextureIcon && E.atlasTextureIcon.bind(E.atlasInterpolationIcon, m.CLAMP_TO_EDGE)), E.isSDF) {
      let I = E.uniformValues;
      E.hasHalo && (I.u_is_halo = 1, MS(E.buffers, C.segments, t3, r3, E.program, P, p, h, I, C.terrainData)), I.u_is_halo = 0;
    }
    MS(E.buffers, C.segments, t3, r3, E.program, P, p, h, E.uniformValues, C.terrainData);
  }
}
r(TS, "drawLayerSymbols");
function MS(r3, e, t3, i, n, o, a, s3, l, c) {
  let p = i.context, h = p.gl;
  n.draw(p, h.TRIANGLES, o, a, s3, ue.disabled, l, c, t3.id, r3.layoutVertexBuffer, r3.indexBuffer, e, t3.paint, i.transform.zoom, r3.programConfigurations.get(t3.id), r3.dynamicLayoutVertexBuffer, r3.opacityVertexBuffer);
}
r(MS, "drawSymbolElements");
q();
function IS(r3, e, t3, i) {
  if (r3.renderPass !== "translucent") return;
  let n = t3.paint.get("circle-opacity"), o = t3.paint.get("circle-stroke-width"), a = t3.paint.get("circle-stroke-opacity"), s3 = !t3.layout.get("circle-sort-key").isConstant();
  if (n.constantOr(1) === 0 && (o.constantOr(1) === 0 || a.constantOr(1) === 0)) return;
  let l = r3.context, c = l.gl, p = r3.depthModeForSublayer(0, ee.ReadOnly), h = fe.disabled, f = r3.colorModeForRenderPass(), m = [];
  for (let y = 0; y < i.length; y++) {
    let g = i[y], x = e.getTile(g), b = x.getBucket(t3);
    if (!b) continue;
    let w = b.programConfigurations.get(t3.id), _ = r3.useProgram("circle", w), S = b.layoutVertexBuffer, P = b.indexBuffer, T = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(g), L = $w(r3, g, x, t3), C = { programConfiguration: w, program: _, layoutVertexBuffer: S, indexBuffer: P, uniformValues: L, terrainData: T };
    if (s3) {
      let E = b.segments.get();
      for (let I of E) m.push({ segments: new me([I]), sortKey: I.sortKey, state: C });
    } else m.push({ segments: b.segments, sortKey: 0, state: C });
  }
  s3 && m.sort((y, g) => y.sortKey - g.sortKey);
  for (let y of m) {
    let { programConfiguration: g, program: x, layoutVertexBuffer: b, indexBuffer: w, uniformValues: _, terrainData: S } = y.state, P = y.segments;
    x.draw(l, c.TRIANGLES, p, h, f, ue.disabled, _, S, t3.id, b, w, P, t3.paint, r3.transform.zoom, g);
  }
}
r(IS, "drawCircles");
q();
function CS(r3, e, t3, i) {
  if (t3.paint.get("heatmap-opacity") !== 0) if (r3.renderPass === "offscreen") {
    let n = r3.context, o = n.gl, a = fe.disabled, s3 = new Ee([o.ONE, o.ONE], X.transparent, [true, true, true, true]);
    LL(n, r3, t3), n.clear({ color: X.transparent });
    for (let l = 0; l < i.length; l++) {
      let c = i[l];
      if (e.hasRenderableParent(c)) continue;
      let p = e.getTile(c), h = p.getBucket(t3);
      if (!h) continue;
      let f = h.programConfigurations.get(t3.id), m = r3.useProgram("heatmap", f), { zoom: y } = r3.transform;
      m.draw(n, o.TRIANGLES, ee.disabled, a, s3, ue.disabled, Yw(c.posMatrix, p, y, t3.paint.get("heatmap-intensity")), null, t3.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, t3.paint, r3.transform.zoom, f);
    }
    n.viewport.set([0, 0, r3.width, r3.height]);
  } else r3.renderPass === "translucent" && (r3.context.setColorMode(r3.colorModeForRenderPass()), zL(r3, t3));
}
r(CS, "drawHeatmap");
function LL(r3, e, t3) {
  let i = r3.gl;
  r3.activeTexture.set(i.TEXTURE1), r3.viewport.set([0, 0, e.width / 4, e.height / 4]);
  let n = t3.heatmapFbo;
  if (n) i.bindTexture(i.TEXTURE_2D, n.colorAttachment.get()), r3.bindFramebuffer.set(n.framebuffer);
  else {
    let o = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), n = t3.heatmapFbo = r3.createFramebuffer(e.width / 4, e.height / 4, false, false), DL(r3, e, o, n);
  }
}
r(LL, "bindFramebuffer");
function DL(r3, e, t3, i) {
  var s3, l;
  let n = r3.gl, o = (s3 = r3.HALF_FLOAT) != null ? s3 : n.UNSIGNED_BYTE, a = (l = r3.RGBA16F) != null ? l : n.RGBA;
  n.texImage2D(n.TEXTURE_2D, 0, a, e.width / 4, e.height / 4, 0, n.RGBA, o, null), i.colorAttachment.set(t3);
}
r(DL, "bindTextureToFramebuffer");
function zL(r3, e) {
  let t3 = r3.context, i = t3.gl, n = e.heatmapFbo;
  if (!n) return;
  t3.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, n.colorAttachment.get()), t3.activeTexture.set(i.TEXTURE1);
  let o = e.colorRampTexture;
  o || (o = e.colorRampTexture = new ve(t3, e.colorRamp, i.RGBA)), o.bind(i.LINEAR, i.CLAMP_TO_EDGE), r3.useProgram("heatmapTexture").draw(t3, i.TRIANGLES, ee.disabled, fe.disabled, r3.colorModeForRenderPass(), ue.disabled, Qw(r3, e, 0, 1), null, e.id, r3.viewportBuffer, r3.quadTriangleIndexBuffer, r3.viewportSegments, e.paint, r3.transform.zoom);
}
r(zL, "renderTextureToMap");
q();
function ES(r3, e, t3, i) {
  if (r3.renderPass !== "translucent") return;
  let n = t3.paint.get("line-opacity"), o = t3.paint.get("line-width");
  if (n.constantOr(1) === 0 || o.constantOr(1) === 0) return;
  let a = r3.depthModeForSublayer(0, ee.ReadOnly), s3 = r3.colorModeForRenderPass(), l = t3.paint.get("line-dasharray"), c = t3.paint.get("line-pattern"), p = c.constantOr(1), h = t3.paint.get("line-gradient"), f = t3.getCrossfadeParameters(), m = p ? "linePattern" : l ? "lineSDF" : h ? "lineGradient" : "line", y = r3.context, g = y.gl, x = true;
  for (let b of i) {
    let w = e.getTile(b);
    if (p && !w.patternsLoaded()) continue;
    let _ = w.getBucket(t3);
    if (!_) continue;
    let S = _.programConfigurations.get(t3.id), P = r3.context.program.get(), T = r3.useProgram(m, S), L = x || T.program !== P, C = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(b), E = c.constantOr(null);
    if (E && w.imageAtlas) {
      let z = w.imageAtlas, k = z.patternPositions[E.to.toString()], M = z.patternPositions[E.from.toString()];
      k && M && S.setConstantPatternPositions(k, M);
    }
    let I = C ? b : null, R = p ? uS(r3, w, t3, f, I) : l ? cS(r3, w, t3, l, f, I) : h ? lS(r3, w, t3, _.lineClipsArray.length, I) : Nu(r3, w, t3, I);
    if (p) y.activeTexture.set(g.TEXTURE0), w.imageAtlasTexture.bind(g.LINEAR, g.CLAMP_TO_EDGE), S.updatePaintBuffers(f);
    else if (l && (L || r3.lineAtlas.dirty)) y.activeTexture.set(g.TEXTURE0), r3.lineAtlas.bind(y);
    else if (h) {
      let z = _.gradients[t3.id], k = z.texture;
      if (t3.gradientVersion !== z.version) {
        let M = 256;
        if (t3.stepInterpolant) {
          let G = e.getSource().maxzoom, K = b.canonical.z === G ? Math.ceil(1 << r3.transform.maxZoom - b.canonical.z) : 1, W = _.maxLineLength / 8192 * 1024 * K;
          M = Ae(Kx(W), 256, y.maxTextureSize);
        }
        z.gradient = zl({ expression: t3.gradientExpression(), evaluationKey: "lineProgress", resolution: M, image: z.gradient || void 0, clips: _.lineClipsArray }), z.texture ? z.texture.update(z.gradient) : z.texture = new ve(y, z.gradient, g.RGBA), z.version = t3.gradientVersion, k = z.texture;
      }
      y.activeTexture.set(g.TEXTURE0), k.bind(t3.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE);
    }
    T.draw(y, g.TRIANGLES, a, r3.stencilModeForClipping(b), s3, ue.disabled, R, C, t3.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, t3.paint, r3.transform.zoom, S, _.layoutVertexBuffer2), x = false;
  }
}
r(ES, "drawLine");
q();
q();
function Ac(r3, e, t3, i, n) {
  if (!t3 || !i || !i.imageAtlas) return;
  let o = i.imageAtlas.patternPositions, a = o[t3.to.toString()], s3 = o[t3.from.toString()];
  if (!a && s3 && (a = s3), !s3 && a && (s3 = a), !a || !s3) {
    let l = n.getPaintProperty(e);
    a = o[l], s3 = o[l];
  }
  a && s3 && r3.setConstantPatternPositions(a, s3);
}
r(Ac, "updatePatternPositionsInProgram");
function LS(r3, e, t3, i) {
  let n = t3.paint.get("fill-color"), o = t3.paint.get("fill-opacity");
  if (o.constantOr(1) === 0) return;
  let a = r3.colorModeForRenderPass(), s3 = t3.paint.get("fill-pattern"), l = r3.opaquePassEnabledForLayer() && !s3.constantOr(1) && n.constantOr(X.transparent).a === 1 && o.constantOr(0) === 1 ? "opaque" : "translucent";
  if (r3.renderPass === l) {
    let c = r3.depthModeForSublayer(1, r3.renderPass === "opaque" ? ee.ReadWrite : ee.ReadOnly);
    kS(r3, e, t3, i, c, a, false);
  }
  if (r3.renderPass === "translucent" && t3.paint.get("fill-antialias")) {
    let c = r3.depthModeForSublayer(t3.getPaintProperty("fill-outline-color") ? 2 : 0, ee.ReadOnly);
    kS(r3, e, t3, i, c, a, true);
  }
}
r(LS, "drawFill");
function kS(r3, e, t3, i, n, o, a) {
  let s3 = r3.context.gl, l = "fill-pattern", c = t3.paint.get(l), p = c && c.constantOr(1), h = t3.getCrossfadeParameters(), f, m, y, g, x;
  a ? (m = p && !t3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", f = s3.LINES) : (m = p ? "fillPattern" : "fill", f = s3.TRIANGLES);
  let b = c.constantOr(null);
  for (let w of i) {
    let _ = e.getTile(w);
    if (p && !_.patternsLoaded()) continue;
    let S = _.getBucket(t3);
    if (!S) continue;
    let P = S.programConfigurations.get(t3.id), T = r3.useProgram(m, P), L = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(w);
    p && (r3.context.activeTexture.set(s3.TEXTURE0), _.imageAtlasTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), P.updatePaintBuffers(h)), Ac(P, l, b, _, t3);
    let C = L ? w : null, E = C ? C.posMatrix : w.posMatrix, I = r3.translatePosMatrix(E, _, t3.paint.get("fill-translate"), t3.paint.get("fill-translate-anchor"));
    if (!a) g = S.indexBuffer, x = S.segments, y = p ? vy(I, r3, h, _) : _y(I);
    else {
      g = S.indexBuffer2, x = S.segments2;
      let R = [s3.drawingBufferWidth, s3.drawingBufferHeight];
      y = m === "fillOutlinePattern" && p ? Nw(I, r3, h, _, R) : Uw(I, R);
    }
    T.draw(r3.context, f, n, r3.stencilModeForClipping(w), o, ue.disabled, y, L, t3.id, S.layoutVertexBuffer, g, x, t3.paint, r3.transform.zoom, P);
  }
}
r(kS, "drawFillTiles");
q();
function DS(r3, e, t3, i) {
  let n = t3.paint.get("fill-extrusion-opacity");
  if (n !== 0 && r3.renderPass === "translucent") {
    let o = new ee(r3.context.gl.LEQUAL, ee.ReadWrite, r3.depthRangeFor3D);
    if (n === 1 && !t3.paint.get("fill-extrusion-pattern").constantOr(1)) {
      let a = r3.colorModeForRenderPass();
      bg(r3, e, t3, i, o, fe.disabled, a);
    } else bg(r3, e, t3, i, o, fe.disabled, Ee.disabled), bg(r3, e, t3, i, o, r3.stencilModeFor3D(), r3.colorModeForRenderPass());
  }
}
r(DS, "drawFillExtrusion");
function bg(r3, e, t3, i, n, o, a) {
  let s3 = r3.context, l = s3.gl, c = "fill-extrusion-pattern", p = t3.paint.get(c), h = p.constantOr(1), f = t3.getCrossfadeParameters(), m = t3.paint.get("fill-extrusion-opacity"), y = p.constantOr(null);
  for (let g of i) {
    let x = e.getTile(g), b = x.getBucket(t3);
    if (!b) continue;
    let w = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(g), _ = b.programConfigurations.get(t3.id), S = r3.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", _);
    h && (r3.context.activeTexture.set(l.TEXTURE0), x.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), _.updatePaintBuffers(f)), Ac(_, c, y, x, t3);
    let P = r3.translatePosMatrix(g.posMatrix, x, t3.paint.get("fill-extrusion-translate"), t3.paint.get("fill-extrusion-translate-anchor")), T = t3.paint.get("fill-extrusion-vertical-gradient"), L = h ? Fw(P, r3, T, m, g, f, x) : by(P, r3, T, m);
    S.draw(s3, s3.gl.TRIANGLES, n, o, a, ue.backCCW, L, w, t3.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, t3.paint, r3.transform.zoom, _, r3.style.map.terrain && b.centroidVertexBuffer);
  }
}
r(bg, "drawExtrusionTiles");
q();
function zS(r3, e, t3, i) {
  if (r3.renderPass !== "offscreen" && r3.renderPass !== "translucent") return;
  let n = r3.context, o = r3.depthModeForSublayer(0, ee.ReadOnly), a = r3.colorModeForRenderPass(), [s3, l] = r3.renderPass === "translucent" ? r3.stencilConfigForOverlap(i) : [{}, i];
  for (let c of l) {
    let p = e.getTile(c);
    typeof p.needsHillshadePrepare < "u" && p.needsHillshadePrepare && r3.renderPass === "offscreen" ? RL(r3, p, t3, o, fe.disabled, a) : r3.renderPass === "translucent" && FL(r3, c, p, t3, o, s3[c.overscaledZ], a);
  }
  n.viewport.set([0, 0, r3.width, r3.height]);
}
r(zS, "drawHillshade");
function FL(r3, e, t3, i, n, o, a) {
  let s3 = r3.context, l = s3.gl, c = t3.fbo;
  if (!c) return;
  let p = r3.useProgram("hillshade"), h = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(e);
  s3.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());
  let f = h ? e : null;
  p.draw(s3, l.TRIANGLES, n, o, a, ue.disabled, rS(r3, t3, i, f), h, i.id, r3.rasterBoundsBuffer, r3.quadTriangleIndexBuffer, r3.rasterBoundsSegments);
}
r(FL, "renderHillshade");
function RL(r3, e, t3, i, n, o) {
  let a = r3.context, s3 = a.gl, l = e.dem;
  if (l && l.data) {
    let c = l.dim, p = l.stride, h = l.getPixels();
    if (a.activeTexture.set(s3.TEXTURE1), a.pixelStoreUnpackPremultiplyAlpha.set(false), e.demTexture = e.demTexture || r3.getTileTexture(p), e.demTexture) {
      let m = e.demTexture;
      m.update(h, { premultiply: false }), m.bind(s3.NEAREST, s3.CLAMP_TO_EDGE);
    } else e.demTexture = new ve(a, h, s3.RGBA, { premultiply: false }), e.demTexture.bind(s3.NEAREST, s3.CLAMP_TO_EDGE);
    a.activeTexture.set(s3.TEXTURE0);
    let f = e.fbo;
    if (!f) {
      let m = new ve(a, { width: c, height: c, data: null }, s3.RGBA);
      m.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), f = e.fbo = a.createFramebuffer(c, c, true, false), f.colorAttachment.set(m.texture);
    }
    a.bindFramebuffer.set(f.framebuffer), a.viewport.set([0, 0, c, c]), r3.useProgram("hillshadePrepare").draw(a, s3.TRIANGLES, i, n, o, ue.disabled, iS(e.tileID, l), null, t3.id, r3.rasterBoundsBuffer, r3.quadTriangleIndexBuffer, r3.rasterBoundsSegments), e.needsHillshadePrepare = false;
  }
}
r(RL, "prepareHillshade");
q();
function FS(r3, e, t3, i) {
  if (r3.renderPass !== "translucent" || t3.paint.get("raster-opacity") === 0 || !i.length) return;
  let n = r3.context, o = n.gl, a = e.getSource(), s3 = r3.useProgram("raster"), l = r3.colorModeForRenderPass(), [c, p] = a instanceof Lt ? [{}, i] : r3.stencilConfigForOverlap(i), h = p[p.length - 1].overscaledZ, f = !r3.options.moving;
  for (let m of p) {
    let y = r3.depthModeForSublayer(m.overscaledZ - h, t3.paint.get("raster-opacity") === 1 ? ee.ReadWrite : ee.ReadOnly, o.LESS), g = e.getTile(m);
    g.registerFadeDuration(t3.paint.get("raster-fade-duration"));
    let x = e.findLoadedParent(m, 0), b = BL(g, x, e, t3, r3.transform, r3.style.map.terrain), w, _, S = t3.paint.get("raster-resampling") === "nearest" ? o.NEAREST : o.LINEAR;
    n.activeTexture.set(o.TEXTURE0), g.texture.bind(S, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), n.activeTexture.set(o.TEXTURE1), x ? (x.texture.bind(S, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - g.tileID.overscaledZ), _ = [g.tileID.canonical.x * w % 1, g.tileID.canonical.y * w % 1]) : g.texture.bind(S, o.CLAMP_TO_EDGE, o.LINEAR_MIPMAP_NEAREST);
    let P = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(m), T = P ? m : null, L = T ? T.posMatrix : r3.transform.calculatePosMatrix(m.toUnwrapped(), f), C = mS(L, _ || [0, 0], w || 1, b, t3);
    a instanceof Lt ? s3.draw(n, o.TRIANGLES, y, fe.disabled, l, ue.disabled, C, P, t3.id, a.boundsBuffer, r3.quadTriangleIndexBuffer, a.boundsSegments) : s3.draw(n, o.TRIANGLES, y, c[m.overscaledZ], l, ue.disabled, C, P, t3.id, r3.rasterBoundsBuffer, r3.quadTriangleIndexBuffer, r3.rasterBoundsSegments);
  }
}
r(FS, "drawRaster");
function BL(r3, e, t3, i, n, o) {
  let a = i.paint.get("raster-fade-duration");
  if (!o && a > 0) {
    let s3 = Y.now(), l = (s3 - r3.timeAdded) / a, c = e ? (s3 - e.timeAdded) / a : -1, p = t3.getSource(), h = n.coveringZoomLevel({ tileSize: p.tileSize, roundZoom: p.roundZoom }), f = !e || Math.abs(e.tileID.overscaledZ - h) > Math.abs(r3.tileID.overscaledZ - h), m = f && r3.refreshedUponExpiration ? 1 : Ae(f ? l : 1 - c, 0, 1);
    return r3.refreshedUponExpiration && l >= 1 && (r3.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - m } : { opacity: m, mix: 0 };
  } else return { opacity: 1, mix: 0 };
}
r(BL, "getFadeValues");
q();
function RS(r3, e, t3, i) {
  let n = t3.paint.get("background-color"), o = t3.paint.get("background-opacity");
  if (o === 0) return;
  let a = r3.context, s3 = a.gl, l = r3.transform, c = l.tileSize, p = t3.paint.get("background-pattern");
  if (r3.isPatternMissing(p)) return;
  let h = !p && n.a === 1 && o === 1 && r3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
  if (r3.renderPass !== h) return;
  let f = fe.disabled, m = r3.depthModeForSublayer(0, h === "opaque" ? ee.ReadWrite : ee.ReadOnly), y = r3.colorModeForRenderPass(), g = r3.useProgram(p ? "backgroundPattern" : "background"), x = i || l.coveringTiles({ tileSize: c, terrain: r3.style.map.terrain });
  p && (a.activeTexture.set(s3.TEXTURE0), r3.imageManager.bind(r3.context));
  let b = t3.getCrossfadeParameters();
  for (let w of x) {
    let _ = i ? w.posMatrix : r3.transform.calculatePosMatrix(w.toUnwrapped()), S = p ? wS(_, o, r3, p, { tileID: w, tileSize: c }, b) : vS(_, o, n), P = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(w);
    g.draw(a, s3.TRIANGLES, m, f, y, ue.disabled, S, P, t3.id, r3.tileExtentBuffer, r3.quadTriangleIndexBuffer, r3.tileExtentSegments);
  }
}
r(RS, "drawBackground");
q();
var OL = new X(1, 0, 0, 1);
var VL = new X(0, 1, 0, 1);
var UL = new X(0, 0, 1, 1);
var NL = new X(1, 0, 1, 1);
var GL = new X(0, 1, 1, 1);
function VS(r3) {
  let e = r3.transform.padding, t3 = 3;
  BS(r3, r3.transform.height - (e.top || 0), t3, OL), BS(r3, e.bottom || 0, t3, VL), OS(r3, e.left || 0, t3, UL), OS(r3, r3.transform.width - (e.right || 0), t3, NL);
  let i = r3.transform.centerPoint;
  $L(r3, i.x, r3.transform.height - i.y, GL);
}
r(VS, "drawDebugPadding");
function $L(r3, e, t3, i) {
  Ic(r3, e - 2 / 2, t3 - 20 / 2, 2, 20, i), Ic(r3, e - 20 / 2, t3 - 2 / 2, 20, 2, i);
}
r($L, "drawCrosshair");
function BS(r3, e, t3, i) {
  Ic(r3, 0, e + t3 / 2, r3.transform.width, t3, i);
}
r(BS, "drawHorizontalLine");
function OS(r3, e, t3, i) {
  Ic(r3, e - t3 / 2, 0, t3, r3.transform.height, i);
}
r(OS, "drawVerticalLine");
function Ic(r3, e, t3, i, n, o) {
  let a = r3.context, s3 = a.gl;
  s3.enable(s3.SCISSOR_TEST), s3.scissor(e * r3.pixelRatio, t3 * r3.pixelRatio, i * r3.pixelRatio, n * r3.pixelRatio), a.clear({ color: o }), s3.disable(s3.SCISSOR_TEST);
}
r(Ic, "drawDebugSSRect");
function US(r3, e, t3) {
  for (let i = 0; i < t3.length; i++) qL(r3, e, t3[i]);
}
r(US, "drawDebug");
function qL(r3, e, t3) {
  let i = r3.context, n = i.gl, o = t3.posMatrix, a = r3.useProgram("debug"), s3 = ee.disabled, l = fe.disabled, c = r3.colorModeForRenderPass(), p = "$debug", h = r3.style.map.terrain && r3.style.map.terrain.getTerrainData(t3);
  i.activeTexture.set(n.TEXTURE0);
  let f = e.getTileByID(t3.key).latestRawTileData, m = f && f.byteLength || 0, y = Math.floor(m / 1024), g = e.getTile(t3).tileSize, x = 512 / Math.min(g, 512) * (t3.overscaledZ / r3.transform.zoom) * 0.5, b = t3.canonical.toString();
  t3.overscaledZ !== t3.canonical.z && (b += ` => ${t3.overscaledZ}`);
  let w = `${b} ${y}kB`;
  jL(r3, w), a.draw(i, n.TRIANGLES, s3, l, Ee.alphaBlended, ue.disabled, wy(o, X.transparent, x), null, p, r3.debugBuffer, r3.quadTriangleIndexBuffer, r3.debugSegments), a.draw(i, n.LINE_STRIP, s3, l, c, ue.disabled, wy(o, X.red), h, p, r3.debugBuffer, r3.tileBorderIndexBuffer, r3.debugSegments);
}
r(qL, "drawDebugTile");
function jL(r3, e) {
  r3.initDebugOverlayCanvas();
  let t3 = r3.debugOverlayCanvas, i = r3.context.gl, n = r3.debugOverlayCanvas.getContext("2d");
  n.clearRect(0, 0, t3.width, t3.height), n.shadowColor = "white", n.shadowBlur = 2, n.lineWidth = 1.5, n.strokeStyle = "white", n.textBaseline = "top", n.font = "bold 36px Open Sans, sans-serif", n.fillText(e, 5, 5), n.strokeText(e, 5, 5), r3.debugOverlayTexture.update(t3), r3.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
}
r(jL, "drawTextToOverlay");
function NS(r3, e) {
  let t3 = null, n = Object.values(r3._layers).flatMap((l) => l.source && !l.isHidden(e) ? [r3.sourceCaches[l.source]] : []), o = n.filter((l) => l.getSource().type === "vector"), a = n.filter((l) => l.getSource().type !== "vector"), s3 = r((l) => {
    (!t3 || t3.getSource().maxzoom < l.getSource().maxzoom) && (t3 = l);
  }, "considerSource");
  return o.forEach((l) => s3(l)), t3 || a.forEach((l) => s3(l)), t3;
}
r(NS, "selectDebugSource");
q();
function GS(r3, e, t3) {
  let i = r3.context, n = t3.implementation;
  if (r3.renderPass === "offscreen") {
    let o = n.prerender;
    o && (r3.setCustomLayerDefaults(), i.setColorMode(r3.colorModeForRenderPass()), o.call(n, i.gl, r3.transform.customLayerMatrix()), i.setDirty(), r3.setBaseState());
  } else if (r3.renderPass === "translucent") {
    r3.setCustomLayerDefaults(), i.setColorMode(r3.colorModeForRenderPass()), i.setStencilMode(fe.disabled);
    let o = n.renderingMode === "3d" ? new ee(r3.context.gl.LEQUAL, ee.ReadWrite, r3.depthRangeFor3D) : r3.depthModeForSublayer(0, ee.ReadOnly);
    i.setDepthMode(o), n.render(i.gl, r3.transform.customLayerMatrix()), i.setDirty(), r3.setBaseState(), i.bindFramebuffer.set(null);
  }
}
r(GS, "drawCustom");
q();
function $S(r3, e) {
  let t3 = r3.context, i = t3.gl, n = Ee.unblended, o = new ee(i.LEQUAL, ee.ReadWrite, [0, 1]), a = e.getTerrainMesh(), s3 = e.sourceCache.getRenderableTiles(), l = r3.useProgram("terrainDepth");
  t3.bindFramebuffer.set(e.getFramebuffer("depth").framebuffer), t3.viewport.set([0, 0, r3.width / devicePixelRatio, r3.height / devicePixelRatio]), t3.clear({ color: X.transparent, depth: 1 });
  for (let c of s3) {
    let p = e.getTerrainData(c.tileID), h = r3.transform.calculatePosMatrix(c.tileID.toUnwrapped()), f = Ew(h, e.getMeshFrameDelta(r3.transform.zoom));
    l.draw(t3, i.TRIANGLES, o, fe.disabled, n, ue.backCCW, f, p, "terrain", a.vertexBuffer, a.indexBuffer, a.segments);
  }
  t3.bindFramebuffer.set(null), t3.viewport.set([0, 0, r3.width, r3.height]);
}
r($S, "drawDepth");
function qS(r3, e) {
  let t3 = r3.context, i = t3.gl, n = Ee.unblended, o = new ee(i.LEQUAL, ee.ReadWrite, [0, 1]), a = e.getTerrainMesh(), s3 = e.getCoordsTexture(), l = e.sourceCache.getRenderableTiles(), c = r3.useProgram("terrainCoords");
  t3.bindFramebuffer.set(e.getFramebuffer("coords").framebuffer), t3.viewport.set([0, 0, r3.width / devicePixelRatio, r3.height / devicePixelRatio]), t3.clear({ color: X.transparent, depth: 1 }), e.coordsIndex = [];
  for (let p of l) {
    let h = e.getTerrainData(p.tileID);
    t3.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, s3.texture);
    let f = r3.transform.calculatePosMatrix(p.tileID.toUnwrapped()), m = kw(f, 255 - e.coordsIndex.length, e.getMeshFrameDelta(r3.transform.zoom));
    c.draw(t3, i.TRIANGLES, o, fe.disabled, n, ue.backCCW, m, h, "terrain", a.vertexBuffer, a.indexBuffer, a.segments), e.coordsIndex.push(p.tileID.key);
  }
  t3.bindFramebuffer.set(null), t3.viewport.set([0, 0, r3.width, r3.height]);
}
r(qS, "drawCoords");
function _g(r3, e, t3) {
  let i = r3.context, n = i.gl, o = r3.colorModeForRenderPass(), a = new ee(n.LEQUAL, ee.ReadWrite, r3.depthRangeFor3D), s3 = r3.useProgram("terrain"), l = e.getTerrainMesh();
  i.bindFramebuffer.set(null), i.viewport.set([0, 0, r3.width, r3.height]);
  for (let c of t3) {
    let p = r3.renderToTexture.getTexture(c), h = e.getTerrainData(c.tileID);
    i.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, p.texture);
    let f = r3.transform.calculatePosMatrix(c.tileID.toUnwrapped()), m = Cw(f, e.getMeshFrameDelta(r3.transform.zoom));
    s3.draw(i, n.TRIANGLES, a, fe.disabled, o, ue.backCCW, m, h, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
  }
}
r(_g, "drawTerrain");
var vg = class vg2 {
  constructor(e, t3) {
    this.context = new Tc(e), this.transform = t3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: $.identity(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ur.maxUnderzooming + ur.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vn();
  }
  resize(e, t3, i) {
    if (this.width = Math.floor(e * i), this.height = Math.floor(t3 * i), this.pixelRatio = i, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let n of this.style._order) this.style._layers[n].resize();
  }
  setup() {
    let e = this.context, t3 = new Mr();
    t3.emplaceBack(0, 0), t3.emplaceBack(8192, 0), t3.emplaceBack(0, 8192), t3.emplaceBack(8192, 8192), this.tileExtentBuffer = e.createVertexBuffer(t3, Ru.members), this.tileExtentSegments = me.simpleSegment(0, 0, 4, 2);
    let i = new Mr();
    i.emplaceBack(0, 0), i.emplaceBack(8192, 0), i.emplaceBack(0, 8192), i.emplaceBack(8192, 8192), this.debugBuffer = e.createVertexBuffer(i, Ru.members), this.debugSegments = me.simpleSegment(0, 0, 4, 5);
    let n = new en();
    n.emplaceBack(0, 0, 0, 0), n.emplaceBack(8192, 0, 8192, 0), n.emplaceBack(0, 8192, 0, 8192), n.emplaceBack(8192, 8192, 8192, 8192), this.rasterBoundsBuffer = e.createVertexBuffer(n, Br.members), this.rasterBoundsSegments = me.simpleSegment(0, 0, 4, 2);
    let o = new Mr();
    o.emplaceBack(0, 0), o.emplaceBack(1, 0), o.emplaceBack(0, 1), o.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(o, Ru.members), this.viewportSegments = me.simpleSegment(0, 0, 4, 2);
    let a = new Do();
    a.emplaceBack(0), a.emplaceBack(1), a.emplaceBack(3), a.emplaceBack(2), a.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(a);
    let s3 = new rt();
    s3.emplaceBack(0, 1, 2), s3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s3);
    let l = this.context.gl;
    this.stencilClearMode = new fe({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO);
  }
  clearStencil() {
    let e = this.context, t3 = e.gl;
    this.nextStencilID = 1, this.currentStencilSource = void 0;
    let i = $.create();
    $.ortho(i, 0, this.width, this.height, 0, 0, 1), $.scale(i, i, [t3.drawingBufferWidth, t3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, t3.TRIANGLES, ee.disabled, this.stencilClearMode, Ee.disabled, ue.disabled, Sy(i), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
  }
  _renderTileClippingMasks(e, t3) {
    if (this.currentStencilSource === e.source || !e.isTileClipped() || !t3 || !t3.length) return;
    this.currentStencilSource = e.source;
    let i = this.context, n = i.gl;
    this.nextStencilID + t3.length > 256 && this.clearStencil(), i.setColorMode(Ee.disabled), i.setDepthMode(ee.disabled);
    let o = this.useProgram("clippingMask");
    this._tileClippingMaskIDs = {};
    for (let a of t3) {
      let s3 = this._tileClippingMaskIDs[a.key] = this.nextStencilID++, l = this.style.map.terrain && this.style.map.terrain.getTerrainData(a);
      o.draw(i, n.TRIANGLES, ee.disabled, new fe({ func: n.ALWAYS, mask: 0 }, s3, 255, n.KEEP, n.KEEP, n.REPLACE), Ee.disabled, ue.disabled, Sy(a.posMatrix), l, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
    }
  }
  stencilModeFor3D() {
    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
    let e = this.nextStencilID++, t3 = this.context.gl;
    return new fe({ func: t3.NOTEQUAL, mask: 255 }, e, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
  }
  stencilModeForClipping(e) {
    let t3 = this.context.gl;
    return new fe({ func: t3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, t3.KEEP, t3.KEEP, t3.REPLACE);
  }
  stencilConfigForOverlap(e) {
    let t3 = this.context.gl, i = e.sort((a, s3) => s3.overscaledZ - a.overscaledZ), n = i[i.length - 1].overscaledZ, o = i[0].overscaledZ - n + 1;
    if (o > 1) {
      this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil();
      let a = {};
      for (let s3 = 0; s3 < o; s3++) a[s3 + n] = new fe({ func: t3.GEQUAL, mask: 255 }, s3 + this.nextStencilID, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
      return this.nextStencilID += o, [a, i];
    }
    return [{ [n]: fe.disabled }, i];
  }
  colorModeForRenderPass() {
    let e = this.context.gl;
    return this._showOverdrawInspector ? new Ee([e.CONSTANT_COLOR, e.ONE], new X(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? Ee.unblended : Ee.alphaBlended;
  }
  depthModeForSublayer(e, t3, i) {
    if (!this.opaquePassEnabledForLayer()) return ee.disabled;
    let n = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
    return new ee(i || this.context.gl.LEQUAL, t3, [n, n]);
  }
  opaquePassEnabledForLayer() {
    return this.currentLayer < this.opaquePassCutoff;
  }
  render(e, t3) {
    this.style = e, this.options = t3, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(Y.now()), this.imageManager.beginFrame();
    let i = this.style._order, n = this.style.sourceCaches, o = {}, a = {}, s3 = {};
    for (let l in n) {
      let c = n[l];
      c.used && c.prepare(this.context), o[l] = c.getVisibleCoordinates(), a[l] = o[l].slice().reverse(), s3[l] = c.getVisibleCoordinates(true).reverse();
    }
    this.opaquePassCutoff = 1 / 0;
    for (let l = 0; l < i.length; l++) {
      let c = i[l];
      if (this.style._layers[c].is3D()) {
        this.opaquePassCutoff = l;
        break;
      }
    }
    this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
    for (let l of i) {
      let c = this.style._layers[l];
      if (!c.hasOffscreenPass() || c.isHidden(this.transform.zoom)) continue;
      let p = a[c.source];
      c.type !== "custom" && !p.length || this.renderLayer(this, n[c.source], c, p);
    }
    if (this.context.bindFramebuffer.set(null), this.context.clear({ color: t3.showOverdrawInspector ? X.black : X.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = t3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = i.length - 1; this.currentLayer >= 0; this.currentLayer--) {
      let l = this.style._layers[i[this.currentLayer]], c = n[l.source], p = o[l.source];
      this._renderTileClippingMasks(l, p), this.renderLayer(this, c, l, p);
    }
    for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < i.length; this.currentLayer++) {
      let l = this.style._layers[i[this.currentLayer]], c = n[l.source];
      if (this.renderToTexture && this.renderToTexture.renderLayer(l)) continue;
      let p = (l.type === "symbol" ? s3 : a)[l.source];
      this._renderTileClippingMasks(l, o[l.source]), this.renderLayer(this, c, l, p);
    }
    if (this.options.showTileBoundaries) {
      let l = NS(this.style, this.transform.zoom);
      l && US(this, l, l.getVisibleCoordinates());
    }
    this.options.showPadding && VS(this), this.context.setDefault();
  }
  maybeDrawDepthAndCoords(e) {
    if (!this.style || !this.style.map || !this.style.map.terrain) return;
    let t3 = this.terrainFacilitator.matrix, i = this.transform.projMatrix, n = this.terrainFacilitator.dirty;
    n || (n = e ? !$.exactEquals(t3, i) : !$.equals(t3, i)), n || (n = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), n && ($.copy(t3, i), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, $S(this, this.style.map.terrain), qS(this, this.style.map.terrain));
  }
  renderLayer(e, t3, i, n) {
    if (!i.isHidden(this.transform.zoom) && !(i.type !== "background" && i.type !== "custom" && !(n || []).length)) switch (this.id = i.id, i.type) {
      case "symbol":
        AS(e, t3, i, n, this.style.placement.variableOffsets);
        break;
      case "circle":
        IS(e, t3, i, n);
        break;
      case "heatmap":
        CS(e, t3, i, n);
        break;
      case "line":
        ES(e, t3, i, n);
        break;
      case "fill":
        LS(e, t3, i, n);
        break;
      case "fill-extrusion":
        DS(e, t3, i, n);
        break;
      case "hillshade":
        zS(e, t3, i, n);
        break;
      case "raster":
        FS(e, t3, i, n);
        break;
      case "background":
        RS(e, t3, i, n);
        break;
      case "custom":
        GS(e, t3, i);
        break;
    }
  }
  translatePosMatrix(e, t3, i, n, o) {
    if (!i[0] && !i[1]) return e;
    let a = o ? n === "map" ? this.transform.angle : 0 : n === "viewport" ? -this.transform.angle : 0;
    if (a) {
      let c = Math.sin(a), p = Math.cos(a);
      i = [i[0] * p - i[1] * c, i[0] * c + i[1] * p];
    }
    let s3 = [o ? i[0] : He(t3, i[0], this.transform.zoom), o ? i[1] : He(t3, i[1], this.transform.zoom), 0], l = new Float32Array(16);
    return $.translate(l, e, s3), l;
  }
  saveTileTexture(e) {
    let t3 = this._tileTextures[e.size[0]];
    t3 ? t3.push(e) : this._tileTextures[e.size[0]] = [e];
  }
  getTileTexture(e) {
    let t3 = this._tileTextures[e];
    return t3 && t3.length > 0 ? t3.pop() : null;
  }
  isPatternMissing(e) {
    if (!e) return false;
    if (!e.from || !e.to) return true;
    let t3 = this.imageManager.getPattern(e.from.toString()), i = this.imageManager.getPattern(e.to.toString());
    return !t3 || !i;
  }
  useProgram(e, t3) {
    this.cache = this.cache || {};
    let i = e + (t3 ? t3.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
    return this.cache[i] || (this.cache[i] = new Vu(this.context, wi[e], t3, SS[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i];
  }
  setCustomLayerDefaults() {
    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
  }
  setBaseState() {
    let e = this.context.gl;
    this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
  }
  initDebugOverlayCanvas() {
    if (this.debugOverlayCanvas == null) {
      this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512;
      let e = this.context.gl;
      this.debugOverlayTexture = new ve(this.context, this.debugOverlayCanvas, e.RGBA);
    }
  }
  destroy() {
    this.debugOverlayTexture && this.debugOverlayTexture.destroy();
  }
  overLimit() {
    let { drawingBufferWidth: e, drawingBufferHeight: t3 } = this.context.gl;
    return this.width !== e || this.height !== t3;
  }
};
r(vg, "Painter");
var Cc = vg;
q();
var We = u(ge(), 1);
q();
var kc = class kc2 {
  constructor(e, t3) {
    this.points = e;
    this.planes = t3;
  }
  static fromInvProjectionMatrix(e, t3, i) {
    let n = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]], o = Math.pow(2, i), a = n.map((c) => {
      c = $e.transformMat4([], c, e);
      let p = 1 / c[3] / t3 * o;
      return $e.mul(c, c, [p, p, 1 / c[3], p]);
    }), l = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((c) => {
      let p = gt.sub([], a[c[0]], a[c[1]]), h = gt.sub([], a[c[2]], a[c[1]]), f = gt.normalize([], gt.cross([], p, h)), m = -gt.dot(f, a[c[1]]);
      return f.concat(m);
    });
    return new kc2(a, l);
  }
};
r(kc, "Frustum");
var Ec = kc;
var Lc = class Lc2 {
  constructor(e, t3) {
    this.min = e, this.max = t3, this.center = gt.scale([], gt.add([], this.min, this.max), 0.5);
  }
  quadrant(e) {
    let t3 = [e % 2 === 0, e < 2], i = gt.clone(this.min), n = gt.clone(this.max);
    for (let o = 0; o < t3.length; o++) i[o] = t3[o] ? this.min[o] : this.center[o], n[o] = t3[o] ? this.center[o] : this.max[o];
    return n[2] = this.max[2], new Lc2(i, n);
  }
  distanceX(e) {
    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
  }
  distanceY(e) {
    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
  }
  intersects(e) {
    let t3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]], i = true;
    for (let n = 0; n < e.planes.length; n++) {
      let o = e.planes[n], a = 0;
      for (let s3 = 0; s3 < t3.length; s3++) $e.dot(o, t3[s3]) >= 0 && a++;
      if (a === 0) return 0;
      a !== t3.length && (i = false);
    }
    if (i) return 2;
    for (let n = 0; n < 3; n++) {
      let o = Number.MAX_VALUE, a = -Number.MAX_VALUE;
      for (let s3 = 0; s3 < e.points.length; s3++) {
        let l = e.points[s3][n] - this.min[n];
        o = Math.min(o, l), a = Math.max(a, l);
      }
      if (a < 0 || o > this.max[n] - this.min[n]) return 0;
    }
    return 1;
  }
};
r(Lc, "Aabb");
var Aa = Lc;
q();
var jS = u(ge(), 1);
var Dc = class Dc2 {
  constructor(e = 0, t3 = 0, i = 0, n = 0) {
    if (isNaN(e) || e < 0 || isNaN(t3) || t3 < 0 || isNaN(i) || i < 0 || isNaN(n) || n < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    this.top = e, this.bottom = t3, this.left = i, this.right = n;
  }
  interpolate(e, t3, i) {
    return t3.top != null && e.top != null && (this.top = Pe.number(e.top, t3.top, i)), t3.bottom != null && e.bottom != null && (this.bottom = Pe.number(e.bottom, t3.bottom, i)), t3.left != null && e.left != null && (this.left = Pe.number(e.left, t3.left, i)), t3.right != null && e.right != null && (this.right = Pe.number(e.right, t3.right, i)), this;
  }
  getCenter(e, t3) {
    let i = Ae((this.left + e - this.right) / 2, 0, e), n = Ae((this.top + t3 - this.bottom) / 2, 0, t3);
    return new jS.default(i, n);
  }
  equals(e) {
    return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
  }
  clone() {
    return new Dc2(this.top, this.bottom, this.left, this.right);
  }
  toJSON() {
    return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
  }
};
r(Dc, "EdgeInsets");
var Ia = Dc;
var zc = 85.051129;
var Rc = class Rc2 {
  constructor(e, t3, i, n, o) {
    this.tileSize = 512, this._renderWorldCopies = o === void 0 ? true : !!o, this._minZoom = e || 0, this._maxZoom = t3 || 22, this._minPitch = i == null ? 0 : i, this._maxPitch = n == null ? 60 : n, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new ie(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new Ia(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
  }
  clone() {
    let e = new Rc2(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
    return e.apply(this), e;
  }
  apply(e) {
    this.tileSize = e.tileSize, this.latRange = e.latRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
  }
  get minZoom() {
    return this._minZoom;
  }
  set minZoom(e) {
    this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
  }
  get maxZoom() {
    return this._maxZoom;
  }
  set maxZoom(e) {
    this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(e) {
    this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(e) {
    this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  set renderWorldCopies(e) {
    e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
  }
  get worldSize() {
    return this.tileSize * this.scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new We.default(this.width, this.height);
  }
  get bearing() {
    return -this.angle / Math.PI * 180;
  }
  set bearing(e) {
    let t3 = -Qt(e, -180, 180) * Math.PI / 180;
    this.angle !== t3 && (this._unmodified = false, this.angle = t3, this._calcMatrices(), this.rotationMatrix = Bo.create(), Bo.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
  }
  get pitch() {
    return this._pitch / Math.PI * 180;
  }
  set pitch(e) {
    let t3 = Ae(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
    this._pitch !== t3 && (this._unmodified = false, this._pitch = t3, this._calcMatrices());
  }
  get fov() {
    return this._fov / Math.PI * 180;
  }
  set fov(e) {
    e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = false, this._fov = e / 180 * Math.PI, this._calcMatrices());
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(e) {
    let t3 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
    this._zoom !== t3 && (this._unmodified = false, this._zoom = t3, this.tileZoom = Math.max(0, Math.floor(t3)), this.scale = this.zoomScale(t3), this._constrain(), this._calcMatrices());
  }
  get center() {
    return this._center;
  }
  set center(e) {
    e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
  }
  get elevation() {
    return this._elevation;
  }
  set elevation(e) {
    e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  set padding(e) {
    this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
  }
  get centerPoint() {
    return this._edgeInsets.getCenter(this.width, this.height);
  }
  isPaddingEqual(e) {
    return this._edgeInsets.equals(e);
  }
  interpolatePadding(e, t3, i) {
    this._unmodified = false, this._edgeInsets.interpolate(e, t3, i), this._constrain(), this._calcMatrices();
  }
  coveringZoomLevel(e) {
    let t3 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
    return Math.max(0, t3);
  }
  getVisibleUnwrappedCoordinates(e) {
    let t3 = [new gn(0, e)];
    if (this._renderWorldCopies) {
      let i = this.pointCoordinate(new We.default(0, 0)), n = this.pointCoordinate(new We.default(this.width, 0)), o = this.pointCoordinate(new We.default(this.width, this.height)), a = this.pointCoordinate(new We.default(0, this.height)), s3 = Math.floor(Math.min(i.x, n.x, o.x, a.x)), l = Math.floor(Math.max(i.x, n.x, o.x, a.x)), c = 1;
      for (let p = s3 - c; p <= l + c; p++) p !== 0 && t3.push(new gn(p, e));
    }
    return t3;
  }
  coveringTiles(e) {
    var b, w;
    let t3 = this.coveringZoomLevel(e), i = t3;
    if (e.minzoom !== void 0 && t3 < e.minzoom) return [];
    e.maxzoom !== void 0 && t3 > e.maxzoom && (t3 = e.maxzoom);
    let n = this.pointCoordinate(this.getCameraPoint()), o = Fe.fromLngLat(this.center), a = Math.pow(2, t3), s3 = [a * n.x, a * n.y, 0], l = [a * o.x, a * o.y, 0], c = Ec.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t3), p = e.minzoom || 0;
    !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (p = t3);
    let h = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, f = r((_) => ({ aabb: new Aa([_ * a, 0, 0], [(_ + 1) * a, a, 0]), zoom: 0, x: 0, y: 0, wrap: _, fullyVisible: false }), "newRootTile"), m = [], y = [], g = t3, x = e.reparseOverscaled ? i : t3;
    if (this._renderWorldCopies) for (let _ = 1; _ <= 3; _++) m.push(f(-_)), m.push(f(_));
    for (m.push(f(0)); m.length > 0; ) {
      let _ = m.pop(), S = _.x, P = _.y, T = _.fullyVisible;
      if (!T) {
        let z = _.aabb.intersects(c);
        if (z === 0) continue;
        T = z === 2;
      }
      let L = e.terrain ? s3 : l, C = _.aabb.distanceX(L), E = _.aabb.distanceY(L), I = Math.max(Math.abs(C), Math.abs(E)), R = h + (1 << g - _.zoom) - 2;
      if (_.zoom === g || I > R && _.zoom >= p) {
        let z = g - _.zoom, k = s3[0] - 0.5 - (S << z), M = s3[1] - 0.5 - (P << z);
        y.push({ tileID: new Ke(_.zoom === g ? x : _.zoom, _.wrap, _.zoom, S, P), distanceSq: nn.sqrLen([l[0] - 0.5 - S, l[1] - 0.5 - P]), tileDistanceToCamera: Math.sqrt(k * k + M * M) });
        continue;
      }
      for (let z = 0; z < 4; z++) {
        let k = (S << 1) + z % 2, M = (P << 1) + (z >> 1), G = _.zoom + 1, K = _.aabb.quadrant(z);
        if (e.terrain) {
          let ne = new Ke(G, _.wrap, G, k, M), J = e.terrain.getMinMaxElevation(ne), W = (b = J.minElevation) != null ? b : this.elevation, Je = (w = J.maxElevation) != null ? w : this.elevation;
          K = new Aa([K.min[0], K.min[1], W], [K.max[0], K.max[1], Je]);
        }
        m.push({ aabb: K, zoom: G, x: k, y: M, wrap: _.wrap, fullyVisible: T });
      }
    }
    return y.sort((_, S) => _.distanceSq - S.distanceSq).map((_) => _.tileID);
  }
  resize(e, t3) {
    this.width = e, this.height = t3, this.pixelsToGLUnits = [2 / e, -2 / t3], this._constrain(), this._calcMatrices();
  }
  get unmodified() {
    return this._unmodified;
  }
  zoomScale(e) {
    return Math.pow(2, e);
  }
  scaleZoom(e) {
    return Math.log(e) / Math.LN2;
  }
  project(e) {
    let t3 = Ae(e.lat, -zc, zc);
    return new We.default(Fr(e.lng) * this.worldSize, Rr(t3) * this.worldSize);
  }
  unproject(e) {
    return new Fe(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
  }
  get point() {
    return this.project(this.center);
  }
  getCameraPosition() {
    let e = this.pointLocation(this.getCameraPoint()), t3 = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;
    return { lngLat: e, altitude: t3 + this.elevation };
  }
  recalculateZoom(e) {
    let t3 = this.elevation, i = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, n = this.pointLocation(this.centerPoint, e), o = e.getElevationForLngLatZoom(n, this.tileZoom);
    if (!(this.elevation - o)) return;
    let s3 = i + t3 - o, p = Math.cos(this._pitch) * this.cameraToCenterDistance / s3 / gu(1, n.lat) / this.tileSize, h = this.scaleZoom(p);
    this._elevation = o, this._center = n, this.zoom = h;
  }
  setLocationAtPoint(e, t3) {
    let i = this.pointCoordinate(t3), n = this.pointCoordinate(this.centerPoint), o = this.locationCoordinate(e), a = new Fe(o.x - (i.x - n.x), o.y - (i.y - n.y));
    this.center = this.coordinateLocation(a), this._renderWorldCopies && (this.center = this.center.wrap());
  }
  locationPoint(e, t3) {
    return t3 ? this.coordinatePoint(this.locationCoordinate(e), t3.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
  }
  pointLocation(e, t3) {
    return this.coordinateLocation(this.pointCoordinate(e, t3));
  }
  locationCoordinate(e) {
    return Fe.fromLngLat(e);
  }
  coordinateLocation(e) {
    return e && e.toLngLat();
  }
  pointCoordinate(e, t3) {
    if (t3) {
      let g = t3.pointCoordinate(e);
      if (g != null) return g;
    }
    let i = 0, n = [e.x, e.y, 0, 1], o = [e.x, e.y, 1, 1];
    $e.transformMat4(n, n, this.pixelMatrixInverse), $e.transformMat4(o, o, this.pixelMatrixInverse);
    let a = n[3], s3 = o[3], l = n[0] / a, c = o[0] / s3, p = n[1] / a, h = o[1] / s3, f = n[2] / a, m = o[2] / s3, y = f === m ? 0 : (i - f) / (m - f);
    return new Fe(Pe.number(l, c, y) / this.worldSize, Pe.number(p, h, y) / this.worldSize);
  }
  coordinatePoint(e, t3 = 0, i = this.pixelMatrix) {
    let n = [e.x * this.worldSize, e.y * this.worldSize, t3, 1];
    return $e.transformMat4(n, n, i), new We.default(n[0] / n[3], n[1] / n[3]);
  }
  getBounds() {
    let e = Math.max(0, this.height / 2 - this.getHorizon());
    return new ut().extend(this.pointLocation(new We.default(0, e))).extend(this.pointLocation(new We.default(this.width, e))).extend(this.pointLocation(new We.default(this.width, this.height))).extend(this.pointLocation(new We.default(0, this.height)));
  }
  getMaxBounds() {
    return !this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2 ? null : new ut([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);
  }
  getHorizon() {
    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
  }
  setMaxBounds(e) {
    e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-zc, zc]);
  }
  calculatePosMatrix(e, t3 = false) {
    let i = e.key, n = t3 ? this._alignedPosMatrixCache : this._posMatrixCache;
    if (n[i]) return n[i];
    let o = e.canonical, a = this.worldSize / this.zoomScale(o.z), s3 = o.x + Math.pow(2, o.z) * e.wrap, l = $.identity(new Float64Array(16));
    return $.translate(l, l, [s3 * a, o.y * a, 0]), $.scale(l, l, [a / 8192, a / 8192, 1]), $.multiply(l, t3 ? this.alignedProjMatrix : this.projMatrix, l), n[i] = new Float32Array(l), n[i];
  }
  customLayerMatrix() {
    return this.mercatorMatrix.slice();
  }
  getConstrained(e, t3) {
    t3 = Ae(+t3, this.minZoom, this.maxZoom);
    let i = { center: new ie(e.lng, e.lat), zoom: t3 }, n = this.lngRange;
    if (!this._renderWorldCopies && n === null) {
      let _ = 179.9999999999;
      n = [-_, _];
    }
    let o = this.tileSize * this.zoomScale(i.zoom), a = 0, s3 = o, l = 0, c = o, p = 0, h = 0, { x: f, y: m } = this.size;
    if (this.latRange) {
      let _ = this.latRange;
      a = Rr(_[1]) * o, s3 = Rr(_[0]) * o, s3 - a < m && (p = m / (s3 - a));
    }
    n && (l = Qt(Fr(n[0]) * o, 0, o), c = Qt(Fr(n[1]) * o, 0, o), c < l && (c += o), c - l < f && (h = f / (c - l)));
    let { x: y, y: g } = this.project.call({ worldSize: o }, e), x, b, w = Math.max(h || 0, p || 0);
    if (w) {
      let _ = new We.default(h ? (c + l) / 2 : y, p ? (s3 + a) / 2 : g);
      return i.center = this.unproject.call({ worldSize: o }, _).wrap(), i.zoom += this.scaleZoom(w), i;
    }
    if (this.latRange) {
      let _ = m / 2;
      g - _ < a && (b = a + _), g + _ > s3 && (b = s3 - _);
    }
    if (n) {
      let _ = (l + c) / 2, S = y;
      this._renderWorldCopies && (S = Qt(y, _ - o / 2, _ + o / 2));
      let P = f / 2;
      S - P < l && (x = l + P), S + P > c && (x = c - P);
    }
    if (x !== void 0 || b !== void 0) {
      let _ = new We.default(x != null ? x : y, b != null ? b : g);
      i.center = this.unproject.call({ worldSize: o }, _).wrap();
    }
    return i;
  }
  _constrain() {
    if (!this.center || !this.width || !this.height || this._constraining) return;
    this._constraining = true;
    let e = this._unmodified, { center: t3, zoom: i } = this.getConstrained(this.center, this.zoom);
    this.center = t3, this.zoom = i, this._unmodified = e, this._constraining = false;
  }
  _calcMatrices() {
    if (!this.height) return;
    let e = this._fov / 2, t3 = this.centerOffset, i = this.point.x, n = this.point.y;
    this.cameraToCenterDistance = 0.5 / Math.tan(e) * this.height, this._pixelPerMeter = gu(1, this.center.lat) * this.worldSize;
    let o = $.identity(new Float64Array(16));
    $.scale(o, o, [this.width / 2, -this.height / 2, 1]), $.translate(o, o, [1, -1, 0]), this.labelPlaneMatrix = o, o = $.identity(new Float64Array(16)), $.scale(o, o, [1, -1, 1]), $.translate(o, o, [-1, -1, 0]), $.scale(o, o, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = o;
    let a = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), s3 = Math.min(this.elevation, this.minElevationForCurrentTile), l = a - s3 * this._pixelPerMeter / Math.cos(this._pitch), c = s3 < 0 ? l : a, p = Math.PI / 2 + this._pitch, h = this._fov * (0.5 + t3.y / this.height), f = Math.sin(h) * c / Math.sin(Ae(Math.PI - p - h, 0.01, Math.PI - 0.01)), m = this.getHorizon(), g = 2 * Math.atan(m / this.cameraToCenterDistance) * (0.5 + t3.y / (m * 2)), x = Math.sin(g) * c / Math.sin(Ae(Math.PI - p - g, 0.01, Math.PI - 0.01)), b = Math.min(f, x), w = (Math.cos(Math.PI / 2 - this._pitch) * b + c) * 1.01, _ = this.height / 50;
    o = new Float64Array(16), $.perspective(o, this._fov, this.width / this.height, _, w), o[8] = -t3.x * 2 / this.width, o[9] = t3.y * 2 / this.height, $.scale(o, o, [1, -1, 1]), $.translate(o, o, [0, 0, -this.cameraToCenterDistance]), $.rotateX(o, o, this._pitch), $.rotateZ(o, o, this.angle), $.translate(o, o, [-i, -n, 0]), this.mercatorMatrix = $.scale([], o, [this.worldSize, this.worldSize, this.worldSize]), $.scale(o, o, [1, 1, this._pixelPerMeter]), this.pixelMatrix = $.multiply(new Float64Array(16), this.labelPlaneMatrix, o), $.translate(o, o, [0, 0, -this.elevation]), this.projMatrix = o, this.invProjMatrix = $.invert([], o), this.pixelMatrix3D = $.multiply(new Float64Array(16), this.labelPlaneMatrix, o);
    let S = this.width % 2 / 2, P = this.height % 2 / 2, T = Math.cos(this.angle), L = Math.sin(this.angle), C = i - Math.round(i) + T * S + L * P, E = n - Math.round(n) + T * P + L * S, I = new Float64Array(o);
    if ($.translate(I, I, [C > 0.5 ? C - 1 : C, E > 0.5 ? E - 1 : E, 0]), this.alignedProjMatrix = I, o = $.invert(new Float64Array(16), this.pixelMatrix), !o) throw new Error("failed to invert matrix");
    this.pixelMatrixInverse = o, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
  }
  maxPitchScaleFactor() {
    if (!this.pixelMatrixInverse) return 1;
    let e = this.pointCoordinate(new We.default(0, 0)), t3 = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
    return $e.transformMat4(t3, t3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
  }
  getCameraPoint() {
    let e = this._pitch, t3 = Math.tan(e) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new We.default(0, t3));
  }
  getCameraQueryGeometry(e) {
    let t3 = this.getCameraPoint();
    if (e.length === 1) return [e[0], t3];
    {
      let i = t3.x, n = t3.y, o = t3.x, a = t3.y;
      for (let s3 of e) i = Math.min(i, s3.x), n = Math.min(n, s3.y), o = Math.max(o, s3.x), a = Math.max(a, s3.y);
      return [new We.default(i, n), new We.default(o, n), new We.default(o, a), new We.default(i, a), new We.default(i, n)];
    }
  }
  lngLatToCameraDepth(e, t3) {
    let i = this.locationCoordinate(e), n = [i.x * this.worldSize, i.y * this.worldSize, t3, 1];
    return $e.transformMat4(n, n, this.projMatrix), n[2] / n[3];
  }
};
r(Rc, "Transform");
var Fc = Rc;
q();
q();
function Bc(r3, e) {
  let t3 = false, i = null, n = null, o, a = r(() => {
    i = null, t3 && (r3.apply(n, o), i = setTimeout(a, e), t3 = false);
  }, "later");
  return (...s3) => (t3 = true, n = this, o = s3, i || a(), i);
}
r(Bc, "throttle");
var wg = class wg2 {
  constructor(e) {
    this._getCurrentHash = () => {
      let e3 = window.location.hash.replace("#", "");
      if (this._hashName) {
        let t3;
        return e3.split("&").map((i) => i.split("=")).forEach((i) => {
          i[0] === this._hashName && (t3 = i);
        }), (t3 && t3[1] || "").split("/");
      }
      return e3.split("/");
    };
    this._onHashChange = () => {
      let e3 = this._getCurrentHash();
      if (e3.length >= 3 && !e3.some((t3) => isNaN(t3))) {
        let t3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
        return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t3, pitch: +(e3[4] || 0) }), true;
      }
      return false;
    };
    this._updateHashUnthrottled = () => {
      let e3 = window.location.href.replace(/(#.+)?$/, this.getHashString());
      try {
        window.history.replaceState(window.history.state, null, e3);
      } catch {
      }
    };
    this._updateHash = Bc(this._updateHashUnthrottled, 30 * 1e3 / 100);
    this._hashName = e && encodeURIComponent(e);
  }
  addTo(e) {
    return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
  }
  remove() {
    return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
  }
  getHashString(e) {
    let t3 = this._map.getCenter(), i = Math.round(this._map.getZoom() * 100) / 100, n = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o = Math.pow(10, n), a = Math.round(t3.lng * o) / o, s3 = Math.round(t3.lat * o) / o, l = this._map.getBearing(), c = this._map.getPitch(), p = "";
    if (e ? p += `/${a}/${s3}/${i}` : p += `${i}/${s3}/${a}`, (l || c) && (p += `/${Math.round(l * 10) / 10}`), c && (p += `/${Math.round(c)}`), this._hashName) {
      let h = this._hashName, f = false, m = window.location.hash.slice(1).split("&").map((y) => {
        let g = y.split("=")[0];
        return g === h ? (f = true, `${g}=${p}`) : y;
      }).filter((y) => y);
      return f || m.push(`${h}=${p}`), `#${m.join("&")}`;
    }
    return `#${p}`;
  }
};
r(wg, "Hash");
var Ca = wg;
q();
q();
var ZS = u(ge(), 1);
var Nc = { linearity: 0.3, easing: In(0, 0, 0.3, 1) };
var ZL = V({ deceleration: 2500, maxSpeed: 1400 }, Nc);
var HL = V({ deceleration: 20, maxSpeed: 1400 }, Nc);
var WL = V({ deceleration: 1e3, maxSpeed: 360 }, Nc);
var XL = V({ deceleration: 1e3, maxSpeed: 90 }, Nc);
var Sg = class Sg2 {
  constructor(e) {
    this._map = e, this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(e) {
    this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: Y.now(), settings: e });
  }
  _drainInertiaBuffer() {
    let e = this._inertiaBuffer, t3 = Y.now(), i = 160;
    for (; e.length > 0 && t3 - e[0].time > i; ) e.shift();
  }
  _onMoveEnd(e) {
    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
    let t3 = { zoom: 0, bearing: 0, pitch: 0, pan: new ZS.default(0, 0), pinchAround: void 0, around: void 0 };
    for (let { settings: a } of this._inertiaBuffer) t3.zoom += a.zoomDelta || 0, t3.bearing += a.bearingDelta || 0, t3.pitch += a.pitchDelta || 0, a.panDelta && t3.pan._add(a.panDelta), a.around && (t3.around = a.around), a.pinchAround && (t3.pinchAround = a.pinchAround);
    let n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {};
    if (t3.pan.mag()) {
      let a = Vc(t3.pan.mag(), n, V({}, ZL, e || {}));
      o.offset = t3.pan.mult(a.amount / t3.pan.mag()), o.center = this._map.transform.center, Oc(o, a);
    }
    if (t3.zoom) {
      let a = Vc(t3.zoom, n, HL);
      o.zoom = this._map.transform.zoom + a.amount, Oc(o, a);
    }
    if (t3.bearing) {
      let a = Vc(t3.bearing, n, WL);
      o.bearing = this._map.transform.bearing + Ae(a.amount, -179, 179), Oc(o, a);
    }
    if (t3.pitch) {
      let a = Vc(t3.pitch, n, XL);
      o.pitch = this._map.transform.pitch + a.amount, Oc(o, a);
    }
    if (o.zoom || o.bearing) {
      let a = t3.pinchAround === void 0 ? t3.around : t3.pinchAround;
      o.around = a ? this._map.unproject(a) : this._map.getCenter();
    }
    return this.clear(), V(o, { noMoveStart: true });
  }
};
r(Sg, "HandlerInertia");
var Uc = Sg;
function Oc(r3, e) {
  (!r3.duration || r3.duration < e.duration) && (r3.duration = e.duration, r3.easing = e.easing);
}
r(Oc, "extendDuration");
function Vc(r3, e, t3) {
  let { maxSpeed: i, linearity: n, deceleration: o } = t3, a = Ae(r3 * n / (e / 1e3), -i, i), s3 = Math.abs(a) / (o * n);
  return { easing: t3.easing, duration: s3 * 1e3, amount: a * (s3 / 2) };
}
r(Vc, "calculateEasing");
q();
q();
var HS = u(ge(), 1);
var Pg = class Pg2 extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t3, i, n = {}) {
    let o = D.mousePos(t3.getCanvas(), i), a = t3.unproject(o);
    super(e, V({ point: o, lngLat: a, originalEvent: i }, n)), this._defaultPrevented = false, this.target = t3;
  }
};
r(Pg, "MapMouseEvent");
var it = Pg;
var Tg = class Tg2 extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t3, i) {
    let n = e === "touchend" ? i.changedTouches : i.touches, o = D.touchPos(t3.getCanvasContainer(), n), a = o.map((c) => t3.unproject(c)), s3 = o.reduce((c, p, h, f) => c.add(p.div(f.length)), new HS.default(0, 0)), l = t3.unproject(s3);
    super(e, { points: o, point: s3, lngLats: a, lngLat: l, originalEvent: i }), this._defaultPrevented = false;
  }
};
r(Tg, "MapTouchEvent");
var Vr = Tg;
var Mg = class Mg2 extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t3, i) {
    super(e, { originalEvent: i }), this._defaultPrevented = false;
  }
};
r(Mg, "MapWheelEvent");
var Ea = Mg;
var Ag = class Ag2 {
  constructor(e, t3) {
    this._map = e, this._clickTolerance = t3.clickTolerance;
  }
  reset() {
    delete this._mousedownPos;
  }
  wheel(e) {
    return this._firePreventable(new Ea(e.type, this._map, e));
  }
  mousedown(e, t3) {
    return this._mousedownPos = t3, this._firePreventable(new it(e.type, this._map, e));
  }
  mouseup(e) {
    this._map.fire(new it(e.type, this._map, e));
  }
  click(e, t3) {
    this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || this._map.fire(new it(e.type, this._map, e));
  }
  dblclick(e) {
    return this._firePreventable(new it(e.type, this._map, e));
  }
  mouseover(e) {
    this._map.fire(new it(e.type, this._map, e));
  }
  mouseout(e) {
    this._map.fire(new it(e.type, this._map, e));
  }
  touchstart(e) {
    return this._firePreventable(new Vr(e.type, this._map, e));
  }
  touchmove(e) {
    this._map.fire(new Vr(e.type, this._map, e));
  }
  touchend(e) {
    this._map.fire(new Vr(e.type, this._map, e));
  }
  touchcancel(e) {
    this._map.fire(new Vr(e.type, this._map, e));
  }
  _firePreventable(e) {
    if (this._map.fire(e), e.defaultPrevented) return {};
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
r(Ag, "MapEventHandler");
var Gc = Ag;
var Ig = class Ig2 {
  constructor(e) {
    this._map = e;
  }
  reset() {
    this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
  }
  mousemove(e) {
    this._map.fire(new it(e.type, this._map, e));
  }
  mousedown() {
    this._delayContextMenu = true, this._ignoreContextMenu = false;
  }
  mouseup() {
    this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new it("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
  }
  contextmenu(e) {
    this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new it(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
r(Ig, "BlockableMapEventHandler");
var $c = Ig;
q();
q();
var WS = u(ge(), 1);
var Cg = class Cg2 {
  constructor(e) {
    this._map = e;
  }
  get transform() {
    return this._map._requestedCameraState || this._map.transform;
  }
  get center() {
    return { lng: this.transform.center.lng, lat: this.transform.center.lat };
  }
  get zoom() {
    return this.transform.zoom;
  }
  get pitch() {
    return this.transform.pitch;
  }
  get bearing() {
    return this.transform.bearing;
  }
  unproject(e) {
    return this.transform.pointLocation(WS.default.convert(e), this._map.terrain);
  }
};
r(Cg, "TransformProvider");
var Dt = Cg;
var Eg = class Eg2 {
  constructor(e, t3) {
    this._map = e, this._tr = new Dt(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
  enable() {
    console.warn("boxZoom will not work. Use SDK interaction events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  mousedown(e, t3) {
    this.isEnabled() && e.shiftKey && e.button === 0 && (D.disableDrag(), this._startPos = this._lastPos = t3, this._active = true);
  }
  mousemoveWindow(e, t3) {
    if (!this._active) return;
    let i = t3;
    if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;
    let n = this._startPos;
    this._lastPos = i, this._box || (this._box = D.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
    let o = Math.min(n.x, i.x), a = Math.max(n.x, i.x), s3 = Math.min(n.y, i.y), l = Math.max(n.y, i.y);
    D.setTransform(this._box, `translate(${o}px,${s3}px)`), this._box.style.width = `${a - o}px`, this._box.style.height = `${l - s3}px`;
  }
  mouseupWindow(e, t3) {
    if (!this._active || e.button !== 0) return;
    let i = this._startPos, n = t3;
    if (this.reset(), D.suppressClick(), i.x === n.x && i.y === n.y) this._fireEvent("boxzoomcancel", e);
    else return this._map.fire(new F("boxzoomend", { originalEvent: e })), { cameraAnimation: (o) => o.fitScreenCoordinates(i, n, this._tr.bearing, { linear: true }) };
  }
  keydown(e) {
    this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
  }
  reset() {
    this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (D.remove(this._box), this._box = null), D.enableDrag(), delete this._startPos, delete this._lastPos;
  }
  _fireEvent(e, t3) {
    return this._map.fire(new F(e, { originalEvent: t3 }));
  }
};
r(Eg, "BoxZoomHandler");
var ka = Eg;
q();
q();
var XS = u(ge(), 1);
q();
function La(r3, e) {
  if (r3.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${r3.length}, points ${e.length}`);
  let t3 = {};
  for (let i = 0; i < r3.length; i++) t3[r3[i].identifier] = e[i];
  return t3;
}
r(La, "indexTouches");
function KL(r3) {
  let e = new XS.default(0, 0);
  for (let t3 of r3) e._add(t3);
  return e.div(r3.length);
}
r(KL, "getCentroid");
var Lg = 500;
var JL = 500;
var qc = 30;
var Dg = class Dg2 {
  constructor(e) {
    this.reset(), this.numTouches = e.numTouches;
  }
  reset() {
    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
  }
  touchstart(e, t3, i) {
    (this.centroid || i.length > this.numTouches) && (this.aborted = true), !this.aborted && (this.startTime === void 0 && (this.startTime = e.timeStamp), i.length === this.numTouches && (this.centroid = KL(t3), this.touches = La(i, t3)));
  }
  touchmove(e, t3, i) {
    if (this.aborted || !this.centroid) return;
    let n = La(i, t3);
    for (let o in this.touches) {
      let a = this.touches[o], s3 = n[o];
      (!s3 || s3.dist(a) > qc) && (this.aborted = true);
    }
  }
  touchend(e, t3, i) {
    if ((!this.centroid || e.timeStamp - this.startTime > JL) && (this.aborted = true), i.length === 0) {
      let n = !this.aborted && this.centroid;
      if (this.reset(), n) return n;
    }
  }
};
r(Dg, "SingleTapRecognizer");
var kg = Dg;
var zg = class zg2 {
  constructor(e) {
    this.singleTap = new kg(e), this.numTaps = e.numTaps, this.reset();
  }
  reset() {
    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
  }
  touchstart(e, t3, i) {
    this.singleTap.touchstart(e, t3, i);
  }
  touchmove(e, t3, i) {
    this.singleTap.touchmove(e, t3, i);
  }
  touchend(e, t3, i) {
    let n = this.singleTap.touchend(e, t3, i);
    if (n) {
      let o = e.timeStamp - this.lastTime < Lg, a = !this.lastTap || this.lastTap.dist(n) < qc;
      if ((!o || !a) && this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = n, this.count === this.numTaps) return this.reset(), n;
    }
  }
};
r(zg, "TapRecognizer");
var Si = zg;
var Fg = class Fg2 {
  constructor(e) {
    this._tr = new Dt(e), this._zoomIn = new Si({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Si({ numTouches: 2, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
  }
  touchstart(e, t3, i) {
    this._zoomIn.touchstart(e, t3, i), this._zoomOut.touchstart(e, t3, i);
  }
  touchmove(e, t3, i) {
    this._zoomIn.touchmove(e, t3, i), this._zoomOut.touchmove(e, t3, i);
  }
  touchend(e, t3, i) {
    let n = this._zoomIn.touchend(e, t3, i), o = this._zoomOut.touchend(e, t3, i), a = this._tr;
    if (n) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom + 1, around: a.unproject(n) }, { originalEvent: e }) };
    if (o) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s3) => s3.easeTo({ duration: 300, zoom: a.zoom - 1, around: a.unproject(o) }, { originalEvent: e }) };
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
r(Fg, "TapZoomHandler");
var jc = Fg;
q();
q();
var Rg = class Rg2 {
  constructor(e) {
    this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
  }
  reset(e) {
    this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
  }
  _move(...e) {
    let t3 = this._moveFunction(...e);
    if (t3.bearingDelta || t3.pitchDelta || t3.around || t3.panDelta) return this._active = true, t3;
  }
  dragStart(e, t3) {
    !this.isEnabled() || this._lastPoint || this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = t3.length ? t3[0] : t3, this._activateOnStart && this._lastPoint && (this._active = true));
  }
  dragMove(e, t3) {
    if (!this.isEnabled()) return;
    let i = this._lastPoint;
    if (!i) return;
    if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) {
      this.reset(e);
      return;
    }
    let n = t3.length ? t3[0] : t3;
    if (!(!this._moved && n.dist(i) < this._clickTolerance)) return this._moved = true, this._lastPoint = n, this._move(i, n);
  }
  dragEnd(e) {
    !this.isEnabled() || !this._lastPoint || this._moveStateManager.isValidEndEvent(e) && (this._moved && D.suppressClick(), this.reset(e));
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};
r(Rg, "DragHandler");
var pr = Rg;
q();
var YL = 0;
var QL = 2;
var eD = { [YL]: 1, [QL]: 2 };
function tD(r3, e) {
  let t3 = eD[e];
  return r3.buttons === void 0 || (r3.buttons & t3) !== t3;
}
r(tD, "buttonNoLongerPressed");
var Bg = class Bg2 {
  constructor(e) {
    this._correctEvent = e.checkCorrectEvent;
  }
  startMove(e) {
    let t3 = D.mouseButton(e);
    this._eventButton = t3;
  }
  endMove(e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    return !tD(e, this._eventButton);
  }
  isValidEndEvent(e) {
    return D.mouseButton(e) === this._eventButton;
  }
};
r(Bg, "MouseMoveStateManager");
var Pn = Bg;
var Og = class Og2 {
  constructor() {
    this._firstTouch = void 0;
  }
  _isOneFingerTouch(e) {
    return e.targetTouches.length === 1;
  }
  _isSameTouchEvent(e) {
    return e.targetTouches[0].identifier === this._firstTouch;
  }
  startMove(e) {
    let t3 = e.targetTouches[0].identifier;
    this._firstTouch = t3;
  }
  endMove(e) {
    delete this._firstTouch;
  }
  isValidStartEvent(e) {
    return this._isOneFingerTouch(e);
  }
  isValidMoveEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
  isValidEndEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
};
r(Og, "OneFingerTouchMoveStateManager");
var Da = Og;
var Vg = 0;
var KS = 2;
var Ug = r((r3) => {
  r3.mousedown = r3.dragStart, r3.mousemoveWindow = r3.dragMove, r3.mouseup = r3.dragEnd, r3.contextmenu = function(e) {
    e.preventDefault();
  };
}, "assignEvents");
var JS = r(({ enable: r3, clickTolerance: e }) => {
  let t3 = new Pn({ checkCorrectEvent: (i) => D.mouseButton(i) === Vg && !i.ctrlKey });
  return new pr({ clickTolerance: e, move: (i, n) => ({ around: n, panDelta: n.sub(i) }), activateOnStart: true, moveStateManager: t3, enable: r3, assignEvents: Ug });
}, "generateMousePanHandler");
var Zc = r(({ enable: r3, clickTolerance: e, bearingDegreesPerPixelMoved: t3 = 0.8 }) => {
  let i = new Pn({ checkCorrectEvent: (n) => D.mouseButton(n) === Vg && n.ctrlKey || D.mouseButton(n) === KS });
  return new pr({ clickTolerance: e, move: (n, o) => ({ bearingDelta: (o.x - n.x) * t3 }), moveStateManager: i, enable: r3, assignEvents: Ug });
}, "generateMouseRotationHandler");
var Hc = r(({ enable: r3, clickTolerance: e, pitchDegreesPerPixelMoved: t3 = -0.5 }) => {
  let i = new Pn({ checkCorrectEvent: (n) => D.mouseButton(n) === Vg && n.ctrlKey || D.mouseButton(n) === KS });
  return new pr({ clickTolerance: e, move: (n, o) => ({ pitchDelta: (o.y - n.y) * t3 }), moveStateManager: i, enable: r3, assignEvents: Ug });
}, "generateMousePitchHandler");
q();
var Wc = u(ge(), 1);
var Ng = class Ng2 {
  constructor(e, t3) {
    this._clickTolerance = e.clickTolerance || 1, this._map = t3, this.reset();
  }
  reset() {
    this._active = false, this._touches = {}, this._sum = new Wc.default(0, 0);
  }
  minTouchs() {
    return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
  }
  touchstart(e, t3, i) {
    return this._calculateTransform(e, t3, i);
  }
  touchmove(e, t3, i) {
    if (!(!this._active || i.length < this.minTouchs())) return e.preventDefault(), this._calculateTransform(e, t3, i);
  }
  touchend(e, t3, i) {
    this._calculateTransform(e, t3, i), this._active && i.length < this.minTouchs() && this.reset();
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, t3, i) {
    i.length > 0 && (this._active = true);
    let n = La(i, t3), o = new Wc.default(0, 0), a = new Wc.default(0, 0), s3 = 0;
    for (let p in n) {
      let h = n[p], f = this._touches[p];
      f && (o._add(h), a._add(h.sub(f)), s3++, n[p] = h);
    }
    if (this._touches = n, s3 < this.minTouchs() || !a.mag()) return;
    let l = a.div(s3);
    return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: o.div(s3), panDelta: l };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
r(Ng, "TouchPanHandler");
var Xc = Ng;
q();
var $g = class $g2 {
  constructor() {
    this.reset();
  }
  reset() {
    this._active = false, delete this._firstTwoTouches;
  }
  touchstart(e, t3, i) {
    this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t3[0], t3[1]]));
  }
  touchmove(e, t3, i) {
    if (!this._firstTwoTouches) return;
    e.preventDefault();
    let [n, o] = this._firstTwoTouches, a = Kc(i, t3, n), s3 = Kc(i, t3, o);
    if (!a || !s3) return;
    let l = this._aroundCenter ? null : a.add(s3).div(2);
    return this._move([a, s3], l, e);
  }
  touchend(e, t3, i) {
    if (!this._firstTwoTouches) return;
    let [n, o] = this._firstTwoTouches, a = Kc(i, t3, n), s3 = Kc(i, t3, o);
    a && s3 || (this._active && D.suppressClick(), this.reset());
  }
  touchcancel() {
    this.reset();
  }
  enable(e) {
    this._enabled = true, this._aroundCenter = !!e && e.around === "center";
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
};
r($g, "TwoFingersTouchHandler");
var za = $g;
function Kc(r3, e, t3) {
  for (let i = 0; i < r3.length; i++) if (r3[i].identifier === t3) return e[i];
}
r(Kc, "getTouchById");
var rD = 0.1;
function YS(r3, e) {
  return Math.log(r3 / e) / Math.LN2;
}
r(YS, "getZoomDelta");
var qg = class qg2 extends za {
  reset() {
    super.reset(), delete this._distance, delete this._startDistance;
  }
  _start(e) {
    this._startDistance = this._distance = e[0].dist(e[1]);
  }
  _move(e, t3) {
    let i = this._distance;
    if (this._distance = e[0].dist(e[1]), !(!this._active && Math.abs(YS(this._distance, this._startDistance)) < rD)) return this._active = true, { zoomDelta: YS(this._distance, i), pinchAround: t3 };
  }
};
r(qg, "TwoFingersTouchZoomHandler");
var Fa = qg;
var iD = 25;
function QS(r3, e) {
  return r3.angleWith(e) * 180 / Math.PI;
}
r(QS, "getBearingDelta");
var jg = class jg2 extends za {
  reset() {
    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
  }
  _start(e) {
    this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
  }
  _move(e, t3, i) {
    let n = this._vector;
    if (this._vector = e[0].sub(e[1]), !(!this._active && this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: QS(this._vector, n), pinchAround: t3 };
  }
  _isBelowThreshold(e) {
    this._minDiameter = Math.min(this._minDiameter, e.mag());
    let t3 = Math.PI * this._minDiameter, i = iD / t3 * 360, n = QS(e, this._startVector);
    return Math.abs(n) < i;
  }
};
r(jg, "TwoFingersTouchRotateHandler");
var Ra = jg;
function Gg(r3) {
  return Math.abs(r3.y) > Math.abs(r3.x);
}
r(Gg, "isVertical");
var nD = 100;
var Zg = class Zg2 extends za {
  constructor(t3) {
    super();
    this._currentTouchCount = 0;
    this._map = t3;
  }
  reset() {
    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
  }
  touchstart(t3, i, n) {
    super.touchstart(t3, i, n), this._currentTouchCount = n.length;
  }
  _start(t3) {
    this._lastPoints = t3, Gg(t3[0].sub(t3[1])) && (this._valid = false);
  }
  _move(t3, i, n) {
    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
    let o = t3[0].sub(this._lastPoints[0]), a = t3[1].sub(this._lastPoints[1]);
    return this._valid = this.gestureBeginsVertically(o, a, n.timeStamp), this._valid ? (this._lastPoints = t3, this._active = true, { pitchDelta: (o.y + a.y) / 2 * -0.5 }) : void 0;
  }
  gestureBeginsVertically(t3, i, n) {
    if (this._valid !== void 0) return this._valid;
    let o = 2, a = t3.mag() >= o, s3 = i.mag() >= o;
    if (!a && !s3) return;
    if (!a || !s3) return this._firstMove === void 0 && (this._firstMove = n), n - this._firstMove < nD ? void 0 : false;
    let l = t3.y > 0 == i.y > 0;
    return Gg(t3) && Gg(i) && l;
  }
};
r(Zg, "TwoFingersTouchPitchHandler");
var Ba = Zg;
q();
var oD = { panStep: 100, bearingStep: 15, pitchStep: 10 };
var Hg = class Hg2 {
  constructor(e) {
    this._tr = new Dt(e);
    let t3 = oD;
    this._panStep = t3.panStep, this._bearingStep = t3.bearingStep, this._pitchStep = t3.pitchStep, this._rotationDisabled = false;
  }
  reset() {
    this._active = false;
  }
  keydown(e) {
    if (e.altKey || e.ctrlKey || e.metaKey) return;
    let t3 = 0, i = 0, n = 0, o = 0, a = 0;
    switch (e.keyCode) {
      case 61:
      case 107:
      case 171:
      case 187:
        t3 = 1;
        break;
      case 189:
      case 109:
      case 173:
        t3 = -1;
        break;
      case 37:
        e.shiftKey ? i = -1 : (e.preventDefault(), o = -1);
        break;
      case 39:
        e.shiftKey ? i = 1 : (e.preventDefault(), o = 1);
        break;
      case 38:
        e.shiftKey ? n = 1 : (e.preventDefault(), a = -1);
        break;
      case 40:
        e.shiftKey ? n = -1 : (e.preventDefault(), a = 1);
        break;
      default:
        return;
    }
    return this._rotationDisabled && (i = 0, n = 0), { cameraAnimation: (s3) => {
      let l = this._tr;
      s3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: aD, zoom: t3 ? Math.round(l.zoom) + t3 * (e.shiftKey ? 2 : 1) : l.zoom, bearing: l.bearing + i * this._bearingStep, pitch: l.pitch + n * this._pitchStep, offset: [-o * this._panStep, -a * this._panStep], center: l.center }, { originalEvent: e });
    } };
  }
  enable() {
    console.warn("maplibre keyboard events are not supported, use SDK keyboard events instead.");
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  disableRotation() {
    this._rotationDisabled = true;
  }
  enableRotation() {
    this._rotationDisabled = false;
  }
};
r(Hg, "KeyboardHandler");
var Oa = Hg;
function aD(r3) {
  return r3 * (2 - r3);
}
r(aD, "easeOut");
q();
var e2 = 4.000244140625;
var sD = 1 / 100;
var lD = 1 / 450;
var uD = 2;
var Wg = class Wg2 {
  constructor(e, t3) {
    this._onTimeout = (e3) => {
      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
    };
    this._map = e, this._tr = new Dt(e), this._triggerRenderFrame = t3, this._delta = 0, this._defaultZoomRate = sD, this._wheelZoomRate = lD;
  }
  setZoomRate(e) {
    this._defaultZoomRate = e;
  }
  setWheelZoomRate(e) {
    this._wheelZoomRate = e;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active || this._finishTimeout !== void 0;
  }
  isZooming() {
    return !!this._zooming;
  }
  enable(e) {
    console.log("Enable maplibre scrollZoom events will not work. Use Mappedin SDK interactions events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  wheel(e) {
    if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !e[this._map.cooperativeGestures._bypassKey]) return;
    let t3 = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY, i = Y.now(), n = i - (this._lastWheelEventTime || 0);
    this._lastWheelEventTime = i, t3 !== 0 && t3 % e2 === 0 ? this._type = "wheel" : t3 !== 0 && Math.abs(t3) < 4 ? this._type = "trackpad" : n > 400 ? (this._type = null, this._lastValue = t3, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(n * t3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t3 += this._lastValue)), e.shiftKey && t3 && (t3 = t3 / 4), this._type && (this._lastWheelEvent = e, this._delta -= t3, this._active || this._start(e)), e.preventDefault();
  }
  _start(e) {
    if (!this._delta) return;
    this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
    let t3 = D.mousePos(this._map.getCanvas(), e), i = this._tr;
    t3.y > i.transform.height / 2 - i.transform.getHorizon() ? this._around = ie.convert(this._aroundCenter ? i.center : i.unproject(t3)) : this._around = ie.convert(i.center), this._aroundPoint = i.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
  }
  renderFrame() {
    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
    let e = this._tr.transform;
    if (this._delta !== 0) {
      let s3 = this._type === "wheel" && Math.abs(this._delta) > e2 ? this._wheelZoomRate : this._defaultZoomRate, l = uD / (1 + Math.exp(-Math.abs(this._delta * s3)));
      this._delta < 0 && l !== 0 && (l = 1 / l);
      let c = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
      this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(c * l))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
    }
    let t3 = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, i = this._startZoom, n = this._easing, o = false, a;
    if (this._type === "wheel" && i && n) {
      let s3 = Math.min((Y.now() - this._lastWheelEventTime) / 200, 1), l = n(s3);
      a = Pe.number(i, t3, l), s3 < 1 ? this._frameId || (this._frameId = true) : o = true;
    } else a = t3, o = true;
    return this._active = true, o && (this._active = false, this._finishTimeout = setTimeout(() => {
      this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
    }, 200)), { noInertia: true, needsRenderFrame: !o, zoomDelta: a - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
  }
  _smoothOutEasing(e) {
    let t3 = Cn;
    if (this._prevEase) {
      let i = this._prevEase, n = (Y.now() - i.start) / i.duration, o = i.easing(n + 0.01) - i.easing(n), a = 0.27 / Math.sqrt(o * o + 1e-4) * 0.01, s3 = Math.sqrt(0.27 * 0.27 - a * a);
      t3 = In(a, s3, 0.25, 1);
    }
    return this._prevEase = { start: Y.now(), duration: e, easing: t3 }, t3;
  }
  reset() {
    this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
  }
};
r(Wg, "ScrollZoomHandler");
var Va = Wg;
q();
var Xg = class Xg2 {
  constructor(e, t3) {
    this._clickZoom = e, this._tapZoom = t3;
  }
  enable() {
    this._clickZoom.enable(), this._tapZoom.enable();
  }
  disable() {
    this._clickZoom.disable(), this._tapZoom.disable();
  }
  isEnabled() {
    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
  }
  isActive() {
    return this._clickZoom.isActive() || this._tapZoom.isActive();
  }
};
r(Xg, "DoubleClickZoomHandler");
var Ua = Xg;
q();
var Kg = class Kg2 {
  constructor(e) {
    this._tr = new Dt(e), this.reset();
  }
  reset() {
    this._active = false;
  }
  dblclick(e, t3) {
    return e.preventDefault(), { cameraAnimation: (i) => {
      i.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(t3) }, { originalEvent: e });
    } };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
r(Kg, "ClickZoomHandler");
var Jc = Kg;
q();
var Jg = class Jg2 {
  constructor() {
    this._tap = new Si({ numTouches: 1, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
  }
  touchstart(e, t3, i) {
    if (!this._swipePoint) if (!this._tapTime) this._tap.touchstart(e, t3, i);
    else {
      let n = t3[0], o = e.timeStamp - this._tapTime < Lg, a = this._tapPoint.dist(n) < qc;
      !o || !a ? this.reset() : i.length > 0 && (this._swipePoint = n, this._swipeTouch = i[0].identifier);
    }
  }
  touchmove(e, t3, i) {
    if (!this._tapTime) this._tap.touchmove(e, t3, i);
    else if (this._swipePoint) {
      if (i[0].identifier !== this._swipeTouch) return;
      let n = t3[0], o = n.y - this._swipePoint.y;
      return this._swipePoint = n, e.preventDefault(), this._active = true, { zoomDelta: o / 128 };
    }
  }
  touchend(e, t3, i) {
    if (this._tapTime) this._swipePoint && i.length === 0 && this.reset();
    else {
      let n = this._tap.touchend(e, t3, i);
      n && (this._tapTime = e.timeStamp, this._tapPoint = n);
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
r(Jg, "TapDragZoomHandler");
var Yc = Jg;
q();
var Yg = class Yg2 {
  constructor(e, t3, i) {
    this._el = e, this._mousePan = t3, this._touchPan = i;
  }
  enable(e) {
    console.log("Maplibre interaction is not supported. Use Mappedin SDK interaction instead");
  }
  disable() {
    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
  }
  isEnabled() {
    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
  }
  isActive() {
    return this._mousePan.isActive() || this._touchPan.isActive();
  }
};
r(Yg, "DragPanHandler");
var Na = Yg;
q();
var Qg = class Qg2 {
  constructor(e, t3, i) {
    this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i;
  }
  enable() {
    console.warn("dragRotate does not work. Use SDK interaction events instead.");
  }
  disable() {
    this._mouseRotate.disable(), this._mousePitch.disable();
  }
  isEnabled() {
    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
  }
  isActive() {
    return this._mouseRotate.isActive() || this._mousePitch.isActive();
  }
};
r(Qg, "DragRotateHandler");
var Ga = Qg;
q();
var ex = class ex2 {
  constructor(e, t3, i, n) {
    this._el = e, this._touchZoom = t3, this._touchRotate = i, this._tapDragZoom = n, this._rotationDisabled = false, this._enabled = true;
  }
  enable(e) {
    this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
  }
  disable() {
    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
  }
  isEnabled() {
    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
  }
  isActive() {
    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
  }
  disableRotation() {
    this._rotationDisabled = true, this._touchRotate.disable();
  }
  enableRotation() {
    this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
  }
};
r(ex, "TwoFingersTouchZoomRotateHandler");
var $a = ex;
q();
var tx = class tx2 {
  constructor(e, t3) {
    this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey";
    this._map = e, this._options = t3, this._enabled = false;
  }
  isActive() {
    return false;
  }
  reset() {
  }
  _setupUI() {
    if (this._container) return;
    let e = this._map.getCanvasContainer();
    e.classList.add("maplibregl-cooperative-gestures"), this._container = D.create("div", "maplibregl-cooperative-gesture-screen", e);
    let t3 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
    this._bypassKey === "metaKey" && (t3 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
    let i = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), n = document.createElement("div");
    n.className = "maplibregl-desktop-message", n.textContent = t3, this._container.appendChild(n);
    let o = document.createElement("div");
    o.className = "maplibregl-mobile-message", o.textContent = i, this._container.appendChild(o), this._container.setAttribute("aria-hidden", "true");
  }
  _destoryUI() {
    this._container && (D.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
  }
  enable() {
    this._setupUI(), this._enabled = true;
  }
  disable() {
    this._enabled = false, this._destoryUI();
  }
  isEnabled() {
    return this._enabled;
  }
  touchmove(e) {
    this._onCooperativeGesture(e.touches.length === 1);
  }
  wheel(e) {
    this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!e[this._bypassKey]);
  }
  _onCooperativeGesture(e) {
    !this._enabled || !e || (this._container.classList.add("maplibregl-show"), setTimeout(() => {
      this._container.classList.remove("maplibregl-show");
    }, 100));
  }
};
r(tx, "CooperativeGesturesHandler");
var qa = tx;
var t2 = u(ge(), 1);
var Qc = r((r3) => r3.zoom || r3.drag || r3.pitch || r3.rotate, "isMoving");
var nx = class nx2 extends F {
};
r(nx, "RenderFrameEvent");
var ix = nx;
function rx(r3) {
  return r3.panDelta && r3.panDelta.mag() || r3.zoomDelta || r3.bearingDelta || r3.pitchDelta;
}
r(rx, "hasChange");
var ox = class ox2 {
  constructor(e, t3) {
    this.handleWindowEvent = (e3) => {
      this.handleEvent(e3, `${e3.type}Window`);
    };
    this.handleEvent = (e3, t4) => {
      if (e3.type === "blur") {
        this.stop(true);
        return;
      }
      this._updatingCamera = true;
      let i3 = e3.type === "renderFrame" ? void 0 : e3, n = { needsRenderFrame: false }, o = {}, a = {}, s3 = e3.touches, l = s3 ? this._getMapTouches(s3) : void 0, c = l ? D.touchPos(this._map.getCanvas(), l) : D.mousePos(this._map.getCanvas(), e3);
      for (let { handlerName: f, handler: m, allowed: y } of this._handlers) {
        if (!m.isEnabled()) continue;
        let g;
        this._blockedByActive(a, y, f) ? m.reset() : m[t4 || e3.type] && (g = m[t4 || e3.type](e3, c, l), this.mergeHandlerResult(n, o, g, f, i3), g && g.needsRenderFrame && this._triggerRenderFrame()), (g || m.isActive()) && (a[f] = m);
      }
      let p = {};
      for (let f in this._previousActiveHandlers) a[f] || (p[f] = i3);
      this._previousActiveHandlers = a, (Object.keys(p).length || rx(n)) && (this._changes.push([n, o, p]), this._triggerRenderFrame()), (Object.keys(a).length || rx(n)) && this._map._stop(true), this._updatingCamera = false;
      let { cameraAnimation: h } = n;
      h && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h(this._map));
    };
    this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Uc(e), this._bearingSnap = t3.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(t3);
    let i = this._el;
    this._listeners = [[i, "touchstart", { passive: true }], [i, "touchmove", { passive: false }], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", { capture: false }], [i, "keyup", void 0], [i, "wheel", { passive: false }], [i, "contextmenu", void 0], [window, "blur", void 0]];
    for (let [n, o, a] of this._listeners) ;
  }
  destroy() {
    for (let [e, t3, i] of this._listeners) D.removeEventListener(e, t3, e === document ? this.handleWindowEvent : this.handleEvent, i);
  }
  _addDefaultHandlers(e) {
    let t3 = this._map, i = t3.getCanvasContainer();
    this._add("mapEvent", new Gc(t3, e));
    let n = t3.boxZoom = new ka(t3, e);
    this._add("boxZoom", n), e.interactive && e.boxZoom && n.enable();
    let o = t3.cooperativeGestures = new qa(t3, e.cooperativeGestures);
    this._add("cooperativeGestures", o), e.cooperativeGestures && o.enable();
    let a = new jc(t3), s3 = new Jc(t3);
    t3.doubleClickZoom = new Ua(s3, a), this._add("tapZoom", a), this._add("clickZoom", s3), e.interactive && e.doubleClickZoom && t3.doubleClickZoom.enable();
    let l = new Yc();
    this._add("tapDragZoom", l);
    let c = t3.touchPitch = new Ba(t3);
    this._add("touchPitch", c), e.interactive && e.touchPitch && t3.touchPitch.enable(e.touchPitch);
    let p = Zc(e), h = Hc(e);
    t3.dragRotate = new Ga(e, p, h), this._add("mouseRotate", p, ["mousePitch"]), this._add("mousePitch", h, ["mouseRotate"]), e.interactive && e.dragRotate && t3.dragRotate.enable();
    let f = JS(e), m = new Xc(e, t3);
    t3.dragPan = new Na(i, f, m), this._add("mousePan", f), this._add("touchPan", m, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && t3.dragPan.enable(e.dragPan);
    let y = new Ra(), g = new Fa();
    t3.touchZoomRotate = new $a(i, g, y, l), this._add("touchRotate", y, ["touchPan", "touchZoom"]), this._add("touchZoom", g, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && t3.touchZoomRotate.enable(e.touchZoomRotate);
    let x = t3.scrollZoom = new Va(t3, () => this._triggerRenderFrame());
    this._add("scrollZoom", x, ["mousePan"]), e.interactive && e.scrollZoom && t3.scrollZoom.enable(e.scrollZoom);
    let b = t3.keyboard = new Oa(t3);
    this._add("keyboard", b), e.interactive && e.keyboard && t3.keyboard.enable(), this._add("blockableMapEvent", new $c(t3));
  }
  _add(e, t3, i) {
    this._handlers.push({ handlerName: e, handler: t3, allowed: i }), this._handlersById[e] = t3;
  }
  stop(e) {
    if (!this._updatingCamera) {
      for (let { handler: t3 } of this._handlers) t3.reset();
      this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
    }
  }
  isActive() {
    for (let { handler: e } of this._handlers) if (e.isActive()) return true;
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return !!Qc(this._eventsInProgress) || this.isZooming();
  }
  _blockedByActive(e, t3, i) {
    for (let n in e) if (n !== i && (!t3 || t3.indexOf(n) < 0)) return true;
    return false;
  }
  _getMapTouches(e) {
    let t3 = [];
    for (let i of e) {
      let n = i.target;
      this._el.contains(n) && t3.push(i);
    }
    return t3;
  }
  mergeHandlerResult(e, t3, i, n, o) {
    if (!i) return;
    V(e, i);
    let a = { handlerName: n, originalEvent: i.originalEvent || o };
    i.zoomDelta !== void 0 && (t3.zoom = a), i.panDelta !== void 0 && (t3.drag = a), i.pitchDelta !== void 0 && (t3.pitch = a), i.bearingDelta !== void 0 && (t3.rotate = a);
  }
  _applyChanges() {
    let e = {}, t3 = {}, i = {};
    for (let [n, o, a] of this._changes) n.panDelta && (e.panDelta = (e.panDelta || new t2.default(0, 0))._add(n.panDelta)), n.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + n.zoomDelta), n.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + n.bearingDelta), n.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + n.pitchDelta), n.around !== void 0 && (e.around = n.around), n.pinchAround !== void 0 && (e.pinchAround = n.pinchAround), n.noInertia && (e.noInertia = n.noInertia), V(t3, o), V(i, a);
    this._updateMapTransform(e, t3, i), this._changes = [];
  }
  _updateMapTransform(e, t3, i) {
    let n = this._map, o = n._getTransformForUpdate(), a = n.terrain;
    if (!rx(e) && !(a && this._terrainMovement)) return this._fireEvents(t3, i, true);
    let { panDelta: s3, zoomDelta: l, bearingDelta: c, pitchDelta: p, around: h, pinchAround: f } = e;
    f !== void 0 && (h = f), n._stop(true), h = h || n.transform.centerPoint;
    let m = o.pointLocation(s3 ? h.sub(s3) : h);
    c && (o.bearing += c), p && (o.pitch += p), l && (o.zoom += l), a ? !this._terrainMovement && (t3.drag || t3.zoom) ? (this._terrainMovement = true, this._map._elevationFreeze = true, o.setLocationAtPoint(m, h), this._map.once("moveend", () => {
      this._map._elevationFreeze = false, this._terrainMovement = false, o.recalculateZoom(n.terrain);
    })) : t3.drag && this._terrainMovement ? o.center = o.pointLocation(o.centerPoint.sub(s3)) : o.setLocationAtPoint(m, h) : o.setLocationAtPoint(m, h), n._applyUpdatedTransform(o), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t3, i, true);
  }
  _fireEvents(e, t3, i) {
    let n = Qc(this._eventsInProgress), o = Qc(e), a = {};
    for (let p in e) {
      let { originalEvent: h } = e[p];
      this._eventsInProgress[p] || (a[`${p}start`] = h), this._eventsInProgress[p] = e[p];
    }
    !n && o && this._fireEvent("movestart", o.originalEvent);
    for (let p in a) this._fireEvent(p, a[p]);
    o && this._fireEvent("move", o.originalEvent);
    for (let p in e) {
      let { originalEvent: h } = e[p];
      this._fireEvent(p, h);
    }
    let s3 = {}, l;
    for (let p in this._eventsInProgress) {
      let { handlerName: h, originalEvent: f } = this._eventsInProgress[p];
      this._handlersById[h].isActive() || (delete this._eventsInProgress[p], l = t3[h] || f, s3[`${p}end`] = l);
    }
    for (let p in s3) this._fireEvent(p, s3[p]);
    let c = Qc(this._eventsInProgress);
    if (i && (n || o) && !c) {
      this._updatingCamera = true;
      let p = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), h = r((f) => f !== 0 && -this._bearingSnap < f && f < this._bearingSnap, "shouldSnapToNorth");
      p && (p.essential || !Y.prefersReducedMotion) ? (h(p.bearing || this._map.getBearing()) && (p.bearing = 0), p.freezeElevation = true, this._map.easeTo(p, { originalEvent: l })) : (this._map.fire(new F("moveend", { originalEvent: l })), h(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
    }
  }
  _fireEvent(e, t3) {
    this._map.fire(new F(e, t3 ? { originalEvent: t3 } : {}));
  }
  _requestFrame() {
    return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
      delete this._frameId, this.handleEvent(new ix("renderFrame", { timeStamp: e })), this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    this._frameId === void 0 && (this._frameId = this._requestFrame());
  }
};
r(ox, "HandlerManager");
var ep = ox;
q();
var Ht = u(ge(), 1);
var ax = class ax2 extends de {
  constructor(t3, i) {
    super();
    this._renderFrameCallback = () => {
      let t4 = Math.min((Y.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(t4)), t4 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
    };
    this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = i.bearingSnap, this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  getCenter() {
    return new ie(this.transform.center.lng, this.transform.center.lat);
  }
  setCenter(t3, i) {
    return this.jumpTo({ center: t3 }, i);
  }
  panBy(t3, i, n) {
    return t3 = Ht.default.convert(t3).mult(-1), this.panTo(this.transform.center, V({ offset: t3 }, i), n);
  }
  panTo(t3, i, n) {
    return this.easeTo(V({ center: t3 }, i), n);
  }
  getZoom() {
    return this.transform.zoom;
  }
  setZoom(t3, i) {
    return this.jumpTo({ zoom: t3 }, i), this;
  }
  zoomTo(t3, i, n) {
    return this.easeTo(V({ zoom: t3 }, i), n);
  }
  zoomIn(t3, i) {
    return this.zoomTo(this.getZoom() + 1, t3, i), this;
  }
  zoomOut(t3, i) {
    return this.zoomTo(this.getZoom() - 1, t3, i), this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  setBearing(t3, i) {
    return this.jumpTo({ bearing: t3 }, i), this;
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(t3, i) {
    return this.jumpTo({ padding: t3 }, i), this;
  }
  rotateTo(t3, i, n) {
    return this.easeTo(V({ bearing: t3 }, i), n);
  }
  resetNorth(t3, i) {
    return this.rotateTo(0, V({ duration: 1e3 }, t3), i), this;
  }
  resetNorthPitch(t3, i) {
    return this.easeTo(V({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i), this;
  }
  snapToNorth(t3, i) {
    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t3, i) : this;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setPitch(t3, i) {
    return this.jumpTo({ pitch: t3 }, i), this;
  }
  cameraForBounds(t3, i) {
    t3 = ut.convert(t3);
    let n = i && i.bearing || 0;
    return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), n, i);
  }
  _cameraForBoxAndBearing(t3, i, n, o) {
    let a = { top: 0, bottom: 0, right: 0, left: 0 };
    if (o = V({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, o), typeof o.padding == "number") {
      let ne = o.padding;
      o.padding = { top: ne, bottom: ne, right: ne, left: ne };
    }
    o.padding = V(a, o.padding);
    let s3 = this.transform, l = s3.padding, c = new ut(t3, i), p = s3.project(c.getNorthWest()), h = s3.project(c.getNorthEast()), f = s3.project(c.getSouthEast()), m = s3.project(c.getSouthWest()), y = _p(-n), g = p.rotate(y), x = h.rotate(y), b = f.rotate(y), w = m.rotate(y), _ = new Ht.default(Math.max(g.x, x.x, w.x, b.x), Math.max(g.y, x.y, w.y, b.y)), S = new Ht.default(Math.min(g.x, x.x, w.x, b.x), Math.min(g.y, x.y, w.y, b.y)), P = _.sub(S), T = (s3.width - (l.left + l.right + o.padding.left + o.padding.right)) / P.x, L = (s3.height - (l.top + l.bottom + o.padding.top + o.padding.bottom)) / P.y;
    if (L < 0 || T < 0) {
      ke("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      return;
    }
    let C = Math.min(s3.scaleZoom(s3.scale * Math.min(T, L)), o.maxZoom), E = Ht.default.convert(o.offset), I = (o.padding.left - o.padding.right) / 2, R = (o.padding.top - o.padding.bottom) / 2, k = new Ht.default(I, R).rotate(_p(n)), G = E.add(k).mult(s3.scale / s3.zoomScale(C));
    return { center: s3.unproject(p.add(f).div(2).sub(G)), zoom: C, bearing: n };
  }
  fitBounds(t3, i, n) {
    return this._fitInternal(this.cameraForBounds(t3, i), i, n);
  }
  fitScreenCoordinates(t3, i, n, o, a) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Ht.default.convert(t3)), this.transform.pointLocation(Ht.default.convert(i)), n, o), o, a);
  }
  _fitInternal(t3, i, n) {
    return t3 ? (i = V(t3, i), delete i.padding, i.linear ? this.easeTo(i, n) : this.flyTo(i, n)) : this;
  }
  jumpTo(t3, i) {
    this.stop();
    let n = this._getTransformForUpdate(), o = false, a = false, s3 = false;
    return "zoom" in t3 && n.zoom !== +t3.zoom && (o = true, n.zoom = +t3.zoom), t3.center !== void 0 && (n.center = ie.convert(t3.center)), "bearing" in t3 && n.bearing !== +t3.bearing && (a = true, n.bearing = +t3.bearing), "pitch" in t3 && n.pitch !== +t3.pitch && (s3 = true, n.pitch = +t3.pitch), t3.padding != null && !n.isPaddingEqual(t3.padding) && (n.padding = t3.padding), this._applyUpdatedTransform(n), this.fire(new F("movestart", i)).fire(new F("move", i)), o && this.fire(new F("zoomstart", i)).fire(new F("zoom", i)).fire(new F("zoomend", i)), a && this.fire(new F("rotatestart", i)).fire(new F("rotate", i)).fire(new F("rotateend", i)), s3 && this.fire(new F("pitchstart", i)).fire(new F("pitch", i)).fire(new F("pitchend", i)), this.fire(new F("moveend", i));
  }
  calculateCameraOptionsFromTo(t3, i, n, o = 0) {
    let a = Fe.fromLngLat(t3, i), s3 = Fe.fromLngLat(n, o), l = s3.x - a.x, c = s3.y - a.y, p = s3.z - a.z, h = Math.hypot(l, c, p);
    if (h === 0) throw new Error("Can't calculate camera options with same From and To");
    let f = Math.hypot(l, c), m = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h / this.transform.tileSize), y = Math.atan2(l, -c) * 180 / Math.PI, g = Math.acos(f / h) * 180 / Math.PI;
    return g = p < 0 ? 90 - g : 90 + g, { center: s3.toLngLat(), zoom: m, pitch: g, bearing: y };
  }
  easeTo(t3, i) {
    var L;
    this._stop(false, t3.easeId), t3 = V({ offset: [0, 0], duration: 500, easing: Cn }, t3), (t3.animate === false || !t3.essential && Y.prefersReducedMotion) && (t3.duration = 0);
    let n = this._getTransformForUpdate(), o = this.getZoom(), a = this.getBearing(), s3 = this.getPitch(), l = this.getPadding(), c = "bearing" in t3 ? this._normalizeBearing(t3.bearing, a) : a, p = "pitch" in t3 ? +t3.pitch : s3, h = "padding" in t3 ? t3.padding : n.padding, f = Ht.default.convert(t3.offset), m = n.centerPoint.add(f), y = n.pointLocation(m), { center: g, zoom: x } = n.getConstrained(ie.convert(t3.center || y), (L = t3.zoom) != null ? L : o);
    this._normalizeCenter(g);
    let b = n.project(y), w = n.project(g).sub(b), _ = n.zoomScale(x - o), S, P;
    t3.around && (S = ie.convert(t3.around), P = n.locationPoint(S));
    let T = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
    return this._zooming = this._zooming || x !== o, this._rotating = this._rotating || a !== c, this._pitching = this._pitching || p !== s3, this._padding = !n.isPaddingEqual(h), this._easeId = t3.easeId, this._prepareEase(i, t3.noMoveStart, T), this.terrain && this._prepareElevation(g), this._ease((C) => {
      if (this._zooming && (n.zoom = Pe.number(o, x, C)), this._rotating && (n.bearing = Pe.number(a, c, C)), this._pitching && (n.pitch = Pe.number(s3, p, C)), this._padding && (n.interpolatePadding(l, h, C), m = n.centerPoint.add(f)), this.terrain && !t3.freezeElevation && this._updateElevation(C), S) n.setLocationAtPoint(S, P);
      else {
        let E = n.zoomScale(n.zoom - o), I = x > o ? Math.min(2, _) : Math.max(0.5, _), R = Math.pow(I, 1 - C), z = n.unproject(b.add(w.mult(C * R)).mult(E));
        n.setLocationAtPoint(n.renderWorldCopies ? z.wrap() : z, m);
      }
      this._applyUpdatedTransform(n), this._fireMoveEvents(i);
    }, (C) => {
      this.terrain && this._finalizeElevation(), this._afterEase(i, C);
    }, t3), this;
  }
  _prepareEase(t3, i, n = {}) {
    this._moving = true, !i && !n.moving && this.fire(new F("movestart", t3)), this._zooming && !n.zooming && this.fire(new F("zoomstart", t3)), this._rotating && !n.rotating && this.fire(new F("rotatestart", t3)), this._pitching && !n.pitching && this.fire(new F("pitchstart", t3));
  }
  _prepareElevation(t3) {
    this._elevationCenter = t3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t3, this.transform.tileZoom), this._elevationFreeze = true;
  }
  _updateElevation(t3) {
    this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    let i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    if (t3 < 1 && i !== this._elevationTarget) {
      let n = this._elevationTarget - this._elevationStart, o = (i - (n * t3 + this._elevationStart)) / (1 - t3);
      this._elevationStart += t3 * (n - o), this._elevationTarget = i;
    }
    this.transform.elevation = Pe.number(this._elevationStart, this._elevationTarget, t3);
  }
  _finalizeElevation() {
    this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
  }
  _getTransformForUpdate() {
    return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
  }
  _applyUpdatedTransform(t3) {
    if (!this.transformCameraUpdate) return;
    let i = t3.clone(), { center: n, zoom: o, pitch: a, bearing: s3, elevation: l } = this.transformCameraUpdate(i);
    n && (i.center = n), o !== void 0 && (i.zoom = o), a !== void 0 && (i.pitch = a), s3 !== void 0 && (i.bearing = s3), l !== void 0 && (i.elevation = l), this.transform.apply(i);
  }
  _fireMoveEvents(t3) {
    this.fire(new F("move", t3)), this._zooming && this.fire(new F("zoom", t3)), this._rotating && this.fire(new F("rotate", t3)), this._pitching && this.fire(new F("pitch", t3));
  }
  _afterEase(t3, i) {
    if (this._easeId && i && this._easeId === i) return;
    delete this._easeId;
    let n = this._zooming, o = this._rotating, a = this._pitching;
    this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, n && this.fire(new F("zoomend", t3)), o && this.fire(new F("rotateend", t3)), a && this.fire(new F("pitchend", t3)), this.fire(new F("moveend", t3));
  }
  flyTo(t3, i) {
    var ne;
    if (!t3.essential && Y.prefersReducedMotion) {
      let J = dr(t3, ["center", "zoom", "bearing", "pitch", "around"]);
      return this.jumpTo(J, i);
    }
    this.stop(), t3 = V({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: Cn }, t3);
    let n = this._getTransformForUpdate(), o = this.getZoom(), a = this.getBearing(), s3 = this.getPitch(), l = this.getPadding(), c = "bearing" in t3 ? this._normalizeBearing(t3.bearing, a) : a, p = "pitch" in t3 ? +t3.pitch : s3, h = "padding" in t3 ? t3.padding : n.padding, f = Ht.default.convert(t3.offset), m = n.centerPoint.add(f), y = n.pointLocation(m), { center: g, zoom: x } = n.getConstrained(ie.convert(t3.center || y), (ne = t3.zoom) != null ? ne : o);
    this._normalizeCenter(g);
    let b = n.zoomScale(x - o), w = n.project(y), _ = n.project(g).sub(w), S = t3.curve, P = Math.max(n.width, n.height), T = P / b, L = _.mag();
    if ("minZoom" in t3) {
      let J = Ae(Math.min(t3.minZoom, o, x), n.minZoom, n.maxZoom), W = P / n.zoomScale(J - o);
      S = Math.sqrt(W / L * 2);
    }
    let C = S * S;
    function E(J) {
      let W = (T * T - P * P + (J ? -1 : 1) * C * C * L * L) / (2 * (J ? T : P) * C * L);
      return Math.log(Math.sqrt(W * W + 1) - W);
    }
    r(E, "zoomOutFactor");
    function I(J) {
      return (Math.exp(J) - Math.exp(-J)) / 2;
    }
    r(I, "sinh");
    function R(J) {
      return (Math.exp(J) + Math.exp(-J)) / 2;
    }
    r(R, "cosh");
    function z(J) {
      return I(J) / R(J);
    }
    r(z, "tanh");
    let k = E(false), M = r(function(J) {
      return R(k) / R(k + S * J);
    }, "w"), G = r(function(J) {
      return P * ((R(k) * z(k + S * J) - I(k)) / C) / L;
    }, "u"), K = (E(true) - k) / S;
    if (Math.abs(L) < 1e-6 || !isFinite(K)) {
      if (Math.abs(P - T) < 1e-6) return this.easeTo(t3, i);
      let J = T < P ? -1 : 1;
      K = Math.abs(Math.log(T / P)) / S, G = r(function() {
        return 0;
      }, "u"), M = r(function(W) {
        return Math.exp(J * S * W);
      }, "w");
    }
    if ("duration" in t3) t3.duration = +t3.duration;
    else {
      let J = "screenSpeed" in t3 ? +t3.screenSpeed / S : +t3.speed;
      t3.duration = 1e3 * K / J;
    }
    return t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0), this._zooming = true, this._rotating = a !== c, this._pitching = p !== s3, this._padding = !n.isPaddingEqual(h), this._prepareEase(i, false), this.terrain && this._prepareElevation(g), this._ease((J) => {
      let W = J * K, Je = 1 / M(W);
      n.zoom = J === 1 ? x : o + n.scaleZoom(Je), this._rotating && (n.bearing = Pe.number(a, c, J)), this._pitching && (n.pitch = Pe.number(s3, p, J)), this._padding && (n.interpolatePadding(l, h, J), m = n.centerPoint.add(f)), this.terrain && !t3.freezeElevation && this._updateElevation(J);
      let Ve = J === 1 ? g : n.unproject(w.add(_.mult(G(W))).mult(Je));
      n.setLocationAtPoint(n.renderWorldCopies ? Ve.wrap() : Ve, m), this._applyUpdatedTransform(n), this._fireMoveEvents(i);
    }, () => {
      this.terrain && this._finalizeElevation(), this._afterEase(i);
    }, t3), this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  stop() {
    return this._stop();
  }
  _stop(t3, i) {
    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
      let n = this._onEaseEnd;
      delete this._onEaseEnd, n.call(this, i);
    }
    if (!t3) {
      let n = this.handlers;
      n && n.stop(false);
    }
    return this;
  }
  _ease(t3, i, n) {
    n.animate === false || n.duration === 0 ? (t3(1), i()) : (this._easeStart = Y.now(), this._easeOptions = n, this._onEaseFrame = t3, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
  }
  _normalizeBearing(t3, i) {
    t3 = Qt(t3, -180, 180);
    let n = Math.abs(t3 - i);
    return Math.abs(t3 - 360 - i) < n && (t3 -= 360), Math.abs(t3 + 360 - i) < n && (t3 += 360), t3;
  }
  _normalizeCenter(t3) {
    let i = this.transform;
    if (!i.renderWorldCopies || i.lngRange) return;
    let n = t3.lng - i.center.lng;
    t3.lng += n > 180 ? -360 : n < -180 ? 360 : 0;
  }
  queryTerrainElevation(t3) {
    return this.terrain ? this.terrain.getElevationForLngLatZoom(ie.convert(t3), this.transform.tileZoom) - this.transform.elevation : null;
  }
};
r(ax, "Camera");
var tp = ax;
var hr = u(ge(), 1);
q();
var sx = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
var lx = class lx2 {
  constructor(e = sx) {
    this._toggleAttribution = () => {
      this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
    };
    this._updateData = (e3) => {
      e3 && (e3.sourceDataType === "metadata" || e3.sourceDataType === "visibility" || e3.dataType === "style" || e3.type === "terrain") && this._updateAttributions();
    };
    this._updateCompact = () => {
      this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : !this._container.classList.contains("maplibregl-compact") && !this._container.classList.contains("maplibregl-attrib-empty") && (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
    };
    this._updateCompactMinimize = () => {
      this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-right";
  }
  onAdd(e) {
    return this._map = e, this._compact = this.options.compact, this._container = D.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = D.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = D.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
  }
  onRemove() {
    D.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
  }
  _setElementTitle(e, t3) {
    let i = this._map._getUIString(`AttributionControl.${t3}`);
    e.title = i, e.setAttribute("aria-label", i);
  }
  _updateAttributions() {
    if (!this._map.style) return;
    let e = [];
    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((n) => typeof n != "string" ? "" : n)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
      let n = this._map.style.stylesheet;
      this.styleOwner = n.owner, this.styleId = n.id;
    }
    let t3 = this._map.style.sourceCaches;
    for (let n in t3) {
      let o = t3[n];
      if (o.used || o.usedForTerrain) {
        let a = o.getSource();
        a.attribution && e.indexOf(a.attribution) < 0 && e.push(a.attribution);
      }
    }
    e = e.filter((n) => String(n).trim()), e.sort((n, o) => n.length - o.length), e = e.filter((n, o) => {
      for (let a = o + 1; a < e.length; a++) if (e[a].indexOf(n) >= 0) return false;
      return true;
    });
    let i = e.join(" | ");
    i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
  }
};
r(lx, "AttributionControl");
var ja = lx;
q();
var ux = class ux2 {
  constructor(e = {}) {
    this._updateCompact = () => {
      let e3 = this._container.children;
      if (e3.length) {
        let t3 = e3[0];
        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && t3.classList.add("maplibregl-compact") : t3.classList.remove("maplibregl-compact");
      }
    };
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    this._map = e, this._compact = this.options && this.options.compact, this._container = D.create("div", "maplibregl-ctrl");
    let t3 = D.create("a", "maplibregl-ctrl-logo");
    return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://maplibre.org/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
  onRemove() {
    D.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
  }
};
r(ux, "LogoControl");
var Za = ux;
q();
var cx = class cx2 {
  constructor() {
    this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
  }
  add(e) {
    let t3 = ++this._id;
    return this._queue.push({ callback: e, id: t3, cancelled: false }), t3;
  }
  remove(e) {
    let t3 = this._currentlyRunning, i = t3 ? this._queue.concat(t3) : this._queue;
    for (let n of i) if (n.id === e) {
      n.cancelled = true;
      return;
    }
  }
  run(e = 0) {
    if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
    let t3 = this._currentlyRunning = this._queue;
    this._queue = [];
    for (let i of t3) if (!i.cancelled && (i.callback(e), this._cleared)) break;
    this._cleared = false, this._currentlyRunning = false;
  }
  clear() {
    this._currentlyRunning && (this._cleared = true), this._queue = [];
  }
};
r(cx, "TaskQueue");
var rp = cx;
q();
var np = ((i) => (i.create = "create", i.load = "load", i.fullLoad = "fullLoad", i))(np || {});
var ip = null;
var Ha = [];
var cD = 60;
var px = 1e3 / cD;
var hx = "loadTime";
var fx = "fullLoadTime";
var Tn = { mark(r3) {
  performance.mark(r3);
}, frame(r3) {
  let e = r3;
  if (ip != null) {
    let t3 = e - ip;
    Ha.push(t3);
  }
  ip = e;
}, clearMetrics() {
  ip = null, Ha = [], performance.clearMeasures(hx), performance.clearMeasures(fx);
  for (let r3 in np) performance.clearMarks(np[r3]);
}, getPerformanceMetrics() {
  performance.measure(hx, "create", "load"), performance.measure(fx, "create", "fullLoad");
  let r3 = performance.getEntriesByName(hx)[0].duration, e = performance.getEntriesByName(fx)[0].duration, t3 = Ha.length, n = 1 / (Ha.reduce((s3, l) => s3 + l, 0) / t3 / 1e3), o = Ha.filter((s3) => s3 > px).reduce((s3, l) => s3 + (l - px) / px, 0), a = o / (t3 + o) * 100;
  return { loadTime: r3, fullLoadTime: e, fps: n, percentDroppedFrames: a, totalFrames: t3 };
} };
q();
q();
var r2 = _e([{ name: "a_pos3d", type: "Int16", components: 3 }]);
q();
var mx = class mx2 extends de {
  constructor(e) {
    super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = true, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
  }
  destruct() {
    this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
  }
  update(e, t3) {
    this.sourceCache.update(e, t3), this._renderableTilesKeys = [];
    let i = {};
    for (let n of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: t3 })) i[n.key] = true, this._renderableTilesKeys.push(n.key), this._tiles[n.key] || (n.posMatrix = new Float64Array(16), $.ortho(n.posMatrix, 0, 8192, 0, 8192, 0, 1), this._tiles[n.key] = new bn(n, this.tileSize));
    for (let n in this._tiles) i[n] || delete this._tiles[n];
  }
  freeRtt(e) {
    for (let t3 in this._tiles) {
      let i = this._tiles[t3];
      (!e || i.tileID.equals(e) || i.tileID.isChildOf(e) || e.isChildOf(i.tileID)) && (i.rtt = []);
    }
  }
  getRenderableTiles() {
    return this._renderableTilesKeys.map((e) => this.getTileByID(e));
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  getTerrainCoords(e) {
    let t3 = {};
    for (let i of this._renderableTilesKeys) {
      let n = this._tiles[i].tileID;
      if (n.canonical.equals(e.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16), $.ortho(o.posMatrix, 0, 8192, 0, 8192, 0, 1), t3[i] = o;
      } else if (n.canonical.isChildOf(e.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16);
        let a = n.canonical.z - e.canonical.z, s3 = n.canonical.x - (n.canonical.x >> a << a), l = n.canonical.y - (n.canonical.y >> a << a), c = 8192 >> a;
        $.ortho(o.posMatrix, 0, c, 0, c, 0, 1), $.translate(o.posMatrix, o.posMatrix, [-s3 * c, -l * c, 0]), t3[i] = o;
      } else if (e.canonical.isChildOf(n.canonical)) {
        let o = e.clone();
        o.posMatrix = new Float64Array(16);
        let a = e.canonical.z - n.canonical.z, s3 = e.canonical.x - (e.canonical.x >> a << a), l = e.canonical.y - (e.canonical.y >> a << a), c = 8192 >> a;
        $.ortho(o.posMatrix, 0, 8192, 0, 8192, 0, 1), $.translate(o.posMatrix, o.posMatrix, [s3 * c, l * c, 0]), $.scale(o.posMatrix, o.posMatrix, [1 / 2 ** a, 1 / 2 ** a, 0]), t3[i] = o;
      }
    }
    return t3;
  }
  getSourceTile(e, t3) {
    let i = this.sourceCache._source, n = e.overscaledZ - this.deltaZoom;
    if (n > i.maxzoom && (n = i.maxzoom), n < i.minzoom) return null;
    this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(n).key);
    let o = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
    if (!(o && o.dem) && t3) for (; n >= i.minzoom && !(o && o.dem); ) o = this.sourceCache.getTileByID(e.scaledTo(n--).key);
    return o;
  }
  tilesAfterTime(e = Date.now()) {
    return Object.values(this._tiles).filter((t3) => t3.timeAdded >= e);
  }
};
r(mx, "TerrainSourceCache");
var op = mx;
var dx = class dx2 {
  constructor(e, t3, i) {
    this.painter = e, this.sourceCache = new op(t3), this.options = i, this.exaggeration = typeof i.exaggeration == "number" ? i.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
  }
  getDEMElevation(e, t3, i, n = 8192) {
    var m;
    if (!(t3 >= 0 && t3 < n && i >= 0 && i < n)) return 0;
    let o = this.getTerrainData(e), a = (m = o.tile) == null ? void 0 : m.dem;
    if (!a) return 0;
    let s3 = nn.transformMat4([], [t3 / n * 8192, i / n * 8192], o.u_terrain_matrix), l = [s3[0] * a.dim, s3[1] * a.dim], c = Math.floor(l[0]), p = Math.floor(l[1]), h = l[0] - c, f = l[1] - p;
    return a.get(c, p) * (1 - h) * (1 - f) + a.get(c + 1, p) * h * (1 - f) + a.get(c, p + 1) * (1 - h) * f + a.get(c + 1, p + 1) * h * f;
  }
  getElevationForLngLatZoom(e, t3) {
    let { tileID: i, mercatorX: n, mercatorY: o } = this._getOverscaledTileIDFromLngLatZoom(e, t3);
    return this.getElevation(i, n % 8192, o % 8192, 8192);
  }
  getElevation(e, t3, i, n = 8192) {
    return this.getDEMElevation(e, t3, i, n) * this.exaggeration;
  }
  getTerrainData(e) {
    if (!this._emptyDemTexture) {
      let n = this.painter.context, o = new Se({ width: 1, height: 1 }, new Uint8Array(1 * 4));
      this._emptyDepthTexture = new ve(n, o, n.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new ve(n, new Se({ width: 1, height: 1 }), n.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(n.gl.NEAREST, n.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = $.identity([]);
    }
    let t3 = this.sourceCache.getSourceTile(e, true);
    if (t3 && t3.dem && (!t3.demTexture || t3.needsTerrainPrepare)) {
      let n = this.painter.context;
      t3.demTexture = this.painter.getTileTexture(t3.dem.stride), t3.demTexture ? t3.demTexture.update(t3.dem.getPixels(), { premultiply: false }) : t3.demTexture = new ve(n, t3.dem.getPixels(), n.gl.RGBA, { premultiply: false }), t3.demTexture.bind(n.gl.NEAREST, n.gl.CLAMP_TO_EDGE), t3.needsTerrainPrepare = false;
    }
    let i = t3 && t3 + t3.tileID.key + e.key;
    if (i && !this._demMatrixCache[i]) {
      let n = this.sourceCache.sourceCache._source.maxzoom, o = e.canonical.z - t3.tileID.canonical.z;
      e.overscaledZ > e.canonical.z && (e.canonical.z >= n ? o = e.canonical.z - n : ke("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
      let a = e.canonical.x - (e.canonical.x >> o << o), s3 = e.canonical.y - (e.canonical.y >> o << o), l = $.fromScaling(new Float64Array(16), [1 / (8192 << o), 1 / (8192 << o), 0]);
      $.translate(l, l, [a * 8192, s3 * 8192, 0]), this._demMatrixCache[e.key] = { matrix: l, coord: e };
    }
    return { u_depth: 2, u_terrain: 3, u_terrain_dim: t3 && t3.dem && t3.dem.dim || 1, u_terrain_matrix: i ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: t3 && t3.dem && t3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (t3 && t3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: t3 };
  }
  getFramebuffer(e) {
    let t3 = this.painter, i = t3.width / devicePixelRatio, n = t3.height / devicePixelRatio;
    return this._fbo && (this._fbo.width !== i || this._fbo.height !== n) && (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new ve(t3.context, { width: i, height: n, data: null }, t3.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t3.context.gl.NEAREST, t3.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new ve(t3.context, { width: i, height: n, data: null }, t3.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t3.context.gl.NEAREST, t3.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t3.context.createFramebuffer(i, n, true, false), this._fbo.depthAttachment.set(t3.context.createRenderbuffer(t3.context.gl.DEPTH_COMPONENT16, i, n))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
  }
  getCoordsTexture() {
    let e = this.painter.context;
    if (this._coordsTexture) return this._coordsTexture;
    let t3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
    for (let o = 0, a = 0; o < this._coordsTextureSize; o++) for (let s3 = 0; s3 < this._coordsTextureSize; s3++, a += 4) t3[a + 0] = s3 & 255, t3[a + 1] = o & 255, t3[a + 2] = s3 >> 8 << 4 | o >> 8, t3[a + 3] = 0;
    let i = new Se({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(t3.buffer)), n = new ve(e, i, e.gl.RGBA, { premultiply: false });
    return n.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = n, n;
  }
  pointCoordinate(e) {
    this.painter.maybeDrawDepthAndCoords(true);
    let t3 = new Uint8Array(4), i = this.painter.context, n = i.gl, o = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), a = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), s3 = Math.round(this.painter.height / devicePixelRatio);
    i.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), n.readPixels(o, s3 - a - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, t3), i.bindFramebuffer.set(null);
    let l = t3[0] + (t3[2] >> 4 << 8), c = t3[1] + ((t3[2] & 15) << 8), p = this.coordsIndex[255 - t3[3]], h = p && this.sourceCache.getTileByID(p);
    if (!h) return null;
    let f = this._coordsTextureSize, m = (1 << h.tileID.canonical.z) * f;
    return new Fe((h.tileID.canonical.x * f + l) / m + h.tileID.wrap, (h.tileID.canonical.y * f + c) / m, this.getElevation(h.tileID, l, c, f));
  }
  depthAtPoint(e) {
    let t3 = new Uint8Array(4), i = this.painter.context, n = i.gl;
    return i.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), n.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, t3), i.bindFramebuffer.set(null), (t3[0] / (256 * 256 * 256) + t3[1] / (256 * 256) + t3[2] / 256 + t3[3]) / 256;
  }
  getTerrainMesh() {
    if (this._mesh) return this._mesh;
    let e = this.painter.context, t3 = new pl(), i = new rt(), n = this.meshSize, o = 8192 / n, a = n * n;
    for (let h = 0; h <= n; h++) for (let f = 0; f <= n; f++) t3.emplaceBack(f * o, h * o, 0);
    for (let h = 0; h < a; h += n + 1) for (let f = 0; f < n; f++) i.emplaceBack(f + h, n + f + h + 1, n + f + h + 2), i.emplaceBack(f + h, n + f + h + 2, f + h + 1);
    let s3 = t3.length, l = s3 + (n + 1) * 2;
    for (let h of [0, 1]) for (let f = 0; f <= n; f++) for (let m of [0, 1]) t3.emplaceBack(f * o, h * 8192, m);
    for (let h = 0; h < n * 2; h += 2) i.emplaceBack(l + h, l + h + 1, l + h + 3), i.emplaceBack(l + h, l + h + 3, l + h + 2), i.emplaceBack(s3 + h, s3 + h + 3, s3 + h + 1), i.emplaceBack(s3 + h, s3 + h + 2, s3 + h + 3);
    let c = t3.length, p = c + (n + 1) * 2;
    for (let h of [0, 1]) for (let f = 0; f <= n; f++) for (let m of [0, 1]) t3.emplaceBack(h * 8192, f * o, m);
    for (let h = 0; h < n * 2; h += 2) i.emplaceBack(c + h, c + h + 1, c + h + 3), i.emplaceBack(c + h, c + h + 3, c + h + 2), i.emplaceBack(p + h, p + h + 3, p + h + 1), i.emplaceBack(p + h, p + h + 2, p + h + 3);
    return this._mesh = { indexBuffer: e.createIndexBuffer(i), vertexBuffer: e.createVertexBuffer(t3, r2.members), segments: me.simpleSegment(0, 0, t3.length, i.length) }, this._mesh;
  }
  getMeshFrameDelta(e) {
    return 2 * Math.PI * la / Math.pow(2, e) / 5;
  }
  getMinTileElevationForLngLatZoom(e, t3) {
    var n;
    let { tileID: i } = this._getOverscaledTileIDFromLngLatZoom(e, t3);
    return (n = this.getMinMaxElevation(i).minElevation) != null ? n : 0;
  }
  getMinMaxElevation(e) {
    let t3 = this.getTerrainData(e).tile, i = { minElevation: null, maxElevation: null };
    return t3 && t3.dem && (i.minElevation = t3.dem.min * this.exaggeration, i.maxElevation = t3.dem.max * this.exaggeration), i;
  }
  _getOverscaledTileIDFromLngLatZoom(e, t3) {
    let i = Fe.fromLngLat(e.wrap()), n = (1 << t3) * 8192, o = i.x * n, a = i.y * n, s3 = Math.floor(o / 8192), l = Math.floor(a / 8192);
    return { tileID: new Ke(t3, 0, t3, s3, l), mercatorX: o, mercatorY: a };
  }
};
r(dx, "Terrain");
var ap = dx;
q();
q();
var yx = class yx2 {
  constructor(e, t3, i) {
    this._context = e;
    this._size = t3;
    this._tileSize = i;
    this._objects = [], this._recentlyUsed = [], this._stamp = 0;
  }
  destruct() {
    for (let e of this._objects) e.texture.destroy(), e.fbo.destroy();
  }
  _createObject(e) {
    let t3 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i = new ve(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
    return i.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), t3.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t3.colorAttachment.set(i.texture), { id: e, fbo: t3, texture: i, stamp: -1, inUse: false };
  }
  getObjectForId(e) {
    return this._objects[e];
  }
  useObject(e) {
    e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t3) => e.id !== t3), this._recentlyUsed.push(e.id);
  }
  stampObject(e) {
    e.stamp = ++this._stamp;
  }
  getOrCreateFreeObject() {
    for (let t3 of this._recentlyUsed) if (!this._objects[t3].inUse) return this._objects[t3];
    if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
    let e = this._createObject(this._objects.length);
    return this._objects.push(e), e;
  }
  freeObject(e) {
    e.inUse = false;
  }
  freeAllObjects() {
    for (let e of this._objects) this.freeObject(e);
  }
  isFull() {
    return this._objects.length < this._size ? false : this._objects.some((e) => !e.inUse) === false;
  }
};
r(yx, "RenderPool");
var sp = yx;
var Mn = { background: true, fill: true, line: true, raster: true, hillshade: true };
var gx = class gx2 {
  constructor(e, t3) {
    this.painter = e, this.terrain = t3, this.pool = new sp(e.context, 30, t3.sourceCache.tileSize * t3.qualityFactor);
  }
  destruct() {
    this.pool.destruct();
  }
  getTexture(e) {
    return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
  }
  prepareForRender(e, t3) {
    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((i) => !e._layers[i].isHidden(t3)), this._coordsDescendingInv = {};
    for (let i in e.sourceCaches) {
      this._coordsDescendingInv[i] = {};
      let n = e.sourceCaches[i].getVisibleCoordinates();
      for (let o of n) {
        let a = this.terrain.sourceCache.getTerrainCoords(o);
        for (let s3 in a) this._coordsDescendingInv[i][s3] || (this._coordsDescendingInv[i][s3] = []), this._coordsDescendingInv[i][s3].push(a[s3]);
      }
    }
    this._coordsDescendingInvStr = {};
    for (let i of e._order) {
      let n = e._layers[i], o = n.source;
      if (Mn[n.type] && !this._coordsDescendingInvStr[o]) {
        this._coordsDescendingInvStr[o] = {};
        for (let a in this._coordsDescendingInv[o]) this._coordsDescendingInvStr[o][a] = this._coordsDescendingInv[o][a].map((s3) => s3.key).sort().join();
      }
    }
    for (let i of this._renderableTiles) for (let n in this._coordsDescendingInvStr) {
      let o = this._coordsDescendingInvStr[n][i.tileID.key];
      o && o !== i.rttCoords[n] && (i.rtt = []);
    }
  }
  renderLayer(e) {
    if (e.isHidden(this.painter.transform.zoom)) return false;
    let t3 = e.type, i = this.painter, n = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
    if (Mn[t3] && ((!this._prevType || !Mn[this._prevType]) && this._stacks.push([]), this._prevType = t3, this._stacks[this._stacks.length - 1].push(e.id), !n)) return true;
    if (Mn[this._prevType] || Mn[t3] && n) {
      this._prevType = t3;
      let o = this._stacks.length - 1, a = this._stacks[o] || [];
      for (let s3 of this._renderableTiles) {
        if (this.pool.isFull() && (_g(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(s3), s3.rtt[o]) {
          let c = this.pool.getObjectForId(s3.rtt[o].id);
          if (c.stamp === s3.rtt[o].stamp) {
            this.pool.useObject(c);
            continue;
          }
        }
        let l = this.pool.getOrCreateFreeObject();
        this.pool.useObject(l), this.pool.stampObject(l), s3.rtt[o] = { id: l.id, stamp: l.stamp }, i.context.bindFramebuffer.set(l.fbo.framebuffer), i.context.clear({ color: X.transparent, stencil: 0 }), i.currentStencilSource = void 0;
        for (let c = 0; c < a.length; c++) {
          let p = i.style._layers[a[c]], h = p.source ? this._coordsDescendingInv[p.source][s3.tileID.key] : [s3.tileID];
          i.context.viewport.set([0, 0, l.fbo.width, l.fbo.height]), i._renderTileClippingMasks(p, h), i.renderLayer(i, i.style.sourceCaches[p.source], p, h), p.source && (s3.rttCoords[p.source] = this._coordsDescendingInvStr[p.source][s3.tileID.key]);
        }
      }
      return _g(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Mn[t3];
    }
    return false;
  }
};
r(gx, "RenderToTexture");
var lp = gx;
q();
var i2 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" };
var pD = Qa.version;
var cp = -2;
var n2 = 22;
var Ur = 0;
var o2 = 80;
var up = 85;
var hD = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: cp, maxZoom: n2, minPitch: Ur, maxPitch: o2, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: sx, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: ot.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] };
var bx = class bx2 extends tp {
  constructor(t3) {
    if (Tn.mark("create"), t3 = V({}, hD, t3), t3.minZoom != null && t3.maxZoom != null && t3.minZoom > t3.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
    if (t3.minPitch != null && t3.maxPitch != null && t3.minPitch > t3.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
    if (t3.minPitch != null && t3.minPitch < Ur) throw new Error(`minPitch must be greater than or equal to ${Ur}`);
    if (t3.maxPitch != null && t3.maxPitch > up) throw new Error(`maxPitch must be less than or equal to ${up}`);
    let i = new Fc(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies);
    super(i, { bearingSnap: t3.bearingSnap });
    this._contextLost = (t4) => {
      t4.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new F("webglcontextlost", { originalEvent: t4 }));
    };
    this._contextRestored = (t4) => {
      this._setupPainter(), this.resize(), this._update(), this.fire(new F("webglcontextrestored", { originalEvent: t4 }));
    };
    this._onMapScroll = (t4) => {
      if (t4.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
    };
    this._onWindowOnline = () => {
      this._update();
    };
    if (this._interactive = t3.interactive, this._maxTileCacheSize = t3.maxTileCacheSize, this._maxTileCacheZoomLevels = t3.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._crossSourceCollisions = t3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t3.collectResourceTiming, this._renderTaskQueue = new rp(), this._controls = [], this._mapId = rs(), this._locale = V({}, i2, t3.locale), this._clickTolerance = t3.clickTolerance, this._overridePixelRatio = t3.pixelRatio, this._maxCanvasSize = t3.maxCanvasSize, this.transformCameraUpdate = t3.transformCameraUpdate, this._imageQueueHandle = st.addThrottleControl(() => this.isMoving()), this._requestManager = new ls(t3.transformRequest), typeof t3.container == "string") {
      if (this._container = document.getElementById(t3.container), !this._container) throw new Error(`Container '${t3.container}' not found.`);
    } else if (t3.container instanceof HTMLElement) this._container = t3.container;
    else throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    if (t3.maxBounds && this.setMaxBounds(t3.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
      this.painter.terrainFacilitator.dirty = true, this._update(true);
    }), this.once("idle", () => {
      this._idleTriggered = true;
    }), typeof window < "u") {
      addEventListener("online", this._onWindowOnline, false);
      let o = false, a = Bc((s3) => {
        this._trackResize && !this._removed && this.resize(s3)._update();
      }, 50);
      this._resizeObserver = new ResizeObserver((s3) => {
        if (!o) {
          o = true;
          return;
        }
        a(s3);
      }), this._resizeObserver.observe(this._container);
    }
    this.handlers = new ep(this, t3);
    let n = typeof t3.hash == "string" && t3.hash || void 0;
    this._hash = t3.hash && new Ca(n).addTo(this), (!this._hash || !this._hash._onHashChange()) && (this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch }), t3.bounds && (this.resize(), this.fitBounds(t3.bounds, V({}, t3.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t3.localIdeographFontFamily, this._validateStyle = t3.validateStyle, t3.style && this.setStyle(t3.style, { localIdeographFontFamily: t3.localIdeographFontFamily }), t3.attributionControl && this.addControl(new ja(typeof t3.attributionControl == "boolean" ? void 0 : t3.attributionControl)), t3.maplibreLogo && this.addControl(new Za(), t3.logoPosition), this.on("style.load", () => {
      this.transform.unmodified && this.jumpTo(this.style.stylesheet);
    }), this.on("data", (o) => {
      this._update(o.dataType === "style"), this.fire(new F(`${o.dataType}data`, o));
    }), this.on("dataloading", (o) => {
      this.fire(new F(`${o.dataType}dataloading`, o));
    }), this.on("dataabort", (o) => {
      this.fire(new F("sourcedataabort", o));
    });
  }
  _getMapId() {
    return this._mapId;
  }
  addControl(t3, i) {
    if (i === void 0 && (t3.getDefaultPosition ? i = t3.getDefaultPosition() : i = "top-right"), !t3 || !t3.onAdd) return this.fire(new Z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
    let n = t3.onAdd(this);
    this._controls.push(t3);
    let o = this._controlPositions[i];
    return i.indexOf("bottom") !== -1 ? o.insertBefore(n, o.firstChild) : o.appendChild(n), this;
  }
  removeControl(t3) {
    if (!t3 || !t3.onRemove) return this.fire(new Z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
    let i = this._controls.indexOf(t3);
    return i > -1 && this._controls.splice(i, 1), t3.onRemove(this), this;
  }
  hasControl(t3) {
    return this._controls.indexOf(t3) > -1;
  }
  calculateCameraOptionsFromTo(t3, i, n, o) {
    return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t3, i, n, o);
  }
  resize(t3) {
    var l;
    let i = this._containerDimensions(), n = i[0], o = i[1], a = this._getClampedPixelRatio(n, o);
    if (this._resizeCanvas(n, o, a), this.painter.resize(n, o, a), this.painter.overLimit()) {
      let c = this.painter.context.gl;
      this._maxCanvasSize = [c.drawingBufferWidth, c.drawingBufferHeight];
      let p = this._getClampedPixelRatio(n, o);
      this._resizeCanvas(n, o, p), this.painter.resize(n, o, p);
    }
    this.transform.resize(n, o), (l = this._requestedCameraState) == null || l.resize(n, o);
    let s3 = !this._moving;
    return s3 && (this.stop(), this.fire(new F("movestart", t3)).fire(new F("move", t3))), this.fire(new F("resize", t3)), s3 && this.fire(new F("moveend", t3)), this;
  }
  _getClampedPixelRatio(t3, i) {
    let { 0: n, 1: o } = this._maxCanvasSize, a = this.getPixelRatio(), s3 = t3 * a, l = i * a, c = s3 > n ? n / s3 : 1, p = l > o ? o / l : 1;
    return Math.min(c, p) * a;
  }
  getPixelRatio() {
    var t3;
    return (t3 = this._overridePixelRatio) != null ? t3 : devicePixelRatio;
  }
  setPixelRatio(t3) {
    this._overridePixelRatio = t3, this.resize();
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(t3) {
    return this.transform.setMaxBounds(ut.convert(t3)), this._update();
  }
  setMinZoom(t3) {
    if (t3 = t3 == null ? cp : t3, t3 >= cp && t3 <= this.transform.maxZoom) return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 && this.setZoom(t3), this;
    throw new Error(`minZoom must be between ${cp} and the current maxZoom, inclusive`);
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(t3) {
    if (t3 = t3 == null ? n2 : t3, t3 >= this.transform.minZoom) return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 && this.setZoom(t3), this;
    throw new Error("maxZoom must be greater than the current minZoom");
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(t3) {
    if (t3 = t3 == null ? Ur : t3, t3 < Ur) throw new Error(`minPitch must be greater than or equal to ${Ur}`);
    if (t3 >= Ur && t3 <= this.transform.maxPitch) return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 && this.setPitch(t3), this;
    throw new Error(`minPitch must be between ${Ur} and the current maxPitch, inclusive`);
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(t3) {
    if (t3 = t3 == null ? o2 : t3, t3 > up) throw new Error(`maxPitch must be less than or equal to ${up}`);
    if (t3 >= this.transform.minPitch) return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 && this.setPitch(t3), this;
    throw new Error("maxPitch must be greater than the current minPitch");
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(t3) {
    return this.transform.renderWorldCopies = t3, this._update();
  }
  project(t3) {
    return this.transform.locationPoint(ie.convert(t3), this.style && this.terrain);
  }
  unproject(t3) {
    return this.transform.pointLocation(hr.default.convert(t3), this.terrain);
  }
  isMoving() {
    var t3;
    return this._moving || ((t3 = this.handlers) == null ? void 0 : t3.isMoving());
  }
  isZooming() {
    var t3;
    return this._zooming || ((t3 = this.handlers) == null ? void 0 : t3.isZooming());
  }
  isRotating() {
    var t3;
    return this._rotating || ((t3 = this.handlers) == null ? void 0 : t3.isRotating());
  }
  _createDelegatedListener(t3, i, n) {
    if (t3 === "mouseenter" || t3 === "mouseover") {
      let o = false;
      return { layer: i, listener: n, delegates: { mousemove: r((l) => {
        let c = this.getLayer(i) ? this.queryRenderedFeatures(l.point, { layers: [i] }) : [];
        c.length ? o || (o = true, n.call(this, new it(t3, this, l.originalEvent, { features: c }))) : o = false;
      }, "mousemove"), mouseout: r(() => {
        o = false;
      }, "mouseout") } };
    } else if (t3 === "mouseleave" || t3 === "mouseout") {
      let o = false;
      return { layer: i, listener: n, delegates: { mousemove: r((l) => {
        (this.getLayer(i) ? this.queryRenderedFeatures(l.point, { layers: [i] }) : []).length ? o = true : o && (o = false, n.call(this, new it(t3, this, l.originalEvent)));
      }, "mousemove"), mouseout: r((l) => {
        o && (o = false, n.call(this, new it(t3, this, l.originalEvent)));
      }, "mouseout") } };
    } else {
      let o = r((a) => {
        let s3 = this.getLayer(i) ? this.queryRenderedFeatures(a.point, { layers: [i] }) : [];
        s3.length && (a.features = s3, n.call(this, a), delete a.features);
      }, "delegate");
      return { layer: i, listener: n, delegates: { [t3]: o } };
    }
  }
  on(t3, i, n) {
    if (n === void 0) return super.on(t3, i);
    let o = this._createDelegatedListener(t3, i, n);
    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t3] = this._delegatedListeners[t3] || [], this._delegatedListeners[t3].push(o);
    for (let a in o.delegates) this.on(a, o.delegates[a]);
    return this;
  }
  once(t3, i, n) {
    if (n === void 0) return super.once(t3, i);
    let o = this._createDelegatedListener(t3, i, n);
    for (let a in o.delegates) this.once(a, o.delegates[a]);
    return this;
  }
  off(t3, i, n) {
    if (n === void 0) return super.off(t3, i);
    let o = r((a) => {
      let s3 = a[t3];
      for (let l = 0; l < s3.length; l++) {
        let c = s3[l];
        if (c.layer === i && c.listener === n) {
          for (let p in c.delegates) this.off(p, c.delegates[p]);
          return s3.splice(l, 1), this;
        }
      }
    }, "removeDelegatedListener");
    return this._delegatedListeners && this._delegatedListeners[t3] && o(this._delegatedListeners), this;
  }
  queryRenderedFeatures(t3, i) {
    if (!this.style) return [];
    let n, o = t3 instanceof hr.default || Array.isArray(t3), a = o ? t3 : [[0, 0], [this.transform.width, this.transform.height]];
    if (i = i || (o ? {} : t3) || {}, a instanceof hr.default || typeof a[0] == "number") n = [hr.default.convert(a)];
    else {
      let s3 = hr.default.convert(a[0]), l = hr.default.convert(a[1]);
      n = [s3, new hr.default(l.x, s3.y), l, new hr.default(s3.x, l.y), s3];
    }
    return this.style.queryRenderedFeatures(n, i, this.transform);
  }
  querySourceFeatures(t3, i) {
    return this.style.querySourceFeatures(t3, i);
  }
  setStyle(t3, i) {
    return i = V({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i), i.diff !== false && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t3 ? (this._diffStyle(t3, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(t3, i));
  }
  setTransformRequest(t3) {
    return this._requestManager.setTransformRequest(t3), this;
  }
  _getUIString(t3) {
    let i = this._locale[t3];
    if (i == null) throw new Error(`Missing UI string '${t3}'`);
    return i;
  }
  _updateStyle(t3, i) {
    if (i.transformStyle && this.style && !this.style._loaded) {
      this.style.once("style.load", () => this._updateStyle(t3, i));
      return;
    }
    let n = this.style && i.transformStyle ? this.style.serialize() : void 0;
    if (this.style && (this.style.setEventedParent(null), this.style._remove(!t3)), t3) this.style = new wn(this, i || {});
    else return delete this.style, this;
    return this.style.setEventedParent(this, { style: this.style }), typeof t3 == "string" ? this.style.loadURL(t3, i, n) : this.style.loadJSON(t3, i, n), this;
  }
  _lazyInitEmptyStyle() {
    this.style || (this.style = new wn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
  }
  _diffStyle(t3, i) {
    if (typeof t3 == "string") {
      let n = t3, o = this._requestManager.transformRequest(n, "Style");
      yr(o, new AbortController()).then((a) => {
        this._updateDiff(a.data, i);
      }).catch((a) => {
        a && this.fire(new Z(a));
      });
    } else typeof t3 == "object" && this._updateDiff(t3, i);
  }
  _updateDiff(t3, i) {
    try {
      this.style.setState(t3, i) && this._update(true);
    } catch (n) {
      ke(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`), this._updateStyle(t3, i);
    }
  }
  getStyle() {
    if (this.style) return this.style.serialize();
  }
  isStyleLoaded() {
    return this.style ? this.style.loaded() : ke("There is no style added to the map.");
  }
  addSource(t3, i) {
    return this._lazyInitEmptyStyle(), this.style.addSource(t3, i), this._update(true);
  }
  isSourceLoaded(t3) {
    let i = this.style && this.style.sourceCaches[t3];
    if (i === void 0) {
      this.fire(new Z(new Error(`There is no source with ID '${t3}'`)));
      return;
    }
    return i.loaded();
  }
  setTerrain(t3) {
    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), !t3) this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
    else {
      let i = this.style.sourceCaches[t3.source];
      if (!i) throw new Error(`cannot load terrain, because there exists no source with ID: ${t3.source}`);
      this.terrain === null && i.reload();
      for (let n in this.style._layers) {
        let o = this.style._layers[n];
        o.type === "hillshade" && o.source === t3.source && ke("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
      }
      this.terrain = new ap(this.painter, i, t3), this.painter.renderToTexture = new lp(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (n) => {
        n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId === t3.source && !this._elevationFreeze && (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(n.tile.tileID));
      }, this.style.on("data", this._terrainDataCallback);
    }
    return this.fire(new F("terrain", { terrain: t3 })), this;
  }
  getTerrain() {
    var t3, i;
    return (i = (t3 = this.terrain) == null ? void 0 : t3.options) != null ? i : null;
  }
  areTilesLoaded() {
    let t3 = this.style && this.style.sourceCaches;
    for (let i in t3) {
      let o = t3[i]._tiles;
      for (let a in o) {
        let s3 = o[a];
        if (!(s3.state === "loaded" || s3.state === "errored")) return false;
      }
    }
    return true;
  }
  removeSource(t3) {
    return this.style.removeSource(t3), this._update(true);
  }
  getSource(t3) {
    return this.style.getSource(t3);
  }
  addImage(t3, i, n = {}) {
    let { pixelRatio: o = 1, sdf: a = false, stretchX: s3, stretchY: l, content: c } = n;
    this._lazyInitEmptyStyle();
    let p = 0;
    if (i instanceof HTMLImageElement || ht(i)) {
      let { width: h, height: f, data: m } = Y.getImageData(i);
      this.style.addImage(t3, { data: new Se({ width: h, height: f }, m), pixelRatio: o, stretchX: s3, stretchY: l, content: c, sdf: a, version: p });
    } else {
      if (i.width === void 0 || i.height === void 0) return this.fire(new Z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
      {
        let { width: h, height: f, data: m } = i, y = i;
        return this.style.addImage(t3, { data: new Se({ width: h, height: f }, new Uint8Array(m)), pixelRatio: o, stretchX: s3, stretchY: l, content: c, sdf: a, version: p, userImage: y }), y.onAdd && y.onAdd(this, t3), this;
      }
    }
  }
  updateImage(t3, i) {
    let n = this.style.getImage(t3);
    if (!n) return this.fire(new Z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
    let o = i instanceof HTMLImageElement || ht(i) ? Y.getImageData(i) : i, { width: a, height: s3, data: l } = o;
    if (a === void 0 || s3 === void 0) return this.fire(new Z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
    if (a !== n.data.width || s3 !== n.data.height) return this.fire(new Z(new Error("The width and height of the updated image must be that same as the previous version of the image")));
    let c = !(i instanceof HTMLImageElement || ht(i));
    return n.data.replace(l, c), this.style.updateImage(t3, n), this;
  }
  getImage(t3) {
    return this.style.getImage(t3);
  }
  hasImage(t3) {
    return t3 ? !!this.style.getImage(t3) : (this.fire(new Z(new Error("Missing required image id"))), false);
  }
  removeImage(t3) {
    this.style.removeImage(t3);
  }
  loadImage(t3) {
    return st.getImage(this._requestManager.transformRequest(t3, "Image"), new AbortController());
  }
  listImages() {
    return this.style.listImages();
  }
  addLayer(t3, i) {
    return this._lazyInitEmptyStyle(), this.style.addLayer(t3, i), this._update(true);
  }
  moveLayer(t3, i) {
    return this.style.moveLayer(t3, i), this._update(true);
  }
  removeLayer(t3) {
    return this.style.removeLayer(t3), this._update(true);
  }
  getLayer(t3) {
    return this.style.getLayer(t3);
  }
  getLayersOrder() {
    return this.style.getLayersOrder();
  }
  setLayerZoomRange(t3, i, n) {
    return this.style.setLayerZoomRange(t3, i, n), this._update(true);
  }
  setFilter(t3, i, n = {}) {
    return this.style.setFilter(t3, i, n), this._update(true);
  }
  getFilter(t3) {
    return this.style.getFilter(t3);
  }
  setPaintProperty(t3, i, n, o = {}) {
    return this.style.setPaintProperty(t3, i, n, o), this._update(true);
  }
  getPaintProperty(t3, i) {
    return this.style.getPaintProperty(t3, i);
  }
  setLayoutProperty(t3, i, n, o = {}) {
    return this.style.setLayoutProperty(t3, i, n, o), this._update(true);
  }
  getLayoutProperty(t3, i) {
    return this.style.getLayoutProperty(t3, i);
  }
  setGlyphs(t3, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setGlyphs(t3, i), this._update(true);
  }
  getGlyphs() {
    return this.style.getGlyphsUrl();
  }
  addSprite(t3, i, n = {}) {
    return this._lazyInitEmptyStyle(), this.style.addSprite(t3, i, n, (o) => {
      o || this._update(true);
    }), this;
  }
  removeSprite(t3) {
    return this._lazyInitEmptyStyle(), this.style.removeSprite(t3), this._update(true);
  }
  getSprite() {
    return this.style.getSprite();
  }
  setSprite(t3, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSprite(t3, i, (n) => {
      n || this._update(true);
    }), this;
  }
  setLight(t3, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setLight(t3, i), this._update(true);
  }
  getLight() {
    return this.style.getLight();
  }
  setFeatureState(t3, i) {
    return this.style.setFeatureState(t3, i), this._update();
  }
  removeFeatureState(t3, i) {
    return this.style.removeFeatureState(t3, i), this._update();
  }
  getFeatureState(t3) {
    return this.style.getFeatureState(t3);
  }
  getContainer() {
    return this._container;
  }
  getCanvasContainer() {
    return this._canvasContainer;
  }
  getCanvas() {
    return this._canvas;
  }
  _containerDimensions() {
    let t3 = 0, i = 0;
    return this._container && (t3 = this._container.clientWidth || 400, i = this._container.clientHeight || 300), [t3, i];
  }
  _setupContainer() {
    let t3 = this._container;
    t3.classList.add("maplibregl-map");
    let i = this._canvasContainer = D.create("div", "maplibregl-canvas-container", t3);
    this._interactive && i.classList.add("maplibregl-interactive"), this._canvas = D.create("canvas", "maplibregl-canvas", i), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
    let n = this._containerDimensions(), o = this._getClampedPixelRatio(n[0], n[1]);
    this._resizeCanvas(n[0], n[1], o);
    let a = this._controlContainer = D.create("div", "maplibregl-control-container", t3), s3 = this._controlPositions = {};
    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((l) => {
      s3[l] = D.create("div", `maplibregl-ctrl-${l} `, a);
    });
  }
  _resizeCanvas(t3, i, n) {
    this._canvas.width = Math.floor(n * t3), this._canvas.height = Math.floor(n * i), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${i}px`;
  }
  _setupPainter() {
    let t3 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }, i = null;
    this._canvas.addEventListener("webglcontextcreationerror", (o) => {
      i = { requestedAttributes: t3 }, o && (i.statusMessage = o.statusMessage, i.type = o.type);
    }, { once: true });
    let n = this._canvas.getContext("webgl2", t3) || this._canvas.getContext("webgl", t3);
    if (!n) {
      let o = "Failed to initialize WebGL";
      throw i ? (i.message = o, new Error(JSON.stringify(i))) : new Error(o);
    }
    this.painter = new Cc(n, this.transform), Ln.testSupport(n);
  }
  loaded() {
    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
  }
  _update(t3) {
    return !this.style || !this.style._loaded ? this : (this._styleDirty = this._styleDirty || t3, this._sourcesDirty = true, this.triggerRepaint(), this);
  }
  _requestRenderFrame(t3) {
    return this._update(), this._renderTaskQueue.add(t3);
  }
  _cancelRenderFrame(t3) {
    this._renderTaskQueue.remove(t3);
  }
  _render(t3) {
    let i = this._idleTriggered ? this._fadeDuration : 0;
    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t3), this._removed) return;
    let n = false;
    if (this.style && this._styleDirty) {
      this._styleDirty = false;
      let a = this.transform.zoom, s3 = Y.now();
      this.style.zoomHistory.update(a, s3);
      let l = new ye(a, { now: s3, fadeDuration: i, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), c = l.crossFadingFactor();
      (c !== 1 || c !== this._crossFadingFactor) && (n = true, this._crossFadingFactor = c), this.style.update(l);
    }
    this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain && (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i, showPadding: this.showPadding }), this.fire(new F("render")), this.loaded() && !this._loaded && (this._loaded = true, Tn.mark("load"), this.fire(new F("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
    let o = this._sourcesDirty || this._styleDirty || this._placementDirty;
    return o || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new F("idle")), this._loaded && !this._fullyLoaded && !o && (this._fullyLoaded = true, Tn.mark("fullLoad")), this;
  }
  redraw() {
    return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
  }
  remove() {
    var i;
    this._hash && this._hash.remove();
    for (let n of this._controls) n.onRemove(this);
    this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), st.removeThrottleControl(this._imageQueueHandle), (i = this._resizeObserver) == null || i.disconnect();
    let t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
    t3 && t3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), D.remove(this._canvasContainer), D.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), Tn.clearMetrics(), this._removed = true, this.fire(new F("remove"));
  }
  triggerRepaint() {
    this.style && !this._frameRequest && (this._frameRequest = new AbortController(), Y.frameAsync(this._frameRequest).then((t3) => {
      Tn.frame(t3), this._frameRequest = null, this._render(t3);
    }).catch(() => {
    }));
  }
  get showTileBoundaries() {
    return !!this._showTileBoundaries;
  }
  set showTileBoundaries(t3) {
    this._showTileBoundaries !== t3 && (this._showTileBoundaries = t3, this._update());
  }
  get showPadding() {
    return !!this._showPadding;
  }
  set showPadding(t3) {
    this._showPadding !== t3 && (this._showPadding = t3, this._update());
  }
  get showCollisionBoxes() {
    return !!this._showCollisionBoxes;
  }
  set showCollisionBoxes(t3) {
    this._showCollisionBoxes !== t3 && (this._showCollisionBoxes = t3, t3 ? this.style._generateCollisionBoxes() : this._update());
  }
  get showOverdrawInspector() {
    return !!this._showOverdrawInspector;
  }
  set showOverdrawInspector(t3) {
    this._showOverdrawInspector !== t3 && (this._showOverdrawInspector = t3, this._update());
  }
  get repaint() {
    return !!this._repaint;
  }
  set repaint(t3) {
    this._repaint !== t3 && (this._repaint = t3, this.triggerRepaint());
  }
  get vertices() {
    return !!this._vertices;
  }
  set vertices(t3) {
    this._vertices = t3, this._update();
  }
  get version() {
    return pD;
  }
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
};
r(bx, "Map");
var xx = bx;
q();
q();
var a2 = r((r3) => {
  r3.touchstart = r3.dragStart, r3.touchmoveWindow = r3.dragMove, r3.touchend = r3.dragEnd;
}, "assignEvents");
var s2 = r(({ enable: r3, clickTolerance: e, bearingDegreesPerPixelMoved: t3 = 0.8 }) => {
  let i = new Da();
  return new pr({ clickTolerance: e, move: (n, o) => ({ bearingDelta: (o.x - n.x) * t3 }), moveStateManager: i, enable: r3, assignEvents: a2 });
}, "generateOneFingerTouchRotationHandler");
var l2 = r(({ enable: r3, clickTolerance: e, pitchDegreesPerPixelMoved: t3 = -0.5 }) => {
  let i = new Da();
  return new pr({ clickTolerance: e, move: (n, o) => ({ pitchDelta: (o.y - n.y) * t3 }), moveStateManager: i, enable: r3, assignEvents: a2 });
}, "generateOneFingerTouchPitchHandler");
var fD = { showCompass: true, showZoom: true, visualizePitch: false };
var wx = class wx2 {
  constructor(e) {
    this._updateZoomButtons = () => {
      let e3 = this._map.getZoom(), t3 = e3 === this._map.getMaxZoom(), i = e3 === this._map.getMinZoom();
      this._zoomInButton.disabled = t3, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", t3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());
    };
    this._rotateCompassArrow = () => {
      let e3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
      this._compassIcon.style.transform = e3;
    };
    this._setButtonTitle = (e3, t3) => {
      let i = this._map._getUIString(`NavigationControl.${t3}`);
      e3.title = i, e3.setAttribute("aria-label", i);
    };
    this.options = V({}, fD, e), this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), D.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), D.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
      this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
    }), this._compassIcon = D.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
  }
  onAdd(e) {
    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new vx(this._map, this._compass, this.options.visualizePitch)), this._container;
  }
  onRemove() {
    D.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
  }
  _createButton(e, t3) {
    let i = D.create("button", e, this._container);
    return i.type = "button", i.addEventListener("click", t3), i;
  }
};
r(wx, "NavigationControl");
var _x = wx;
var Sx = class Sx2 {
  constructor(e, t3, i = false) {
    this.mousedown = (e3) => {
      this.startMouse(V({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), D.mousePos(this.element, e3)), D.addEventListener(window, "mousemove", this.mousemove), D.addEventListener(window, "mouseup", this.mouseup);
    };
    this.mousemove = (e3) => {
      this.moveMouse(e3, D.mousePos(this.element, e3));
    };
    this.mouseup = (e3) => {
      this.mouseRotate.dragEnd(e3), this.mousePitch && this.mousePitch.dragEnd(e3), this.offTemp();
    };
    this.touchstart = (e3) => {
      e3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = D.touchPos(this.element, e3.targetTouches)[0], this.startTouch(e3, this._startPos), D.addEventListener(window, "touchmove", this.touchmove, { passive: false }), D.addEventListener(window, "touchend", this.touchend));
    };
    this.touchmove = (e3) => {
      e3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = D.touchPos(this.element, e3.targetTouches)[0], this.moveTouch(e3, this._lastPos));
    };
    this.touchend = (e3) => {
      e3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
    };
    this.reset = () => {
      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
    };
    this._clickTolerance = 10;
    let n = e.dragRotate._mouseRotate.getClickTolerance(), o = e.dragRotate._mousePitch.getClickTolerance();
    this.element = t3, this.mouseRotate = Zc({ clickTolerance: n, enable: true }), this.touchRotate = s2({ clickTolerance: n, enable: true }), this.map = e, i && (this.mousePitch = Hc({ clickTolerance: o, enable: true }), this.touchPitch = l2({ clickTolerance: o, enable: true })), D.addEventListener(t3, "mousedown", this.mousedown), D.addEventListener(t3, "touchstart", this.touchstart, { passive: false }), D.addEventListener(t3, "touchcancel", this.reset);
  }
  startMouse(e, t3) {
    this.mouseRotate.dragStart(e, t3), this.mousePitch && this.mousePitch.dragStart(e, t3), D.disableDrag();
  }
  startTouch(e, t3) {
    this.touchRotate.dragStart(e, t3), this.touchPitch && this.touchPitch.dragStart(e, t3), D.disableDrag();
  }
  moveMouse(e, t3) {
    let i = this.map, { bearingDelta: n } = this.mouseRotate.dragMove(e, t3) || {};
    if (n && i.setBearing(i.getBearing() + n), this.mousePitch) {
      let { pitchDelta: o } = this.mousePitch.dragMove(e, t3) || {};
      o && i.setPitch(i.getPitch() + o);
    }
  }
  moveTouch(e, t3) {
    let i = this.map, { bearingDelta: n } = this.touchRotate.dragMove(e, t3) || {};
    if (n && i.setBearing(i.getBearing() + n), this.touchPitch) {
      let { pitchDelta: o } = this.touchPitch.dragMove(e, t3) || {};
      o && i.setPitch(i.getPitch() + o);
    }
  }
  off() {
    let e = this.element;
    D.removeEventListener(e, "mousedown", this.mousedown), D.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), D.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), D.removeEventListener(window, "touchend", this.touchend), D.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
  }
  offTemp() {
    D.enableDrag(), D.removeEventListener(window, "mousemove", this.mousemove), D.removeEventListener(window, "mouseup", this.mouseup), D.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), D.removeEventListener(window, "touchend", this.touchend);
  }
};
r(Sx, "MouseRotateWrapper");
var vx = Sx;
q();
q();
var Pi;
async function u2(r3 = false) {
  if (Pi !== void 0 && !r3) return Pi;
  if (window.navigator.permissions === void 0) return Pi = !!window.navigator.geolocation, Pi;
  try {
    Pi = (await window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
  } catch {
    Pi = !!window.navigator.geolocation;
  }
  return Pi;
}
r(u2, "checkGeolocationSupport");
q();
var Xa = u(ge(), 1);
q();
function pp(r3, e, t3) {
  let i = new ie(r3.lng, r3.lat);
  if (r3 = new ie(r3.lng, r3.lat), e) {
    let n = new ie(r3.lng - 360, r3.lat), o = new ie(r3.lng + 360, r3.lat), a = t3.locationPoint(r3).distSqr(e);
    t3.locationPoint(n).distSqr(e) < a ? r3 = n : t3.locationPoint(o).distSqr(e) < a && (r3 = o);
  }
  for (; Math.abs(r3.lng - t3.center.lng) > 180; ) {
    let n = t3.locationPoint(r3);
    if (n.x >= 0 && n.y >= 0 && n.x <= t3.width && n.y <= t3.height) break;
    r3.lng > t3.center.lng ? r3.lng -= 360 : r3.lng += 360;
  }
  return r3.lng !== i.lng && t3.locationPoint(r3).y > t3.height / 2 - t3.getHorizon() ? r3 : i;
}
r(pp, "smartWrap");
q();
var Wa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
function hp(r3, e, t3) {
  let i = r3.classList;
  for (let n in Wa) i.remove(`maplibregl-${t3}-anchor-${n}`);
  i.add(`maplibregl-${t3}-anchor-${e}`);
}
r(hp, "applyAnchorClass");
var Px = class Px2 extends de {
  constructor(t3) {
    super();
    this._onKeyPress = (t4) => {
      let i = t4.code, n = t4.charCode || t4.keyCode;
      (i === "Space" || i === "Enter" || n === 32 || n === 13) && this.togglePopup();
    };
    this._onMapClick = (t4) => {
      let i = t4.originalEvent.target, n = this._element;
      this._popup && (i === n || n.contains(i)) && this.togglePopup();
    };
    this._update = (t4) => {
      var a;
      if (!this._map) return;
      let i = this._map.loaded() && !this._map.isMoving();
      ((t4 == null ? void 0 : t4.type) === "terrain" || (t4 == null ? void 0 : t4.type) === "render" && !i) && this._map.once("render", this._update), this._map.transform.renderWorldCopies ? this._lngLat = pp(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (a = this._lngLat) == null ? void 0 : a.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
      let n = "";
      this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? n = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (n = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
      let o = "";
      this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = `rotateX(${this._map.getPitch()}deg)`), (!t4 || t4.type === "moveend") && (this._pos = this._pos.round()), D.setTransform(this._element, `${Wa[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${n}`), Y.frameAsync(new AbortController()).then(() => {
        this._updateOpacity(t4 && t4.type === "moveend");
      }).catch(() => {
      });
    };
    this._onMove = (t4) => {
      if (!this._isDragging) {
        let i = this._clickTolerance || this._map._clickTolerance;
        this._isDragging = t4.point.dist(this._pointerdownPos) >= i;
      }
      this._isDragging && (this._pos = t4.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new F("dragstart"))), this.fire(new F("drag")));
    };
    this._onUp = () => {
      this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new F("dragend")), this._state = "inactive";
    };
    this._addDragHandler = (t4) => {
      this._element.contains(t4.originalEvent.target) && (t4.preventDefault(), this._positionDelta = t4.point.sub(this._pos).add(this._offset), this._pointerdownPos = t4.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
    };
    if (this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && t3.pitchAlignment !== "auto" ? t3.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t3 == null ? void 0 : t3.opacity, t3 == null ? void 0 : t3.opacityWhenCovered), !t3 || !t3.element) {
      this._defaultMarker = true, this._element = D.create("div"), this._element.setAttribute("aria-label", "Map marker");
      let i = D.createNS("http://www.w3.org/2000/svg", "svg"), n = 41, o = 27;
      i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${n}px`), i.setAttributeNS(null, "width", `${o}px`), i.setAttributeNS(null, "viewBox", `0 0 ${o} ${n}`);
      let a = D.createNS("http://www.w3.org/2000/svg", "g");
      a.setAttributeNS(null, "stroke", "none"), a.setAttributeNS(null, "stroke-width", "1"), a.setAttributeNS(null, "fill", "none"), a.setAttributeNS(null, "fill-rule", "evenodd");
      let s3 = D.createNS("http://www.w3.org/2000/svg", "g");
      s3.setAttributeNS(null, "fill-rule", "nonzero");
      let l = D.createNS("http://www.w3.org/2000/svg", "g");
      l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");
      let c = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
      for (let w of c) {
        let _ = D.createNS("http://www.w3.org/2000/svg", "ellipse");
        _.setAttributeNS(null, "opacity", "0.04"), _.setAttributeNS(null, "cx", "10.5"), _.setAttributeNS(null, "cy", "5.80029008"), _.setAttributeNS(null, "rx", w.rx), _.setAttributeNS(null, "ry", w.ry), l.appendChild(_);
      }
      let p = D.createNS("http://www.w3.org/2000/svg", "g");
      p.setAttributeNS(null, "fill", this._color);
      let h = D.createNS("http://www.w3.org/2000/svg", "path");
      h.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), p.appendChild(h);
      let f = D.createNS("http://www.w3.org/2000/svg", "g");
      f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "fill", "#000000");
      let m = D.createNS("http://www.w3.org/2000/svg", "path");
      m.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f.appendChild(m);
      let y = D.createNS("http://www.w3.org/2000/svg", "g");
      y.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), y.setAttributeNS(null, "fill", "#FFFFFF");
      let g = D.createNS("http://www.w3.org/2000/svg", "g");
      g.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
      let x = D.createNS("http://www.w3.org/2000/svg", "circle");
      x.setAttributeNS(null, "fill", "#000000"), x.setAttributeNS(null, "opacity", "0.25"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962");
      let b = D.createNS("http://www.w3.org/2000/svg", "circle");
      b.setAttributeNS(null, "fill", "#FFFFFF"), b.setAttributeNS(null, "cx", "5.5"), b.setAttributeNS(null, "cy", "5.5"), b.setAttributeNS(null, "r", "5.4999962"), g.appendChild(x), g.appendChild(b), s3.appendChild(l), s3.appendChild(p), s3.appendChild(f), s3.appendChild(y), s3.appendChild(g), i.appendChild(s3), i.setAttributeNS(null, "height", `${n * this._scale}px`), i.setAttributeNS(null, "width", `${o * this._scale}px`), this._element.appendChild(i), this._offset = Xa.default.convert(t3 && t3.offset || [0, -14]);
    } else this._element = t3.element, this._offset = Xa.default.convert(t3 && t3.offset || [0, 0]);
    if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i) => {
      i.preventDefault();
    }), this._element.addEventListener("mousedown", (i) => {
      i.preventDefault();
    }), hp(this._element, this._anchor, "marker"), t3 && t3.className) for (let i of t3.className.split(" ")) this._element.classList.add(i);
    this._popup = null;
  }
  addTo(t3) {
    return this.remove(), this._map = t3, t3.getCanvasContainer().appendChild(this._element), t3.on("move", this._update), t3.on("moveend", this._update), t3.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
  }
  remove() {
    return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), D.remove(this._element), this._popup && this._popup.remove(), this;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t3) {
    return this._lngLat = ie.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
  }
  getElement() {
    return this._element;
  }
  setPopup(t3) {
    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t3) {
      if (!("offset" in t3.options)) {
        let o = Math.abs(13.5) / Math.SQRT2;
        t3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o, (38.1 - 13.5 + o) * -1], "bottom-right": [-o, (38.1 - 13.5 + o) * -1], left: [13.5, (38.1 - 13.5) * -1], right: [-13.5, (38.1 - 13.5) * -1] } : this._offset;
      }
      this._popup = t3, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
    }
    return this;
  }
  getPopup() {
    return this._popup;
  }
  togglePopup() {
    let t3 = this._popup;
    if (this._element.style.opacity === this._opacityWhenCovered) return this;
    if (t3) t3.isOpen() ? t3.remove() : (t3.setLngLat(this._lngLat), t3.addTo(this._map));
    else return this;
    return this;
  }
  _updateOpacity(t3 = false) {
    var y, g;
    if (!((y = this._map) == null ? void 0 : y.terrain)) {
      this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity);
      return;
    }
    if (t3) this._opacityTimeout = null;
    else {
      if (this._opacityTimeout) return;
      this._opacityTimeout = setTimeout(() => {
        this._opacityTimeout = null;
      }, 100);
    }
    let n = this._map, o = n.terrain.depthAtPoint(this._pos), a = n.terrain.getElevationForLngLatZoom(this._lngLat, n.transform.tileZoom), s3 = n.transform.lngLatToCameraDepth(this._lngLat, a), l = 6e-3;
    if (s3 - o < l) {
      this._element.style.opacity = this._opacity;
      return;
    }
    let c = -this._offset.y / n.transform._pixelPerMeter, p = Math.sin(n.getPitch() * Math.PI / 180) * c, h = n.terrain.depthAtPoint(new Xa.default(this._pos.x, this._pos.y - this._offset.y)), m = n.transform.lngLatToCameraDepth(this._lngLat, a + p) - h > l;
    (g = this._popup) != null && g.isOpen() && m && this._popup.remove(), this._element.style.opacity = m ? this._opacityWhenCovered : this._opacity;
  }
  getOffset() {
    return this._offset;
  }
  setOffset(t3) {
    return this._offset = Xa.default.convert(t3), this._update(), this;
  }
  addClassName(t3) {
    this._element.classList.add(t3);
  }
  removeClassName(t3) {
    this._element.classList.remove(t3);
  }
  toggleClassName(t3) {
    return this._element.classList.toggle(t3);
  }
  setDraggable(t3) {
    return this._draggable = !!t3, this._map && (t3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
  }
  isDraggable() {
    return this._draggable;
  }
  setRotation(t3) {
    return this._rotation = t3 || 0, this._update(), this;
  }
  getRotation() {
    return this._rotation;
  }
  setRotationAlignment(t3) {
    return this._rotationAlignment = t3 || "auto", this._update(), this;
  }
  getRotationAlignment() {
    return this._rotationAlignment;
  }
  setPitchAlignment(t3) {
    return this._pitchAlignment = t3 && t3 !== "auto" ? t3 : this._rotationAlignment, this._update(), this;
  }
  getPitchAlignment() {
    return this._pitchAlignment;
  }
  setOpacity(t3, i) {
    return t3 === void 0 && i === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t3 !== void 0 && (this._opacity = t3), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(true), this;
  }
};
r(Px, "Marker");
var An = Px;
var mD = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
var fp = 0;
var Ka = false;
var Mx = class Mx2 extends de {
  constructor(t3) {
    super();
    this._onSuccess = (t4) => {
      if (this._map) {
        if (this._isOutOfMapMaxBounds(t4)) {
          this._setErrorState(), this.fire(new F("outofmaxbounds", t4)), this._updateMarker(), this._finish();
          return;
        }
        if (this.options.trackUserLocation) switch (this._lastKnownPosition = t4, this._watchState) {
          case "WAITING_ACTIVE":
          case "ACTIVE_LOCK":
          case "ACTIVE_ERROR":
            this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
            break;
          case "BACKGROUND":
          case "BACKGROUND_ERROR":
            this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
            break;
          default:
            throw new Error(`Unexpected watchState ${this._watchState}`);
        }
        this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t4), (!this.options.trackUserLocation || this._watchState === "ACTIVE_LOCK") && this._updateCamera(t4), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new F("geolocate", t4)), this._finish();
      }
    };
    this._updateCamera = (t4) => {
      let i = new ie(t4.coords.longitude, t4.coords.latitude), n = t4.coords.accuracy, o = this._map.getBearing(), a = V({ bearing: o }, this.options.fitBoundsOptions), s3 = ut.fromLngLat(i, n);
      this._map.fitBounds(s3, a, { geolocateSource: true });
    };
    this._updateMarker = (t4) => {
      if (t4) {
        let i = new ie(t4.coords.longitude, t4.coords.latitude);
        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t4.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
      } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
    };
    this._onZoom = () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    };
    this._onError = (t4) => {
      if (this._map) {
        if (this.options.trackUserLocation) if (t4.code === 1) {
          this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch();
        } else {
          if (t4.code === 3 && Ka) return;
          this._setErrorState();
        }
        this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new F("error", t4)), this._finish();
      }
    };
    this._finish = () => {
      this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
    };
    this._setupUI = (t4) => {
      if (this._map) {
        if (this._container.addEventListener("contextmenu", (i) => i.preventDefault()), this._geolocateButton = D.create("button", "maplibregl-ctrl-geolocate", this._container), D.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t4 === false) {
          ke("Geolocation support is not available so the GeolocateControl will be disabled.");
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = true, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        } else {
          let i = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = D.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new An({ element: this._dotElement }), this._circleElement = D.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new An({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (i) => {
          let n = i.originalEvent && i.originalEvent.type === "resize";
          !i.geolocateSource && this._watchState === "ACTIVE_LOCK" && !n && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new F("trackuserlocationend")));
        });
      }
    };
    this.options = V({}, mD, t3);
  }
  onAdd(t3) {
    return this._map = t3, this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), u2().then((i) => this._setupUI(i)), this._container;
  }
  onRemove() {
    this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), D.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, fp = 0, Ka = false;
  }
  _isOutOfMapMaxBounds(t3) {
    let i = this._map.getMaxBounds(), n = t3.coords;
    return i && (n.longitude < i.getWest() || n.longitude > i.getEast() || n.latitude < i.getSouth() || n.latitude > i.getNorth());
  }
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      default:
        throw new Error(`Unexpected watchState ${this._watchState}`);
    }
  }
  _updateCircleRadius() {
    let t3 = this._map.getBounds(), i = t3.getSouthEast(), n = t3.getNorthEast(), o = i.distanceTo(n), a = this._map._container.clientHeight, s3 = Math.ceil(2 * (this._accuracy / (o / a)));
    this._circleElement.style.width = `${s3}px`, this._circleElement.style.height = `${s3}px`;
  }
  trigger() {
    if (!this._setup) return ke("Geolocate control triggered before added to a map"), false;
    if (this.options.trackUserLocation) {
      switch (this._watchState) {
        case "OFF":
          this._watchState = "WAITING_ACTIVE", this.fire(new F("trackuserlocationstart"));
          break;
        case "WAITING_ACTIVE":
        case "ACTIVE_LOCK":
        case "ACTIVE_ERROR":
        case "BACKGROUND_ERROR":
          fp--, Ka = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new F("trackuserlocationend"));
          break;
        case "BACKGROUND":
          this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new F("trackuserlocationstart"));
          break;
        default:
          throw new Error(`Unexpected watchState ${this._watchState}`);
      }
      switch (this._watchState) {
        case "WAITING_ACTIVE":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "ACTIVE_LOCK":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "OFF":
          break;
        default:
          throw new Error(`Unexpected watchState ${this._watchState}`);
      }
      if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
      else if (this._geolocationWatchID === void 0) {
        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), fp++;
        let t3;
        fp > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Ka = true) : (t3 = this.options.positionOptions, Ka = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3);
      }
    } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
    return true;
  }
  _clearWatch() {
    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
  }
};
r(Mx, "GeolocateControl");
var Tx = Mx;
q();
var dD = { maxWidth: 100, unit: "metric" };
var Ix = class Ix2 {
  constructor(e) {
    this._onMove = () => {
      c2(this._map, this._container, this.options);
    };
    this.setUnit = (e3) => {
      this.options.unit = e3, c2(this._map, this._container, this.options);
    };
    this.options = { ...dD, ...e };
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    return this._map = e, this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
  }
  onRemove() {
    D.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
  }
};
r(Ix, "ScaleControl");
var Ax = Ix;
function c2(r3, e, t3) {
  let i = t3 && t3.maxWidth || 100, n = r3._container.clientHeight / 2, o = r3.unproject([0, n]), a = r3.unproject([i, n]), s3 = o.distanceTo(a);
  if (t3 && t3.unit === "imperial") {
    let l = 3.2808 * s3;
    if (l > 5280) {
      let c = l / 5280;
      Ja(e, i, c, r3._getUIString("ScaleControl.Miles"));
    } else Ja(e, i, l, r3._getUIString("ScaleControl.Feet"));
  } else if (t3 && t3.unit === "nautical") {
    let l = s3 / 1852;
    Ja(e, i, l, r3._getUIString("ScaleControl.NauticalMiles"));
  } else s3 >= 1e3 ? Ja(e, i, s3 / 1e3, r3._getUIString("ScaleControl.Kilometers")) : Ja(e, i, s3, r3._getUIString("ScaleControl.Meters"));
}
r(c2, "updateScale");
function Ja(r3, e, t3, i) {
  let n = gD(t3), o = n / t3;
  r3.style.width = `${e * o}px`, r3.innerHTML = `${n}&nbsp;${i}`;
}
r(Ja, "setScale");
function yD(r3) {
  let e = Math.pow(10, Math.ceil(-Math.log(r3) / Math.LN10));
  return Math.round(r3 * e) / e;
}
r(yD, "getDecimalRoundNum");
function gD(r3) {
  let e = Math.pow(10, `${Math.floor(r3)}`.length - 1), t3 = r3 / e;
  return t3 = t3 >= 10 ? 10 : t3 >= 5 ? 5 : t3 >= 3 ? 3 : t3 >= 2 ? 2 : t3 >= 1 ? 1 : yD(t3), e * t3;
}
r(gD, "getRoundNum");
q();
var Ex = class Ex2 extends de {
  constructor(t3 = {}) {
    super();
    this._onFullscreenChange = () => {
      var i;
      let t4 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
      for (; (i = t4 == null ? void 0 : t4.shadowRoot) != null && i.fullscreenElement; ) t4 = t4.shadowRoot.fullscreenElement;
      t4 === this._container !== this._fullscreen && this._handleFullscreenChange();
    };
    this._onClickFullscreen = () => {
      this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
    };
    this._fullscreen = false, t3 && t3.container && (t3.container instanceof HTMLElement ? this._container = t3.container : ke("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
  }
  onAdd(t3) {
    return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
  }
  onRemove() {
    D.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _setupUI() {
    let t3 = this._fullscreenButton = D.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
    D.create("span", "maplibregl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _updateTitle() {
    let t3 = this._getTitle();
    this._fullscreenButton.setAttribute("aria-label", t3), this._fullscreenButton.title = t3;
  }
  _getTitle() {
    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
  }
  _isFullscreen() {
    return this._fullscreen;
  }
  _handleFullscreenChange() {
    this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new F("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new F("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
  }
  _exitFullscreen() {
    window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
  }
  _requestFullscreen() {
    this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
  }
  _togglePseudoFullScreen() {
    this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
  }
};
r(Ex, "FullscreenControl");
var Cx = Ex;
q();
var Lx = class Lx2 {
  constructor(e) {
    this._toggleTerrain = () => {
      this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
    };
    this._updateTerrainIcon = () => {
      this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
    };
    this.options = e;
  }
  onAdd(e) {
    return this._map = e, this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = D.create("button", "maplibregl-ctrl-terrain", this._container), D.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    D.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
};
r(Lx, "TerrainControl");
var kx = Lx;
q();
var qe = u(ge(), 1);
var xD = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false };
var bD = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
var zx = class zx2 extends de {
  constructor(t3) {
    super();
    this.remove = () => (this._content && D.remove(this._content), this._container && (D.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new F("close"))), this);
    this._onMouseUp = (t4) => {
      this._update(t4.point);
    };
    this._onMouseMove = (t4) => {
      this._update(t4.point);
    };
    this._onDrag = (t4) => {
      this._update(t4.point);
    };
    this._update = (t4) => {
      var l;
      let i = this._lngLat || this._trackPointer;
      if (!this._map || !i || !this._content) return;
      if (!this._container) {
        if (this._container = D.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = D.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (let c of this.options.className.split(" ")) this._container.classList.add(c);
        this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
      }
      if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer ? this._lngLat = pp(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (l = this._lngLat) == null ? void 0 : l.wrap(), this._trackPointer && !t4) return;
      let n = this._flatPos = this._pos = this._trackPointer && t4 ? t4 : this._map.project(this._lngLat);
      this._map.terrain && (this._flatPos = this._trackPointer && t4 ? t4 : this._map.transform.locationPoint(this._lngLat));
      let o = this.options.anchor, a = p2(this.options.offset);
      if (!o) {
        let c = this._container.offsetWidth, p = this._container.offsetHeight, h;
        n.y + a.bottom.y < p ? h = ["top"] : n.y > this._map.transform.height - p ? h = ["bottom"] : h = [], n.x < c / 2 ? h.push("left") : n.x > this._map.transform.width - c / 2 && h.push("right"), h.length === 0 ? o = "bottom" : o = h.join("-");
      }
      let s3 = n.add(a[o]);
      this.options.subpixelPositioning || (s3 = s3.round()), D.setTransform(this._container, `${Wa[o]} translate(${s3.x}px,${s3.y}px)`), hp(this._container, o, "popup");
    };
    this._onClose = () => {
      this.remove();
    };
    this.options = V(Object.create(xD), t3);
  }
  addTo(t3) {
    return this._map && this.remove(), this._map = t3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new F("open")), this;
  }
  isOpen() {
    return !!this._map;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t3) {
    return this._lngLat = ie.convert(t3), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
  }
  trackPointer() {
    return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
  }
  getElement() {
    return this._container;
  }
  setText(t3) {
    return this.setDOMContent(document.createTextNode(t3));
  }
  setHTML(t3) {
    let i = document.createDocumentFragment(), n = document.createElement("body"), o;
    for (n.innerHTML = t3; o = n.firstChild, !!o; ) i.appendChild(o);
    return this.setDOMContent(i);
  }
  getMaxWidth() {
    var t3;
    return (t3 = this._container) == null ? void 0 : t3.style.maxWidth;
  }
  setMaxWidth(t3) {
    return this.options.maxWidth = t3, this._update(), this;
  }
  setDOMContent(t3) {
    if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
    else this._content = D.create("div", "maplibregl-popup-content", this._container);
    return this._content.appendChild(t3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
  }
  addClassName(t3) {
    this._container && this._container.classList.add(t3);
  }
  removeClassName(t3) {
    this._container && this._container.classList.remove(t3);
  }
  setOffset(t3) {
    return this.options.offset = t3, this._update(), this;
  }
  toggleClassName(t3) {
    if (this._container) return this._container.classList.toggle(t3);
  }
  setSubpixelPositioning(t3) {
    this.options.subpixelPositioning = t3;
  }
  _createCloseButton() {
    this.options.closeButton && (this._closeButton = D.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
  }
  _focusFirstElement() {
    if (!this.options.focusAfterOpen || !this._container) return;
    let t3 = this._container.querySelector(bD);
    t3 && t3.focus();
  }
};
r(zx, "Popup");
var Dx = zx;
function p2(r3) {
  if (r3) if (typeof r3 == "number") {
    let e = Math.round(Math.abs(r3) / Math.SQRT2);
    return { center: new qe.default(0, 0), top: new qe.default(0, r3), "top-left": new qe.default(e, e), "top-right": new qe.default(-e, e), bottom: new qe.default(0, -r3), "bottom-left": new qe.default(e, -e), "bottom-right": new qe.default(-e, -e), left: new qe.default(r3, 0), right: new qe.default(-r3, 0) };
  } else if (r3 instanceof qe.default || Array.isArray(r3)) {
    let e = qe.default.convert(r3);
    return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
  } else return { center: qe.default.convert(r3.center || [0, 0]), top: qe.default.convert(r3.top || [0, 0]), "top-left": qe.default.convert(r3["top-left"] || [0, 0]), "top-right": qe.default.convert(r3["top-right"] || [0, 0]), bottom: qe.default.convert(r3.bottom || [0, 0]), "bottom-left": qe.default.convert(r3["bottom-left"] || [0, 0]), "bottom-right": qe.default.convert(r3["bottom-right"] || [0, 0]), left: qe.default.convert(r3.left || [0, 0]), right: qe.default.convert(r3.right || [0, 0]) };
  else return p2(new qe.default(0, 0));
}
r(p2, "normalizeOffset");
var _D = u(ge(), 1);
var vD = Qa.version;
function Fle(r3, e) {
  return Or().setRTLTextPlugin(r3, e);
}
r(Fle, "setRTLTextPlugin");
function Rle() {
  return Or().getRTLTextPluginStatus();
}
r(Rle, "getRTLTextPluginStatus");
function Ble() {
  return vD;
}
r(Ble, "getVersion");
function Ole() {
  return Dr.workerCount;
}
r(Ole, "getWorkerCount");
function Vle(r3) {
  Dr.workerCount = r3;
}
r(Vle, "setWorkerCount");
function Ule() {
  return ot.MAX_PARALLEL_IMAGE_REQUESTS;
}
r(Ule, "getMaxParallelImageRequests");
function Nle(r3) {
  ot.MAX_PARALLEL_IMAGE_REQUESTS = r3;
}
r(Nle, "setMaxParallelImageRequests");
function Gle() {
  return ot.WORKER_URL;
}
r(Gle, "getWorkerUrl");
function $le(r3) {
  ot.WORKER_URL = r3;
}
r($le, "setWorkerUrl");
function qle(r3) {
  return mu().broadcast("IS", r3);
}
r(qle, "importScriptInWorkers");

export {
  ot,
  w2,
  S2,
  jr,
  de,
  Gk,
  $k,
  ie,
  ut,
  Fe,
  ua,
  xi,
  pa,
  ha,
  Lt,
  fa,
  ma,
  Qk,
  wn,
  Ia,
  Ca,
  it,
  Vr,
  Ea,
  ka,
  Fa,
  Ra,
  Ba,
  Oa,
  Va,
  Ua,
  Na,
  Ga,
  $a,
  qa,
  ja,
  Za,
  xx,
  _x,
  An,
  Tx,
  Ax,
  Cx,
  kx,
  Dx,
  _D,
  Fle,
  Rle,
  Ble,
  Ole,
  Vle,
  Ule,
  Nle,
  Gle,
  $le,
  qle
};
//# sourceMappingURL=chunk-LFU6THUQ.js.map

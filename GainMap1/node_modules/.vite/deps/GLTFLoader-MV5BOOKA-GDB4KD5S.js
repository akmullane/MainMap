import {
  X
} from "./chunk-Z4ENL6JO.js";
import {
  $s,
  $u,
  Bu,
  Ce,
  Cn,
  Cu,
  Dn,
  Ed,
  Fi,
  Ft,
  Ie,
  In,
  Jt,
  Ke,
  Ks,
  Ku,
  Le,
  Md,
  Me,
  Mi,
  Ni,
  Oi,
  Ou,
  P,
  Pu,
  Re,
  Sd,
  Se,
  So,
  Te,
  Va,
  Vi,
  Vt,
  Vu,
  Ye,
  Yn,
  Zr,
  _v,
  ar,
  be,
  co,
  dr,
  gd,
  ge,
  gr,
  gv,
  ho,
  je,
  jn,
  ju,
  ka,
  le,
  lt,
  md,
  mr,
  mv,
  ne,
  pd,
  ti,
  ud,
  uh,
  un,
  uo,
  vd,
  wd
} from "./chunk-763QVDXZ.js";
import {
  q,
  r
} from "./chunk-F6LUTOTK.js";

// node_modules/@mappedin/mappedin-js/lib/esm/GLTFLoader-MV5BOOKA.js
q();
var He = class He2 extends ti {
  constructor(t) {
    super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
      return new pe(e);
    }), this.register(function(e) {
      return new Se2(e);
    }), this.register(function(e) {
      return new ye(e);
    }), this.register(function(e) {
      return new we(e);
    }), this.register(function(e) {
      return new Ae(e);
    }), this.register(function(e) {
      return new ge2(e);
    }), this.register(function(e) {
      return new Te2(e);
    }), this.register(function(e) {
      return new Re2(e);
    }), this.register(function(e) {
      return new he(e);
    }), this.register(function(e) {
      return new _e(e);
    }), this.register(function(e) {
      return new me(e);
    }), this.register(function(e) {
      return new xe(e);
    }), this.register(function(e) {
      return new Ee(e);
    }), this.register(function(e) {
      return new fe(e);
    }), this.register(function(e) {
      return new Ne(e);
    }), this.register(function(e) {
      return new be2(e);
    });
  }
  load(t, e, r2, n) {
    let s = this, i;
    if (this.resourcePath !== "") i = this.resourcePath;
    else if (this.path !== "") {
      let c = Ed.extractUrlBase(t);
      i = Ed.resolveURL(c, this.path);
    } else i = Ed.extractUrlBase(t);
    this.manager.itemStart(t);
    let a = r(function(c) {
      n ? n(c) : console.error(c), s.manager.itemError(t), s.manager.itemEnd(t);
    }, "_onError"), o = new md(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function(c) {
      try {
        s.parse(c, i, function(l) {
          e(l), s.manager.itemEnd(t);
        }, a);
      } catch (l) {
        a(l);
      }
    }, r2, a);
  }
  setDRACOLoader(t) {
    return this.dracoLoader = t, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(t) {
    return this.ktx2Loader = t, this;
  }
  setMeshoptDecoder(t) {
    return this.meshoptDecoder = t, this;
  }
  register(t) {
    return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
  }
  unregister(t) {
    return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
  }
  parse(t, e, r2, n) {
    let s, i = {}, a = {}, o = new TextDecoder();
    if (typeof t == "string") s = JSON.parse(t);
    else if (t instanceof ArrayBuffer) if (o.decode(new Uint8Array(t, 0, 4)) === $t) {
      try {
        i[g.KHR_BINARY_GLTF] = new Me2(t);
      } catch (u) {
        n && n(u);
        return;
      }
      s = JSON.parse(i[g.KHR_BINARY_GLTF].content);
    } else s = JSON.parse(o.decode(t));
    else s = t;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    let c = new ke(s, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let l = 0; l < this.pluginCallbacks.length; l++) {
      let u = this.pluginCallbacks[l](c);
      u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[u.name] = u, i[u.name] = true;
    }
    if (s.extensionsUsed) for (let l = 0; l < s.extensionsUsed.length; ++l) {
      let u = s.extensionsUsed[l], f = s.extensionsRequired || [];
      switch (u) {
        case g.KHR_MATERIALS_UNLIT:
          i[u] = new de();
          break;
        case g.KHR_DRACO_MESH_COMPRESSION:
          i[u] = new Ie2(s, this.dracoLoader);
          break;
        case g.KHR_TEXTURE_TRANSFORM:
          i[u] = new Le2();
          break;
        case g.KHR_MESH_QUANTIZATION:
          i[u] = new Oe();
          break;
        default:
          f.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
      }
    }
    c.setExtensions(i), c.setPlugins(a), c.parse(r2, n);
  }
  parseAsync(t, e) {
    let r2 = this;
    return new Promise(function(n, s) {
      r2.parse(t, e, n, s);
    });
  }
};
r(He, "GLTFLoader");
var Wt = He;
function en() {
  let h = {};
  return { get: function(t) {
    return h[t];
  }, add: function(t, e) {
    h[t] = e;
  }, remove: function(t) {
    delete h[t];
  }, removeAll: function() {
    h = {};
  } };
}
r(en, "GLTFRegistry");
var g = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" };
var Be = class Be2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    let t = this.parser, e = this.parser.json.nodes || [];
    for (let r2 = 0, n = e.length; r2 < n; r2++) {
      let s = e[r2];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(t) {
    let e = this.parser, r2 = "light:" + t, n = e.cache.get(r2);
    if (n) return n;
    let s = e.json, o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t], c, l = new Vt(16777215);
    o.color !== void 0 && l.setRGB(o.color[0], o.color[1], o.color[2], Dn);
    let u = o.range !== void 0 ? o.range : 0;
    switch (o.type) {
      case "directional":
        c = new Sd(l), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Md(l), c.distance = u;
        break;
      case "spot":
        c = new vd(l), c.distance = u, o.spot = o.spot || {}, o.spot.innerConeAngle = o.spot.innerConeAngle !== void 0 ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = o.spot.outerConeAngle !== void 0 ? o.spot.outerConeAngle : Math.PI / 4, c.angle = o.spot.outerConeAngle, c.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, C(c, o), o.intensity !== void 0 && (c.intensity = o.intensity), c.name = e.createUniqueName(o.name || "light_" + t), n = Promise.resolve(c), e.cache.add(r2, n), n;
  }
  getDependency(t, e) {
    if (t === "light") return this._loadLight(e);
  }
  createNodeAttachment(t) {
    let e = this, r2 = this.parser, s = r2.json.nodes[t], a = (s.extensions && s.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(o) {
      return r2._getNodeRef(e.cache, a, o);
    });
  }
};
r(Be, "GLTFLightsExtension");
var fe = Be;
var ve = class ve2 {
  constructor() {
    this.name = g.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ar;
  }
  extendParams(t, e, r2) {
    let n = [];
    t.color = new Vt(1, 1, 1), t.opacity = 1;
    let s = e.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        let i = s.baseColorFactor;
        t.color.setRGB(i[0], i[1], i[2], Dn), t.opacity = i[3];
      }
      s.baseColorTexture !== void 0 && n.push(r2.assignTexture(t, "map", s.baseColorTexture, Ke));
    }
    return Promise.all(n);
  }
};
r(ve, "GLTFMaterialsUnlitExtension");
var de = ve;
var Ue = class Ue2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(t, e) {
    let n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (e.emissiveIntensity = s), Promise.resolve();
  }
};
r(Ue, "GLTFMaterialsEmissiveStrengthExtension");
var he = Ue;
var je2 = class je3 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    if (i.clearcoatFactor !== void 0 && (e.clearcoat = i.clearcoatFactor), i.clearcoatTexture !== void 0 && s.push(r2.assignTexture(e, "clearcoatMap", i.clearcoatTexture)), i.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = i.clearcoatRoughnessFactor), i.clearcoatRoughnessTexture !== void 0 && s.push(r2.assignTexture(e, "clearcoatRoughnessMap", i.clearcoatRoughnessTexture)), i.clearcoatNormalTexture !== void 0 && (s.push(r2.assignTexture(e, "clearcoatNormalMap", i.clearcoatNormalTexture)), i.clearcoatNormalTexture.scale !== void 0)) {
      let a = i.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new lt(a, a);
    }
    return Promise.all(s);
  }
};
r(je2, "GLTFMaterialsClearcoatExtension");
var pe = je2;
var Ke2 = class Ke3 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    return i.iridescenceFactor !== void 0 && (e.iridescence = i.iridescenceFactor), i.iridescenceTexture !== void 0 && s.push(r2.assignTexture(e, "iridescenceMap", i.iridescenceTexture)), i.iridescenceIor !== void 0 && (e.iridescenceIOR = i.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), i.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = i.iridescenceThicknessMinimum), i.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = i.iridescenceThicknessMaximum), i.iridescenceThicknessTexture !== void 0 && s.push(r2.assignTexture(e, "iridescenceThicknessMap", i.iridescenceThicknessTexture)), Promise.all(s);
  }
};
r(Ke2, "GLTFMaterialsIridescenceExtension");
var me = Ke2;
var Fe = class Fe2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [];
    e.sheenColor = new Vt(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    let i = n.extensions[this.name];
    if (i.sheenColorFactor !== void 0) {
      let a = i.sheenColorFactor;
      e.sheenColor.setRGB(a[0], a[1], a[2], Dn);
    }
    return i.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = i.sheenRoughnessFactor), i.sheenColorTexture !== void 0 && s.push(r2.assignTexture(e, "sheenColorMap", i.sheenColorTexture, Ke)), i.sheenRoughnessTexture !== void 0 && s.push(r2.assignTexture(e, "sheenRoughnessMap", i.sheenRoughnessTexture)), Promise.all(s);
  }
};
r(Fe, "GLTFMaterialsSheenExtension");
var Ae = Fe;
var Ve = class Ve2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    return i.transmissionFactor !== void 0 && (e.transmission = i.transmissionFactor), i.transmissionTexture !== void 0 && s.push(r2.assignTexture(e, "transmissionMap", i.transmissionTexture)), Promise.all(s);
  }
};
r(Ve, "GLTFMaterialsTransmissionExtension");
var ge2 = Ve;
var Xe = class Xe2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    e.thickness = i.thicknessFactor !== void 0 ? i.thicknessFactor : 0, i.thicknessTexture !== void 0 && s.push(r2.assignTexture(e, "thicknessMap", i.thicknessTexture)), e.attenuationDistance = i.attenuationDistance || 1 / 0;
    let a = i.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new Vt().setRGB(a[0], a[1], a[2], Dn), Promise.all(s);
  }
};
r(Xe, "GLTFMaterialsVolumeExtension");
var Te2 = Xe;
var Ge = class Ge2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_IOR;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = n.extensions[this.name];
    return e.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
};
r(Ge, "GLTFMaterialsIorExtension");
var Re2 = Ge;
var ze = class ze2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    e.specularIntensity = i.specularFactor !== void 0 ? i.specularFactor : 1, i.specularTexture !== void 0 && s.push(r2.assignTexture(e, "specularIntensityMap", i.specularTexture));
    let a = i.specularColorFactor || [1, 1, 1];
    return e.specularColor = new Vt().setRGB(a[0], a[1], a[2], Dn), i.specularColorTexture !== void 0 && s.push(r2.assignTexture(e, "specularColorMap", i.specularColorTexture, Ke)), Promise.all(s);
  }
};
r(ze, "GLTFMaterialsSpecularExtension");
var _e = ze;
var qe = class qe2 {
  constructor(t) {
    this.parser = t, this.name = g.EXT_MATERIALS_BUMP;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    return e.bumpScale = i.bumpFactor !== void 0 ? i.bumpFactor : 1, i.bumpTexture !== void 0 && s.push(r2.assignTexture(e, "bumpMap", i.bumpTexture)), Promise.all(s);
  }
};
r(qe, "GLTFMaterialsBumpExtension");
var Ee = qe;
var We = class We2 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(t) {
    let r2 = this.parser.json.materials[t];
    return !r2.extensions || !r2.extensions[this.name] ? null : ud;
  }
  extendMaterialParams(t, e) {
    let r2 = this.parser, n = r2.json.materials[t];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let s = [], i = n.extensions[this.name];
    return i.anisotropyStrength !== void 0 && (e.anisotropy = i.anisotropyStrength), i.anisotropyRotation !== void 0 && (e.anisotropyRotation = i.anisotropyRotation), i.anisotropyTexture !== void 0 && s.push(r2.assignTexture(e, "anisotropyMap", i.anisotropyTexture)), Promise.all(s);
  }
};
r(We, "GLTFMaterialsAnisotropyExtension");
var xe = We;
var Ye2 = class Ye3 {
  constructor(t) {
    this.parser = t, this.name = g.KHR_TEXTURE_BASISU;
  }
  loadTexture(t) {
    let e = this.parser, r2 = e.json, n = r2.textures[t];
    if (!n.extensions || !n.extensions[this.name]) return null;
    let s = n.extensions[this.name], i = e.options.ktx2Loader;
    if (!i) {
      if (r2.extensionsRequired && r2.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(t, s.source, i);
  }
};
r(Ye2, "GLTFTextureBasisUExtension");
var Se2 = Ye2;
var Qe = class Qe2 {
  constructor(t) {
    this.parser = t, this.name = g.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(t) {
    let e = this.name, r2 = this.parser, n = r2.json, s = n.textures[t];
    if (!s.extensions || !s.extensions[e]) return null;
    let i = s.extensions[e], a = n.images[i.source], o = r2.textureLoader;
    if (a.uri) {
      let c = r2.options.manager.getHandler(a.uri);
      c !== null && (o = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return r2.loadTextureImage(t, i.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r2.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      let e = new Image();
      e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
};
r(Qe, "GLTFTextureWebPExtension");
var ye = Qe;
var Ze = class Ze2 {
  constructor(t) {
    this.parser = t, this.name = g.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(t) {
    let e = this.name, r2 = this.parser, n = r2.json, s = n.textures[t];
    if (!s.extensions || !s.extensions[e]) return null;
    let i = s.extensions[e], a = n.images[i.source], o = r2.textureLoader;
    if (a.uri) {
      let c = r2.options.manager.getHandler(a.uri);
      c !== null && (o = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return r2.loadTextureImage(t, i.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r2.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      let e = new Image();
      e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
};
r(Ze, "GLTFTextureAVIFExtension");
var we = Ze;
var Je = class Je2 {
  constructor(t) {
    this.name = g.EXT_MESHOPT_COMPRESSION, this.parser = t;
  }
  loadBufferView(t) {
    let e = this.parser.json, r2 = e.bufferViews[t];
    if (r2.extensions && r2.extensions[this.name]) {
      let n = r2.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), i = this.parser.options.meshoptDecoder;
      if (!i || !i.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(a) {
        let o = n.byteOffset || 0, c = n.byteLength || 0, l = n.count, u = n.byteStride, f = new Uint8Array(a, o, c);
        return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(l, u, f, n.mode, n.filter).then(function(d) {
          return d.buffer;
        }) : i.ready.then(function() {
          let d = new ArrayBuffer(l * u);
          return i.decodeGltfBuffer(new Uint8Array(d), l, u, f, n.mode, n.filter), d;
        });
      });
    } else return null;
  }
};
r(Je, "GLTFMeshoptCompression");
var Ne = Je;
var $e = class $e2 {
  constructor(t) {
    this.name = g.EXT_MESH_GPU_INSTANCING, this.parser = t;
  }
  createNodeMesh(t) {
    let e = this.parser.json, r2 = e.nodes[t];
    if (!r2.extensions || !r2.extensions[this.name] || r2.mesh === void 0) return null;
    let n = e.meshes[r2.mesh];
    for (let c of n.primitives) if (c.mode !== S.TRIANGLES && c.mode !== S.TRIANGLE_STRIP && c.mode !== S.TRIANGLE_FAN && c.mode !== void 0) return null;
    let i = r2.extensions[this.name].attributes, a = [], o = {};
    for (let c in i) a.push(this.parser.getDependency("accessor", i[c]).then((l) => (o[c] = l, o[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(t)), Promise.all(a).then((c) => {
      let l = c.pop(), u = l.isGroup ? l.children : [l], f = c[0].count, d = [];
      for (let m of u) {
        let R = new Ft(), A = new P(), T = new In(), E = new P(1, 1, 1), x = new Vu(m.geometry, m.material, f);
        for (let _ = 0; _ < f; _++) o.TRANSLATION && A.fromBufferAttribute(o.TRANSLATION, _), o.ROTATION && T.fromBufferAttribute(o.ROTATION, _), o.SCALE && E.fromBufferAttribute(o.SCALE, _), x.setMatrixAt(_, R.compose(A, T, E));
        for (let _ in o) if (_ === "_COLOR_0") {
          let w = o[_];
          x.instanceColor = new mr(w.array, w.itemSize, w.normalized);
        } else _ !== "TRANSLATION" && _ !== "ROTATION" && _ !== "SCALE" && m.geometry.setAttribute(_, o[_]);
        le.prototype.copy.call(x, m), this.parser.assignFinalMaterial(x), d.push(x);
      }
      return l.isGroup ? (l.clear(), l.add(...d), l) : d[0];
    }));
  }
};
r($e, "GLTFMeshGpuInstancing");
var be2 = $e;
var $t = "glTF";
var K = 12;
var Yt = { JSON: 1313821514, BIN: 5130562 };
var et = class et2 {
  constructor(t) {
    this.name = g.KHR_BINARY_GLTF, this.content = null, this.body = null;
    let e = new DataView(t, 0, K), r2 = new TextDecoder();
    if (this.header = { magic: r2.decode(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, true), length: e.getUint32(8, true) }, this.header.magic !== $t) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    let n = this.header.length - K, s = new DataView(t, K), i = 0;
    for (; i < n; ) {
      let a = s.getUint32(i, true);
      i += 4;
      let o = s.getUint32(i, true);
      if (i += 4, o === Yt.JSON) {
        let c = new Uint8Array(t, K + i, a);
        this.content = r2.decode(c);
      } else if (o === Yt.BIN) {
        let c = K + i;
        this.body = t.slice(c, c + a);
      }
      i += a;
    }
    if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
};
r(et, "GLTFBinaryExtension");
var Me2 = et;
var tt = class tt2 {
  constructor(t, e) {
    if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = g.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(t, e) {
    let r2 = this.json, n = this.dracoLoader, s = t.extensions[this.name].bufferView, i = t.extensions[this.name].attributes, a = {}, o = {}, c = {};
    for (let l in i) {
      let u = De[l] || l.toLowerCase();
      a[u] = i[l];
    }
    for (let l in t.attributes) {
      let u = De[l] || l.toLowerCase();
      if (i[l] !== void 0) {
        let f = r2.accessors[t.attributes[l]], d = v[f.componentType];
        c[u] = d.name, o[u] = f.normalized === true;
      }
    }
    return e.getDependency("bufferView", s).then(function(l) {
      return new Promise(function(u, f) {
        n.decodeDracoFile(l, function(d) {
          for (let m in d.attributes) {
            let R = d.attributes[m], A = o[m];
            A !== void 0 && (R.normalized = A);
          }
          u(d);
        }, a, c, Dn, f);
      });
    });
  }
};
r(tt, "GLTFDracoMeshCompressionExtension");
var Ie2 = tt;
var nt = class nt2 {
  constructor() {
    this.name = g.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t, e) {
    return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = true), t;
  }
};
r(nt, "GLTFTextureTransformExtension");
var Le2 = nt;
var st = class st2 {
  constructor() {
    this.name = g.KHR_MESH_QUANTIZATION;
  }
};
r(st, "GLTFMeshQuantizationExtension");
var Oe = st;
var rt = class rt2 extends Ni {
  constructor(t, e, r2, n) {
    super(t, e, r2, n);
  }
  copySampleValue_(t) {
    let e = this.resultBuffer, r2 = this.sampleValues, n = this.valueSize, s = t * n * 3 + n;
    for (let i = 0; i !== n; i++) e[i] = r2[s + i];
    return e;
  }
  interpolate_(t, e, r2, n) {
    let s = this.resultBuffer, i = this.sampleValues, a = this.valueSize, o = a * 2, c = a * 3, l = n - e, u = (r2 - e) / l, f = u * u, d = f * u, m = t * c, R = m - c, A = -2 * d + 3 * f, T = d - f, E = 1 - A, x = T - f + u;
    for (let _ = 0; _ !== a; _++) {
      let w = i[R + _ + a], M = i[R + _ + o] * l, y = i[m + _ + a], U = i[m + _] * l;
      s[_] = E * w + x * M + A * y + T * U;
    }
    return s;
  }
};
r(rt, "GLTFCubicSplineInterpolant");
var z = rt;
var tn = new In();
var it = class it2 extends z {
  interpolate_(t, e, r2, n) {
    let s = super.interpolate_(t, e, r2, n);
    return tn.fromArray(s).normalize().toArray(s), s;
  }
};
r(it, "GLTFCubicSplineQuaternionInterpolant");
var Ce2 = it;
var S = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 };
var v = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
var Qt = { 9728: ge, 9729: Ce, 9984: uh, 9985: Zr, 9986: Vi, 9987: Yn };
var Zt = { 33071: Ye, 33648: Va, 10497: ka };
var ce = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var De = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" };
var O = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" };
var nn = { CUBICSPLINE: void 0, LINEAR: Ks, STEP: $s };
var ue = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function sn(h) {
  return h.DefaultMaterial === void 0 && (h.DefaultMaterial = new So({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: Cn })), h.DefaultMaterial;
}
r(sn, "createDefaultMaterial");
function P2(h, t, e) {
  for (let r2 in e.extensions) h[r2] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r2] = e.extensions[r2]);
}
r(P2, "addUnknownExtensionsToUserData");
function C(h, t) {
  t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(h.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
}
r(C, "assignExtrasToUserData");
function rn(h, t, e) {
  let r2 = false, n = false, s = false;
  for (let c = 0, l = t.length; c < l; c++) {
    let u = t[c];
    if (u.POSITION !== void 0 && (r2 = true), u.NORMAL !== void 0 && (n = true), u.COLOR_0 !== void 0 && (s = true), r2 && n && s) break;
  }
  if (!r2 && !n && !s) return Promise.resolve(h);
  let i = [], a = [], o = [];
  for (let c = 0, l = t.length; c < l; c++) {
    let u = t[c];
    if (r2) {
      let f = u.POSITION !== void 0 ? e.getDependency("accessor", u.POSITION) : h.attributes.position;
      i.push(f);
    }
    if (n) {
      let f = u.NORMAL !== void 0 ? e.getDependency("accessor", u.NORMAL) : h.attributes.normal;
      a.push(f);
    }
    if (s) {
      let f = u.COLOR_0 !== void 0 ? e.getDependency("accessor", u.COLOR_0) : h.attributes.color;
      o.push(f);
    }
  }
  return Promise.all([Promise.all(i), Promise.all(a), Promise.all(o)]).then(function(c) {
    let l = c[0], u = c[1], f = c[2];
    return r2 && (h.morphAttributes.position = l), n && (h.morphAttributes.normal = u), s && (h.morphAttributes.color = f), h.morphTargetsRelative = true, h;
  });
}
r(rn, "addMorphTargets");
function on(h, t) {
  if (h.updateMorphTargets(), t.weights !== void 0) for (let e = 0, r2 = t.weights.length; e < r2; e++) h.morphTargetInfluences[e] = t.weights[e];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    let e = t.extras.targetNames;
    if (h.morphTargetInfluences.length === e.length) {
      h.morphTargetDictionary = {};
      for (let r2 = 0, n = e.length; r2 < n; r2++) h.morphTargetDictionary[e[r2]] = r2;
    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
r(on, "updateMorphTargets");
function an(h) {
  let t, e = h.extensions && h.extensions[g.KHR_DRACO_MESH_COMPRESSION];
  if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + le2(e.attributes) : t = h.indices + ":" + le2(h.attributes) + ":" + h.mode, h.targets !== void 0) for (let r2 = 0, n = h.targets.length; r2 < n; r2++) t += ":" + le2(h.targets[r2]);
  return t;
}
r(an, "createPrimitiveKey");
function le2(h) {
  let t = "", e = Object.keys(h).sort();
  for (let r2 = 0, n = e.length; r2 < n; r2++) t += e[r2] + ":" + h[e[r2]] + ";";
  return t;
}
r(le2, "createAttributesKey");
function Pe(h) {
  switch (h) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
r(Pe, "getNormalizedComponentScale");
function cn(h) {
  return h.search(/\.jpe?g($|\?)/i) > 0 || h.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : h.search(/\.webp($|\?)/i) > 0 || h.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
r(cn, "getImageURIMimeType");
var un2 = new Ft();
var ot = class ot2 {
  constructor(t = {}, e = {}) {
    this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new en(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r2 = false, n = false, s = -1;
    typeof navigator < "u" && (r2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r2 || n && s < 98 ? this.textureLoader = new gd(this.options.manager) : this.textureLoader = new wd(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new md(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(t) {
    this.extensions = t;
  }
  setPlugins(t) {
    this.plugins = t;
  }
  parse(t, e) {
    let r2 = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(i) {
      return i._markDefs && i._markDefs();
    }), Promise.all(this._invokeAll(function(i) {
      return i.beforeRoot && i.beforeRoot();
    })).then(function() {
      return Promise.all([r2.getDependencies("scene"), r2.getDependencies("animation"), r2.getDependencies("camera")]);
    }).then(function(i) {
      let a = { scene: i[0][n.scene || 0], scenes: i[0], animations: i[1], cameras: i[2], asset: n.asset, parser: r2, userData: {} };
      return P2(s, a, n), C(a, n), Promise.all(r2._invokeAll(function(o) {
        return o.afterRoot && o.afterRoot(a);
      })).then(function() {
        t(a);
      });
    }).catch(e);
  }
  _markDefs() {
    let t = this.json.nodes || [], e = this.json.skins || [], r2 = this.json.meshes || [];
    for (let n = 0, s = e.length; n < s; n++) {
      let i = e[n].joints;
      for (let a = 0, o = i.length; a < o; a++) t[i[a]].isBone = true;
    }
    for (let n = 0, s = t.length; n < s; n++) {
      let i = t[n];
      i.mesh !== void 0 && (this._addNodeRef(this.meshCache, i.mesh), i.skin !== void 0 && (r2[i.mesh].isSkinnedMesh = true)), i.camera !== void 0 && this._addNodeRef(this.cameraCache, i.camera);
    }
  }
  _addNodeRef(t, e) {
    e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
  }
  _getNodeRef(t, e, r2) {
    if (t.refs[e] <= 1) return r2;
    let n = r2.clone(), s = r((i, a) => {
      let o = this.associations.get(i);
      o != null && this.associations.set(a, o);
      for (let [c, l] of i.children.entries()) s(l, a.children[c]);
    }, "updateMappings");
    return s(r2, n), n.name += "_instance_" + t.uses[e]++, n;
  }
  _invokeOne(t) {
    let e = Object.values(this.plugins);
    e.push(this);
    for (let r2 = 0; r2 < e.length; r2++) {
      let n = t(e[r2]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(t) {
    let e = Object.values(this.plugins);
    e.unshift(this);
    let r2 = [];
    for (let n = 0; n < e.length; n++) {
      let s = t(e[n]);
      s && r2.push(s);
    }
    return r2;
  }
  getDependency(t, e) {
    let r2 = t + ":" + e, n = this.cache.get(r2);
    if (!n) {
      switch (t) {
        case "scene":
          n = this.loadScene(e);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(e);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(e);
          });
          break;
        case "accessor":
          n = this.loadAccessor(e);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(e);
          });
          break;
        case "buffer":
          n = this.loadBuffer(e);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(e);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(e);
          });
          break;
        case "skin":
          n = this.loadSkin(e);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(e);
          });
          break;
        case "camera":
          n = this.loadCamera(e);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(t, e);
          }), !n) throw new Error("Unknown type: " + t);
          break;
      }
      this.cache.add(r2, n);
    }
    return n;
  }
  getDependencies(t) {
    let e = this.cache.get(t);
    if (!e) {
      let r2 = this, n = this.json[t + (t === "mesh" ? "es" : "s")] || [];
      e = Promise.all(n.map(function(s, i) {
        return r2.getDependency(t, i);
      })), this.cache.add(t, e);
    }
    return e;
  }
  loadBuffer(t) {
    let e = this.json.buffers[t], r2 = this.fileLoader;
    if (e.type && e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && t === 0) return Promise.resolve(this.extensions[g.KHR_BINARY_GLTF].body);
    let n = this.options;
    return new Promise(function(s, i) {
      r2.load(Ed.resolveURL(e.uri, n.path), s, void 0, function() {
        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  loadBufferView(t) {
    let e = this.json.bufferViews[t];
    return this.getDependency("buffer", e.buffer).then(function(r2) {
      let n = e.byteLength || 0, s = e.byteOffset || 0;
      return r2.slice(s, s + n);
    });
  }
  loadAccessor(t) {
    let e = this, r2 = this.json, n = this.json.accessors[t];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      let i = ce[n.type], a = v[n.componentType], o = n.normalized === true, c = new a(n.count * i);
      return Promise.resolve(new Se(c, i, o));
    }
    let s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(i) {
      let a = i[0], o = ce[n.type], c = v[n.componentType], l = c.BYTES_PER_ELEMENT, u = l * o, f = n.byteOffset || 0, d = n.bufferView !== void 0 ? r2.bufferViews[n.bufferView].byteStride : void 0, m = n.normalized === true, R, A;
      if (d && d !== u) {
        let T = Math.floor(f / d), E = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + T + ":" + n.count, x = e.cache.get(E);
        x || (R = new c(a, T * d, n.count * d / l), x = new Cu(R, d / l), e.cache.add(E, x)), A = new Pu(x, o, f % d / l, m);
      } else a === null ? R = new c(n.count * o) : R = new c(a, f, n.count * o), A = new Se(R, o, m);
      if (n.sparse !== void 0) {
        let T = ce.SCALAR, E = v[n.sparse.indices.componentType], x = n.sparse.indices.byteOffset || 0, _ = n.sparse.values.byteOffset || 0, w = new E(i[1], x, n.sparse.count * T), M = new c(i[2], _, n.sparse.count * o);
        a !== null && (A = new Se(A.array.slice(), A.itemSize, A.normalized));
        for (let y = 0, U = w.length; y < U; y++) {
          let I = w[y];
          if (A.setX(I, M[y * o]), o >= 2 && A.setY(I, M[y * o + 1]), o >= 3 && A.setZ(I, M[y * o + 2]), o >= 4 && A.setW(I, M[y * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return A;
    });
  }
  loadTexture(t) {
    let e = this.json, r2 = this.options, s = e.textures[t].source, i = e.images[s], a = this.textureLoader;
    if (i.uri) {
      let o = r2.manager.getHandler(i.uri);
      o !== null && (a = o);
    }
    return this.loadTextureImage(t, s, a);
  }
  loadTextureImage(t, e, r2) {
    let n = this, s = this.json, i = s.textures[t], a = s.images[e], o = (a.uri || a.bufferView) + ":" + i.sampler;
    if (this.textureCache[o]) return this.textureCache[o];
    let c = this.loadImageSource(e, r2).then(function(l) {
      l.flipY = false, l.name = i.name || a.name || "", l.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === false && (l.name = a.uri);
      let f = (s.samplers || {})[i.sampler] || {};
      return l.magFilter = Qt[f.magFilter] || Ce, l.minFilter = Qt[f.minFilter] || Yn, l.wrapS = Zt[f.wrapS] || ka, l.wrapT = Zt[f.wrapT] || ka, n.associations.set(l, { textures: t }), l;
    }).catch(function() {
      return null;
    });
    return this.textureCache[o] = c, c;
  }
  loadImageSource(t, e) {
    let r2 = this, n = this.json, s = this.options;
    if (this.sourceCache[t] !== void 0) return this.sourceCache[t].then((u) => u.clone());
    let i = n.images[t], a = self.URL || self.webkitURL, o = i.uri || "", c = false;
    if (i.bufferView !== void 0) o = r2.getDependency("bufferView", i.bufferView).then(function(u) {
      c = true;
      let f = new Blob([u], { type: i.mimeType });
      return o = a.createObjectURL(f), o;
    });
    else if (i.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
    let l = Promise.resolve(o).then(function(u) {
      return new Promise(function(f, d) {
        let m = f;
        e.isImageBitmapLoader === true && (m = r(function(R) {
          let A = new be(R);
          A.needsUpdate = true, f(A);
        }, "onLoad")), e.load(Ed.resolveURL(u, s.path), m, void 0, d);
      });
    }).then(function(u) {
      return c === true && a.revokeObjectURL(o), u.userData.mimeType = i.mimeType || cn(i.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", o), u;
    });
    return this.sourceCache[t] = l, l;
  }
  assignTexture(t, e, r2, n) {
    let s = this;
    return this.getDependency("texture", r2.index).then(function(i) {
      if (!i) return null;
      if (r2.texCoord !== void 0 && r2.texCoord > 0 && (i = i.clone(), i.channel = r2.texCoord), s.extensions[g.KHR_TEXTURE_TRANSFORM]) {
        let a = r2.extensions !== void 0 ? r2.extensions[g.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          let o = s.associations.get(i);
          i = s.extensions[g.KHR_TEXTURE_TRANSFORM].extendTexture(i, a), s.associations.set(i, o);
        }
      }
      return n !== void 0 && (i.colorSpace = n), t[e] = i, i;
    });
  }
  assignFinalMaterial(t) {
    let e = t.geometry, r2 = t.material, n = e.attributes.tangent === void 0, s = e.attributes.color !== void 0, i = e.attributes.normal === void 0;
    if (t.isPoints) {
      let a = "PointsMaterial:" + r2.uuid, o = this.cache.get(a);
      o || (o = new uo(), je.prototype.copy.call(o, r2), o.color.copy(r2.color), o.map = r2.map, o.sizeAttenuation = false, this.cache.add(a, o)), r2 = o;
    } else if (t.isLine) {
      let a = "LineBasicMaterial:" + r2.uuid, o = this.cache.get(a);
      o || (o = new ho(), je.prototype.copy.call(o, r2), o.color.copy(r2.color), o.map = r2.map, this.cache.add(a, o)), r2 = o;
    }
    if (n || s || i) {
      let a = "ClonedMaterial:" + r2.uuid + ":";
      n && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), i && (a += "flat-shading:");
      let o = this.cache.get(a);
      o || (o = r2.clone(), s && (o.vertexColors = true), i && (o.flatShading = true), n && (o.normalScale && (o.normalScale.y *= -1), o.clearcoatNormalScale && (o.clearcoatNormalScale.y *= -1)), this.cache.add(a, o), this.associations.set(o, this.associations.get(r2))), r2 = o;
    }
    t.material = r2;
  }
  getMaterialType() {
    return So;
  }
  loadMaterial(t) {
    let e = this, r2 = this.json, n = this.extensions, s = r2.materials[t], i, a = {}, o = s.extensions || {}, c = [];
    if (o[g.KHR_MATERIALS_UNLIT]) {
      let u = n[g.KHR_MATERIALS_UNLIT];
      i = u.getMaterialType(), c.push(u.extendParams(a, s, e));
    } else {
      let u = s.pbrMetallicRoughness || {};
      if (a.color = new Vt(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
        let f = u.baseColorFactor;
        a.color.setRGB(f[0], f[1], f[2], Dn), a.opacity = f[3];
      }
      u.baseColorTexture !== void 0 && c.push(e.assignTexture(a, "map", u.baseColorTexture, Ke)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(e.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(e.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))), i = this._invokeOne(function(f) {
        return f.getMaterialType && f.getMaterialType(t);
      }), c.push(Promise.all(this._invokeAll(function(f) {
        return f.extendMaterialParams && f.extendMaterialParams(t, a);
      })));
    }
    s.doubleSided === true && (a.side = un);
    let l = s.alphaMode || ue.OPAQUE;
    if (l === ue.BLEND ? (a.transparent = true, a.depthWrite = false) : (a.transparent = false, l === ue.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && i !== ar && (c.push(e.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new lt(1, 1), s.normalTexture.scale !== void 0)) {
      let u = s.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    if (s.occlusionTexture !== void 0 && i !== ar && (c.push(e.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && i !== ar) {
      let u = s.emissiveFactor;
      a.emissive = new Vt().setRGB(u[0], u[1], u[2], Dn);
    }
    return s.emissiveTexture !== void 0 && i !== ar && c.push(e.assignTexture(a, "emissiveMap", s.emissiveTexture, Ke)), Promise.all(c).then(function() {
      let u = new i(a);
      return s.name && (u.name = s.name), C(u, s), e.associations.set(u, { materials: t }), s.extensions && P2(n, u, s), u;
    });
  }
  createUniqueName(t) {
    let e = ne.sanitizeNodeName(t || "");
    return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
  }
  loadGeometries(t) {
    let e = this, r2 = this.extensions, n = this.primitiveCache;
    function s(a) {
      return r2[g.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, e).then(function(o) {
        return Jt2(o, a, e);
      });
    }
    r(s, "createDracoPrimitive");
    let i = [];
    for (let a = 0, o = t.length; a < o; a++) {
      let c = t[a], l = an(c), u = n[l];
      if (u) i.push(u.promise);
      else {
        let f;
        c.extensions && c.extensions[g.KHR_DRACO_MESH_COMPRESSION] ? f = s(c) : f = Jt2(new Le(), c, e), n[l] = { primitive: c, promise: f }, i.push(f);
      }
    }
    return Promise.all(i);
  }
  loadMesh(t) {
    let e = this, r2 = this.json, n = this.extensions, s = r2.meshes[t], i = s.primitives, a = [];
    for (let o = 0, c = i.length; o < c; o++) {
      let l = i[o].material === void 0 ? sn(this.cache) : this.getDependency("material", i[o].material);
      a.push(l);
    }
    return a.push(e.loadGeometries(i)), Promise.all(a).then(function(o) {
      let c = o.slice(0, o.length - 1), l = o[o.length - 1], u = [];
      for (let d = 0, m = l.length; d < m; d++) {
        let R = l[d], A = i[d], T, E = c[d];
        if (A.mode === S.TRIANGLES || A.mode === S.TRIANGLE_STRIP || A.mode === S.TRIANGLE_FAN || A.mode === void 0) T = s.isSkinnedMesh === true ? new Ou(R, E) : new Me(R, E), T.isSkinnedMesh === true && T.normalizeSkinWeights(), A.mode === S.TRIANGLE_STRIP ? T.geometry = X(T.geometry, mv) : A.mode === S.TRIANGLE_FAN && (T.geometry = X(T.geometry, gv));
        else if (A.mode === S.LINES) T = new $u(R, E);
        else if (A.mode === S.LINE_STRIP) T = new gr(R, E);
        else if (A.mode === S.LINE_LOOP) T = new Ku(R, E);
        else if (A.mode === S.POINTS) T = new ju(R, E);
        else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
        Object.keys(T.geometry.morphAttributes).length > 0 && on(T, s), T.name = e.createUniqueName(s.name || "mesh_" + t), C(T, s), A.extensions && P2(n, T, A), e.assignFinalMaterial(T), u.push(T);
      }
      for (let d = 0, m = u.length; d < m; d++) e.associations.set(u[d], { meshes: t, primitives: d });
      if (u.length === 1) return s.extensions && P2(n, u[0], s), u[0];
      let f = new Mi();
      s.extensions && P2(n, f, s), e.associations.set(f, { meshes: t });
      for (let d = 0, m = u.length; d < m; d++) f.add(u[d]);
      return f;
    });
  }
  loadCamera(t) {
    let e, r2 = this.json.cameras[t], n = r2[r2.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r2.type === "perspective" ? e = new Te(_v.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : r2.type === "orthographic" && (e = new dr(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r2.name && (e.name = this.createUniqueName(r2.name)), C(e, r2), Promise.resolve(e);
  }
  loadSkin(t) {
    let e = this.json.skins[t], r2 = [];
    for (let n = 0, s = e.joints.length; n < s; n++) r2.push(this._loadNodeShallow(e.joints[n]));
    return e.inverseBindMatrices !== void 0 ? r2.push(this.getDependency("accessor", e.inverseBindMatrices)) : r2.push(null), Promise.all(r2).then(function(n) {
      let s = n.pop(), i = n, a = [], o = [];
      for (let c = 0, l = i.length; c < l; c++) {
        let u = i[c];
        if (u) {
          a.push(u);
          let f = new Ft();
          s !== null && f.fromArray(s.array, c * 16), o.push(f);
        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[c]);
      }
      return new Bu(a, o);
    });
  }
  loadAnimation(t) {
    let e = this.json, r2 = this, n = e.animations[t], s = n.name ? n.name : "animation_" + t, i = [], a = [], o = [], c = [], l = [];
    for (let u = 0, f = n.channels.length; u < f; u++) {
      let d = n.channels[u], m = n.samplers[d.sampler], R = d.target, A = R.node, T = n.parameters !== void 0 ? n.parameters[m.input] : m.input, E = n.parameters !== void 0 ? n.parameters[m.output] : m.output;
      R.node !== void 0 && (i.push(this.getDependency("node", A)), a.push(this.getDependency("accessor", T)), o.push(this.getDependency("accessor", E)), c.push(m), l.push(R));
    }
    return Promise.all([Promise.all(i), Promise.all(a), Promise.all(o), Promise.all(c), Promise.all(l)]).then(function(u) {
      let f = u[0], d = u[1], m = u[2], R = u[3], A = u[4], T = [];
      for (let E = 0, x = f.length; E < x; E++) {
        let _ = f[E], w = d[E], M = m[E], y = R[E], U = A[E];
        if (_ === void 0) continue;
        _.updateMatrix && _.updateMatrix();
        let I = r2._createAnimationTracks(_, w, M, y, U);
        if (I) for (let q2 = 0; q2 < I.length; q2++) T.push(I[q2]);
      }
      return new pd(s, void 0, T);
    });
  }
  createNodeMesh(t) {
    let e = this.json, r2 = this, n = e.nodes[t];
    return n.mesh === void 0 ? null : r2.getDependency("mesh", n.mesh).then(function(s) {
      let i = r2._getNodeRef(r2.meshCache, n.mesh, s);
      return n.weights !== void 0 && i.traverse(function(a) {
        if (a.isMesh) for (let o = 0, c = n.weights.length; o < c; o++) a.morphTargetInfluences[o] = n.weights[o];
      }), i;
    });
  }
  loadNode(t) {
    let e = this.json, r2 = this, n = e.nodes[t], s = r2._loadNodeShallow(t), i = [], a = n.children || [];
    for (let c = 0, l = a.length; c < l; c++) i.push(r2.getDependency("node", a[c]));
    let o = n.skin === void 0 ? Promise.resolve(null) : r2.getDependency("skin", n.skin);
    return Promise.all([s, Promise.all(i), o]).then(function(c) {
      let l = c[0], u = c[1], f = c[2];
      f !== null && l.traverse(function(d) {
        d.isSkinnedMesh && d.bind(f, un2);
      });
      for (let d = 0, m = u.length; d < m; d++) l.add(u[d]);
      return l;
    });
  }
  _loadNodeShallow(t) {
    let e = this.json, r2 = this.extensions, n = this;
    if (this.nodeCache[t] !== void 0) return this.nodeCache[t];
    let s = e.nodes[t], i = s.name ? n.createUniqueName(s.name) : "", a = [], o = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(t);
    });
    return o && a.push(o), s.camera !== void 0 && a.push(n.getDependency("camera", s.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, s.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(t);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[t] = Promise.all(a).then(function(c) {
      let l;
      if (s.isBone === true ? l = new co() : c.length > 1 ? l = new Mi() : c.length === 1 ? l = c[0] : l = new le(), l !== c[0]) for (let u = 0, f = c.length; u < f; u++) l.add(c[u]);
      if (s.name && (l.userData.name = s.name, l.name = i), C(l, s), s.extensions && P2(r2, l, s), s.matrix !== void 0) {
        let u = new Ft();
        u.fromArray(s.matrix), l.applyMatrix4(u);
      } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale);
      return n.associations.has(l) || n.associations.set(l, {}), n.associations.get(l).nodes = t, l;
    }), this.nodeCache[t];
  }
  loadScene(t) {
    let e = this.extensions, r2 = this.json.scenes[t], n = this, s = new Mi();
    r2.name && (s.name = n.createUniqueName(r2.name)), C(s, r2), r2.extensions && P2(e, s, r2);
    let i = r2.nodes || [], a = [];
    for (let o = 0, c = i.length; o < c; o++) a.push(n.getDependency("node", i[o]));
    return Promise.all(a).then(function(o) {
      for (let l = 0, u = o.length; l < u; l++) s.add(o[l]);
      let c = r((l) => {
        let u = /* @__PURE__ */ new Map();
        for (let [f, d] of n.associations) (f instanceof je || f instanceof be) && u.set(f, d);
        return l.traverse((f) => {
          let d = n.associations.get(f);
          d != null && u.set(f, d);
        }), u;
      }, "reduceAssociations");
      return n.associations = c(s), s;
    });
  }
  _createAnimationTracks(t, e, r2, n, s) {
    let i = [], a = t.name ? t.name : t.uuid, o = [];
    O[s.path] === O.weights ? t.traverse(function(f) {
      f.morphTargetInfluences && o.push(f.name ? f.name : f.uuid);
    }) : o.push(a);
    let c;
    switch (O[s.path]) {
      case O.weights:
        c = Oi;
        break;
      case O.rotation:
        c = jn;
        break;
      case O.position:
      case O.scale:
        c = Fi;
        break;
      default:
        switch (r2.itemSize) {
          case 1:
            c = Oi;
            break;
          case 2:
          case 3:
          default:
            c = Fi;
            break;
        }
        break;
    }
    let l = n.interpolation !== void 0 ? nn[n.interpolation] : Ks, u = this._getArrayFromAccessor(r2);
    for (let f = 0, d = o.length; f < d; f++) {
      let m = new c(o[f] + "." + O[s.path], e.array, u, l);
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), i.push(m);
    }
    return i;
  }
  _getArrayFromAccessor(t) {
    let e = t.array;
    if (t.normalized) {
      let r2 = Pe(e.constructor), n = new Float32Array(e.length);
      for (let s = 0, i = e.length; s < i; s++) n[s] = e[s] * r2;
      e = n;
    }
    return e;
  }
  _createCubicSplineTrackInterpolant(t) {
    t.createInterpolant = r(function(r2) {
      let n = this instanceof jn ? Ce2 : z;
      return new n(this.times, this.values, this.getValueSize() / 3, r2);
    }, "InterpolantFactoryMethodGLTFCubicSpline"), t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
r(ot, "GLTFParser");
var ke = ot;
function ln(h, t, e) {
  let r2 = t.attributes, n = new Ie();
  if (r2.POSITION !== void 0) {
    let a = e.json.accessors[r2.POSITION], o = a.min, c = a.max;
    if (o !== void 0 && c !== void 0) {
      if (n.set(new P(o[0], o[1], o[2]), new P(c[0], c[1], c[2])), a.normalized) {
        let l = Pe(v[a.componentType]);
        n.min.multiplyScalar(l), n.max.multiplyScalar(l);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else return;
  let s = t.targets;
  if (s !== void 0) {
    let a = new P(), o = new P();
    for (let c = 0, l = s.length; c < l; c++) {
      let u = s[c];
      if (u.POSITION !== void 0) {
        let f = e.json.accessors[u.POSITION], d = f.min, m = f.max;
        if (d !== void 0 && m !== void 0) {
          if (o.setX(Math.max(Math.abs(d[0]), Math.abs(m[0]))), o.setY(Math.max(Math.abs(d[1]), Math.abs(m[1]))), o.setZ(Math.max(Math.abs(d[2]), Math.abs(m[2]))), f.normalized) {
            let R = Pe(v[f.componentType]);
            o.multiplyScalar(R);
          }
          a.max(o);
        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  h.boundingBox = n;
  let i = new Re();
  n.getCenter(i.center), i.radius = n.min.distanceTo(n.max) / 2, h.boundingSphere = i;
}
r(ln, "computeBounds");
function Jt2(h, t, e) {
  let r2 = t.attributes, n = [];
  function s(i, a) {
    return e.getDependency("accessor", i).then(function(o) {
      h.setAttribute(a, o);
    });
  }
  r(s, "assignAttributeAccessor");
  for (let i in r2) {
    let a = De[i] || i.toLowerCase();
    a in h.attributes || n.push(s(r2[i], a));
  }
  if (t.indices !== void 0 && !h.index) {
    let i = e.getDependency("accessor", t.indices).then(function(a) {
      h.setIndex(a);
    });
    n.push(i);
  }
  return Jt.workingColorSpace !== Dn && "COLOR_0" in r2 && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Jt.workingColorSpace}" not supported.`), C(h, t), ln(h, t, e), Promise.all(n).then(function() {
    return t.targets !== void 0 ? rn(h, t.targets, e) : h;
  });
}
r(Jt2, "addPrimitiveAttributes");
export {
  Wt as GLTFLoader
};
//# sourceMappingURL=GLTFLoader-MV5BOOKA-GDB4KD5S.js.map

import {
  Q,
  gw
} from "./chunk-5QC6BETS.js";
import "./chunk-Z4ENL6JO.js";
import {
  Vt
} from "./chunk-763QVDXZ.js";
import "./chunk-LFU6THUQ.js";
import {
  __publicField,
  q,
  r
} from "./chunk-F6LUTOTK.js";

// node_modules/@mappedin/mappedin-js/lib/esm/inspector-RBV6MS2D.js
q();
q();
q();
q();
var E = class E2 {
  constructor(t, e, i, r2, s = "div") {
    this.parent = t, this.object = e, this.property = i, this._disabled = false, this._hidden = false, this.initialValue = this.getValue(), this.domElement = document.createElement(s), this.domElement.classList.add("controller"), this.domElement.classList.add(r2), this.$name = document.createElement("div"), this.$name.classList.add("name"), E2.nextNameID = E2.nextNameID || 0, this.$name.id = `lil-gui-name-${++E2.nextNameID}`, this.$widget = document.createElement("div"), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.domElement.addEventListener("keydown", (a) => a.stopPropagation()), this.domElement.addEventListener("keyup", (a) => a.stopPropagation()), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(i);
  }
  name(t) {
    return this._name = t, this.$name.textContent = t, this;
  }
  onChange(t) {
    return this._onChange = t, this;
  }
  _callOnChange() {
    this.parent._callOnChange(this), this._onChange !== void 0 && this._onChange.call(this, this.getValue()), this._changed = true;
  }
  onFinishChange(t) {
    return this._onFinishChange = t, this;
  }
  _callOnFinishChange() {
    this._changed && (this.parent._callOnFinishChange(this), this._onFinishChange !== void 0 && this._onFinishChange.call(this, this.getValue())), this._changed = false;
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this;
  }
  enable(t = true) {
    return this.disable(!t);
  }
  disable(t = true) {
    return t === this._disabled ? this : (this._disabled = t, this.domElement.classList.toggle("disabled", t), this.$disable.toggleAttribute("disabled", t), this);
  }
  show(t = true) {
    return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this;
  }
  hide() {
    return this.show(false);
  }
  options(t) {
    let e = this.parent.add(this.object, this.property, t);
    return e.name(this._name), this.destroy(), e;
  }
  min(t) {
    return this;
  }
  max(t) {
    return this;
  }
  step(t) {
    return this;
  }
  decimals(t) {
    return this;
  }
  listen(t = true) {
    return this._listening = t, this._listenCallbackID !== void 0 && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this;
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    let t = this.save();
    t !== this._listenPrevValue && this.updateDisplay(), this._listenPrevValue = t;
  }
  getValue() {
    return this.object[this.property];
  }
  setValue(t) {
    return this.getValue() !== t && (this.object[this.property] = t, this._callOnChange(), this.updateDisplay()), this;
  }
  updateDisplay() {
    return this;
  }
  load(t) {
    return this.setValue(t), this._callOnFinishChange(), this;
  }
  save() {
    return this.getValue();
  }
  destroy() {
    this.listen(false), this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement);
  }
};
r(E, "Controller");
var _ = E;
var G = class G2 extends _ {
  constructor(t, e, i) {
    super(t, e, i, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", () => {
      this.setValue(this.$input.checked), this._callOnFinishChange();
    }), this.$disable = this.$input, this.updateDisplay();
  }
  updateDisplay() {
    return this.$input.checked = this.getValue(), this;
  }
};
r(G, "BooleanController");
var M = G;
function I(n) {
  let t, e;
  return (t = n.match(/(#|0x)?([a-f0-9]{6})/i)) ? e = t[2] : (t = n.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? e = parseInt(t[1]).toString(16).padStart(2, 0) + parseInt(t[2]).toString(16).padStart(2, 0) + parseInt(t[3]).toString(16).padStart(2, 0) : (t = n.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (e = t[1] + t[1] + t[2] + t[2] + t[3] + t[3]), e ? "#" + e : false;
}
r(I, "normalizeColorString");
var ht = { isPrimitive: true, match: (n) => typeof n == "string", fromHexString: I, toHexString: I };
var k = { isPrimitive: true, match: (n) => typeof n == "number", fromHexString: (n) => parseInt(n.substring(1), 16), toHexString: (n) => "#" + n.toString(16).padStart(6, 0) };
var ct = { isPrimitive: false, match: (n) => Array.isArray(n), fromHexString(n, t, e = 1) {
  let i = k.fromHexString(n);
  t[0] = (i >> 16 & 255) / 255 * e, t[1] = (i >> 8 & 255) / 255 * e, t[2] = (i & 255) / 255 * e;
}, toHexString([n, t, e], i = 1) {
  i = 255 / i;
  let r2 = n * i << 16 ^ t * i << 8 ^ e * i << 0;
  return k.toHexString(r2);
} };
var ut = { isPrimitive: false, match: (n) => Object(n) === n, fromHexString(n, t, e = 1) {
  let i = k.fromHexString(n);
  t.r = (i >> 16 & 255) / 255 * e, t.g = (i >> 8 & 255) / 255 * e, t.b = (i & 255) / 255 * e;
}, toHexString({ r: n, g: t, b: e }, i = 1) {
  i = 255 / i;
  let r2 = n * i << 16 ^ t * i << 8 ^ e * i << 0;
  return k.toHexString(r2);
} };
var pt = [ht, k, ct, ut];
function gt(n) {
  return pt.find((t) => t.match(n));
}
r(gt, "getColorFormat");
var H = class H2 extends _ {
  constructor(t, e, i, r2) {
    super(t, e, i, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = gt(this.initialValue), this._rgbScale = r2, this._initialValueHexString = this.save(), this._textFocused = false, this.$input.addEventListener("input", () => {
      this._setValueFromHexString(this.$input.value);
    }), this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    }), this.$text.addEventListener("input", () => {
      let s = I(this.$text.value);
      s && this._setValueFromHexString(s);
    }), this.$text.addEventListener("focus", () => {
      this._textFocused = true, this.$text.select();
    }), this.$text.addEventListener("blur", () => {
      this._textFocused = false, this.updateDisplay(), this._callOnFinishChange();
    }), this.$disable = this.$text, this.updateDisplay();
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this;
  }
  _setValueFromHexString(t) {
    if (this._format.isPrimitive) {
      let e = this._format.fromHexString(t);
      this.setValue(e);
    } else this._format.fromHexString(t, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay();
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(t) {
    return this._setValueFromHexString(t), this._callOnFinishChange(), this;
  }
  updateDisplay() {
    return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this;
  }
};
r(H, "ColorController");
var F = H;
var V = class V2 extends _ {
  constructor(t, e, i) {
    super(t, e, i, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", (r2) => {
      r2.preventDefault(), this.getValue().call(this.object), this._callOnChange();
    }), this.$button.addEventListener("touchstart", () => {
    }, { passive: true }), this.$disable = this.$button;
  }
};
r(V, "FunctionController");
var $ = V;
var T = class T2 extends _ {
  constructor(t, e, i, r2, s, a) {
    super(t, e, i, "number"), this._initInput(), this.min(r2), this.max(s);
    let u = a !== void 0;
    this.step(u ? a : this._getImplicitStep(), u), this.updateDisplay();
  }
  decimals(t) {
    return this._decimals = t, this.updateDisplay(), this;
  }
  min(t) {
    return this._min = t, this._onUpdateMinMax(), this;
  }
  max(t) {
    return this._max = t, this._onUpdateMinMax(), this;
  }
  step(t, e = true) {
    return this._step = t, this._stepExplicit = e, this;
  }
  updateDisplay() {
    let t = this.getValue();
    if (this._hasSlider) {
      let e = (t - this._min) / (this._max - this._min);
      e = Math.max(0, Math.min(e, 1)), this.$fill.style.width = e * 100 + "%";
    }
    return this._inputFocused || (this.$input.value = this._decimals === void 0 ? t : t.toFixed(this._decimals)), this;
  }
  _initInput() {
    this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), window.matchMedia("(pointer: coarse)").matches && (this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any")), this.$widget.appendChild(this.$input), this.$disable = this.$input;
    let e = r(() => {
      let p = parseFloat(this.$input.value);
      isNaN(p) || (this._stepExplicit && (p = this._snap(p)), this.setValue(this._clamp(p)));
    }, "onInput"), i = r((p) => {
      let C = parseFloat(this.$input.value);
      isNaN(C) || (this._snapClampSetValue(C + p), this.$input.value = this.getValue());
    }, "increment"), r2 = r((p) => {
      p.key === "Enter" && this.$input.blur(), p.code === "ArrowUp" && (p.preventDefault(), i(this._step * this._arrowKeyMultiplier(p))), p.code === "ArrowDown" && (p.preventDefault(), i(this._step * this._arrowKeyMultiplier(p) * -1));
    }, "onKeyDown"), s = r((p) => {
      this._inputFocused && (p.preventDefault(), i(this._step * this._normalizeMouseWheel(p)));
    }, "onWheel"), a = false, u, g, b, f, c, d = 5, l = r((p) => {
      u = p.clientX, g = b = p.clientY, a = true, f = this.getValue(), c = 0, window.addEventListener("mousemove", h), window.addEventListener("mouseup", v);
    }, "onMouseDown"), h = r((p) => {
      if (a) {
        let C = p.clientX - u, L = p.clientY - g;
        Math.abs(L) > d ? (p.preventDefault(), this.$input.blur(), a = false, this._setDraggingStyle(true, "vertical")) : Math.abs(C) > d && v();
      }
      if (!a) {
        let C = p.clientY - b;
        c -= C * this._step * this._arrowKeyMultiplier(p), f + c > this._max ? c = this._max - f : f + c < this._min && (c = this._min - f), this._snapClampSetValue(f + c);
      }
      b = p.clientY;
    }, "onMouseMove"), v = r(() => {
      this._setDraggingStyle(false, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", h), window.removeEventListener("mouseup", v);
    }, "onMouseUp"), A = r(() => {
      this._inputFocused = true;
    }, "onFocus"), m = r(() => {
      this._inputFocused = false, this.updateDisplay(), this._callOnFinishChange();
    }, "onBlur");
    this.$input.addEventListener("input", e), this.$input.addEventListener("keydown", r2), this.$input.addEventListener("wheel", s, { passive: false }), this.$input.addEventListener("mousedown", l), this.$input.addEventListener("focus", A), this.$input.addEventListener("blur", m);
  }
  _initSlider() {
    this._hasSlider = true, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
    let t = r((m, p, C, L, dt) => (m - p) / (C - p) * (dt - L) + L, "map"), e = r((m) => {
      let p = this.$slider.getBoundingClientRect(), C = t(m, p.left, p.right, this._min, this._max);
      this._snapClampSetValue(C);
    }, "setValueFromX"), i = r((m) => {
      this._setDraggingStyle(true), e(m.clientX), window.addEventListener("mousemove", r2), window.addEventListener("mouseup", s);
    }, "mouseDown"), r2 = r((m) => {
      e(m.clientX);
    }, "mouseMove"), s = r(() => {
      this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("mousemove", r2), window.removeEventListener("mouseup", s);
    }, "mouseUp"), a = false, u, g, b = r((m) => {
      m.preventDefault(), this._setDraggingStyle(true), e(m.touches[0].clientX), a = false;
    }, "beginTouchDrag"), f = r((m) => {
      m.touches.length > 1 || (this._hasScrollBar ? (u = m.touches[0].clientX, g = m.touches[0].clientY, a = true) : b(m), window.addEventListener("touchmove", c, { passive: false }), window.addEventListener("touchend", d));
    }, "onTouchStart"), c = r((m) => {
      if (a) {
        let p = m.touches[0].clientX - u, C = m.touches[0].clientY - g;
        Math.abs(p) > Math.abs(C) ? b(m) : (window.removeEventListener("touchmove", c), window.removeEventListener("touchend", d));
      } else m.preventDefault(), e(m.touches[0].clientX);
    }, "onTouchMove"), d = r(() => {
      this._callOnFinishChange(), this._setDraggingStyle(false), window.removeEventListener("touchmove", c), window.removeEventListener("touchend", d);
    }, "onTouchEnd"), l = this._callOnFinishChange.bind(this), h = 400, v, A = r((m) => {
      if (Math.abs(m.deltaX) < Math.abs(m.deltaY) && this._hasScrollBar) return;
      m.preventDefault();
      let C = this._normalizeMouseWheel(m) * this._step;
      this._snapClampSetValue(this.getValue() + C), this.$input.value = this.getValue(), clearTimeout(v), v = setTimeout(l, h);
    }, "onWheel");
    this.$slider.addEventListener("mousedown", i), this.$slider.addEventListener("touchstart", f, { passive: false }), this.$slider.addEventListener("wheel", A, { passive: false });
  }
  _setDraggingStyle(t, e = "horizontal") {
    this.$slider && this.$slider.classList.toggle("active", t), document.body.classList.toggle("lil-gui-dragging", t), document.body.classList.toggle(`lil-gui-${e}`, t);
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
  }
  _onUpdateMinMax() {
    !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), false), this._initSlider(), this.updateDisplay());
  }
  _normalizeMouseWheel(t) {
    let { deltaX: e, deltaY: i } = t;
    return Math.floor(t.deltaY) !== t.deltaY && t.wheelDelta && (e = 0, i = -t.wheelDelta / 120, i *= this._stepExplicit ? 1 : 10), e + -i;
  }
  _arrowKeyMultiplier(t) {
    let e = this._stepExplicit ? 1 : 10;
    return t.shiftKey ? e *= 10 : t.altKey && (e /= 10), e;
  }
  _snap(t) {
    let e = Math.round(t / this._step) * this._step;
    return parseFloat(e.toPrecision(15));
  }
  _clamp(t) {
    return t < this._min && (t = this._min), t > this._max && (t = this._max), t;
  }
  _snapClampSetValue(t) {
    this.setValue(this._clamp(this._snap(t)));
  }
  get _hasScrollBar() {
    let t = this.parent.root.$children;
    return t.scrollHeight > t.clientHeight;
  }
  get _hasMin() {
    return this._min !== void 0;
  }
  get _hasMax() {
    return this._max !== void 0;
  }
};
r(T, "NumberController");
var D = T;
var U = class U2 extends _ {
  constructor(t, e, i, r2) {
    super(t, e, i, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$select.addEventListener("change", () => {
      this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange();
    }), this.$select.addEventListener("focus", () => {
      this.$display.classList.add("focus");
    }), this.$select.addEventListener("blur", () => {
      this.$display.classList.remove("focus");
    }), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.options(r2);
  }
  options(t) {
    return this._values = Array.isArray(t) ? t : Object.values(t), this._names = Array.isArray(t) ? t : Object.keys(t), this.$select.replaceChildren(), this._names.forEach((e) => {
      let i = document.createElement("option");
      i.textContent = e, this.$select.appendChild(i);
    }), this.updateDisplay(), this;
  }
  updateDisplay() {
    let t = this.getValue(), e = this._values.indexOf(t);
    return this.$select.selectedIndex = e, this.$display.textContent = e === -1 ? t : this._names[e], this;
  }
};
r(U, "OptionController");
var O = U;
var P = class P2 extends _ {
  constructor(t, e, i) {
    super(t, e, i, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("spellcheck", "false"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", () => {
      this.setValue(this.$input.value);
    }), this.$input.addEventListener("keydown", (r2) => {
      r2.code === "Enter" && this.$input.blur();
    }), this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    }), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay();
  }
  updateDisplay() {
    return this.$input.value = this.getValue(), this;
  }
};
r(P, "StringController");
var z = P;
var mt = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "â†•";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "â–¾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "â–¸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "âœ“";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;
function ft(n) {
  let t = document.createElement("style");
  t.innerHTML = n;
  let e = document.querySelector("head link[rel=stylesheet], head style");
  e ? document.head.insertBefore(t, e) : document.head.appendChild(t);
}
r(ft, "_injectStyles");
var K = false;
var S = class S2 {
  constructor({ parent: t, autoPlace: e = t === void 0, container: i, width: r2, title: s = "Controls", closeFolders: a = false, injectStyles: u = true, touchStyles: g = true } = {}) {
    if (this.parent = t, this.root = t ? t.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = false, this._hidden = false, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", true), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", (b) => {
      (b.code === "Enter" || b.code === "Space") && (b.preventDefault(), this.$title.click());
    }), this.$title.addEventListener("touchstart", () => {
    }, { passive: true }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(s), this.parent) {
      this.parent.children.push(this), this.parent.folders.push(this), this.parent.$children.appendChild(this.domElement);
      return;
    }
    this.domElement.classList.add("root"), g && this.domElement.classList.add("allow-touch-styles"), !K && u && (ft(mt), K = true), i ? i.appendChild(this.domElement) : e && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), r2 && this.domElement.style.setProperty("--width", r2 + "px"), this._closeFolders = a;
  }
  add(t, e, i, r2, s) {
    if (Object(i) === i) return new O(this, t, e, i);
    let a = t[e];
    switch (typeof a) {
      case "number":
        return new D(this, t, e, i, r2, s);
      case "boolean":
        return new M(this, t, e);
      case "string":
        return new z(this, t, e);
      case "function":
        return new $(this, t, e);
    }
    console.error(`gui.add failed
	property:`, e, `
	object:`, t, `
	value:`, a);
  }
  addColor(t, e, i = 1) {
    return new F(this, t, e, i);
  }
  addFolder(t) {
    let e = new S2({ parent: this, title: t });
    return this.root._closeFolders && e.close(), e;
  }
  load(t, e = true) {
    return t.controllers && this.controllers.forEach((i) => {
      i instanceof $ || i._name in t.controllers && i.load(t.controllers[i._name]);
    }), e && t.folders && this.folders.forEach((i) => {
      i._title in t.folders && i.load(t.folders[i._title]);
    }), this;
  }
  save(t = true) {
    let e = { controllers: {}, folders: {} };
    return this.controllers.forEach((i) => {
      if (!(i instanceof $)) {
        if (i._name in e.controllers) throw new Error(`Cannot save GUI with duplicate property "${i._name}"`);
        e.controllers[i._name] = i.save();
      }
    }), t && this.folders.forEach((i) => {
      if (i._title in e.folders) throw new Error(`Cannot save GUI with duplicate folder "${i._title}"`);
      e.folders[i._title] = i.save();
    }), e;
  }
  open(t = true) {
    return this._setClosed(!t), this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this;
  }
  close() {
    return this.open(false);
  }
  _setClosed(t) {
    this._closed !== t && (this._closed = t, this._callOnOpenClose(this));
  }
  show(t = true) {
    return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this;
  }
  hide() {
    return this.show(false);
  }
  openAnimated(t = true) {
    return this._setClosed(!t), this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
      let e = this.$children.clientHeight;
      this.$children.style.height = e + "px", this.domElement.classList.add("transition");
      let i = r((s) => {
        s.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", i));
      }, "onTransitionEnd");
      this.$children.addEventListener("transitionend", i);
      let r2 = t ? this.$children.scrollHeight : 0;
      this.domElement.classList.toggle("closed", !t), requestAnimationFrame(() => {
        this.$children.style.height = r2 + "px";
      });
    }), this;
  }
  title(t) {
    return this._title = t, this.$title.textContent = t, this;
  }
  reset(t = true) {
    return (t ? this.controllersRecursive() : this.controllers).forEach((i) => i.reset()), this;
  }
  onChange(t) {
    return this._onChange = t, this;
  }
  _callOnChange(t) {
    this.parent && this.parent._callOnChange(t), this._onChange !== void 0 && this._onChange.call(this, { object: t.object, property: t.property, value: t.getValue(), controller: t });
  }
  onFinishChange(t) {
    return this._onFinishChange = t, this;
  }
  _callOnFinishChange(t) {
    this.parent && this.parent._callOnFinishChange(t), this._onFinishChange !== void 0 && this._onFinishChange.call(this, { object: t.object, property: t.property, value: t.getValue(), controller: t });
  }
  onOpenClose(t) {
    return this._onOpenClose = t, this;
  }
  _callOnOpenClose(t) {
    this.parent && this.parent._callOnOpenClose(t), this._onOpenClose !== void 0 && this._onOpenClose.call(this, t);
  }
  destroy() {
    this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach((t) => t.destroy());
  }
  controllersRecursive() {
    let t = Array.from(this.controllers);
    return this.folders.forEach((e) => {
      t = t.concat(e.controllersRecursive());
    }), t;
  }
  foldersRecursive() {
    let t = Array.from(this.folders);
    return this.folders.forEach((e) => {
      t = t.concat(e.foldersRecursive());
    }), t;
  }
};
r(S, "GUI");
var B = S;
var Z = B;
q();
q();
var w = (() => {
  let n = new Vt();
  return r(function(e) {
    return n.set(e), `#${n.getHexString()}`;
  }, "normalize");
})();
function Q2(n) {
  let t;
  for (t of n) t();
}
r(Q2, "runAll");
function q2(n, t) {
  let e = window.location.href, i = new URL(e), r2 = new URLSearchParams(i.search);
  for (let s in n) if (n.hasOwnProperty(s)) {
    let a = `${t}.${s}`;
    r2.set(a, n[s]);
  }
  i.search = r2.toString(), history.pushState({ path: i.toString() }, "", i.toString());
}
r(q2, "updateCurrentUrlParamsWithNamespace");
function tt(n, t) {
  let e = new URLSearchParams(window.location.search), i = {};
  for (let [r2, s] of e) if (r2.startsWith(`${n}.`)) {
    let a = r2.slice(n.length + 1);
    s === "true" || s === "false" ? i[a] = s === "true" : typeof t[a] == "number" ? i[a] = Number(s) : i[a] = s;
  }
  return { namespace: n, params: i };
}
r(tt, "getUrlParamsWithNamespace");
q();
function et(n, t) {
  t.domElement.id = "interactionPanel";
  let e = t.addFolder("Click ðŸ‘‡");
  vt(n, e);
  let i = t.addFolder("Hover ðŸš");
  yt(n, i);
}
r(et, "createInteractionControls");
function vt(n, t) {
  let e = { position: "", hoverColor: w(n.getHoverColor()) }, i = t.add(e, "position").disable(), r2 = [];
  function s() {
    r2.forEach((u) => u()), r2.length = 0;
  }
  r(s, "reset");
  let a = 0;
  n.on("click", (u) => {
    var l;
    let { labels: g, markers: b, coordinate: f } = u;
    s(), clearInterval(a), i.load(JSON.stringify([f.longitude, f.latitude]));
    let c = g[0] || b[0];
    if (c) {
      let h = Y(n, c, t);
      if (!h) return;
      r2.push(h.destroy), h.labelItemFolder.openAnimated();
    }
    let d = (l = u.spaces[0]) != null ? l : u.objects[0];
    if (d) {
      let h = { id: d.id, ...n.getState(d.id), type: d.type, isInView: false, isInViewCheck: j(n, d.id) }, { cleanup: v } = At(n, h, t);
      a = setInterval(() => {
        h.isInView = n.isInView(c || d);
      }, 500), r2.push(v);
    }
  });
}
r(vt, "createClickControls");
var bt = ["interactive"];
function At(n, t, e) {
  let i = e.addFolder(`${t.type}-${t.id}`);
  for (let r2 in t) {
    if (r2 === "visible" && i.add(t, r2).onChange((s) => {
      n.updateState(t.id, { [r2]: s });
    }), r2 === "color" || r2 === "hoverColor") {
      t[r2] = w(t[r2]), i.addColor(t, r2).onChange((s) => {
        n.updateState(t.id, { [r2]: s });
      });
      continue;
    }
    if (r2 === "height") {
      i.add(t, r2, 0, 20, 1).onChange((s) => {
        n.updateState(t.id, { [r2]: s });
      });
      continue;
    }
    bt.includes(r2) && i.add(t, r2).onChange((s) => {
      n.updateState(t.id, { [r2]: s });
    });
  }
  return i.add(t, "isInView").listen().disable(), i.add(t, "isInViewCheck"), { cleanup() {
    i.destroy();
  } };
}
r(At, "renderByProp");
function yt(n, t) {
  n.setHoverColor("#1f3a7a");
  let e = { position: "", hoverColor: w(n.getHoverColor()), intersected: "", type: "", id: "" }, i = t.add(e, "position").disable();
  t.add(e, "id").disable().listen(), t.add(e, "type").disable().listen(), t.addColor(e, "hoverColor").onChange((a) => {
    n.setHoverColor(a);
  });
  let r2 = [];
  function s() {
    r2.forEach((a) => a()), r2.length = 0;
  }
  r(s, "reset"), n.on("hover", (a) => {
    var h, v, A;
    let { coordinate: u, spaces: g, objects: b, markers: f, labels: c } = a;
    s(), i.load(JSON.stringify([u.longitude, u.latitude]));
    let d = (A = (v = (h = g[0]) != null ? h : b[0]) != null ? v : f[0]) != null ? A : c[0];
    if (!d) return;
    let l = n.getState(d);
    l && (e.type = l.type, e.id = d.id);
  });
}
r(yt, "createHoverControls");
function j(n, t) {
  return r(function() {
    console.log("isInView", n.isInView(t));
  }, "isInView");
}
r(j, "createIsInViewHandler");
function it(n, t, e) {
  let i = { labels: {}, all() {
    e.Labels.all().forEach((l) => {
      this.labels[l.id] = l;
    }), g();
  }, removeAllLabels() {
    e.Labels.removeAll().forEach((l) => {
      delete this.labels[l.id];
    }), g();
  } }, { addLabel: r2, destroy: s } = Ct(n, e);
  n.add(i, "all"), n.add(i, "removeAllLabels");
  let a = n.addFolder("Label List");
  n.close();
  let u = /* @__PURE__ */ new Map(), { rerender: g } = b();
  function b() {
    function d(v) {
      var A;
      delete i.labels[v.id], (A = u.get(v.id)) == null || A.destroy();
    }
    r(d, "remove");
    function l(v) {
      let A = Y(e, v, a, { onRemove: (p) => {
        d(p);
      } });
      if (!A) return;
      let { labelItemFolder: m } = A;
      u.set(v.id, m);
    }
    r(l, "add");
    function h() {
      a.destroy(), a = n.addFolder("Label");
      for (let v in i.labels) {
        let A = i.labels[v];
        l(A);
      }
    }
    return r(h, "rerender"), { rerender: h, add: l, remove: d };
  }
  r(b, "createLabelControls"), n.domElement.classList.add("list-items");
  let f;
  e.on("click", ({ labels: d, coordinate: l }) => {
    if (!n._closed) if (d[0]) {
      f == null || f.close();
      let h = u.get(d[0].id);
      if (n.open(), !h) return;
      h == null || h.open(), h == null || h.domElement.scrollIntoView({ block: "start" }), h == null || h.domElement.focus(), f = h;
    } else r2(l);
  });
  function c(d) {
    for (let l of d) i.labels[l.id] = l;
    g();
  }
  return r(c, "populatelabels"), { populatelabels: c, destroy() {
    s();
  } };
}
r(it, "createLabelControls");
function Y(n, t, e, { onRemove: i } = {}) {
  var b, f, c, d;
  let r2 = e.addFolder(`${(b = t.text) == null ? void 0 : b.substring(0, 12)}`);
  r2.onChange((l) => {
    n.updateState(t, { appearance: g.appearance, interactive: g.interactive });
  }), r2.close();
  let s = n.getState(t);
  if ((s == null ? void 0 : s.type) !== "label") throw new Error(`error getting state for label: ${t.id}`);
  let { appearance: a, interactive: u } = s;
  if (!a || a.margin == null || u == null) throw new Error("incomplte label state");
  let g = { text: t.text, interactive: u, appearance: { ...a, margin: a.margin || 0, marker: { foregroundColor: (c = (f = a.marker) == null ? void 0 : f.foregroundColor) != null && c.active ? w((d = a.marker.foregroundColor) == null ? void 0 : d.active) : "black" }, text: { foregroundColor: w(a.text.foregroundColor) } }, remove() {
    n.Labels.remove(t), i == null || i(t), r2.destroy();
  }, isInView: j(n, t.id) };
  return r2.add(g.appearance, "margin", 0, 20).name("margin"), r2.add(g, "text"), r2.add(g, "interactive"), r2.addColor(g.appearance.marker, "foregroundColor").name("marker foreground"), r2.addColor(g.appearance.text, "foregroundColor").name("text forground"), r2.add(g, "isInView"), r2.add(g, "remove"), { labelItemFolder: r2, destroy() {
    r2.destroy();
  } };
}
r(Y, "addLabelControlToFolder");
function Ct(n, t) {
  let e = n.addFolder("Add"), i = { onClick: false, margin: 0, text: "New Label!", interactive: true, marginForegroundColor: w("skyblue"), marginBackgroundColor: w("coral"), textForegroundColor: w("slategray"), textBackgroundColor: w("white") };
  return e.add(i, "onClick"), e.add(i, "margin"), e.add(i, "interactive"), e.add(i, "text"), e.addColor(i, "marginForegroundColor"), e.addColor(i, "marginBackgroundColor"), e.addColor(i, "textForegroundColor"), e.addColor(i, "textBackgroundColor"), { destroy() {
    e.destroy();
  }, addLabel(r2) {
    return e._closed || !i.onClick ? void 0 : t.Labels.add(r2, i.text, { appearance: { margin: i.margin, marker: { foregroundColor: { active: i.marginForegroundColor, inactive: i.marginForegroundColor }, backgroundColor: { active: i.marginBackgroundColor, inactive: i.marginBackgroundColor } }, text: { foregroundColor: i.textForegroundColor, backgroundColor: i.marginBackgroundColor } }, interactive: i.interactive });
  } };
}
r(Ct, "createAddControl");
var nt = {};
q();
function rt(n, t) {
  let e = n.addFolder("Camera ðŸ“·").close(), i = t.Camera.center.toJSON(), r2 = document.createElement("div");
  Object.assign(r2.style, { display: "none", position: "absolute", left: "0px", top: "0px", bottom: "0px", right: "0px", backgroundColor: "aqua", pointerEvents: "none", opacity: 0.5, zIndex: 99999 }), document.body.appendChild(r2);
  let s = { center_lat: i.latitude, center_lon: i.longitude, zoomLevel: t.Camera.zoomLevel, pitch: t.Camera.pitch, bearing: t.Camera.bearing, minZoomLevel: t.Camera.minZoomLevel, maxZoomLevel: t.Camera.maxZoomLevel, inset_top: 0, inset_left: 0, inset_right: 0, inset_bottom: 0, animateOnLoad: true, share: () => {
    q2(e.save().controllers, "camera"), navigator.clipboard.writeText(window.location.href);
  }, visualizeInset: false };
  function a() {
    Object.assign(r2.style, { left: s.inset_left + "px", top: s.inset_top + "px", bottom: s.inset_bottom + "px", right: s.inset_right + "px" });
  }
  r(a, "updateInsetVisualizer"), e.add(s, "center_lat").listen().disable(), e.add(s, "center_lon").listen().disable(), e.add(s, "zoomLevel", 16, 22, 0.5).listen().disable(), e.add(s, "pitch").listen().disable(), e.add(s, "bearing").listen().disable(), e.add(s, "minZoomLevel", 5, 22, 0.5).onChange((l) => {
    t.Camera.setMinZoomLevel(l);
  }), e.add(s, "maxZoomLevel", 10, 22, 0.5).onChange((l) => {
    t.Camera.setMaxZoomLevel(l);
  }), e.add(s, "animateOnLoad"), e.add(s, "visualizeInset").onChange((l) => {
    l ? r2.style.display = "block" : r2.style.display = "none";
  });
  let { innerHeight: u, innerWidth: g } = window;
  e.add(s, "inset_top", 0, u, 1).onChange(d), e.add(s, "inset_bottom", 0, u, 1).onChange(d), e.add(s, "inset_left", 0, g, 1).onChange(d), e.add(s, "inset_right", 0, g, 1).onChange(d), e.add(s, "share");
  let b = r((l) => {
    e._closed || (s.center_lat = l.center.latitude, s.center_lon = l.center.longitude, s.zoomLevel = l.zoomLevel, s.bearing = l.bearing, s.pitch = l.pitch);
  }, "onCameraChanged");
  t.on("camera-change", b);
  let { params: f } = tt("camera", s);
  if (Object.keys(f).length > 0) {
    let l = f;
    t.Camera.setScreenOffsets({ top: l.inset_top, left: l.inset_left, right: l.inset_right, bottom: l.inset_bottom });
    let h = { pitch: l.pitch, center: new Q(l.center_lat, l.center_lon), bearing: l.bearing, zoomLevel: l.zoomLevel };
    l.animateOnLoad ? t.Camera.animateTo(h) : t.Camera.set(h), e.load({ controllers: l, folders: {} }), a();
  }
  let c = [() => {
    t.off("camera-change", b);
  }];
  function d() {
    t.Camera.setScreenOffsets({ top: s.inset_top, left: s.inset_left, right: s.inset_right, bottom: s.inset_bottom }), a();
  }
  return r(d, "updateInset"), () => ({ destroy() {
    e.destroy(), Q2(c);
  } });
}
r(rt, "createCameraControls");
q();
function st(n, t, e) {
  let i = { markers: {}, removeAllMarkers() {
    e.Markers.removeAll().forEach((l) => {
      delete this.markers[l.id];
    }), g();
  } }, { addMarker: r2, destroy: s } = _t(n, e);
  n.add(i, "removeAllMarkers");
  let a = n.addFolder("Marker List");
  n.close();
  let u = /* @__PURE__ */ new Map(), { rerender: g } = b();
  function b() {
    function d(v) {
      var A;
      delete i.markers[v.id], (A = u.get(v.id)) == null || A.destroy();
    }
    r(d, "remove");
    function l(v) {
      let A = xt(e, v, a, { onRemove: (p) => {
        d(p);
      } });
      if (!A) return;
      let { markerItemFolder: m } = A;
      u.set(v.id, m);
    }
    r(l, "add");
    function h() {
      a.destroy(), a = n.addFolder("marker");
      for (let v in i.markers) {
        let A = i.markers[v];
        l(A);
      }
    }
    return r(h, "rerender"), { rerender: h, add: l, remove: d };
  }
  r(b, "createMarkerControls"), n.domElement.classList.add("list-items");
  let f;
  e.on("click", ({ markers: d, coordinate: l }) => {
    if (!n._closed) if (d[0]) {
      f == null || f.close();
      let h = u.get(d[0].id);
      if (n.open(), !h) return;
      h == null || h.open(), h == null || h.domElement.scrollIntoView({ block: "start" }), h == null || h.domElement.focus(), f = h;
    } else r2(l);
  });
  function c(d) {
    for (let l of d) i.markers[l.id] = l;
    g();
  }
  return r(c, "populateMarkers"), { populateMarkers: c, destroy() {
    s();
  } };
}
r(st, "createMarkerControls");
function xt(n, t, e, { onRemove: i } = {}) {
  let r2 = e.addFolder(`${t.id.toString().substring(0, 8)}`);
  r2.onChange((g) => {
    n.updateState(t, { interactive: u.interactive });
  }), r2.close();
  let s = n.getState(t);
  if ((s == null ? void 0 : s.type) !== "marker") throw new Error(`error getting state for marker: ${t.id}`);
  let { interactive: a } = s;
  if (a == null) throw new Error("incomplte label state");
  let u = { interactive: a, remove() {
    n.Markers.remove(t), i == null || i(t), r2.destroy();
  } };
  return r2.add(u, "interactive"), r2.add(u, "remove"), { markerItemFolder: r2, destroy() {
    r2.destroy();
  } };
}
r(xt, "addMarkerControlToFolder");
function _t(n, t) {
  let e = n.addFolder("Add"), i = { onClick: false, interactive: true };
  return e.add(i, "onClick"), e.add(i, "interactive"), { destroy() {
    e.destroy();
  }, addMarker(r2) {
    return e._closed || !i.onClick ? void 0 : t.Markers.add(r2, "<div>New Marker</div>", { interactive: i.interactive });
  } };
}
r(_t, "createAddControl");
q();
function ot(n, t) {
  let e = n.addFolder("Walls").close(), i = { visible: true, topColor: "#3269a8" };
  e.add(i, "visible").onChange((r2) => {
    t.updateState("walls", { visible: r2 });
  }), e.addColor(i, "topColor").onChange((r2) => {
    t.updateState("walls", { topColor: r2 });
  }), t.updateState("walls", { topColor: i.topColor });
}
r(ot, "createGeometryControl");
function lt(n, t) {
  Et();
  let e = new Z({ title: "SDK Controls" });
  e.domElement.classList.add("mappedin-js-inspector"), et(t, e), rt(e, t);
  let i = e.addFolder("Levels").close(), r2 = e.addFolder("Scene Controls"), s = e.addFolder("Labels"), a = e.addFolder("Markers");
  ot(e, t);
  let u = { level: t.currentFloor.id, load: () => {
    let c = localStorage.getItem("mappedin-debug"), d = c ? JSON.parse(c) : {};
    for (let l in d) t.updateState(l, d[l]);
  }, clear() {
    localStorage.removeItem("mappedin-debug");
  } };
  e.add(u, "load"), e.add(u, "clear");
  let { populatelabels: g } = it(s, n, t), { populateMarkers: b } = st(a, n, t), f = n.getByType("floor").reduce((c, d) => (c[d.name] = d.id, c), {});
  return i.add(u, "level", f).onChange((c) => {
    t.setFloor(c);
  }), t.on("floor-change-start", (c) => {
    i.controllers[0].setValue(c.floor.id);
  }), n.getByType("space").forEach((c) => {
    t.updateState(c, { interactive: true });
  }), n.getByType("object").forEach((c) => {
    t.updateState(c, { interactive: true });
  }), n.getByType("object").forEach((c) => {
    t.updateState(c, { interactive: true });
  }), t.setHoverColor("#a2b7e6"), { populatelabels: g, sceneFolder: r2, populateMarkers: b };
}
r(lt, "createUi");
var at = "mappedin-sdk-debug-css";
function Et() {
  if (document.getElementById(at)) return;
  let n = document.createElement("style");
  n.id = at, n.textContent = nt, document.head.appendChild(n);
}
r(Et, "injectCss");
var N = class N2 {
  constructor(t, e) {
    __publicField(this, "_enabled", false);
    __publicField(this, "mv");
    __publicField(this, "api");
    __publicField(this, "mapData");
    __publicField(this, "storeStateToLocalStorageEnabled", false);
    this.mv = t, this.api = e, this.mapData = this.api.getMapData();
  }
  setMapData(t) {
    this.mapData = t;
  }
  async enable() {
    var e;
    if (this._enabled) return;
    if (this._enabled = true, !this.mapData) throw new Error("Please set mapData before enable debug.");
    let { sceneFolder: t } = lt(this.mapData, this.mv);
    gw(this.api.core, t), (e = this.api.getMapDataInternal()) == null || e.spaces.forEach((i) => {
      this.mv.updateState(i.id, { interactive: true });
    });
  }
  get enabled() {
    return this._enabled;
  }
  storeState(t, e) {
    if (!this.storeStateToLocalStorageEnabled) return;
    let i = localStorage.getItem("mappedin-debug"), r2 = i ? JSON.parse(i) : {};
    r2[t] = { ...r2[t], ...e }, localStorage.setItem("mappedin-debug", JSON.stringify(r2));
  }
};
r(N, "Inspector");
var J = N;
export {
  J as Inspector
};
//# sourceMappingURL=inspector-RBV6MS2D-QYRLEC3A.js.map
